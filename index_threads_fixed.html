<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
<!-- ▼▼▼ 用這整塊代碼替換掉你舊的meta和icon連結 ▼▼▼ -->
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">


<!-- 1. (核心) 為蘋果設備設置主螢幕圖示 -->
<link rel="apple-touch-icon" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg">
<link rel="apple-touch-icon" sizes="152x152" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg">
<link rel="apple-touch-icon" sizes="180x180" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg">
<link rel="apple-touch-icon" sizes="167x167" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg">

<!-- 2. (核心) 連結到manifest檔 -->
<link rel="manifest" href="manifest.json">

<!-- 3. (核心) 告訴蘋果設備，這是一個Web應用，可以全屏顯示 -->
<meta name="apple-mobile-web-app-capable" content="yes">

<!-- 4. (核心) 設置蘋果設備全屏模式下的狀態列樣式 -->
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<!-- 5. (可選) 設置應用在主螢幕上顯示的標題 -->
<meta name="apple-mobile-web-app-title" content="EPhone（兔k機版）">

<!-- 6. (相容) 為部分安卓流覽器提供支援 -->
<meta name="mobile-web-app-capable" content="yes">

<!-- 7. (備用) 標準流覽器頁簽圖示 -->
<link rel="icon" type="image/png" href="https://i.postimg.cc/Kj8JnRcp/267611-CC01-F8-A3-B4910-A2-C2-FFDE479-DC.jpg">
<!-- ▲▲▲ 替換結束 ▲▲▲ -->


    <title>iPhone</title>

    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>
    <script src="https://sssayhi07-gif.github.io/ee/pp.js" defer></script>

    <style>
        :root { --screen-width: 350px; --screen-height: 650px; --secondary-bg: #ffffff; --border-color: #e0e0e0; --text-primary: #1f1f1f; --text-secondary: #8a8a8a; --accent-color: #007bff;    --status-bar-text-color: var(--accent-color); }
/* ▼▼▼ 用這塊終極代碼，替換掉你現有的 html 和 body 樣式 ▼▼▼ */
html {
    -webkit-text-size-adjust: 100%;
    height: 100%; /* 確保html元素也能撐滿 */
}

body {
    margin: 0;
    font-family: 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    font-weight: normal;
    background-color: #f0f2f5;
    height: 100%; /* 讓body也撐滿父元素(html) */
    overflow: hidden; /* 防止body本身出現捲軸 */
}
/* ▲▲▲ 替換結束 ▲▲▲ */

/* 2. 讓 #phone-screen 成為新的“根”容器，撐滿整個流覽器視窗 */
/* ▼▼▼ 請用這塊【最終修正版】的代碼，替換掉你現有的 #phone-screen 樣式 ▼▼▼ */
#phone-screen {
    width: 100%;
    height: 100vh;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    background-color: #ffffff; /* ★ 修改這裡為白色 */
}
/* ▲▲▲ 替換結束 ▲▲▲ */

/* 3. 【核心】隱藏掉模擬器的狀態列 */
#status-bar {
    display: none;
}

/* 4. 【核心】讓所有頁面的頭部自動適應iPhone的“劉海”安全區 */
.header, .qzone-header {
    /* 使用 env(safe-area-inset-top) 自動獲取頂部安全距離 */
    padding-top: calc(15px + env(safe-area-inset-top));
}

/* 5. 【核心】讓聊天輸入框和底部巡覽列自動適應iPhone底部的“小黑條”安全區 */
#chat-input-area {
    padding-bottom: calc(8px + env(safe-area-inset-bottom));
}

#chat-list-bottom-nav {
     padding-bottom: env(safe-area-inset-bottom);
}

/* ▲▲▲ 替換結束 ▲▲▲ */

      /* 修改後的代碼塊 */
/* ▼▼▼ 用這整塊【可愛圓潤版】代碼，替換掉所有舊的 status-bar 和 battery 樣式 ▼▼▼ */

#status-bar { 
    position: absolute; 
    top: 0; 
    left: 0; 
    width: 100%; 
    padding: 12px 20px; 
    display: none; 
    justify-content: space-between; 
    align-items: center; 
    color: var(--accent-color); /* ★ 修改：狀態列文字/圖示顏色，現在會跟隨主題色！ */
    z-index: 10; 
    font-size: 14px; 
    box-sizing: border-box; 
    pointer-events: none; 
    /* ★ 新增：使用你的自訂字體，並加上柔和的光暈，讓它更可愛 */
    font-family: 'bulangni', sans-serif; 
    text-shadow: 0 0 8px rgba(255, 255, 255, 0.5); 
}

#status-bar-time { 
    font-weight: 600; 
}

.battery-container { 
    display: flex; 
    align-items: center; 
    gap: 5px; 
}

.battery-icon { 
    width: 25px; 
    height: 12px; 
    border: 1.5px solid currentColor; /* ★ 邊框加粗一點點 */
    border-radius: 5px; /* ★ 修改：增加圓角，讓它更圓潤可愛 */
    position: relative; 
    padding: 1px; 
}

.battery-icon::after { 
    content: ''; 
    position: absolute; 
    right: -4px; /* 微調位置 */
    top: 2.5px; 
    width: 2px; 
    height: 5px; 
    background-color: currentColor; 
    border-radius: 0 2px 2px 0; /* ★ 頭部小塊也變圓潤 */
}

.battery-level { 
    height: 100%; 
    background-color: currentColor; /* ★ 預設填充色也跟隨主題色 */
    border-radius: 3px; /* ★ 內部填充條也變圓潤 */
    transition: width 0.5s ease; 
}

/* ★ 核心修改：讓充電時也顯示主題色！ */
.battery-container.charging .battery-level { 
    animation: charge-breath 2s infinite; 
}
@keyframes charge-breath { 
    0%, 100% { opacity: 1; } 
    50% { opacity: 0.7; } 
}
/* ▲▲▲ 替換結束 ▲▲▲ */
/* ▼▼▼ 【終極修正版】請用這塊代碼完整替換掉所有舊的 .screen 樣式 ▼▼▼ */
.screen {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;  /* ★ 新增 */
    bottom: 0; /* ★ 新增 */
    width: 100%; /* 保留 */
    /* height: 100%; */ /* ★ 注釋或刪除掉這一行 */

    display: flex;
    flex-direction: column;
    overflow: hidden;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
}
/* ▲▲▲ 替換結束 ▲▲▲ */
/* ▲▲▲ 替換結束 ▲▲▲ */
/* ▲▲▲ 替換結束 ▲▲▲ */

        .screen.active { opacity: 1; visibility: visible; z-index: 1; }
       .header {
    position: relative;
    z-index: 15;
    flex-shrink: 0;
    padding: 15px 15px;
    padding-top: 45px;
    background-color: rgba(247, 247, 247, 0.8);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 18px;
    font-weight: 600;
    
    /* ▼▼▼ 新增下面這兩行 ▼▼▼ */
    height: 110px;               /* ★ 新增：強制設置一個統一的高度 */
    box-sizing: border-box;     /* ★ 新增：確保高度計算包含內邊距 */
    /* ▲▲▲ 新增結束 ▲▲▲ */
}

        .header .header-actions { display: flex; align-items: center; gap: 5px; }
        /* ▼▼▼ 【觸摸區域優化版】替換舊的 .header .back-btn, .header .action-btn 樣式 ▼▼▼ */
.header .back-btn, .header .action-btn {
    font-size: 24px; /* 保持圖示大小不變 */
    cursor: pointer;
    color: var(--accent-color);
    display: flex;
    align-items: center;
    justify-content: center;

    /* --- 核心修改從這裡開始 --- */
    width: 40px;              /* 1. 將按鈕寬度從30px增加到40px */
    height: 40px;             /* 2. 將按鈕高度從30px增加到40px */
    border-radius: 50%;       /* 3. (可選但推薦) 讓按鈕變成圓形，更美觀 */
    transition: background-color 0.2s; /* 4. 為懸停效果添加平滑動畫 */
}

/* 【新增】為按鈕添加懸停/點擊時的背景色，給用戶明確的回饋 */
.header .back-btn:hover, .header .action-btn:hover {
    background-color: rgba(0, 0, 0, 0.05); /* 滑鼠放上去時給一個淡淡的背景 */
}
#phone-screen.dark-mode .header .back-btn:hover,
#phone-screen.dark-mode .header .action-btn:hover {
    background-color: rgba(255, 255, 255, 0.1); /* 夜間模式下的懸停顏色 */
}
/* ▲▲▲ 替換結束 ▲▲▲ */


.header .action-btn {
    font-size: 16px; /* 專門為“上傳”、“+”等文字按鈕縮小字型大小 */
    font-weight: 600; /* 可以加粗一點讓它更清晰 */
}

        .header .action-btn img { height: 26px; }
        .header .save-btn { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; }
/* ▼▼▼ 【終極合併修正版】請用這塊代碼完整替換掉舊的 #home-screen, #clock-container, .app-grid 樣式 ▼▼▼ */
        
/* 1. (核心) 為鎖屏和主螢幕應用相同的全屏佈局 (此部分保持不變) */
#lock-screen, 
#home-screen {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
    background-size: cover;
    background-position: center;
    
    /* 用padding把內容擠進來，同時讓背景鋪滿安全區 */
    padding-top: env(safe-area-inset-top);
    padding-bottom: env(safe-area-inset-bottom);
    padding-left: 20px;
    padding-right: 20px;
    
    box-sizing: border-box;
}

/* 2. (核心) 單獨處理鎖屏的文字，讓它自動貼底 (這是本次的唯一修改) */
#lock-screen-content {
    margin-top: auto; /* 關鍵：自動將此元素推到容器底部 */
    margin-bottom: 40px; /* ★ 核心修正：使用 margin-bottom 向上推開，而不是padding */
    text-align: center;
    color: white;
    text-shadow: 0 2px 6px rgba(0,0,0,0.5);
    font-size: 16px;
    font-weight: 500;
}

/* 3. 保持主螢幕的時鐘和App圖示佈局不變 */
#clock-container {
    text-align: center;
    color: white;
    text-shadow: 0 3px 8px rgba(0,0,0,0.4);
    margin-bottom: 20px;
    flex-shrink: 0;
    margin-top: 60px; 
}
.app-grid {
    margin-top: auto;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 20px;
    width: 100%;
    padding: 20px;
    margin-bottom: 30px; 
}



/* ▲▲▲ 替換結束 ▲▲▲ */



        .app-row { display: flex; justify-content: center; gap: 25px; width: 100%; }
        .app-icon { display: flex; flex-direction: column; align-items: center; cursor: pointer; color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.5); font-size: 14px; font-weight: 500; text-align: center; }
        .app-icon .icon-bg { width: 65px; height: 65px; border-radius: 18px; background-color: var(--secondary-bg); display: flex; justify-content: center; align-items: center; font-size: 32px; margin-bottom: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.15); transition: transform 0.2s ease; overflow: hidden; }
        .app-icon:active .icon-bg { transform: scale(0.9); }
        .app-icon .icon-bg img { width: 100%; height: 100%; object-fit: cover; }
        .app-icon .label { color: white; }
        .form-container, .list-container { padding: 20px; overflow-y: auto; flex-grow: 1; display:flex; flex-direction: column; }
        .form-group { margin-bottom: 20px; }
        .form-group label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-secondary); }
        .form-group input, .form-group select, .form-group textarea { width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; }
        .form-group textarea { min-height: 80px; resize: vertical; }
        #world-book-content-input { height: calc(100% - 120px); }
        .form-button { width: 100%; padding: 15px; background-color: var(--accent-color); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 10px; }
        .form-button-secondary { background-color: #f0f0f0; color: var(--text-primary); border: 1px solid var(--border-color); }
        #wallpaper-screen .form-container { align-items: center; }
        #wallpaper-preview { width: 180px; height: 320px; border: 2px dashed var(--border-color); background-color: var(--secondary-bg); margin-bottom: 20px; background-size: cover; background-position: center; border-radius: 10px; display: flex; justify-content: center; align-items: center; color: var(--text-secondary); }
        #wallpaper-upload-input { display: none; }
/* 修改後的 #world-book-list 樣式 */
/* 【終極修復版】世界書主介面清單樣式 */
#world-book-list {
    flex-grow: 1;          /* 讓列表佔據所有剩餘的垂直空間 */
    overflow-y: auto;      /* 內容超出時，自動顯示垂直捲動條 */
    min-height: 0;         /* 解決Flex佈局下的滾動相容性問題 */
    background-color: var(--secondary-bg); /* 保留你喜歡的背景色 */
    /* 我們不再需要 padding-top 和 margin-top 這兩個技巧了 */
}


/* 修改後的 #chat-list 樣式，適配了iOS底部安全區 */
#chat-list {
    flex-grow: 1;
    background-color: var(--secondary-bg);
    padding-top: 110px; 
    /* 核心修復：將底部內邊距從 8px 增加到 60px，為巡覽列留出足夠空間 */
    padding-bottom: calc(60px + env(safe-area-inset-bottom)); 
    box-sizing: border-box;
}


        .list-item { display: flex; flex-direction: column; padding: 12px 20px; cursor: pointer; border-bottom: 1px solid var(--border-color); }
        .list-item:hover { background-color: #f5f5f5; }
        .list-item .item-title { font-weight: 500; font-size: 16px; margin-bottom: 5px; }
        .list-item .item-content { font-size: 14px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .chat-list-item { display: flex; align-items: center; padding: 10px 15px; cursor: pointer; border-bottom: 1px solid var(--border-color); position: relative; }
        .chat-list-item:hover { background-color: #f5f5f5; }
        .chat-list-item .avatar { width: 45px; height: 45px; border-radius: 50%; margin-right: 12px; object-fit: cover; background-color: #ccc; }
        .chat-list-item .info { flex-grow: 1; overflow: hidden; }
        .chat-list-item .name-line { display: flex; align-items: center; gap: 6px; margin-bottom: 2px; }
        .chat-list-item .name { font-weight: 500; color: var(--text-primary); }
        .chat-list-item .group-tag { font-size: 10px; color: var(--accent-color); background-color: #e7f3ff; padding: 2px 6px; border-radius: 4px; font-weight: bold; flex-shrink: 0; }
        .chat-list-item .last-msg { font-size: 13px; color: var(--text-secondary); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 180px; }
        /* 修改後的代碼 */
/* ▼▼▼ 用這塊【終極修復版】代碼，替換你舊的 #chat-interface-screen 和 #chat-messages 樣式 ▼▼▼ */

/* 1. 聊天螢幕總容器：讓它成為一個撐滿螢幕的Flex列佈局 */
#chat-interface-screen { 
    background-size: cover; 
    background-position: center; 
    display: flex; /* <-- 核心：必須是flex佈局 */
    flex-direction: column; /* <-- 核心：子元素垂直排列 */
    height: 100%; /* <-- 核心：撐滿父容器 */
    overflow: hidden; /* <-- 核心：防止任何意外溢出 */
}

/* 2. 聊天消息區域：讓它自動填充剩餘空間，而不是固定高度 */
#chat-messages {
    flex-grow: 1;           /* ★★★ 最最關鍵的一行！讓它自動伸縮，填滿剩餘空間 ★★★ */
    min-height: 0;          /* 一個神奇的保險絲，解決Flex佈局下的滾動相容問題 */
    overflow-y: auto;       /* 內容超出時，允許自身垂直捲動 */
    overflow-x: hidden;
    padding: 10px 15px;     /* 保留舒適的左右內邊距 */
    box-sizing: border-box;

    /* 
     * 保留你的頭部適配方案：
     * 為頂部半透明的header留出空間，同時讓背景圖能透上去。
     * 110px是header的高度, -80px是向上拉的距離，你可以根據你的header樣式微調。
    */
    padding-top: 110px;
    margin-top: -80px;

    /* 保持內部消息氣泡的flex佈局 */
    display: flex;
    flex-direction: column;
    gap: 20px;
}

/* ▲▲▲ 替換結束 ▲▲▲ */
        #load-more-btn { text-align: center; padding: 10px; color: var(--accent-color); font-size: 14px; cursor: pointer; background-color: transparent; border: none; width: 100%; }
        #load-more-btn:hover { text-decoration: underline; }

        .sender-name { font-size: 11px; color: #666; margin-bottom: 3px; }

.message-wrapper.ai .sender-name {
    margin-left: 50px; /* 稍微調整，與頭像對齊 */
    margin-bottom: 3px;
    position: absolute; /* 讓它脫離流，避免影響氣泡對齊 */
    top: -16px;       /* 定位到氣泡上方 */
    left: 0;
}

/* === 【全新】消息佈局與時間戳記樣式 === */

/* 1. 消息單元的總容器 (重構) */
.message-wrapper {
    display: flex;          /* 使用Flex佈局 */
    gap: 8px;               /* 氣泡和時間戳記之間的間距 */
    align-items: flex-end;  /* 核心：讓氣泡和時間戳記底部對齊 */
    position: relative;
    max-width: 90%;         /* 可以稍微放寬一點，因為時間戳記現在在外面了 */
}

/* 2. AI消息單元靠左 */
.message-wrapper.ai {
    align-self: flex-start;
    flex-direction: row; /* 頭像、氣泡、時間戳記，從左到右排列 */
}

/* 3. 使用者消息單元靠右 */
.message-wrapper.user {
    align-self: flex-end;
    flex-direction: row-reverse; /* 時間戳記、氣泡、頭像，從右到左排列 */
}

/* 4. 氣泡和頭像的直接容器 (保持不變) */
.message-bubble {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    max-width: 100%;
}

.timestamp {
    /* 移除舊的 position: absolute */
    font-size: 11px;
    color: #999;
    text-shadow: 0 0 3px rgba(255,255,255,0.6);
    white-space: nowrap; /* 防止時間換行 */
    margin-bottom: 5px;  /* 讓它和氣泡底部有輕微的對齊偏移，更美觀 */
    flex-shrink: 0;      /* 防止被壓縮 */
}

        .message-bubble.selected::after { content: '✔'; position: absolute; left: -10px; top: 50%; transform: translateY(-50%); background-color: var(--accent-color); color: white; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 12px; }
        .message-bubble.user.selected::after { left: auto; right: -10px; }

        .message-bubble.user { flex-direction: row-reverse; }
        #typing-indicator { align-self: flex-start; display: none; margin: 0 10px 10px; color: var(--text-secondary); }
        /* 修改聊天輸入框區域的 padding */
#chat-input-area { 
    flex-shrink: 0; 
    /* ▼▼▼ 核心修改1：增加了上、左、右的內邊距，讓整個區域更“寬敞” ▼▼▼ */
    padding: 10px 12px; 
    background-color: rgba(247, 247, 247, 0.8); 
    backdrop-filter: blur(10px); 
    -webkit-backdrop-filter: blur(10px); 
    border-top: 1px solid var(--border-color); 
    display: flex; 
    flex-direction: column; 
    gap: 5px; 
}

/* 修改iPhone底部安全區的適配 */
#chat-input-area {
    /* ▼▼▼ 核心修改2：將這裡的 8px 也同步為 10px，保持一致 ▼▼▼ */
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
}

        #chat-input-main-row { display: flex; align-items: flex-end; gap: 8px; width: 100%; }
        #chat-input { flex-grow: 1; border: none; padding: 10px 15px; border-radius: 20px; background-color: var(--secondary-bg); font-size: 16px; max-height: 100px; resize: none; }
        .action-button { border: none; color: white; border-radius: 20px; cursor: pointer; font-weight: 600; font-size: 14px; flex-shrink: 0; }
        #send-btn { background-color: var(--accent-color); height: 40px; padding: 0 15px;}
        .modal {
    /* ▼▼▼ 核心修改：將定位方式從 absolute 改為 fixed ▼▼▼ */
    position: fixed; 
    /* ▲▲▲ 修改結束 ▲▲▲ */
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    background-color: rgba(0,0,0,0.4); 
    display: none; 
    justify-content: center; 
    align-items: center; 
    z-index: 100; 
}

        .modal.visible { display: flex; }
        .modal-content { width: 90%; max-height: 90%; background-color: white; border-radius: 15px; display: flex; flex-direction: column; }
        .modal-header { padding: 15px; font-weight: 600; border-bottom: 1px solid var(--border-color); text-align: center; display: flex; justify-content: space-between; align-items: center; }
        .modal-body { padding: 15px; overflow-y: auto; }
        .modal-footer { padding: 15px; border-top: 1px solid var(--border-color); display: flex; justify-content: space-around; }
        .modal-footer button { width: 45%; padding: 12px; border-radius: 8px; border: 1px solid var(--accent-color); cursor: pointer; font-size: 16px; }
        .modal-footer .save { background-color: var(--accent-color); color: white; }
        .modal-footer .cancel { background-color: white; color: var(--accent-color); }
        .avatar-upload { display: flex; align-items: center; gap: 15px; }
        .avatar-upload img { width: 60px; height: 60px; border-radius: 50%; object-fit: cover; background-color: #eee; }
        .avatar-upload button { padding: 8px 12px; border: 1px solid #ccc; background-color: #f0f0f0; border-radius: 5px; cursor: pointer; }
        #open-persona-library-btn { font-size: 14px; padding: 6px 10px; margin-left: 0; }
        .avatar-upload input[type="file"] { display: none; }
        .theme-selector label { display: inline-flex; align-items: center; margin-right: 15px; margin-bottom: 5px; cursor: pointer; }
        #reset-theme-btn { background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px; }
        #group-members-settings { display: flex; overflow-x: auto; padding-bottom: 10px; gap: 15px; }
        .member-editor { text-align: center; cursor: pointer; }
        .member-editor img { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; background-color: #eee; margin-bottom: 5px; }
        .member-editor .member-name { font-size: 12px; }
        #notification-bar { position: absolute; top: 40px; left: 50%; width: 90%; z-index: 500; background-color: rgba(250, 250, 250, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); border-radius: 16px; padding: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); display: flex; align-items: center; gap: 12px; cursor: pointer;     transform: translateX(-50%) translateY(-150%); 
    transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    visibility: hidden;
}
#notification-bar.visible {
    /* 關鍵：在Y軸回到原位的同時，保持X軸的居中變換 */
    transform: translateX(-50%) translateY(0);
    visibility: visible;
}
        #notification-avatar { width: 30px; height: 30px; border-radius: 50%; object-fit: cover; }
        #notification-content .name { font-weight: 600; font-size: 15px; color: #000; }
        #notification-content .message { font-size: 14px; color: #555; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px; }
        .sticker-image { max-width: 100px; max-height: 100px; display: block; object-fit: contain; }
        .message-bubble.is-sticker .content, .message-bubble.is-voice-message .content { padding: 0; background-color: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; }
        #chat-input-actions-top { display: flex; gap: 8px; padding: 0 5px; }
        .chat-action-icon-btn { font-size: 24px; padding: 0; width: 38px; height: 38px; line-height: 38px; text-align: center; border-radius: 50%; background-color: rgba(255, 255, 255, 0.5); color: var(--text-primary); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.05); cursor: pointer; display:flex; justify-content:center; align-items:center; }
        #sticker-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 50%; background-color: rgba(242, 242, 247, 0.85); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 20px 20px 0 0; z-index: 200; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #sticker-panel.visible { transform: translateY(0); visibility: visible; }
        #sticker-panel-header { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); }
        #sticker-panel-header .title { font-weight: 600; }
        #sticker-panel-header .panel-btn { font-size: 16px; padding: 5px 10px; cursor: pointer; color: var(--accent-color); }
        #sticker-grid, #exclusive-sticker-grid, #common-sticker-grid { flex-grow: 1; overflow-y: auto; padding: 15px; display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px; }
        .sticker-item { position: relative; aspect-ratio: 1 / 1; background-color: white; border-radius: 10px; background-size: contain; background-repeat: no-repeat; background-position: center; cursor: pointer; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .sticker-item .delete-btn { display: none; position: absolute; top: -5px; right: -5px; width: 20px; height: 20px; background-color: #ff3b30; color: white; border-radius: 50%; text-align: center; line-height: 20px; font-size: 14px; cursor: pointer; border: 2px solid white; }
        #input-actions-wrapper { position: static; display: flex; align-items: flex-end; gap: 8px; flex-shrink: 0; }
        #wait-reply-btn { position: static; bottom: auto; right: auto; width: auto; height: 40px; padding: 0 10px; border-radius: 20px; display: flex; align-items: center; justify-content: center; background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border: 1px solid rgba(0,0,0,0.08); box-shadow: 0 2px 5px rgba(0,0,0,0.1); transition: opacity 0.2s, transform 0.1s; cursor: pointer;}
        #wait-reply-btn:hover { opacity: 0.8; }
        #wait-reply-btn:active { transform: scale(0.9); }
        #wait-reply-btn img { height: 22px; display: block; margin: auto; }
        .chat-image { max-width: 100%; border-radius: 10px; display: block; }
        .message-bubble.has-image .content { padding: 5px; }
        #custom-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 1000; opacity: 0; transition: opacity 0.2s ease-in-out; }
        #custom-modal-overlay.visible { display: flex; opacity: 1; }
        #custom-modal { background-color: #fff; width: 280px; border-radius: 14px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); display: flex; flex-direction: column; transform: scale(0.95); transition: transform 0.2s ease-in-out; }
        #custom-modal-overlay.visible #custom-modal { transform: scale(1); }
        .custom-modal-header { padding: 16px; font-size: 17px; font-weight: 600; text-align: center; }
        .custom-modal-body { padding: 0 16px 16px; text-align: center; font-size: 14px; color: #333; line-height: 1.5; }
        .custom-modal-body p { margin: 0; margin-bottom: 12px; }
        .custom-modal-body input { width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; }
        .custom-modal-footer { border-top: 1px solid #dbdbdb; display: flex; }
        .custom-modal-footer button { flex: 1; background: none; border: none; padding: 12px; font-size: 17px; cursor: pointer; color: var(--accent-color); }
        .custom-modal-footer button:first-child { border-right: 1px solid #dbdbdb; }
        .custom-modal-footer .confirm-btn { font-weight: 600; }
        .custom-modal-footer .confirm-btn.btn-danger { color: #ff3b30; }
        #preset-actions-modal .custom-modal-footer { flex-direction: column; }
        #preset-actions-modal .custom-modal-footer button { width: 100%; border: none; border-bottom: 1px solid #dbdbdb; padding: 14px; font-size: 18px; }
        #preset-actions-modal .custom-modal-footer button:last-child { border-bottom: none; }
        .custom-multiselect { position: relative; user-select: none; }
        .select-box { display: flex; align-items: center; width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 8px; font-size: 16px; box-sizing: border-box; background-color: #fff; cursor: pointer; }
        .select-box .selected-options-text { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text-primary); }
        .select-box .arrow-down { margin-left: auto; font-size: 10px; color: var(--text-secondary); transition: transform 0.2s; }
        .select-box.expanded .arrow-down { transform: rotate(180deg); }

.checkboxes-container {
    display: none;
    position: absolute;
    top: 100%; 
    margin-top: 5px;
    left: 0;
    right: 0;
    max-height: 400px; /* ★★★ 修改點在這裡 ★★★ 我把高度從 150px 增加到了 350px */
    overflow-y: auto;
    overflow-x: hidden;
    background-color: #fff;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    z-index: 101;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
        .checkboxes-container.visible { display: block; }
        .checkboxes-container label { display: block; padding: 10px 12px; cursor: pointer; font-weight: normal; color: var(--text-primary); }

.checkboxes-container label {
    display: block;
    padding: 12px 15px; /* <-- 修改：增加了上下和左右的內邊距，讓每一行更高更寬 */
    cursor: pointer;
    font-weight: normal;
    color: var(--text-primary);
    font-size: 15px; /* <-- 新增：將字體大小從預設值放大到15px */
}

        .checkboxes-container input { margin-right: 10px; vertical-align: middle; }
        .bg-upload-container { display: flex; align-items: center; gap: 10px; margin-top: 8px; flex-wrap: wrap; }
        .bg-preview-img { max-width: 120px; max-height: 80px; border-radius: 8px; border: 1px solid var(--border-color); object-fit: cover; display: none; }
        #remove-bg-btn { padding: 8px 12px; border: 1px solid #ff3b30; color: #ff3b30; background-color: #fff; border-radius: 5px; cursor: pointer; font-size: 14px; display: none; }
        .message-bubble.is-ai-image .content { padding: 5px; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; }
        .ai-generated-image { max-width: 180px; border-radius: 12px; display: block; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; }
        .ai-generated-image:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .voice-message-body { display: flex; align-items: center; cursor: pointer; padding: 8px 12px; min-width: 80px; max-width: 200px; }
        .message-bubble.user .voice-message-body { color: #1a3d00; flex-direction: row-reverse; }
        .message-bubble.ai .voice-message-body { color: var(--text-primary); }
        .voice-waveform { display: flex; align-items: center; height: 20px; gap: 2px; flex-grow: 1; margin: 0 10px; }
        .voice-waveform div { width: 3px; background-color: currentColor; border-radius: 2px; animation: wave-quiet 1.5s ease-in-out infinite; }
        @keyframes wave-quiet { 0%, 100% { height: 2px; } 50% { height: 10px; } }
        .voice-waveform div:nth-child(2) { animation-delay: 0.2s; } .voice-waveform div:nth-child(3) { animation-delay: 0.4s; } .voice-waveform div:nth-child(4) { animation-delay: 0.6s; } .voice-waveform div:nth-child(5) { animation-delay: 0.8s; }
.voice-duration {
    /* --- 核心修正 --- */
    font-size: var(--chat-font-size, 13px);
    /* --- 修正結束 --- */
    font-weight: 500;
    color: var(--text-secondary);
}
        .message-bubble.user .voice-duration { color: #3e6224; }

/* ▼▼▼ 用這塊代碼替換掉你原來的 .message-bubble .content 樣式 ▼▼▼ */
/* 通用內容區樣式，為時間戳記和字體大小做準備 */
.message-bubble .content {
    position: relative;
    font-size: var(--chat-font-size, 16px);
    padding: 8px 12px;
    line-height: 1.5;
    word-break: break-word; /* 核心修正: 強制長單詞或URL換行，防止撐破氣泡 */
}
/* ▲▲▲ 替換結束 ▲▲▲ */

        /* === 氣泡主題樣式 === */
        .message-bubble.user .content { background-color: rgba(255, 255, 255, 0.75); color: #585858; border-radius: 8px 2px 8px 8px; }
        .message-bubble.ai .content { background-color: rgba(255, 255, 255, 0.7); color: #585858; border-radius: 2px 8px 8px 8px; }
      
.message-bubble::after {
    content: "";
    position: absolute;
    width: 20px;  
    height: 20px; 
    background-size: contain;
    background-repeat: no-repeat;
    opacity: 1; 
    z-index: 1;
}
      
        #chat-messages[data-theme="pink_blue"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_blue"] .message-bubble.ai .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.user .content { background-color: #eff7ff; color: #263a4e; }
        #chat-messages[data-theme="blue_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.user .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="purple_yellow"] .message-bubble.ai .content { background-color: #fffde4; color: #5C4033; }
        #chat-messages[data-theme="black_white"] .message-bubble.user .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="black_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #343a40; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.user .content { background-color: #FFEB3B; color: #5D4037; }
        #chat-messages[data-theme="yellow_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="red_black"] .message-bubble.user .content { background-color: #C62828; color: #FFFFFF; }
        #chat-messages[data-theme="red_black"] .message-bubble.ai .content { background-color: #212121; color: #FFFFFF; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.user .content { background-color: #A0D2EB; color: #153243; }
        #chat-messages[data-theme="blue_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.user .content { background-color: #fff0f6; color: #432531; }
        #chat-messages[data-theme="pink_yellow"] .message-bubble.ai .content { background-color: #FEF9E7; color: #5D4037; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_purple"] .message-bubble.ai .content { background-color: #faf7ff; color: #827693; }
        #chat-messages[data-theme="gray_white"] .message-bubble.user .content { background-color: #e9ecef; color: #495057; }
        #chat-messages[data-theme="gray_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="blue_green"] .message-bubble.user .content { background-color: #d1ecf1; color: #0c5460; }
        #chat-messages[data-theme="blue_green"] .message-bubble.ai .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="pink_white"] .message-bubble.user .content { background-color: #fff0f6; color: #a78396; }
        #chat-messages[data-theme="pink_white"] .message-bubble.ai .content { background-color: #f8f9fa; color: #383d41; }
        #chat-messages[data-theme="pink_black"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }
        #chat-messages[data-theme="pink_green"] .message-bubble.user .content { background-color: #F8BBD0; color: #5B2C6F; }
        #chat-messages[data-theme="pink_green"] .message-bubble.ai .content { background-color: #C8E6C9; color: #1B5E20; }
        #chat-messages[data-theme="green_black"] .message-bubble.user .content { background-color: #d4edda; color: #155724; }
        #chat-messages[data-theme="green_black"] .message-bubble.ai .content { background-color: #343a40; color: #f8f9fa; }

        #transfer-btn { font-weight: bold; }
        #transfer-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: none; align-items: center; justify-content: center; z-index: 1001; }
        #transfer-modal.visible { display: flex; }
        .transfer-content { background-color: #fff0f5; border-radius: 20px; width: 290px; padding: 20px; box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3); text-align: center; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100" opacity="0.05"><path d="M50,4 C35,4 28,15 28,24 C28,33 35,32 35,40 C35,48 28,49 28,57 C28,65 35,66 35,74 C35,82 28,83 28,91 C28,99 35,100 50,100 C65,100 72,99 72,91 C72,83 65,82 65,74 C65,66 72,65 72,57 C72,49 65,48 65,40 C65,32 72,33 72,24 C72,15 65,4 50,4 Z" fill="%23FF69B4"/></svg>'); background-repeat: no-repeat; background-position: top right; background-size: 80px; }
        .transfer-header { font-size: 20px; font-weight: bold; color: #a35c7b; margin-bottom: 20px; }
        .transfer-input-group { margin-bottom: 15px; text-align: left; }
        .transfer-input-group label { display: block; font-size: 14px; color: #ff85b3; margin-bottom: 5px; font-weight: 500; }
        .transfer-input-group input { width: 100%; padding: 12px; border-radius: 10px; border: 2px solid #ffcce0; background-color: #fff; font-size: 16px; box-sizing: border-box; }
        .transfer-input-group input:focus { border-color: #ff85b3; outline: none; }
        .transfer-actions { display: flex; justify-content: space-between; gap: 10px; }
        .transfer-actions button { flex: 1; padding: 12px; border: none; border-radius: 10px; font-size: 16px; font-weight: bold; cursor: pointer; transition: transform 0.2s; }
        .transfer-actions button:active { transform: scale(0.95); }
        #transfer-cancel-btn { background-color: #ffdde9; color: #a35c7b; }
        #transfer-confirm-btn { background-color: #ff85b3; color: white; }
        .message-bubble.is-transfer .content { padding: 0; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; cursor: pointer; }
        .transfer-card { width: 200px; border-radius: 12px; padding: 12px; color: white; position: relative; overflow: hidden; }
        .transfer-card::before { content: '🐾'; position: absolute; right: 10px; top: 5px; font-size: 30px; opacity: 0.2; transform: rotate(15deg); }
        .message-bubble.user .transfer-card { background: radial-gradient(circle at top left, #ffc5d5, #ff85b3); }
        .message-bubble.ai .transfer-card { background: radial-gradient(circle at top left, #a1c4fd, #c2e9fb); }
        .transfer-title { font-size: 16px; font-weight: 600; display: flex; align-items: center; gap: 6px; margin-bottom: 8px; }
        .transfer-amount { font-size: 28px; font-weight: bold; margin-bottom: 4px; }
        .transfer-note { font-size: 13px; opacity: 0.9; border-top: 1px solid rgba(255,255,255,0.3); padding-top: 8px; margin-top: 8px; word-break: break-all; }
        
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        #listen-together-btn img.rotating { animation: spin 2s linear infinite; }
        #listen-together-btn img.paused { animation-play-state: paused; }
        #music-player-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 50; display: none; justify-content: center; align-items: center; background-color: rgba(0,0,0,0.3); }
        #music-player-overlay.visible { display: flex; }
        .music-player-window { width: 90%; background-color: rgba(255, 255, 255, 0.6); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border-radius: 20px; box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37); border: 1px solid rgba(255, 255, 255, 0.18); padding: 25px; display: flex; flex-direction: column; align-items: center; color: #1f1f1f; position: relative; }
        #music-playlist-btn { position: absolute; top: 15px; right: 15px; font-size: 24px; cursor: pointer; color: #333; }
        #music-time-counter { font-size: 12px; color: #555; margin-bottom: 20px; }
        #music-player-song-title { font-size: 20px; font-weight: 600; margin-bottom: 5px; text-align: center; }
        #music-player-artist { font-size: 14px; color: #666; margin-bottom: 25px; }
        .music-controls { display: flex; align-items: center; justify-content: center; gap: 20px; width: 100%; margin-bottom: 30px; }
        .music-controls button { background: none; border: none; font-size: 16px; font-weight: bold; cursor: pointer; color: #333; width: 44px; height: 44px; display: flex; justify-content: center; align-items: center; transition: transform 0.2s; }
        .music-controls button:active { transform: scale(0.9); }
        .music-controls .play-pause-btn { font-size: 24px; width: 60px; height: 60px; border-radius: 50%; background-color: rgba(0,0,0,0.05); }
        .music-bottom-actions { display: flex; justify-content: space-between; width: 100%; }
        .music-bottom-actions button { flex: 1; padding: 12px 0; border: none; border-radius: 10px; font-size: 15px; font-weight: 500; cursor: pointer; }
        #music-exit-btn { background-color: rgba(255, 100, 100, 0.7); color: white; margin-right: 5px; }
        #music-return-btn { background-color: rgba(0, 123, 255, 0.7); color: white; margin-left: 5px; }
        
        #music-playlist-panel { position: absolute; bottom: 0; left: 0; width: 100%; height: 70%; background-color: rgba(242, 242, 247, 0.9); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border-top: 1px solid var(--border-color); border-radius: 20px 20px 0 0; z-index: 210; display: flex; flex-direction: column; transform: translateY(100%); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); visibility: hidden; }
        #music-playlist-panel.visible { transform: translateY(0); visibility: visible; }
        .playlist-header { padding: 15px 20px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; border-bottom: 1px solid var(--border-color); font-weight: 600; }
        .playlist-header .panel-btn { font-size: 16px; cursor: pointer; color: var(--accent-color); }
        .playlist-body { flex-grow: 1; overflow-y: auto; padding: 10px 0; }
        .playlist-item { padding: 10px 20px; display: flex; justify-content: space-between; align-items: center; cursor: pointer; border-bottom: 1px solid #eee; }
        .playlist-item.playing { background-color: rgba(0, 123, 255, 0.1); }
        .playlist-item-info .title { font-weight: 500; font-size: 15px; }
        .playlist-item-info .artist { font-size: 12px; color: #666; }
        .playlist-item .delete-track-btn { color: #ff3b30; font-size: 20px; padding: 5px; }

        /* Persona Library Styles */
        #persona-library-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; padding: 10px; }
        .persona-preset-item { aspect-ratio: 1 / 1; border-radius: 12px; background-size: cover; background-position: center; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s; border: 1px solid rgba(0,0,0,0.1); }
        .persona-preset-item:hover { transform: scale(1.08); box-shadow: 0 4px 10px rgba(0,0,0,0.2); }
        .modal-header .action-button { font-size: 16px; color: var(--accent-color); font-weight: 600; cursor: pointer; background: none; border: none; padding: 5px; }
        
        /* Battery Alert Modal Styles */
        #battery-alert-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.4); display: none; justify-content: center; align-items: center; z-index: 2000; opacity: 0; transition: opacity 0.3s ease; }
        #battery-alert-modal.visible { display: flex; opacity: 1; }
        .battery-alert-content { background-color: rgba(255, 255, 255, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); width: 280px; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.2); text-align: center; padding: 20px; cursor: pointer; transform: scale(0.9); transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); }
        #battery-alert-modal.visible .battery-alert-content { transform: scale(1); }
        #battery-alert-image { max-width: 100px; max-height: 100px; margin-bottom: 15px; }
        #battery-alert-text { font-size: 16px; font-weight: 500; color: #333; margin: 0; line-height: 1.4; }

/* 這是你要添加的新樣式 */
#font-preview {
    transition: font-family 0.3s ease;}

/* === 聊天清單介面新增樣式 (這是新添加的) === */
#chat-list-screen {
}

.chat-list-view {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s, visibility 0.2s;
    z-index: 1; 
}
.chat-list-view.active {
    opacity: 1;
    visibility: visible;
    z-index: 2; 
}

#messages-view {
    overflow-y: auto; 
}

/* 底部巡覽列樣式 */
#chat-list-bottom-nav {
    position: absolute; /* 讓它固定在底部 */
    bottom: 0;
    left: 0;
    width: 100%;
    z-index: 15; /* 確保它在視圖之上 */
    display: flex;
    border-top: 1px solid var(--border-color);
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
}

.nav-item {
    flex: 1;
    text-align: center;
    padding: 13px 0;
    font-size: 14px;
    color: var(--text-secondary);
    cursor: pointer;
    transition: color 0.2s;
}

.nav-item.active {
    color: var(--accent-color);
    font-weight: 600;
}

/* === 動態介面 (QZone) 樣式 (這是新添加的) === */
#qzone-screen {
    background-color: #f0f2f5;
}

.qzone-header {
    /* position: absolute;  <-- 把這個改成 relative */
    position: relative;
    z-index: 10; /* z-index 保持，或者可以更高 */
    flex-shrink: 0; /* 防止被壓縮 */
    padding: 15px 20px;
    padding-top: 45px;
    background-color: rgba(247, 247, 247, 0.7); 
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-bottom: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 18px;
    font-weight: 600;
    text-align: center;
}

.qzone-header .back-btn {
    font-size: 24px;
    cursor: pointer;
    color: var(--accent-color);
}

.qzone-header span:nth-child(2) { /* "好友動態"文字 */
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
}

.qzone-content {
    flex-grow: 1;
    overflow-y: auto;
    /* padding-top: 80px;  <-- 刪除這個，因為header不再是absolute了 */
}

.qzone-profile-header {
    position: relative;
    margin-bottom: 20px;
}

.qzone-banner-container {
    width: 100%;
    height: 180px; /* 背景板高度 */
    position: relative;
}

#qzone-banner-img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.qzone-user-info {
    position: absolute;
    bottom: -30px; /* 讓頭像和昵稱區域向下偏移，一半在背景板內，一半在外 */
    left: 20px;
    display: flex;
    align-items: flex-end; /* 讓昵稱和頭像底部對齊 */
    gap: 10px;
}

.qzone-avatar-container {
    position: relative;
}

#qzone-avatar-img {
    width: 70px;
    height: 70px;
    border-radius: 50%;
    border: 3px solid white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    object-fit: cover;
}

#qzone-nickname {
    font-size: 18px;
    font-weight: 600;
    color: #fff;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
    padding-bottom: 5px; /* 微調位置 */
}

/* 編輯按鈕的通用樣式 */
.qzone-edit-btn {
    position: absolute;
    background-color: rgba(0,0,0,0.4);
    color: white;
    border: none;
    border-radius: 10px;
    padding: 4px 8px;
    font-size: 12px;
    cursor: pointer;
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
}

#change-qzone-banner-btn {
    bottom: 10px;
    right: 10px;
}

#change-qzone-avatar-btn {
    bottom: 5px;
    right: 5px;
}

#change-qzone-nickname-btn {
    font-size: 14px;
    padding: 2px 6px;
    margin-left: 5px; /* 與昵稱的間距 */
    color: var(--text-primary);
    background-color: rgba(255,255,255,0.7);
    border-radius: 5px;
    position: relative; /* 脫離flex佈局的對齊 */
    bottom: 5px; /* 微調垂直位置 */
}

/* === 讓編輯功能更“隱形” === */
#qzone-banner-container,
#qzone-avatar-container,
#qzone-nickname {
    cursor: pointer; /* 滑鼠懸停時顯示為可點擊手勢 */
    transition: opacity 0.2s;
}
#qzone-banner-container:hover,
#qzone-avatar-container:hover,
#qzone-nickname:hover {
    opacity: 0.85; /* 懸停時稍微變暗，給用戶回饋 */
}
/* 隱藏掉舊的、獨立的編輯按鈕 */
.qzone-edit-btn {
    display: none;
}

/* === 控制 Header 和 Bottom Nav 的顯隱 === */
/* 預設隱藏動態介面的 Header */
#qzone-screen .qzone-header {
    display: none;
}
/* 當動態視圖啟動時，顯示它的Header */
#qzone-screen.active .qzone-header {
    display: flex;
}

/* 當進入動態視圖時，隱藏主Header和底部巡覽列 */
#chat-list-screen.in-qzone-view > .header,
#chat-list-screen.in-qzone-view > #chat-list-bottom-nav {
    display: none;
}

.chat-group-container:first-child {
    margin-top: 10px; 
}

/* ▲▲▲ 新樣式替換結束 ▲▲▲ */

/* ▼▼▼ 把所有這些新樣式黏貼到 <style> 的末尾 ▼▼▼ */

/* === 動態功能欄樣式 === */
.qzone-actions-bar {
    display: flex;
    justify-content: space-around;
    padding: 10px 0;
    margin: 40px 15px 15px 15px; /* 上邊距更大，為浮動的頭像留出空間 */
    background-color: var(--secondary-bg);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
}

.action-item {
    flex: 1;
    text-align: center;
    font-size: 15px;
    font-weight: 500;
    color: var(--text-primary);
    cursor: pointer;
    padding: 8px 0;
    position: relative;
}

/* 用偽元素創建分隔線 */
.action-item:not(:last-child)::after {
    content: '';
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 1px;
    height: 20px;
    background-color: var(--border-color);
}

/* === 動態帖子清單樣式 === */
#qzone-posts-list {
    padding: 0 15px 20px 15px; /* 左右和底部留出邊距 */
    display: flex;
    flex-direction: column;
    gap: 20px; /* 帖子之間的間距 */
}

.qzone-post-item {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
}

.post-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

.post-header .post-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
}

.post-info {
    display: flex;
    flex-direction: column;
}

.post-info .post-nickname {
    font-weight: 600;
    font-size: 15px;
    color: var(--text-primary);
}

.post-info .post-timestamp {
    font-size: 12px;
    color: var(--text-secondary);
}

.post-content {
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    white-space: pre-wrap; /* 讓分行符號生效 */
    word-break: break-word; /* 防止長單詞溢出 */
}

/* ▲▲▲ 新樣式結束 ▲▲▲ */

/* ▼▼▼ 新樣式黏貼到末尾 ▼▼▼ */

/* === 發佈動態模態框樣式 === */
#post-public-text {
    min-height: 80px; /* 確保文本域有足夠的高度 */
    resize: vertical;
}

.post-image-preview-container {
    position: relative;
    width: 100%;
    aspect-ratio: 16 / 9; /* 保持16:9的預覽比例 */
    background-color: #f0f2f5;
    border: 2px dashed var(--border-color);
    border-radius: 8px;
    margin-bottom: 15px;
    display: none; /* 默認隱藏 */
    justify-content: center;
    align-items: center;
}
.post-image-preview-container.visible {
    display: flex; /* 上傳後顯示 */
}

#post-image-preview {
    max-width: 100%;
    max-height: 100%;
    object-fit: contain;
    border-radius: 6px;
}

#post-remove-image-btn {
    position: absolute;
    top: -10px;
    right: -10px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background-color: #ff3b30;
    color: white;
    border: 2px solid white;
    font-size: 16px;
    line-height: 20px;
    text-align: center;
    cursor: pointer;
    box-shadow: 0 1px 4px rgba(0,0,0,0.3);
}

.post-image-upload-options {
    display: flex;
    gap: 10px;
}

.post-image-upload-options button {
    flex: 1;
    margin-top: 0;
}

/* ▲▲▲ 新樣式結束 ▲▲▲ */

/* ▼▼▼ 新樣式 ▼▼▼ */

/* === 發佈動態模態框 - 模式切換樣式 === */
.post-mode-switcher {
    display: flex;
    margin-bottom: 20px;
    background-color: #e9ecef;
    border-radius: 8px;
    padding: 4px;
}

.mode-btn {
    flex: 1;
    padding: 8px;
    border: none;
    background-color: transparent;
    border-radius: 6px;
    font-size: 14px;
    font-weight: 500;
    color: var(--text-secondary);
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

.mode-btn.active {
    background-color: var(--secondary-bg);
    color: var(--text-primary);
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.post-mode-content {
    display: none; /* 默認都隱藏 */
}

.post-mode-content.active {
    display: block; /* 啟動的才顯示 */
}

/* ▲▲▲ 新樣式結束 ▲▲▲ */

/* === 相冊頁面背景色 === */
#album-screen {
    background-color: #f0f2f5; /* 使用一個柔和的淺灰色，比純白更護眼 */
}

/* === 相冊頁面網格佈局 === */
#album-grid-page {
    padding: 15px;
    display: grid;
    grid-template-columns: repeat(2, 1fr); /* 每行顯示2個相冊 */
    gap: 15px;
}

/* === 相冊專案樣式 (美化) === */
.album-item {
    display: flex;
    flex-direction: column;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    border-radius: 8px; /* 給整個項目也加個圓角 */
}

.album-item:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 15px rgba(0,0,0,0.1);
}

.album-cover {
    aspect-ratio: 1 / 1; /* 保持封面為正方形 */
    background-size: cover;
    background-position: center;
    border-radius: 8px;
    margin-bottom: 8px;
    background-color: #f0f2f5; /* 封面載入前的占位顏色 */
}

.album-info {
    text-align: center;
}

.album-name {
    font-weight: 500;
    margin: 0 0 4px 0;
    color: var(--text-primary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis; /* 防止長名字換行 */
}

.album-count {
    font-size: 12px;
    color: var(--text-secondary);
    margin: 0;
}

/* ▲▲▲ 新的 CSS 黏貼結束 ▲▲▲ */

/* ▼▼▼ 請將這些新樣式黏貼到 <style> 的末尾 ▼▼▼ */

/* === 相冊照片詳情頁 === */
#album-photos-screen {
    background-color: #f0f2f5;
}

#photos-grid-page {
    padding: 15px;
    display: grid;
    /* 每行顯示3張照片，並保持間距 */
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
}

.photo-item {
    position: relative; /* 為了定位刪除按鈕 */
    aspect-ratio: 1 / 1; /* 保持照片為正方形 */
    border-radius: 6px;
    overflow: hidden; /* 防止圖片溢出圓角 */
    background-color: #e9ecef; /* 圖片載入前的預留位置顏色 */
}

.photo-item .photo-thumb {
    width: 100%;
    height: 100%;
    object-fit: cover; /* 保證圖片填滿容器且不變形 */
    cursor: pointer;
}

/* 刪除按鈕的樣式 */
.photo-item .photo-delete-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 22px;
    height: 22px;
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 16px;
    line-height: 22px;
    text-align: center;
    cursor: pointer;
    opacity: 0; /* 默認隱藏 */
    transition: opacity 0.2s ease;
}

/* 滑鼠懸停在照片上時顯示刪除按鈕 */
.photo-item:hover .photo-delete-btn {
    opacity: 1;
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */

/* === 圖片檢視器模態框樣式 === */
#photo-viewer-modal {
    background-color: rgba(0, 0, 0, 0.85);
    z-index: 1002;
    -webkit-backdrop-filter: blur(5px);
    backdrop-filter: blur(5px);
}

.photo-viewer-content {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
}

#photo-viewer-image {
    max-width: 90vw;  /* 圖片最大寬度為視口的90% */
    max-height: 85vh; /* 圖片最大高度為視口的85% */
    object-fit: contain;
    border-radius: 8px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    /* 為圖片的切換添加一點平滑的淡入淡出效果 */
    transition: opacity 0.2s ease-in-out;
}

/* 關閉按鈕 */
#photo-viewer-close-btn {
    position: absolute;
    top: 20px;
    right: 20px;
    background: none;
    border: none;
    color: white;
    font-size: 40px;
    font-weight: 200;
    cursor: pointer;
    line-height: 1;
    text-shadow: 0 0 5px black;
}

/* 左右導航箭頭 */
#photo-viewer-modal .nav-arrow {
    position: absolute; /* 現在我們用絕對定位來控制箭頭 */
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    font-size: 50px; /* 在手機螢幕上，可以稍微小一點 */
    font-weight: 100;
    cursor: pointer;
    padding: 10px; /* 調整內邊距 */
    user-select: none;
    transition: color 0.2s;
    z-index: 1003; /* 確保箭頭在最上層 */
}

#photo-viewer-prev-btn {
    left: 5px; /* 定位左箭頭 */
}

#photo-viewer-next-btn {
    right: 5px; /* 定位右箭頭 */
}

#photo-viewer-modal .nav-arrow:hover {
    color: white;
}

/* 當箭頭被禁用時（比如第一張或最後一張） */
#photo-viewer-modal .nav-arrow:disabled {
    color: rgba(255, 255, 255, 0.2);
    cursor: default;
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */

/* ▼▼▼ 請將這些新樣式黏貼到 <style> 的末尾 ▼▼▼ */

/* ▼▼▼ 請用這塊新CSS替換掉上一版的交互區CSS ▼▼▼ */

/* === 帖子內容區 - 相對定位容器 === */
/* === 帖子內容區 === */
.post-main-content {
    /* 它現在只是一個普通的內容容器，不再需要特殊樣式了 */
}

/* === 帖子互動圖示區 (新樣式) === */
.post-feedback-icons {
    display: flex;
    justify-content: flex-end; /* 讓圖示靠右對齊 */
    align-items: center;
    gap: 12px;
    padding: 8px 0; /* 核心修改：給圖示區域上下各8px的留白 */
}

.action-icon {
    cursor: pointer;
    color: var(--text-secondary); /* 默認灰色 */
    transition: all 0.2s ease-in-out;
}

.action-icon svg {
    width: 22px;
    height: 22px;
    fill: none;
    stroke: currentColor;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
}

/* 圖示啟動(點贊/收藏後)的樣式 */
.action-icon.active {
    color: #ff5252; /* 啟動後變紅色 */
    transform: scale(1.1); /* 輕微放大 */
}

.action-icon.active.favorite {
    color: #ffc107; /* 收藏用黃色 */
}

.action-icon.active svg {
    fill: currentColor; /* 啟動後填充顏色 */
}

/* 點擊時的動畫效果 */
.animate-like {
    animation: like-bounce 0.4s ease-in-out;
}

@keyframes like-bounce {
    0%   { transform: scale(1); }
    25%  { transform: scale(0.8); }
    50%  { transform: scale(1.2); }
    75%  { transform: scale(1.05); }
    100% { transform: scale(1.1); }
}


/* === 帖子底部評論區樣式 (現在是獨立部分) === */
.post-footer {
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid #f0f0f0; /* 用一條淺色線分隔 */
    display: flex;
    align-items: center;
    gap: 8px; /* 調整整體間距 */
}

/* 評論區容器 */
.comment-section {
    flex-grow: 1; /* 佔據大部分空間 */
    display: flex;
    align-items: center;
    gap: 8px;
}

.comment-section .comment-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}

.comment-section .comment-input {
    width: 100%;
    padding: 8px 12px;
    border: none;
    background-color: #f0f2f5;
    border-radius: 14px;
    font-size: 13px;
    outline: none;
}

/* 新增的發送按鈕樣式 */
.comment-send-btn {
    flex-shrink: 0; /* 防止被壓縮 */
    padding: 8px 15px;
    border: none;
    background-color: var(--accent-color);
    color: white;
    border-radius: 14px;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */

/* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */

/* === 未讀消息小紅點通用樣式 === */
.unread-indicator {
    position: absolute;
    top: -8px;      
    right: -15px;    
    min-width: 18px;
    height: 18px;
    padding: 0 5px;
    background-color: #ff3b30;
    color: white;
    font-size: 11px;
    font-weight: bold;
    line-height: 18px;
    text-align: center;
    border-radius: 9px;
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
    display: none;
    z-index: 1;
}

/* 聊天介面返回按鈕上的小紅點 (只顯示點，不顯示數位) */
.back-btn-indicator {
    top: 0;
    right: -8px; /* 放到返回箭頭右上角 */
    width: 10px;
    height: 10px;
    min-width: 10px;
    padding: 0;
    border-radius: 50%;
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */

/* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */

/* === 評論列表容器 === */
.post-comments-container {
    padding: 10px 0; /* 上下留白 */
    display: flex;
    flex-direction: column;
    gap: 8px; /* 評論之間的間距 */
    font-size: 13px; /* 統一評論區字體大小 */
}

/* 每一條評論 */
.comment-item {
    line-height: 1.5;
}

/* 評論者的名字，加粗並使用主題色 */
.comment-item .commenter-name {
    font-weight: 600;
    color: var(--accent-color);
    cursor: pointer;
    margin-right: 5px; /* 和評論內容之間留點空隙 */
}

/* 評論內容 */
.comment-item .comment-text {
    color: var(--text-primary);
    word-break: break-word;
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */

/* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */

/* === 帖子點贊區域樣式 === */
.post-likes-section {
    display: flex;
    align-items: center;
    gap: 6px; /* 圖示和文字的間距 */
    padding: 8px 10px; /* 內邊距 */
    font-size: 13px;
    color: var(--accent-color); /* 使用主題藍色 */
    background-color: #f0f5fa; /* 給一個淡淡的背景色 */
    border-top: 1px solid #e9eef3;
    border-bottom: 1px solid #e9eef3;
    margin-top: 5px; /* 和上方的圖示保持一點距離 */
}

.post-likes-section .like-icon {
    width: 16px;
    height: 16px;
    fill: currentColor; /* 讓SVG圖示繼承父元素的顏色 */
    flex-shrink: 0; /* 防止圖示被壓縮 */
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */

/* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */

/* === @提及 彈出功能表樣式 === */
.at-mention-popup {
    position: absolute; /* 相對于父元素定位 */
    bottom: 100%; /* 顯示在輸入框的上方 */
    left: 40px; /* 和輸入框左側對齊 (考慮了頭像寬度) */
    width: calc(100% - 40px); /* 寬度和輸入框差不多 */
    max-height: 120px;
    overflow-y: auto;
    background-color: var(--secondary-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
    z-index: 10;
    display: none; /* 默認隱藏 */
}

.at-mention-item {
    padding: 8px 12px;
    font-size: 14px;
    cursor: pointer;
    color: var(--text-primary);
    border-bottom: 1px solid #f0f0f0;
}

.at-mention-item:last-child {
    border-bottom: none;
}

.at-mention-item:hover {
    background-color: #f5f5f5;
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */

/* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */

/* ▼▼▼ 請用下面這段【新樣式】替換掉你現有的 #favorites-list 樣式 ▼▼▼ */

/* 讓收藏視圖成為一個flex容器, 從上到下排列 */
#favorites-view {
    display: flex;
    flex-direction: column;
}

/* 確保收藏頁的header高度固定，不被壓縮 */
#favorites-view > .header {
    flex-shrink: 0;
}

/* === 收藏清單樣式 (修正後) === */
#favorites-list {
    flex-grow: 1; 
    overflow-y: auto; 
    overflow-x: hidden; /* <-- 新增這行，禁止水準滾動 */
    padding: 15px; 
    display: flex;
    flex-direction: column;
    gap: 15px; 
}

/* ▲▲▲ 替換結束 ▲▲▲ */

.favorite-item-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 1px 4px rgba(0,0,0,0.06);
    position: relative; /* 為了定位刪除按鈕 */
}

/* 卡片頭部，包含頭像、名字和來源 */
.fav-card-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

.fav-card-header .avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
}

.fav-card-header .info {
    flex-grow: 1;
}

.fav-card-header .name {
    font-weight: 600;
    font-size: 15px;
}

.fav-card-header .source {
    font-size: 12px;
    color: var(--text-secondary);
}

/* 卡片內容 */
.fav-card-content {
    font-size: 14px;
    line-height: 1.6;
    color: #333;
    white-space: pre-wrap;
    word-break: break-word;
}

.fav-card-content .chat-image {
    margin-top: 8px; /* 圖片和文字的間距 */
}

/* 刪除按鈕 */
.fav-delete-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 28px;
    height: 28px;
    background: #f0f2f5;
    border: none;
    border-radius: 50%;
    cursor: pointer;
    font-size: 18px;
    color: var(--text-secondary);
    line-height: 28px;
    text-align: center;
}

.fav-delete-btn:hover {
    background-color: #e9ecef;
    color: #ff3b30;
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */

/* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */

/* === 搜索欄樣式 === */
.search-bar-container {
    padding: 10px 15px;
    background-color: #f9f9f9; /* 和列表背景色保持一致 */
    position: relative; /* 為了定位清除按鈕 */
    flex-shrink: 0;
}

#favorites-search-input {
    width: 100%;
    padding: 10px 30px 10px 15px; /* 右側留出清除按鈕的位置 */
    font-size: 14px;
    border: 1px solid var(--border-color);
    border-radius: 18px; /* 圓角矩形，更現代化 */
    background-color: var(--secondary-bg);
    box-sizing: border-box;
    outline: none;
}
#favorites-search-input:focus {
    border-color: var(--accent-color);
}

.search-clear-btn {
    position: absolute;
    right: 25px;
    top: 50%;
    transform: translateY(-50%);
    background: #ccc;
    color: white;
    border: none;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    line-height: 20px;
    text-align: center;
    font-size: 16px;
    cursor: pointer;
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */

/* === 聊天介面多選操作欄優化 === */
#chat-interface-screen .header .selection-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

#chat-interface-screen .selection-controls .action-btn {
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    padding: 5px;
}

/* === 收藏頁面多選模式樣式 === */
#favorites-view.selection-mode .favorite-item-card {
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

/* 選擇框的樣式 */
.favorite-item-card::before {
    content: '';
    position: absolute;
    left: -25px; /* 把它放在卡片左邊外面 */
    top: 50%;
    transform: translateY(-50%);
    width: 20px;
    height: 20px;
    border: 2px solid #ccc;
    border-radius: 50%;
    background-color: white;
    transition: all 0.2s ease;
    opacity: 0; /* 默認隱藏 */
}

/* 進入選擇模式時，卡片向右移動，露出選擇框 */
#favorites-view.selection-mode .favorite-item-card {
    transform: translateX(35px);
}
#favorites-view.selection-mode .favorite-item-card::before {
    opacity: 1;
}

/* 選中後的樣式 */
#favorites-view.selection-mode .favorite-item-card.selected::before {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    content: '✔';
    color: white;
    font-size: 14px;
    text-align: center;
    line-height: 20px;
}

/* 底部操作欄 (終極修正版) */
#favorites-action-bar {
    position: absolute; /* ★ 改為 absolute，相對於 #phone-screen 定位 */
    bottom: 0;
    left: 0;
    right: 0;           /* ★ 新增 right: 0，和 left: 0 一起撐滿寬度 */
    width: auto;        /* ★ 改為 auto，讓 left/right 決定寬度 */
    padding: 10px 15px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom)); /* 適配iPhone底部安全區 */
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid var(--border-color);
    box-sizing: border-box;
    z-index: 5;
    display: none;
    /* max-width 已經不需要了，因為父元素已經限制了寬度 */
}

#favorites-action-bar .action-bar-btn {
    width: 100%;
    padding: 12px;
    border-radius: 8px;
    border: none;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    background-color: #ff3b30;
    color: white;
}

/* === 【修正】聊天介面頭部控制項切換邏輯 === */

/* 預設狀態：隱藏多選控制項 */
#chat-interface-screen .header .selection-controls {
    display: none;
}

/* 預設狀態：顯示預設控制項，並讓它撐滿整個頭部 */
#chat-interface-screen .header .default-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

/* 當進入多選模式時：隱藏預設控制項 */
#chat-interface-screen.selection-mode .header .default-controls {
    display: none;
}

/* 當進入多選模式時：顯示多選控制項，並讓它撐滿整個頭部 */
#chat-interface-screen.selection-mode .header .selection-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
}

/* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */

/* === 修正：放大所有主要的“+”號按鈕 === */
#add-chat-btn,
#add-world-book-btn,
#create-album-btn-page {
    font-size: 28px;   /* 顯著增大字體大小，使其視覺上與旁邊的圖示匹配 */
    font-weight: 300;  /* 使用更細的字重，讓加號看起來更清爽，不顯粗笨 */
    position: relative;/* 允許進行位置微調 */
    top: -1px;         /* 字體放大後，通常需要稍微向上移動一點，使其視覺上更居中 */
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */

/* ▼▼▼ 請將這些新樣式黏貼到 <style> 的末尾 ▼▼▼ */

/* 預覽區容器樣式 */
#settings-preview-area {
    width: 100%;
    height: 180px; /* 給一個固定的高度 */
    background-color: #f0f2f5;
    border-radius: 8px;
    padding: 15px;
    box-sizing: border-box;
    overflow: hidden; /* 防止內容溢出 */
    display: flex;
    flex-direction: column;
    gap: 10px; /* 預覽氣泡之間的間距 */
    border: 1px solid var(--border-color);
    position: relative; /* 為了定位背景 */
}

/* 預覽區的背景，可以和真實聊天介面同步 */
#settings-preview-area::before {
    content: '';
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background-size: cover;
    background-position: center;
    z-index: 1;
    opacity: 0.8;
}

/* 讓預覽氣泡在背景之上 */
#settings-preview-area .message-wrapper {
    position: relative;
    z-index: 2;
}

/* 預覽區內使用的頭像要小一點 */
#settings-preview-area .message-bubble .avatar {
    width: 30px;
    height: 30px;
}

#settings-preview-area .message-bubble .timestamp {
    display: none; /* 預覽區不需要顯示時間戳記 */
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */

/* ▼▼▼ 請將這段新CSS黏貼到 <style> 的末尾 ▼▼▼ */
.existing-group-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 12px;
    background-color: #f9f9f9;
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

.existing-group-item .group-name {
    font-weight: 500;
}

.existing-group-item .delete-group-btn {
    color: #ff3b30;
    font-size: 20px;
    cursor: pointer;
    padding: 5px;
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 請將這段新CSS黏貼到 <style> 的末尾 ▼▼▼ */
.chat-group-container {
    border-bottom: 1px solid var(--border-color);
}
.chat-group-container:first-child {
    border-top: 1px solid var(--border-color);
}

.chat-group-header {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    cursor: pointer;
    background-color: var(--secondary-bg); /* <-- 修改這裡，使用變數 */
}


.chat-group-header .arrow {
    font-size: 14px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}

.chat-group-header.collapsed .arrow {
    transform: rotate(-90deg);
}

.chat-group-header .group-name {
    font-weight: 600;
    font-size: 15px;
}

.chat-group-content {
    max-height: 1000px; /* 一個足夠大的值 */
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}

.chat-group-content.collapsed {
    max-height: 0;
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 請將這段新CSS黏貼到 <style> 的末尾 ▼▼▼ */

/* 格式助手按鈕的容器 */
.format-helpers {
    display: flex;
    gap: 10px;
    margin-bottom: 15px; /* 與下方的文字方塊拉開距離 */
    flex-wrap: wrap; /* 如果按鈕太多可以換行 */
}

/* 單個格式助手按鈕的樣式 */
.format-btn {
    background-color: #e9ecef;
    color: var(--text-primary);
    border: none;
    padding: 6px 12px;
    border-radius: 16px; /* 膠囊形狀，更友好 */
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s;
}

.format-btn:hover {
    background-color: #dcdfe3;
}

/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 請將這段新CSS黏貼到 <style> 的末尾 ▼▼▼ */

/* “…”按鈕的樣式 */
.post-actions-btn {
    margin-left: auto; /* 關鍵：讓它自動靠到最右邊 */
    padding: 5px 10px;
    font-size: 20px;
    font-weight: bold;
    color: var(--text-secondary);
    cursor: pointer;
    border-radius: 50%;
    line-height: 1;
}
.post-actions-btn:hover {
    background-color: #f0f0f0;
}

/* 動態編輯模態框的樣式 (它將複用現有的操作功能表樣式) */
#post-actions-modal .custom-modal-footer button {
    width: 100%;
    border: none;
    border-bottom: 1px solid #dbdbdb;
    padding: 14px;
    font-size: 18px;
}
#post-actions-modal .custom-modal-footer button:last-child {
    border-bottom: none;
}
#post-actions-modal #cancel-post-action-btn {
    margin-top: 8px;
    border-radius: 8px;
    background-color: #f0f0f0;
}

/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* 統一重置轉帳卡片內所有文字的特效和顏色 */
#chat-messages .transfer-card .transfer-title,
#chat-messages .transfer-card .transfer-amount,
#chat-messages .transfer-card .transfer-note {
    text-shadow: none !important; /* 強制移除任何發光或陰影效果 */
    color: white !important;      /* 強制鎖定文字顏色為白色 */
}

/* 分別鎖定各自的字體大小和字重，防止被篡改 */
#chat-messages .transfer-card .transfer-title {
    font-size: 16px !important;
    font-weight: 600 !important;
}

#chat-messages .transfer-card .transfer-amount {
    font-size: 28px !important;
    font-weight: bold !important;
}

#chat-messages .transfer-card .transfer-note {
    font-size: 13px !important;
    opacity: 0.9 !important;
}

/* ▼▼▼ 這是新增的樣式，用於修正所有頭部標題的居中問題 ▼▼▼ */
/* ▼▼▼ 這是新增的樣式，用於修正所有頭部標題的居中問題 ▼▼▼ */
.header > span:nth-child(2) {
    position: absolute;
    left: 50%;
    transform: translateX(calc(-50% - 2px)); /* 在-50%的基礎上，再向左推2圖元 */
    
    /* (可選但推薦) 防止長標題與兩邊按鈕重疊 */
    max-width: 60%;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
/* ▲▲▲ 黏貼結束 ▲▲▲ */


/* ▼▼▼ 【全新】視覺化消息編輯器樣式 ▼▼▼ */
#message-editor-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.message-editor-block {
    background-color: #f9f9f9;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px;
}

.message-editor-block textarea {
    width: 100%;
    min-height: 60px;
    resize: vertical;
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 8px;
    font-size: 14px;
    box-sizing: border-box;
}

.message-editor-block .format-helpers {
    margin-top: 8px;
    margin-bottom: 0; /* 覆蓋默認的 margin-bottom */
}

.message-editor-block .delete-block-btn {
    float: right;
    margin-top: -5px;
    background: none;
    border: none;
    color: #ff3b30;
    font-size: 20px;
    cursor: pointer;
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新】連絡人選擇器樣式 ▼▼▼ */
.contact-picker-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
}
.contact-picker-item .checkbox {
    width: 20px;
    height: 20px;
    border: 2px solid #ccc;
    border-radius: 50%;
    margin-right: 15px;
    transition: all 0.2s ease;
}
.contact-picker-item.selected .checkbox {
    background-color: var(--accent-color);
    border-color: var(--accent-color);
    content: '✔';
    color: white;
    font-size: 14px;
    text-align: center;
    line-height: 20px;
}
.contact-picker-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
}
.contact-picker-item .name {
    font-weight: 500;
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新】群成員管理介面樣式 ▼▼▼ */
#member-management-list {
    padding: 0; /* 移除默認padding，讓列表項撐滿 */
}

.member-management-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
}

.member-management-item .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
}

.member-management-item .name {
    flex-grow: 1;
    font-weight: 500;
}

.member-management-item .remove-member-btn {
    background-color: #ff3b30;
    color: white;
    border: none;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    font-size: 20px;
    line-height: 28px;
    text-align: center;
    cursor: pointer;
    flex-shrink: 0;
}

#member-management-actions {
    flex-shrink: 0;
    padding: 15px;
    border-top: 1px solid var(--border-color);
    background-color: #f7f7f7;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

#member-management-actions button {
    width: 100%;
    padding: 15px;
    background-color: var(--accent-color);
    color: white;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
}
#member-management-actions #create-new-member-btn {
    background-color: #4cd964; /* 新建用綠色，以示區分 */
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新】外賣代付卡片樣式 ▼▼▼ */
.message-bubble.is-waimai-request .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.waimai-card {
    width: 240px;
    border-radius: 12px;
    overflow: hidden;
    background-color: #fff;
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
}

.waimai-header {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 12px;
    border-bottom: 1px solid #f0f0f0;
}

.waimai-header .icon {
    width: 20px;
    height: 20px;
}

.waimai-header .title-group {
    display: flex;
    align-items: baseline;
    font-size: 14px;
    color: #8a8a8a;
}
.waimai-header .title-group .brand {
    font-weight: 600;
    color: #555;
    margin-right: 5px;
}
.waimai-header .title-group .separator {
    margin: 0 5px;
}

.waimai-catchphrase {
    font-size: 13px;
    color: #1f1f1f;
    padding: 12px;
}

.waimai-main {
    background-color: #FFD66B; /* 橙黃色背景 */
    padding: 12px;
    text-align: center;
}

.waimai-main .request-title {
    font-size: 12px;
    color: #856404;
    margin-bottom: 8px;
}

.waimai-main .payment-box {
    background-color: #fff;
    border-radius: 8px;
    padding: 15px 10px;
}

.waimai-main .payment-label {
    font-size: 13px;
    color: #8a8a8a;
}

.waimai-main .amount {
    font-size: 32px;
    font-weight: 700;
    color: #1f1f1f;
    margin: 4px 0 12px 0;
}

.waimai-main .countdown-label {
    font-size: 13px;
    color: #8a8a8a;
}
.waimai-main .countdown-timer {
    display: inline-flex;
    align-items: center;
    gap: 2px;
    margin-left: 5px;
}
.waimai-main .countdown-timer span {
    background-color: #333;
    color: white;
    padding: 2px 4px;
    border-radius: 2px;
    font-weight: bold;
    font-size: 12px;
}

.waimai-details-btn {
    width: 100%;
    padding: 10px 0;
    margin-top: 15px;
    border: none;
    border-radius: 6px;
    background-color: #FFC33A;
    color: #49380a;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新】外賣回應狀態樣式 ▼▼▼ */

/* === 同意支付後的樣式 === */
.message-bubble.status-paid .waimai-card {
    border: 2px solid #28a745; /* 綠色邊框 */
}
.message-bubble.status-paid .waimai-main .request-title::before {
    content: '✅  ';
}
.message-bubble.status-paid .waimai-main .request-title {
    color: #155724;
    font-weight: 600;
    /* 重寫 request-title 的內容 */
    content: "我已為您買單，請盡情享用吧～" !important;
    display: block;
    margin-bottom: 15px;
}

.message-bubble.status-paid .payment-box {
    display: none; /* 隱藏支付詳情 */
}
.message-bubble.status-paid .waimai-details-btn {
    background-color: #28a745;
    color: white;
}

/* === 拒絕支付後的樣式 === */
.message-bubble.status-rejected .waimai-card {
    border: 2px solid #dc3545; /* 紅色邊框 */
    opacity: 0.8;
}
.message-bubble.status-rejected .waimai-main {
    background-color: #e9ecef;
}
.message-bubble.status-rejected .waimai-main .request-title::before {
    content: '❌ ';
}
.message-bubble.status-rejected .waimai-main .request-title {
    color: #721c24;
    font-weight: 600;
    /* 重寫 request-title 的內容 */
    content: "我拒絕了您的代付請求" !important;
    display: block;
    margin-bottom: 15px;
}
.message-bubble.status-rejected .payment-box {
    display: none; /* 隱藏支付詳情 */
}
 .message-bubble.status-rejected .waimai-details-btn {
    background-color: #6c757d;
    color: white;
}

/* 強制重寫 request-title 內容的技巧 */
.message-bubble[class*="status-"] .request-title {
    font-size: 0; /* 隱藏原始文本 */
}
.message-bubble[class*="status-"] .request-title::after {
    font-size: 14px; /* 讓偽元素顯示新文本 */
}
.message-bubble.status-paid .request-title::after {
    content: "我已為您買單，請盡情享用吧～";
}
.message-bubble.status-rejected .request-title::after {
    content: "我拒絕了您的代付請求";
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新】外賣請求的使用者操作按鈕樣式 ▼▼▼ */
.waimai-user-actions {
    display: flex;
    gap: 10px;
    padding: 0 12px 12px 12px; /* 在卡片底部留出空間 */
    background-color: #fff;
}

.waimai-user-actions button {
    flex: 1;
    padding: 10px;
    border-radius: 8px;
    border: 1.5px solid;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
}

.waimai-pay-btn {
    background-color: #28a745;
    border-color: #1f7a33;
    color: white;
}
.waimai-pay-btn:hover {
    background-color: #218838;
}

.waimai-decline-btn {
    background-color: #f8f9fa;
    border-color: #ced4da;
    color: #495057;
}
.waimai-decline-btn:hover {
    background-color: #e2e6ea;
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* 確保這些頁面的內容區能正確滾動，同時背景透明以顯示父級顏色 */
#api-settings-screen .form-container,
#font-settings-screen .form-container,
#wallpaper-screen .form-container {
    padding-top: 100px;
    margin-top: -80px;
    /* 不再需要背景色，讓父元素決定 */
}
#font-settings-screen,
#wallpaper-screen {
    /* 將背景色設置為變數，這樣夜間模式才能覆蓋它 */
    background-color: var(--secondary-bg);
}
/* 壁紙設置頁面的預覽區比較特殊，需要額外調整 */
#wallpaper-screen .form-container {
    align-items: center; /* 保持內容居中 */
}

/* ▼▼▼ 【全新】來電請求與視頻通話介面樣式 ▼▼▼ */

/* --- 來電請求模態框 --- */
#incoming-call-modal .incoming-call-content {
    background-color: rgba(40, 40, 40, 0.85);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 20px;
    width: 280px;
    padding: 30px 20px;
    text-align: center;
    color: white;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
}

.caller-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    object-fit: cover;
    margin-bottom: 12px;
    border: 3px solid rgba(255,255,255,0.5);
}

.caller-name {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 5px;
}

.caller-text {
    font-size: 14px;
    color: #ccc;
    margin-bottom: 30px;
}

.incoming-call-actions {
    display: flex;
    justify-content: space-around;
    align-items: center;
}

.action-button-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: #e0e0e0;
}

.call-action-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    background-size: 50%;
    background-repeat: no-repeat;
    background-position: center;
    transition: transform 0.2s, box-shadow 0.2s;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
}
.call-action-btn:active {
    transform: scale(0.9);
}

.call-action-btn.decline {
    background-color: #ff3b30;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>');
}

.call-action-btn.accept {
    background-color: #4cd964;
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"/></svg>');
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0.7); }
    70% { box-shadow: 0 0 0 15px rgba(76, 217, 100, 0); }
    100% { box-shadow: 0 0 0 0 rgba(76, 217, 100, 0); }
}

/* ▼▼▼ 請用這一整塊【最終結構重寫版】的代碼，替換所有舊的 video-call 相關CSS ▼▼▼ */

/* 1. 通話螢幕總容器 (保持不變) */
#video-call-screen {
    background-color: #1c1c1e;
    color: white;
    display: flex; /* ★ 核心：它依然是flex容器 */
    flex-direction: column;
    overflow: hidden;
}

/* 2. 頂部欄和底部控制欄 (保持不變) */
.video-call-top-bar, .video-call-controls {
    position: absolute;
    left: 0;
    width: 100%;
    z-index: 10;
    box-sizing: border-box;
    pointer-events: none; /* 讓它們不影響下方內容的點擊 */
}
.video-call-top-bar {
    top: 0;
    padding: 15px 20px 30px; /* 增加底部padding */
    padding-top: 50px;
    background: linear-gradient(to bottom, rgba(0,0,0,0.5), transparent);
    text-align: center;
}
.video-call-controls {
    bottom: 0;
    display: flex;
    justify-content: space-around;
    align-items: center;
    padding: 20px;
    padding-bottom: 40px;
    background: linear-gradient(to top, rgba(0,0,0,0.5), transparent);
    pointer-events: all; /* 控制按鈕需要能點擊 */
}
#call-timer {
    font-size: 16px;
    font-weight: 500;
    letter-spacing: 1px;
}

/* 3. 【核心重構】預設文字通話的總容器 */
#text-call-interface {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
    overflow: hidden;
}

/* 4. 【核心重構】頭像區域 */
.video-call-avatar-area {
    flex-shrink: 0; /* ★ 核心：高度雷打不動，絕不壓縮 */
    display: flex;
    justify-content: center;
    align-items: center;
    padding-top: 100px; /* ★ 核心：與頂部狀態列拉開距離 */
    padding-bottom: 20px; /* ★ 核心：與下方氣泡區拉開距離 */
}

/* 5. 【核心重構】氣泡區域 */
#video-call-main {
    flex-grow: 1; /* ★ 核心：佔據所有剩餘的垂直空間 */
    min-height: 0; /* ★ 核心：一個防止flex溢出的重要保險絲 */
    margin: 0 15px 130px 15px; /* ★ 核心：定義四周邊界，底部留足空間給按鈕 */
    overflow-y: auto;
    padding: 15px;
    background-color: rgba(255, 255, 255, 0.08); /* 稍微調亮一點背景 */
    border-radius: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

/* 6. 頭像網格和頭像本身樣式 (微調) */
#participant-avatars-grid {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 20px;
}
.participant-avatar-wrapper {
    text-align: center;
}
.participant-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    object-fit: cover;
    border: 3px solid rgba(255, 255, 255, 0.2);
    transition: all 0.3s ease;
}
.participant-name {
    margin-top: 8px;
    font-size: 13px;
    color: #ccc;
}
.participant-avatar.speaking {
    border-color: #4cd964;
    box-shadow: 0 0 20px rgba(76, 217, 100, 0.6);
    transform: scale(1.05);
}

/* 7. 控制按鈕樣式 (保持不變) */
.control-btn {
    width: 70px; height: 70px; border-radius: 50%; border: none; cursor: pointer;
    background-repeat: no-repeat; background-position: center;
    transition: transform 0.2s, background-color 0.2s;
    pointer-events: all;
}
.control-btn:active { transform: scale(0.9); }
.control-btn.speak-btn { background-color: rgba(255,255,255,0.2); background-size: 55%; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>'); }
.control-btn.hangup-btn { background-color: #ff3b30; background-size: 50%; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13.5 16.5L3 6m18 6l-5.6-5.6a1.2 1.2 0 0 0-1.7 0L3 18.2a1.2 1.2 0 0 0-.3 1.2l1.2 3.6a1.2 1.2 0 0 0 1.2.9h15.6a1.2 1.2 0 0 0 1.2-1.2V7.7a1.2 1.2 0 0 0-.3-1.1z"/></svg>'); }
.control-btn.join-btn { background-color: #007bff; background-size: 50%; background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="17" y1="11" x2="23" y2="11"></line></svg>'); }

/* ▲▲▲ 新CSS替換結束 ▲▲▲ */

/* ▼▼▼ 【全新】視頻通話對話氣泡樣式 ▼▼▼ */
.call-message-bubble {
    padding: 10px 15px;
    border-radius: 12px;
    max-width: 85%;
    line-height: 1.6;
    word-break: break-word;
    white-space: pre-wrap;
}

.call-message-bubble.ai-speech {
    background-color: rgba(255, 255, 255, 0.15);
    align-self: flex-start; /* AI發言靠左 */
}

.call-message-bubble.user-speech {
    background-color: #4cd964; /* 用戶發言用綠色，類似微信 */
    align-self: flex-end;   /* 用戶發言靠右 */
    text-align: left; /* 確保使用者氣泡內的文字是左對齊的 */
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */

/* ▼▼▼ 【全新添加】正在呼叫介面樣式 ▼▼▼ */
#outgoing-call-screen {
    background-color: #1c1c1e;
    color: white;
    justify-content: center; /* 垂直居中 */
    align-items: center;   /* 水準居中 */
}

.outgoing-call-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}

.outgoing-call-actions {
    margin-top: 50px; /* 和上方文字拉開距離 */
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    font-size: 13px;
    color: #e0e0e0;
}
/* ▲▲▲ 添加結束 ▲▲▲ */

/* 1. 動態帖子的外層容器，我們需要它來定位和裁剪 */
.qzone-post-container {
    position: relative; /* 讓內部的刪除按鈕可以相對於它定位 */
    overflow: hidden;   /* 隱藏掉超出部分的刪除按鈕 */
    border-radius: 12px;/* 和內部卡片保持一致的圓角 */
}

/* 2. 可滑動的內容卡片，增加一個平滑的過渡效果 */
.qzone-post-item {
    transition: transform 0.3s ease;
    background-color: var(--secondary-bg); /* 確保它有背景色，能蓋住下面的刪除按鈕 */
    position: relative; /* 確保它在最上層 */
    z-index: 2;
}

/* 3. 【核心】這就是那個“刪除”按鈕的樣式！*/
.qzone-post-delete-action {
    position: absolute; /* 絕對定位，脫離文檔流 */
    top: 0;
    right: 0;
    bottom: 0;
    width: 90px; /* 刪除按鈕的寬度 */
    background-color: #ff3b30; /* 您想要的紅色背景 */
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 500;
    cursor: pointer;
    z-index: 1; /* 確保它在卡片下面 */
}

/* 4. 當卡片左滑時，把它向左移動，露出刪除按鈕 */
.qzone-post-item.swiped {
    transform: translateX(-90px); /* 移動的距離和刪除按鈕的寬度一致 */
}

/* ▲▲▲ 黏貼結束 ▲▲▲ */

/* ▼▼▼ 請將這【一整塊】全新的“拍一拍”樣式，黏貼到 <style> 的末尾 ▼▼▼ */

/* 1. “拍一拍”的螢幕震動動畫 */
@keyframes pat-shake {
    0%, 100% { transform: translateX(0); }
    10%, 30%, 50%, 70%, 90% { transform: translateX(-3px); }
    20%, 40%, 60%, 80% { transform: translateX(3px); }
}

.pat-animation {
    animation: pat-shake 0.4s ease-in-out;
}

/* 2. “拍一拍”系統提示消息的樣式 */
.system-message {
    align-self: center; /* 居中顯示 */
    padding: 4px 12px;
    margin: 5px 0;
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    border-radius: 10px;
    text-align: center;
    max-width: 80%;
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */

/* 讓“拍一拍”類型的 wrapper 居中 */
.message-wrapper.system-pat {
    justify-content: center;
    align-self: center;
    margin: 5px 0;
    max-width: 80%;
}
/* “拍一-拍”消息氣泡的樣式 */
.message-bubble.system-bubble {
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    padding: 4px 12px;
    border-radius: 10px;
}

/* ▼▼▼ 請將這段新CSS黏貼到 <style> 的末尾 ▼▼▼ */

/* === 修正：讓頂部操作欄可以橫向滾動 === */
#chat-input-actions-top {
    display: flex;
    gap: 8px;
    padding: 0 5px;

    /* --- 核心代碼開始 --- */
    overflow-x: auto;      
    flex-wrap: nowrap;     
    -webkit-overflow-scrolling: touch; 

    scrollbar-width: none; 
    -ms-overflow-style: none;  
}

#chat-input-actions-top::-webkit-scrollbar {
    display: none; 
}

/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* === 【全新】聊天介面頭部狀態列樣式 === */

/* === 【全新】聊天介面頭部狀態列樣式 === */

/* ▼▼▼ 用這塊【居中修復版】的代碼，替換舊的 #chat-header-title-wrapper 樣式 ▼▼▼ */
#chat-header-title-wrapper {
    /* --- 核心修改：讓標題區域絕對居中 --- */
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    /* ------------------------------------ */
    
    /* 保持其內部元素（標題和狀態）的佈局不變 */
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px; 
    
    /* (可選但推薦) 防止長標題與兩邊按鈕重疊 */
    max-width: 60%;
    
    /* 注意：我們不再需要 flex-grow: 1; 了，因為絕對定位已經使其脫離了flex佈局流 */
}
/* ▲▲▲ 替換結束 ▲▲▲ */

/* ▲▲▲ 替換結束 ▲▲▲ */

/* 【新增】這是我們新加的樣式，用於將標題和心形按鈕橫向排列 */
#chat-header-main-line {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px; /* 標題和心形按鈕之間的間距 */
}


/* ▼▼▼ 請用這塊【終極修復版】代碼，替換掉你舊的 #chat-header-title 樣式 ▼▼▼ */
#chat-header-title {
    font-size: 16px;
    font-weight: 600;
    
    /* (這兩行是上次修復定位問題的，必須保留！) */
    position: static !important;
    transform: none !important;

    /* ★★★ 核心修復：我們已經把導致省略號的四行代碼全部刪掉了！ ★★★ */
}
/* ▲▲▲ 替換結束 ▲▲▲ */




/* 3. 狀態列容器 */
#chat-header-status {
    display: flex;
    align-items: center;
    gap: 5px;
    font-size: 11px;
    color: var(--text-secondary);
    transition: all 0.3s ease;
}

/* 4. 狀態小圓點 */
.status-dot {
    width: 7px;
    height: 7px;
    border-radius: 50%;
    background-color: #4cd964; /* 默認綠色，代表線上 */
    transition: background-color 0.3s ease;
}

/* 當AI狀態為“忙碌”或“離開”時，讓圓點變灰色 */
#chat-header-status.busy .status-dot {
    background-color: #cccccc;
}

/* 5. 狀態文本 */
.status-text {
    font-weight: 500;
}

/* === 【全新美化版】回憶卡片樣式 === */

/* 1. 卡片總容器：這裡負責定義整體的背景色和邊框 */
.memory-card {
    background-color: #fffaf0; /* 統一的、溫暖的米黃色背景 */
    border-radius: 12px;
    padding: 15px; /* 在卡片四周留出內邊距 */
    box-shadow: 0 2px 6px rgba(0,0,0,0.07);
    border-left: 5px solid #ffb74d; 
    display: flex; /* 讓它成為flex容器，方便內部元素排列 */
    flex-direction: column; /* 讓頭部和內容垂直堆疊 */
    gap: 8px; /* 在頭部和內容之間創造一個自然的間距 */
}

/* 2. 頭部容器：現在只負責佈局和分割線 */
.memory-card .header {
    border-bottom: 1px solid rgba(217, 129, 0, 0.15); /* 分割線顏色可以稍微加深一點 */
    padding-bottom: 8px; 
}

/* 3. 日期樣式 (保持不變) */
.memory-card .header .date {
    font-size: 11px;
    color: #a1887f;
    margin-bottom: 4px; 
}

/* 4. 作者樣式 (保持不變) */
.memory-card .header .author {
    font-weight: 600;
    color: #d98100;
    font-size: 15px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 5. 內容區樣式 (保持不變) */
.memory-card .content {
    font-size: 14px;
    line-height: 1.7;
    color: #5d4037;
    white-space: pre-wrap;
}

/* === 【全新】約定/倒計時卡片樣式 === */
.countdown-card {
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border-radius: 12px;
    padding: 20px;
    box-shadow: 0 4px 15px rgba(118, 75, 162, 0.4);
    text-align: center;
    position: relative;
    overflow: hidden;
    flex-shrink: 0;
}
.countdown-card::before {
    content: '✨';
    position: absolute;
    top: -10px;
    left: -10px;
    font-size: 50px;
    opacity: 0.1;
    transform: rotate(-15deg);
}
.countdown-card .title {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 15px;
}
.countdown-card .timer {
    font-size: 28px;
    font-weight: 300;
    letter-spacing: 2px;
    margin-bottom: 15px;
}
.countdown-card .target-date {
    font-size: 12px;
    opacity: 0.8;
    border-top: 1px solid rgba(255,255,255,0.2);
    padding-top: 10px;
}

/* === 【全新】聊天鎖定遮罩層樣式 === */
#chat-lock-overlay {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    z-index: 150; /* 比輸入框高，比貼紙面板低 */
    display: none; /* 默認隱藏 */
    align-items: center;
    justify-content: center;
    padding: 20px;
    box-sizing: border-box;
    border-top: 1px solid var(--border-color);
    text-align: center;
}
#chat-lock-content {
    display: flex;
    flex-direction: column;
    gap: 15px;
}
#chat-lock-content .lock-text {
    color: var(--text-secondary);
    font-size: 14px;
}
#chat-lock-content .lock-action-btn {
    padding: 10px 20px;
    border-radius: 20px;
    border: 1px solid var(--accent-color);
    background-color: var(--accent-color);
    color: white;
    cursor: pointer;
}
#chat-lock-content .lock-action-btn.secondary {
    background-color: transparent;
    color: var(--accent-color);
}

/* ▼▼▼ 【全新】紅包卡片樣式 ▼▼▼ */
.message-bubble.is-red-packet .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.red-packet-card {
    width: 220px;
    border-radius: 8px;
    background: linear-gradient(160deg, #F96259, #E44D44);
    color: #ffd700; /* 金色文字 */
    padding: 12px;
    cursor: pointer;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    position: relative;
    overflow: hidden;
}

.red-packet-card.opened {
    background: linear-gradient(160deg, #d3c4a0, #c4b693);
    cursor: default;
}

.red-packet-card::before {
    content: '🧧';
    position: absolute;
    top: -5px;
    left: -5px;
    font-size: 30px;
    opacity: 0.2;
    transform: rotate(-10deg);
}

.rp-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}

.rp-icon {
    width: 20px;
    height: 20px;
}

.rp-greeting {
    font-size: 15px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.rp-type {
    font-size: 11px;
    color: white;
    opacity: 0.8;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    padding-top: 8px;
    margin-top: 8px;
}

.rp-claimed-info {
    font-size: 13px;
    color: white;
    margin-top: 10px;
    padding-top: 10px;
    border-top: 1px solid rgba(255,255,255,0.3);
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新】紅包詳情清單樣式 ▼▼▼ */
.rp-details-item {
    display: flex;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid #eee;
}
.rp-details-item:last-child {
    border-bottom: none;
}
.rp-details-item .name {
    flex-grow: 1;
    font-weight: 500;
    color: #333;
}
.rp-details-item .amount {
    font-weight: 500;
    color: #555;
}
.rp-details-item .lucky-king-tag {
    font-size: 10px;
    background-color: #ffd700;
    color: #a67c00;
    padding: 2px 5px;
    border-radius: 4px;
    margin-left: 8px;
    font-weight: bold;
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新】投票功能樣式 ▼▼▼ */

/* 投票卡片在消息氣泡中的樣式 */
.message-bubble.is-poll .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

/* 投票卡片主體 */
.poll-card {
    width: 250px;
    background-color: #f9f9f9;
    border-radius: 10px;
    border: 1px solid #e0e0e0;
    padding: 12px;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.poll-card.closed {
    background-color: #e9ecef; /* 結束後變灰 */
}

/* 投票問題 */
.poll-question {
    font-weight: 600;
    font-size: 15px;
    margin-bottom: 12px;
    line-height: 1.4;
    word-break: break-word;
}

/* 投票選項清單 */
.poll-options-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

/* 單個投票選項 */
.poll-option-item {
    background-color: white;
    border: 1px solid #dcdcdc;
    border-radius: 8px;
    padding: 10px;
    cursor: pointer;
    position: relative;
    overflow: hidden;
    transition: background-color 0.2s;
}

.poll-card:not(.closed) .poll-option-item:hover {
    background-color: #f0f8ff;
}

/* 使用者已投票的選項樣式 */
.poll-option-item.voted {
    border-color: var(--accent-color);
    background-color: #e7f3ff;
    font-weight: 500;
}

/* 投票進度條 */
.poll-option-bar {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background-color: rgba(0, 123, 255, 0.1);
    z-index: 1;
    transition: width 0.3s ease-in-out;
}

/* 選項內容（文字和票數），確保在進度條之上 */
.poll-option-content {
    position: relative;
    z-index: 2;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.poll-option-text {
    font-size: 14px;
}

.poll-option-votes {
    font-size: 13px;
    color: #8a8a8a;
    font-weight: 500;
}

/* 投票卡片底部 */
.poll-footer {
    margin-top: 12px;
    padding-top: 8px;
    border-top: 1px solid #e9e9e9;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: var(--text-secondary);
}

.poll-total-votes {
    font-weight: 500;
}

.poll-action-btn {
    background: none;
    border: 1px solid var(--accent-color);
    color: var(--accent-color);
    padding: 4px 10px;
    border-radius: 15px;
    cursor: pointer;
    font-size: 12px;
}
.poll-card.closed .poll-action-btn {
    background-color: #6c757d;
    color: white;
    border-color: #6c757d;
}

/* 創建投票模態框的選項輸入 */
.poll-option-input-wrapper {
    display: flex;
    align-items: center;
    gap: 8px;
}
.poll-option-input-wrapper input {
    flex-grow: 1;
}
.poll-option-input-wrapper .remove-option-btn {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-color: #f0f0f0;
    color: #ff3b30;
    border: none;
    cursor: pointer;
    font-size: 18px;
    line-height: 28px;
    text-align: center;
    flex-shrink: 0;
}

/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* === 【全新】聊天頭部“正在輸入”狀態樣式 === */
#chat-header-title.typing-status {
    color: var(--text-secondary);
    animation: typing-pulse 1.5s infinite;
    font-style: italic;
}

@keyframes typing-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.6; }
}

#chat-header-title {
    transition: opacity 0.2s ease-in-out;
}

@keyframes message-pop-in {
  from {
    opacity: 0;
    transform: translateY(15px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.message-wrapper.animate-in {
  animation: message-pop-in 0.3s cubic-bezier(0.25, 0.1, 0.25, 1) forwards;
  }

/* ▼▼▼ 【全新】App圖示設置樣式 ▼▼▼ */
#icon-settings-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
    gap: 20px;
    width: 100%;
    padding: 0 10px;
    box-sizing: border-box;
}

.icon-setting-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
}

.icon-preview {
    width: 60px;
    height: 60px;
    border-radius: 15px;
    background-size: cover;
    background-position: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}

.change-icon-btn {
    padding: 4px 10px;
    font-size: 12px;
    border: 1px solid #ccc;
    background-color: #f0f0f0;
    border-radius: 5px;
    cursor: pointer;
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新】外觀設置頁面配置修正 ▼▼▼ */

/* 1. 修正滾動問題 */
#wallpaper-screen .form-container {
    /* 核心修正1: 解決flex佈局下的滾動衝突，讓捲軸能正常出現 */
    min-height: 0; 
}

/* 2. 修正壁紙預覽被壓扁的問題 */
#wallpaper-preview {
    /* 核心修正2: 防止預覽框被過多的內容擠壓變形，讓它保持自己的高度 */
    flex-shrink: 0; 
}
/* ▲▲▲ 修正結束 ▲▲▲ */

/* ▼▼▼ 【全新】分享連結功能樣式 (無圖版) ▼▼▼ */

/* 1. 流覽器介面背景色和內容區樣式 (保持不變) */
#browser-screen {
    background-color: #f8f9fa;
}
#browser-content {
    padding: 20px;
    font-size: 16px;
    line-height: 1.8;
    color: #333;
    overflow-y: auto;
    background-color: #f8f9fa;
}
#browser-content .article-title {
    font-size: 24px;
    font-weight: 700;
    margin-bottom: 10px;
}
#browser-content .article-meta {
    font-size: 13px;
    color: #8a8a8a;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 1px solid #e0e0e0;
}
#browser-content .article-body {
    white-space: pre-wrap;
    word-break: break-word;
}
#browser-content .article-body p {
    margin-bottom: 1em;
}

/* 2. 聊天氣泡中的連結卡片樣式 (無圖版) */
.message-bubble.is-link-share .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

.link-share-card {
    width: 210px; 
    background-color: #fff;
    border-radius: 10px;
    border: 1px solid #e0e0e0;
    padding: 12px;
    cursor: pointer;
    transition: background-color 0.2s;
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.link-share-card:hover {
    background-color: #f9f9f9;
}

.link-share-card .title {
    font-weight: 600;
    font-size: 15px;
    line-height: 1.4;
    color: #1f1f1f;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

.link-share-card .description {
    font-size: 13px;
    color: #8a8a8a;
    display: -webkit-box;
    -webkit-line-clamp: 3;
    -webkit-box-orient: vertical;
    overflow: hidden;
    text-overflow: ellipsis;
}

.link-share-card .footer {
    display: flex; /* 讓圖示和文字水準對齊 */
    align-items: center;
    gap: 6px; /* 圖示和文字的間距 */
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px; /* 和上面的描述拉開一點距離 */
}
.link-share-card .footer-icon {
    width: 14px;
    height: 14px;
    flex-shrink: 0; /* 防止圖示被壓縮 */
}

/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */

/* 單條評論的容器，現在需要相對定位 */
.comment-item {
    position: relative;
    padding-right: 25px; /* 在右側留出刪除按鈕的空間 */
}

/* 評論刪除按鈕的樣式 */
.comment-delete-btn {
    position: absolute;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    line-height: 22px;
    text-align: center;
    border-radius: 50%;
    color: var(--text-secondary);
    font-size: 18px;
    cursor: pointer;
    transition: all 0.2s ease;
    opacity: 0; /* 默認隱藏 */
}

/* 滑鼠懸停在評論上時，顯示刪除按鈕 */
.comment-item:hover .comment-delete-btn {
    opacity: 1;
}

.comment-delete-btn:hover {
    background-color: #f0f0f0;
    color: #ff3b30;
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */

/* ▼▼▼ 【請求7】主螢幕預設保存按鈕主題色適配 (請將這塊代碼也黏貼到 <style> 的末尾) ▼▼▼ */
#save-home-preset-btn {
    background-color: var(--accent-color);
    color: white;
}
/* ▲▲▲ 黏貼結束 ▲▲▲ */


/* ▼▼▼ 【全新】引用回復功能樣式 ▼▼▼ */

/* 1. 輸入框上方的“回復預覽欄” */
#reply-preview-bar {
    display: none; /* 默認隱藏 */
    padding: 8px 12px;
    margin: 0 8px 8px 8px; /* 和輸入框周圍的邊距保持一致 */
    background-color: rgba(0, 0, 0, 0.05);
    border-left: 3px solid var(--accent-color);
    border-radius: 6px;
    position: relative;
    font-size: 13px;
    color: var(--text-secondary);
}

#phone-screen.dark-mode #reply-preview-bar {
    background-color: rgba(255, 255, 255, 0.1);
}

.reply-preview-content .sender {
    font-weight: 600;
    color: var(--text-primary);
}

.reply-preview-content .text {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    display: block; /* 確保省略號生效 */
    max-width: 95%;
}

#cancel-reply-btn {
    position: absolute;
    top: 50%;
    right: 8px;
    transform: translateY(-50%);
    width: 20px;
    height: 20px;
    line-height: 20px;
    text-align: center;
    border-radius: 50%;
    background-color: rgba(0,0,0,0.1);
    cursor: pointer;
    font-size: 14px;
}

/* 2. 消息氣泡內部的“引用消息塊” */
.quoted-message {
    padding: 6px 10px;
    margin-bottom: 6px;
    background-color: rgba(0, 0, 0, 0.04);
    border-left: 2px solid var(--accent-color);
    border-radius: 4px;
    font-size: 0.9em; /* 字體比正文小一點 */
    opacity: 0.8;
    /* (已移除 overflow: hidden;) */
}

#phone-screen.dark-mode .quoted-message {
    background-color: rgba(255, 255, 255, 0.08);
    border-left-color: #a0cff1;
}

.quoted-message .quoted-sender {
    font-weight: 600;
    color: var(--accent-color);
}
#phone-screen.dark-mode .quoted-message .quoted-sender {
    color: #a0cff1;
}

.quoted-message .quoted-content {
    color: var(--text-secondary);
    white-space: normal;     /* 核心修正1: 允許文本正常換行 */
    word-break: break-word;  /* 核心修正2: 強制長單詞或連續字元斷開，防止溢出 */
    display: block;
    /* (已移除 overflow 和 text-overflow，因為我們需要多行顯示而不是單行省略號) */
}

/* === 字體預覽框樣式 (修正後) === */

/* 將它修改為 ▼▼▼ */
#font-preview {
    padding: 20px;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    background-color: #f0f2f5; /* 統一為更淺的灰色，然後讓夜間模式CSS去覆蓋 */
    transition: background-color 0.3s, border-color 0.3s;
}

/* 預覽框裡的文字顏色，預設是黑色 */
#font-preview p {
    color: var(--text-primary);
}

/* 夜間模式下的修正樣式 */
#phone-screen.dark-mode #font-preview {
    background-color: #1c1c1e; /* 深灰色背景 */
    border-color: #38383a;     /* 暗色邊框 */
}

/* 夜間模式下，預覽框裡的文字變為白色 */
#phone-screen.dark-mode #font-preview p {
    color: #ffffff;
}

/* ▼▼▼ 【全新】精緻版轉帳操作彈窗樣式 ▼▼▼ */
.transfer-actions-content {
    background-color: #fff0f5; /* 粉嫩的背景色 */
    border-radius: 20px;
    width: 290px;
    padding: 20px;
    box-shadow: 0 5px 25px rgba(255, 105, 180, 0.3); /* 粉色陰影 */
    text-align: center;
    position: relative;
    border: 1px solid #ffcce0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

.transfer-actions-header {
    font-size: 20px;
    font-weight: bold;
    color: #a35c7b; /* 深粉色標題 */
    margin-bottom: 15px;
}

.transfer-actions-body p {
    font-size: 15px;
    color: #555;
    margin: 0 0 25px 0;
    line-height: 1.5;
}

.transfer-actions-footer {
    display: flex;
    justify-content: space-between;
    gap: 15px;
}

.transfer-actions-footer .action-btn {
    flex: 1;
    padding: 12px;
    border: none;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    color: white;
}

.transfer-actions-footer .action-btn:active {
    transform: scale(0.95);
}

.transfer-actions-footer .action-btn.accept {
    background: linear-gradient(135deg, #ff85b3, #ff69b4);
    box-shadow: 0 4px 10px rgba(255, 105, 180, 0.4);
}

.transfer-actions-footer .action-btn.decline {
    background: linear-gradient(135deg, #c2c2c2, #a0a0a0);
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
}

.transfer-actions-content .cancel-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: none;
    background-color: rgba(0, 0, 0, 0.1);
    color: #a35c7b;
    font-size: 20px;
    line-height: 28px;
    cursor: pointer;
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */

/* === 未讀消息紅點樣式 === */
.unread-count-wrapper {
    flex-shrink: 0;
    width: 40px;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding-top: 20px; /* 讓紅點和名字差不多高 */
}

.unread-count {
    min-width: 20px;
    height: 20px;
    padding: 0 6px;
    background-color: #ff3b30; /* iOS 風格的紅色 */
    color: white;
    font-size: 13px;
    font-weight: 500;
    line-height: 20px;
    text-align: center;
    border-radius: 10px; /* 圓角矩形 */
    box-shadow: 0 1px 2px rgba(0,0,0,0.15);
    display: none; /* 默認隱藏 */
    justify-content: center;
    align-items: center;
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新】通話記錄頁面與卡片樣式 ▼▼▼ */

/* 確保頁面背景色統一 */
#call-history-screen {
    background-color: #f0f2f5;
}

/* 通話記錄卡片樣式 */
.call-record-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    border-left: 5px solid var(--accent-color);
}
.call-record-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.1);
}

/* 卡片頭部：包含日期和時長 */
.call-record-card .card-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 13px;
    color: var(--text-secondary);
    margin-bottom: 12px;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border-color);
}
.call-record-card .card-header .duration {
    font-weight: 500;
    color: var(--text-primary);
}

/* 卡片主體：參與者頭像 */
.call-record-card .card-body {
    display: flex;
    align-items: center;
}
.call-record-card .participants-avatars {
    display: flex;
    align-items: center;
}
.call-record-card .participant-avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid white;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
/* 讓頭像有一個漂亮的堆疊效果 */
.call-record-card .participant-avatar:not(:first-child) {
    margin-left: -12px;
}
.call-record-card .participants-names {
    margin-left: 12px;
    font-weight: 600;
    color: var(--text-primary);
    font-size: 15px;
}

/* --- 通話詳情彈窗樣式 --- */
#transcript-modal-body {
    display: flex;
    flex-direction: column;
    gap: 12px;
    padding: 15px;
}
.transcript-entry {
    padding: 8px 12px;
    border-radius: 10px;
    max-width: 85%;
    line-height: 1.5;
    word-break: break-word;
}
.transcript-entry.user {
    background-color: #dcf8c6; /* 類似微信的綠色 */
    align-self: flex-end;
}
.transcript-entry.assistant {
    background-color: #ffffff;
    align-self: flex-start;
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

#chat-list-title {
    cursor: pointer;
}

/* ▼▼▼ 【全新】通話記錄卡片美化樣式 ▼▼▼ */

.call-record-card .card-body {
    /* 將 body 改為 flex 佈局，讓標題和參與者資訊垂直排列 */
    display: flex;
    flex-direction: column;
    gap: 8px; /* 標題和參與者資訊之間的間距 */
}

.call-record-card .custom-title {
    font-size: 16px;
    font-weight: 600; /* 加粗，讓它像個標題 */
    color: var(--text-primary);
    padding-bottom: 8px; /* 標題下的留白 */
    border-bottom: 1px solid var(--border-color); /* 在標題下加一條分割線 */
    margin-bottom: 4px; /* 和下面的參與者資訊拉開一點距離 */
}

.call-record-card .participants-info {
    /* 這個新容器讓頭像和“與xx”能水準對齊 */
    display: flex;
    align-items: center;
}

/* 參與者名字的樣式微調，讓它不那麼突出 */
.call-record-card .participants-names {
    margin-left: 12px;
    font-weight: 500; /* 不再加粗 */
    font-size: 14px; /* 稍微小一點 */
    color: var(--text-secondary); /* 使用次要文字顏色 */
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新】語音轉文字功能樣式 ▼▼▼ */

/* 1. 語音文字內容的樣式 */
.voice-transcript {
    font-size: 14px;         /* 文字大小 */
    line-height: 1.6;        /* 行高，讓多行文本更易讀 */
    color: var(--text-secondary); /* 使用次要文字顏色，與語音條區分 */
    padding: 8px 12px;       /* 內邊距 */
    margin-top: 6px;         /* 和上方的語音條拉開一點距離 */
    background-color: rgba(0, 0, 0, 0.04); /* 給一個淡淡的背景，更有層次感 */
    border-radius: 6px;      /* 圓角 */
    word-break: break-word;  /* 確保長文本能正常換行 */
    display: none;           /* 默認隱藏 */
}

#phone-screen.dark-mode .voice-transcript {
    background-color: rgba(255, 255, 255, 0.1); /* 夜間模式下的背景色 */
}

/* 2. 旋轉載入動畫的樣式 */
.loading-spinner {
    display: none; /* 默認隱藏 */
    width: 16px;
    height: 16px;
    border: 2px solid rgba(0, 0, 0, 0.2);
    border-top-color: var(--accent-color); /* 旋轉部分的顏色 */
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 8px; /* 和波形圖、時長保持一點間距 */
}

/* 3. 定義旋轉動畫 */
@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新】分享記錄檢視器樣式修正 ▼▼▼ */
#shared-history-viewer-content {
    display: flex;
    flex-direction: column; /* 讓氣泡垂直排列 */
    gap: 20px; /* 在每個氣泡之間增加20圖元的間距 */
    padding: 15px; /* 在容器四周也增加一些內邊距，避免氣泡貼邊 */
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新】播放機和歌詞樣式 ▼▼▼ */
#music-player-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 50;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding-top: 60px;
    background-color: rgba(0,0,0,0.3);
    opacity: 0;
    visibility: hidden;
    transform: translateY(-50px);
    transition: opacity 0.4s ease-out, transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
}

#music-player-overlay.visible {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
}

.music-player-window { 
    width: 70%; 
    min-height: 420px;
    background-color: rgba(255, 255, 255, 0.6); 
    backdrop-filter: blur(20px); 
    -webkit-backdrop-filter: blur(20px); 
    border-radius: 25px; 
    box-shadow: 0 8px 32px 0 rgba(25, 25, 25, 0.37); 
    border: 1px solid rgba(255, 255, 255, 0.18); 
    padding: 25px; 
    display: flex; 
    flex-direction: column; 
    align-items: center; 
    color: #1f1f1f; 
    position: relative;
    justify-content: space-between;
    padding-bottom: 15px;
}

.music-player-top-actions {
    position: absolute;
    top: 15px;
    left: 15px;
    right: 15px;
    width: calc(100% - 30px);
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.top-left-cluster {
    display: flex;
    align-items: center;
    gap: 15px;
}
#music-return-btn, #music-exit-btn {
    background: none;
    border: none;
    font-size: 28px;
    font-weight: 300;
    cursor: pointer;
    color: #555;
    padding: 5px;
    line-height: 1;
}
#music-exit-btn {
    font-size: 24px;
    font-weight: 400;
}

.music-progress-bar-container {
    width: 100%;
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 25px;
    margin-bottom: 10px;
}
.time-display {
    font-size: 11px;
    color: #888;
    width: 35px;
    text-align: center;
    flex-shrink: 0;
    font-family: 'SF Mono', 'Menlo', monospace;
}
.progress-bar {
    flex-grow: 1;
    height: 5px;
    background-color: #e5e5e5;
    border-radius: 2.5px;
    cursor: pointer;
}
.progress-bar-fill {
    width: 0%;
    height: 100%;
    background-color: #333;
    border-radius: 2.5px;
}

#music-lyrics-container {
    width: 100%;
    height: 192px;
    overflow: hidden;
    position: relative;
    -webkit-mask-image: linear-gradient(transparent, black 20%, black 80%, transparent);
    mask-image: linear-gradient(transparent, black 20%, black 80%, transparent);
}

#music-lyrics-list {
    display: flex;
    flex-direction: column;
    align-items: center;
    transition: transform 0.5s cubic-bezier(0.25, 0.1, 0.25, 1);
}

.lyric-line {
    padding: 4px 0;
    font-size: 14px;
    color: #666;
    text-align: center;
    line-height: 1.5;
    transition: all 0.5s ease;
    opacity: 0.7;
    transform: scale(0.95);
}

.lyric-line.active {
    font-size: 16px;
    color: #000;
    opacity: 1;
    transform: scale(1);
}

.music-player-controls-wrapper {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.music-controls {
    margin-top: 0;
}

#music-return-btn, #music-exit-btn, #music-playlist-btn {
    position: relative;
}

#music-return-btn { top: -2px; }
#music-playlist-btn { top: -3px; }

.playlist-item-actions {
    display: flex;
    align-items: center;
    gap: 15px;
}
.playlist-action-btn {
    font-size: 18px;
    color: #888;
    cursor: pointer;
    transition: color 0.2s;
}
.playlist-action-btn:hover { color: #000; }
.delete-track-btn { font-size: 24px; color: #ff3b30; }
.delete-track-btn:hover { color: #c00; }
.lyrics-btn { font-weight: 500; }

/* ▼▼▼ 【最終頭像放大版】請用這塊代碼替換所有相關的頭像尺寸規則 ▼▼▼ */

/* 1. 普通頭像樣式（無框） */
.message-bubble .avatar {
    width: 38px;  /* ★ 修改點：將尺寸從 34px 放大到 42px */
    height: 38px; /* ★ 修改點：高度也同步放大 */
    border-radius:  20%;
    object-fit: cover;
    flex-shrink: 0; 
}

/* 2. 帶框頭像的容器樣式 */
.avatar-with-frame {
    position: relative;
    width: 41px;  /* ★ 修改點：尺寸與普通頭像保持一致 */
    height: 41px; /* ★ 修改點：高度也同步放大 */
    flex-shrink: 0;
}

/* ▲▲▲ 替換結束 ▲▲▲ */


/* ▼▼▼ 【全新】撤回消息樣式 ▼▼▼ */

/* 1. 撤回消息的預留位置樣式 */
.recalled-message-placeholder {
    align-self: center; /* 居中顯示 */
    padding: 4px 12px;
    margin: 5px 0;
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    border-radius: 10px;
    text-align: center;
    max-width: 80%;
    cursor: pointer; /* 讓它看起來可以點擊 */
}

/* 2. 夜間模式下的適配 */
#phone-screen.dark-mode .recalled-message-placeholder {
    background-color: rgba(255, 255, 255, 0.15);
}

/* 3. AI撤回消息時的動畫效果 */
@keyframes recall-animation {
  from {
    opacity: 1;
    transform: scale(1);
  }
  to {
    opacity: 0;
    transform: scale(0.8);
  }
}

.message-wrapper.recalled-animation {
  animation: recall-animation 0.3s ease-out forwards;
}

/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新】撤回消息樣式修正 ▼▼▼ */

/* 強制撤回消息的預留位置不換行，並保持內容居中 */
.recalled-message-placeholder {
    white-space: nowrap; /* 核心：禁止文本換行 */
    display: inline-block; /* 讓背景根據內容自我調整寬度 */
    padding: 4px 12px;
}

/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新】世界書分類清單樣式 ▼▼▼ */
.world-book-group-container {
    border-bottom: 1px solid var(--border-color);
}
.world-book-group-container:first-child {
    border-top: 1px solid var(--border-color);
}
.world-book-group-header {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    cursor: pointer;
    background-color: #f7f7f7;
}
.world-book-group-header .arrow {
    font-size: 14px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}
.world-book-group-header.collapsed .arrow {
    transform: rotate(-90deg);
}
.world-book-group-header .group-name {
    font-weight: 600;
    font-size: 15px;
}
.world-book-group-content {
    max-height: 100000px; /* <--- 就是修改這裡，把值改大即可 */
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}
.world-book-group-content.collapsed {
    max-height: 0;
}
#phone-screen.dark-mode .world-book-group-header {
    background-color: #1c1c1e;
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新】紅包/轉帳模態框頁簽樣式 ▼▼▼ */
.frame-tabs {
    display: flex;
    background-color: #f0f0f0;
    padding: 4px;
    margin: 15px;
    border-radius: 8px;
}
.frame-tab {
    flex: 1;
    text-align: center;
    padding: 8px;
    font-size: 14px;
    font-weight: 500;
    color: #555;
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.2s ease-in-out;
}
.frame-tab.active {
    background-color: #ffffff;
    color: #000000;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 請將這段全新的CSS黏貼到 <style> 的末尾 ▼▼▼ */

/* 1. 分類資料夾的樣式 */
.wb-category-header {
    display: flex;
    align-items: center;
    padding: 10px 12px;
    cursor: pointer;
    background-color: #f0f2f5; /* 給資料夾一個淡淡的背景色以區分 */
    font-weight: 600; /* 加粗字體 */
}
#phone-screen.dark-mode .wb-category-header {
    background-color: #2c2c2e; /* 夜間模式下的背景色 */
}


/* 2. 展開/收起的小箭頭 */
.wb-category-header .arrow {
    font-size: 12px;
    margin-right: 8px;
    transition: transform 0.2s ease;
}

/* 3. 當資料夾收起時，箭頭旋轉 */
.wb-category-header.collapsed .arrow {
    transform: rotate(-90deg);
}

/* 4. 存放書籍條目的容器 */
.wb-book-container {
    padding-left: 20px; /* 核心：讓書籍條目向內縮進，看起來像在資料夾裡 */
    max-height: 100000px; /* 一個足夠大的值，用於動畫 */
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}

/* 5. 當資料夾收起時，書籍容器的高度變為0，實現動畫效果 */
.wb-book-container.collapsed {
    max-height: 0;
}

/* 6. 單個書籍條目（覆蓋預設的label樣式，微調間距） */
.wb-book-container label {
    padding: 8px 12px;
}

/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新】世界書關聯選擇器 - 視覺優化 ▼▼▼ */

/* 1. 讓分類標題更突出 */
.wb-category-header > span:last-of-type {
    font-size: 14px;
    font-weight: 700; /* 加粗 */
    color: var(--text-primary);
}

/* 2. 為箭頭設置一個漂亮的顏色迴圈 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+1) .arrow { color: #007bff; } /* 藍色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+2) .arrow { color: #28a745; } /* 綠色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+3) .arrow { color: #fd7e14; } /* 橙色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+4) .arrow { color: #6f42c1; } /* 紫色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+5) .arrow { color: #dc3545; } /* 紅色 */
#world-book-checkboxes-container .wb-category-header:nth-of-type(6n+6) .arrow { color: #ffc107; } /* 黃色 */

/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* === 頭像框選擇模態框樣式 (這是新添加的) === */
.change-frame-btn {
    padding: 6px 10px;
    border: 1px solid #ccc;
    background-color: #f0f0f0;
    border-radius: 5px;
    cursor: pointer;
    font-size: 13px;
    margin-left: 10px;
}

#avatar-frame-modal .modal-content {
    height: 70%; /* 讓窗口高一點 */
}

#avatar-frame-modal .modal-body {
    padding: 0;
    display: flex;
    flex-direction: column;
}
      
.frame-tabs {
    display: flex;
    border-bottom: 1px solid var(--border-color);
    flex-shrink: 0;
}

.frame-tab {
    flex: 1;
    padding: 12px;
    text-align: center;
    font-weight: 500;
    cursor: pointer;
    color: var(--text-secondary);
    border-bottom: 2px solid transparent;
}

.frame-tab.active {
    color: var(--accent-color);
    border-bottom-color: var(--accent-color);
}

.frame-content {
    flex-grow: 1;
    overflow-y: auto;
    padding: 15px;
}

.frame-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(70px, 1fr)); /* 每行自動填充，最小70px寬 */
    gap: 15px;
}

.frame-item {
    aspect-ratio: 1 / 1; /* 保持正方形 */
    border: 2px solid transparent;
    border-radius: 10px;
    cursor: pointer;
    background-color: #f0f0f0;
    background-size: cover;
    background-position: center;
    padding: 5px;
    transition: all 0.2s ease;
    position: relative; /* 為預覽圖做準備 */
}

.frame-item.selected {
    border-color: var(--accent-color);
    transform: scale(1.05);
}

.frame-item .preview-avatar {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

.frame-item .preview-frame {
    position: absolute;
    top: -7px;
    left: 0;
    width: 100%;
    height: 100%;
}

/* ▼▼▼ 把這些CSS加回去 ▼▼▼ */

.avatar-with-frame .avatar-img {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    border-radius: 50%; /* 帶框的頭像通常是圓的 */
    object-fit: cover;
    z-index: 1;
}
/* ▼▼▼ 【最終修復版】請用這整塊代碼，替換掉舊的聊天和心聲頭像框規則 ▼▼▼ */

.avatar-with-frame .avatar-frame,
#inner-voice-avatar-frame {
    position: absolute;
    /* 核心修改1：將寬高統一設置為125%，確保能完全包裹34px的頭像，並留出漂亮的邊距 */
    width: 125%; 
    height: 125%;

    /* 核心修改2：使用標準的-50%來精確定位，確保頭像框完美居中 */
    transform: translate(-50%, -50%); 
    
    /* 核心修改3：將定位基點也改為標準的50%，與transform配合使用 */
    top: 50%;
    left: 50%;

    z-index: 2;
    pointer-events: none;
}

/* ▲▲▲ 替換結束 ▲▲▲ */

/* ▲▲▲ 添加結束 ▲▲▲ */

/* ▼▼▼ 【最終美化版】聊天列表左滑置頂功能樣式 (已修復Bug) ▼▼▼ */

/* 1. 外層包裹容器 (已移除 display:flex) */
.chat-list-item-swipe-container {
    position: relative;
    overflow: hidden;
}

/* 2. 可滑動的內容區 (保持不變) */
.chat-list-item-content {
    position: relative;
    z-index: 2;
    background-color: var(--secondary-bg);
    transition: transform 0.3s ease, background-color 0.3s ease;
    width: 100%;
    flex-shrink: 0;
}

/* 3. 【核心修改1】置頂聊天時，使用對比度更強的背景色 */
.chat-list-item-content.pinned {
    background-color: #f0f2f5; /* 日間模式下的置頂顏色 (已加深) */
}
#phone-screen.dark-mode .chat-list-item-content.pinned {
    background-color: #3a3a3c; /* 夜間模式下的置頂顏色 (已加深) */
}

/* 4. 隱藏的操作按鈕區域 (保持不變) */
.swipe-actions {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    z-index: 1;
    display: flex;
}

/* 5. 單個操作按鈕的樣式 (保持不變) */
.swipe-action-btn {
    height: 100%;
    padding: 0 20px;
    border: none;
    color: white;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 80px;
}

.swipe-action-btn.pin { background-color: #f0ad4e; }
.swipe-action-btn.unpin { background-color: #777; }
.swipe-action-btn.delete { background-color: #ff3b30; }

/* 6. 當內容區被滑開時 (保持不變) */
.chat-list-item-content.swiped {
    transform: translateX(-160px);
}

/* 7. 分割線的正確邏輯 (保持不變) */
.chat-list-item {
    border-bottom: none;
}
.chat-list-item-swipe-container:not(:last-child) {
     border-bottom: 1px solid var(--border-color);
}
.chat-group-container {
    border-bottom: 1px solid var(--border-color);
}
.chat-group-container:first-of-type {
    border-top: 1px solid var(--border-color);
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */

/* ▼▼▼ 用下面這段【新樣式】，替換掉你舊的 .date-stamp 樣式 ▼▼▼ */

/* 日期戳的外層包裹，讓它像系統消息一樣居中 */
.date-stamp-wrapper {
    justify-content: center;
    align-self: center;
    margin: 10px 0;
    max-width: 80%;
}

/* 日期戳的氣泡本身 */
.date-stamp-bubble {
    background-color: rgba(0, 0, 0, 0.1);
    color: var(--text-secondary);
    font-size: 12px;
    padding: 4px 12px;
    border-radius: 10px;
}

/* 適配夜間模式 */
#phone-screen.dark-mode .date-stamp-bubble {
    background-color: rgba(255, 255, 255, 0.15);
}
/* ▲▲▲ 替換結束 ▲▲▲ */

/* ▼▼▼ 請將這段新CSS黏貼到 <style> 的末尾 ▼▼▼ */
.chat-list-time {
    font-size: 12px;
    color: var(--text-secondary);
    text-align: right;
    margin-left: 8px; /* 和中間的資訊區拉開一點距離 */
    flex-shrink: 0;   /* 防止在空間不足時被壓縮 */
    align-self: flex-start; /* 讓它和頂部的名字對齊 */
    padding-top: 2px; /* 微調垂直位置 */
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 請將這段新CSS黏貼到 <style> 的末尾 ▼▼▼ */
.chat-list-right-column {
    display: flex;
    flex-direction: column;
    align-items: flex-end; /* 讓內容靠右對齊 */
    gap: 4px; /* 在時間和紅點之間加一點點間距 */
    flex-shrink: 0;
    margin-left: 8px;
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新】鎖屏與密碼介面樣式 ▼▼▼ */

/* 1. 鎖屏介面的總容器 */
#lock-screen {
    /* 核心：用一個非常高的 z-index 確保它能覆蓋所有其他螢幕 */
    z-index: 999; 
    background-size: cover;
    background-position: center;
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: space-between; /* 讓時鐘和提示語上下分佈 */
    align-items: center;
    padding: 80px 20px 50px 20px;
    box-sizing: border-box;
    transition: transform 0.3s ease-out;
}

/* 2. 鎖屏時鐘 (複用主螢幕時鐘的樣式) */
#lock-clock-container {
    text-align: center;
    text-shadow: 0 3px 8px rgba(0,0,0,0.4);
    flex-shrink: 0;
}
#lock-main-time {
    font-size: 80px;
    font-weight: 200;
}
#lock-main-date {
    font-size: 18px;
    font-weight: 500;
}

/* 3. “向上輕掃”的提示文字和動畫 */
#unlock-hint {
    font-size: 16px;
    font-weight: 500;
    text-shadow: 0 1px 4px rgba(0,0,0,0.3);
    /* 添加一個呼吸動畫，吸引用戶注意 */
    animation: hint-pulse 2s infinite ease-in-out;
}
@keyframes hint-pulse {
    0%, 100% { opacity: 0.7; transform: translateY(0); }
    50% { opacity: 1; transform: translateY(-5px); }
}

/* 4. 密碼輸入彈窗的遮罩層 */
#password-modal-overlay {
    /* 使用一個半透明的毛玻璃效果背景 */
    background-color: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    z-index: 1000; /* 比鎖屏更高，確保在最上層 */
}

/* 5. 密碼輸入彈窗的內容區 */
.password-modal-content {
    background-color: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    width: 280px;
    border-radius: 15px;
    padding: 20px;
    box-shadow: 0 5px 20px rgba(0,0,0,0.2);
    text-align: center;
    display: flex;
    flex-direction: column;
    gap: 15px;
    color: #333;
}
.password-modal-content p {
    font-size: 17px;
    font-weight: 600;
    margin: 0;
}

/* 6. 密碼輸入框 */
#password-input-field {
    width: 100%;
    padding: 12px;
    border: 1px solid rgba(0,0,0,0.1);
    border-radius: 8px;
    font-size: 16px;
    text-align: center;
    box-sizing: border-box;
    background-color: rgba(255,255,255,0.7);
}
#password-input-field:focus {
    outline: none;
    border-color: var(--accent-color);
}

/* 7. 密碼彈窗的按鈕區域 */
.password-actions {
    display: flex;
    gap: 10px;
    margin-top: 5px;
}
.password-actions button {
    flex: 1;
    padding: 12px;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
}
#password-cancel-btn {
    background-color: #e9ecef;
    color: #495057;
}
#password-confirm-btn {
    background-color: var(--accent-color);
    color: white;
}

/* 8. 密碼錯誤時的晃動動畫 */
@keyframes shake-error {
  0%, 100% { transform: translateX(0); }
  10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
  20%, 40%, 60%, 80% { transform: translateX(5px); }
}
.password-modal-content.error {
    animation: shake-error 0.4s ease-in-out;
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */


/* ▼▼▼ 用這塊【最終修復版】代碼，完整替換掉你舊的 .bubble-preset-manager 樣式 ▼▼▼ */

/* 這是你要修改前的代碼 */
/* ▼▼▼ 【全新】氣泡/API樣式預設功能CSS ▼▼▼ */
.bubble-preset-manager {
    display: flex;
    align-items: baseline; /* 核心修改：從 center 改為 baseline */
    gap: 10px; /* 元素之間的間距 */
}



/* ▲▲▲ 替換結束 ▲▲▲ */


/* 下拉清單的樣式，讓它佔據大部分空間 */
.bubble-preset-manager select {
    flex-grow: 1; /* 佔據所有剩餘空間 */
}

/* 管理按鈕的樣式，讓它小巧精緻 */
.bubble-preset-manager .action-btn {
    flex-shrink: 0; /* 防止按鈕被壓縮 */
    padding: 8px 10px;
    font-size: 13px;
    background-color: #e9ecef;
    color: var(--text-primary);
    border: 1px solid var(--border-color);
    border-radius: 5px;
    cursor: pointer;
    font-weight: 500;
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 的末尾 ▼▼▼ */

/* 1. 讓鎖屏和主螢幕可以堆疊 */
/* 核心：把鎖屏和主螢幕都設為絕對定位，這樣它們才能重疊 */
#lock-screen, #home-screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

/* 2. 定義毛玻璃背景層的樣式 */
#lock-screen-background-blur {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1; /* 【核心修改1】它的層級現在和主螢幕一樣低 */
    
    background-size: cover;
    background-position: center;

    /* 【核心修改2】魔法在這裡！我們直接模糊這個元素本身 */
    filter: blur(20px);
    -webkit-filter: blur(20px);
    
    /* (可選但推薦) 輕微放大可以避免模糊後邊緣變暗，效果更好 */
    transform: scale(1.1); 

    /* 【核心修改3】默認隱藏，且帶有淡入淡出效果 */
    display: none;
    opacity: 0;
    transition: opacity 0.3s ease-out;
}

/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 從這裡開始複製 ▼▼▼ */

/* === 【最終修復版】世界書選擇器清單樣式 === */

/* 1. 分類資料夾行樣式：用flex和gap創建固定間距，非常穩定 */
.wb-category-header {
    display: flex;
    align-items: center;
    gap: 8px; /* 箭頭、核取方塊、文字之間的固定間距 */
    padding: 10px 12px;
    cursor: pointer;
    background-color: #f0f2f5;
    font-weight: 600;
    overflow: hidden; /* 防止任何意外溢出 */
}

/* 2. 分類資料夾裡的文字樣式：只負責截斷，不負責佈局 */
.wb-category-header > span:last-of-type {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex-shrink: 1; /* 允許文字部分在空間不足時被壓縮 */
}

/* 3. 【核心修復】為分類和書目裡的核取方塊“解綁”全域樣式！ */
.wb-category-header input[type="checkbox"],
.wb-book-container input[type="checkbox"] {
    width: auto !important; /* 讓它恢復自己的天然大小，!important確保最高優先順序 */
    flex-shrink: 0;         /* 防止它被壓縮，保持完整 */
}

/* 4. 具體書目行的樣式：強制從左邊開始排列，解決不同設備的顯示差異 */
.wb-book-container label {
    display: flex;
    align-items: center;
    justify-content: flex-start; /* 強制所有內容從左邊開始對齊 */
    padding: 8px 12px;
    gap: 10px; /* 核取方塊和文字的間距 */
    overflow: hidden;
}

/* 5. 具體書目的文字樣式 */
.wb-book-container label .wb-book-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    text-align: left;
    flex-shrink: 1; /* 同樣允許它被壓縮 */
}

/* 6. 夜間模式適配 (保持不變) */
#phone-screen.dark-mode .wb-category-header {
    background-color: #2c2c2e;
}

/* 7. 小箭頭的樣式 (保持不變) */
.wb-category-header .arrow {
    font-size: 12px;
    transition: transform 0.2s ease;
    flex-shrink: 0; /* 防止箭頭被壓縮 */
}
.wb-category-header.collapsed .arrow {
    transform: rotate(-90deg);
}

/* 8. 書籍容器的樣式 (保持不變) */
.wb-book-container {
    padding-left: 20px;
    max-height: 1000px;
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}
.wb-book-container.collapsed {
    max-height: 0;
}


/* ▼▼▼ 【全新】滑鼠拖動工具列時的手勢樣式 ▼▼▼ */
#chat-input-actions-top.grabbing {
    cursor: grabbing;
    cursor: -webkit-grabbing;
    user-select: none; /* 防止拖動時選中文本 */
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 【SVG終極版】發送定位功能樣式 ▼▼▼ */

/* 1. 基礎卡片和氣泡樣式 (保持不變) */
.message-bubble.is-location .content { padding: 0; background: transparent; box-shadow: none; border: none; backdrop-filter: none; -webkit-backdrop-filter: none; }
.location-card { width: 230px; background-color: #f7f7f7; border-radius: 12px; overflow: hidden; border: 1px solid #e0e0e0; box-shadow: 0 2px 5px rgba(0,0,0,0.08); }

/* 2. 【核心升級】地圖區域現在直接用於容納SVG */
.location-map-area {
    height: 90px;
    background-color: #f0f2f5;
    background-image:
        linear-gradient(rgba(0,0,0,0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0,0,0,0.05) 1px, transparent 1px);
    background-size: 20px 20px;
    padding: 5px; /* 給SVG一點呼吸空間 */
    box-sizing: border-box;
}
.location-map-area svg {
    width: 100%;
    height: 100%;
}

/* 3. 【全新】SVG內部元素的樣式 */
/* 軌跡曲線 */
.svg-trajectory-path {
    stroke-width: 2px;
    stroke: rgba(180, 180, 180, 0.8);
    stroke-dasharray: 3 3; /* 虛線效果 */
    fill: none;
}
/* 定位點 (起點/終點) */
.svg-pin {
    stroke-width: 2px;
    stroke: white;
}
.svg-pin.user-pin { fill: #4CAF50; } /* 綠色用戶點 */
.svg-pin.ai-pin { fill: #ff5252; } /* 紅色AI點 */

/* 腳印圖示 */
.svg-footprint {
    font-size: 14px;
    fill: rgba(0, 0, 0, 0.4);
}
/* 途經點地名標籤 */
.svg-location-label {
    font-size: 10px;
    font-weight: 500;
    fill: #555;
    /* 給文字一點白色的描邊，讓它在複雜背景下更清晰 */
    stroke: white;
    stroke-width: 2px;
    paint-order: stroke;
}

/* 4. 卡片底部資訊區域 (已升級) */
.location-info { padding: 12px; }
.location-address {
    font-size: 13px;
    line-height: 1.6;
    margin-bottom: 8px;
    color: #333;
}
.location-address .name-tag {
    font-weight: 600;
    color: var(--text-primary);
}
.location-address p.hidden { display: none; }
.location-distance {
    font-size: 12px;
    color: var(--text-secondary);
    border-top: 1px solid #e9e9e9;
    padding-top: 8px;
    text-align: center;
}
/* ▲▲▲ 升級版CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新 | 修復版】“一鍵重roll”按鈕樣式 ▼▼▼ */
#reroll-btn {
    /* --- 直接複用其他按鈕的樣式，確保外觀統一 --- */
    font-size: 24px;
    padding: 0;
    width: 38px;
    height: 38px;
    line-height: 38px;
    text-align: center;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.5);
    color: var(--text-primary);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
    /* 核心修復：邊框顏色和其他按鈕統一 */
    border: 1px solid rgba(0,0,0,0.05); 
    cursor: pointer;
    display: flex;
    justify-content: center;
    align-items: center;
    
    /* 移除導致差異的陰影 */
    box-shadow: none; 

    /* 保留原有的交互動效 */
    transition: opacity 0.2s, transform 0.1s;
}

#reroll-btn:hover {
    opacity: 0.8;
}

#reroll-btn:active {
    transform: scale(0.9);
}

#reroll-btn svg {
    width: 20px;
    height: 20px;
}
/* ▲▲▲ 替換結束 ▲▲▲ */


/* ▼▼▼ 【最終美化版】懸浮歌詞欄樣式 ▼▼▼ */
#floating-lyrics-bar {
    position: absolute;
    /* 【問題1修復】默認位置改為頂部 */
    top: 50px; 
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    
    display: none;
    align-items: center;
    justify-content: center;
    gap: 10px; /* 在歌詞和按鈕間增加間距 */

    width: 90%; 
    max-width: 320px; /* 同時設一個最大圖元寬度，避免在寬屏上過長 */
    padding: 8px 12px; /* 稍微增加一點內邊距以適應新寬度 */
    background-color: rgba(0, 0, 0, 0); 
    
    /* 【問題3需要】為字體顏色和背景透明度添加過渡動畫 */
    transition: background-color 0.3s, opacity 0.3s;

    color: white;
    font-size: 14px;
    font-weight: 500; /* 字體稍微加粗 */
    text-align: center;
    border-radius: 12px;
    
    /* 文字陰影，讓它在任何背景下都清晰 */
    text-shadow: 0 1px 3px rgba(0,0,0,0.5); 
    
    cursor: pointer;
    user-select: none;
    
    /* 【問題4需要】為關閉按鈕準備 */
    overflow: visible; /* 允許按鈕超出範圍 */
}

/* 【問題4需要】關閉按鈕的樣式 */
#floating-lyrics-bar .close-btn,
#floating-lyrics-bar #lyrics-settings-btn {
    position: absolute;
    top: -8px;
    width: 20px;
    height: 20px;
    background-color: rgba(0,0,0,0.6);
    color: white;
    border-radius: 50%;
    border: 1px solid white;
    cursor: pointer;
    opacity: 0; /* 默認隱藏 */
    transition: opacity 0.2s;
    display: flex; /* 確保SVG能居中 */
    align-items: center;
    justify-content: center;
}

/* 把關閉按鈕和設置按鈕分開放置 */
#floating-lyrics-bar .close-btn { right: -8px; line-height: 18px; font-size: 14px; }
#floating-lyrics-bar #lyrics-settings-btn { right: 22px; } /* 放在關閉按鈕旁邊 */

/* 滑鼠懸停在整個歌詞欄上時，一起顯示它們 */
#floating-lyrics-bar:hover .close-btn,
#floating-lyrics-bar:hover #lyrics-settings-btn {
    opacity: 1;
}

#floating-lyrics-bar.dragging {
    cursor: grabbing;
    cursor: -webkit-grabbing;
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新】“查角色手機”功能相關樣式 ▼▼▼ */

/* 角色選擇列表項 */
.character-select-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
}
.character-select-item:hover {
    background-color: #f5f5f5;
}
.character-select-item img {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    margin-right: 12px;
}
.character-select-item .name {
    font-weight: 500;
}

/* 角色手機的聊天氣泡 (簡化版) */
.character-chat-bubble {
    padding: 8px 12px;
    border-radius: 12px;
    max-width: 80%;
    word-break: break-word;
    line-height: 1.5;
}
.character-chat-bubble.sent {
    background-color: #dcf8c6;
    align-self: flex-end; /* 自己發的靠右 */
}
.character-chat-bubble.received {
    background-color: #ffffff;
    align-self: flex-start; /* 收到的靠左 */
}

/* ▼▼▼ 【美化版】角色手機資料清單項樣式 ▼▼▼ */
.character-data-item {
    padding: 12px 15px;
    border-bottom: 1px solid #f0f0f0; /* 邊框顏色變淺 */
    margin: 8px 10px; /* 增加外邊距，形成卡片感 */
    border-radius: 8px; /* 增加圓角 */
    box-shadow: 0 1px 3px rgba(0,0,0,0.05); /* 增加非常淡的陰影 */
    transition: transform 0.2s, box-shadow 0.2s; /* 增加懸浮動畫 */
    background-color: var(--secondary-bg);
}

.character-data-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.08);
}

.character-data-item .title {
    font-weight: 600;
    margin-bottom: 5px;
    color: #333; /* 標題顏色加深 */
}
.character-data-item .content {
    font-size: 14px;
    color: #555;
    line-height: 1.6;
    white-space: pre-wrap;
}
.character-data-item .meta {
    font-size: 12px;
    color: #888;
    margin-top: 10px;
    padding-top: 8px; /* 在meta上方增加一點距離和分割線 */
    border-top: 1px solid #f5f5f5;
    display: flex;
    justify-content: space-between;
}
/* ▲▲▲ 替換結束 ▲▲▲ */

/* ▼▼▼ 【V3修正版】角色手機“畫中畫”樣式修正 ▼▼▼ */

/* 1. 【核心修正1】讓手機外殼容器佔據整個螢幕，並用內邊距把手機框“推”下來 */
#character-phone-container {
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #ffffff; /* ★★★ 把這裡改為純白色 ★★★ */
    padding-top: 50px; 
    box-sizing: border-box; /* 確保內邊距計算正確 */
}


/* 2. 手機邊框樣式 (保持不變) */
.character-phone-frame {
    width: 95%;
    height: 98%;
    background-color: #111;
    border-radius: 30px;
    padding: 10px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    box-sizing: border-box;
    position: relative;
    display: flex;
}

/* ▼▼▼ 用下面這塊【已修復】的代碼替換舊的 #character-app-grid .app-icon .icon-bg 規則 ▼▼▼ */
#character-app-grid .app-icon .icon-bg {
    width: 65px;  /* 恢復原來的尺寸 */
    height: 65px; /* 恢復原來的尺寸 */
    border-radius: 18px; /* 恢復原來的圓角 */
    background-color: #fff5f7; /* 設置為你想要的淡粉色背景 */
}
/* ▲▲▲ 替換結束 ▲▲▲ */

/* 3. 【核心修正2】縮小APP圖示內的SVG */
#character-app-grid .app-icon .icon-bg svg {
    width: 60%;  /* ★★★ 將SVG的寬度縮小到其容器的60% ★★★ */
    height: 60%; /* ★★★ 高度也同步縮小 ★★★ */
}

/* 4. 其餘樣式保持不變 */
.character-phone-inner-screen {
    flex-grow: 1;
    border-radius: 20px;
    overflow: hidden;
    position: relative;
    background-color: var(--secondary-bg) !important; /* 使用變數 */
}
.character-phone-notch {
    position: absolute;
    top: 10px;
    left: 50%;
    transform: translateX(-50%);
    width: 100px;
    height: 20px;
    border-radius: 0 0 10px 10px;
    z-index: 10;
}
.character-phone-page {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
}
.character-phone-page.active {
    opacity: 1;
    visibility: visible;
    z-index: 5;
}
/* ▼▼▼ 用這塊【透明毛玻璃版】代碼，完整替換掉舊的 .character-phone-header 樣式 ▼▼▼ */

/* ▼▼▼ 用這塊【透明毛玻璃版】代碼，完整替換掉舊的 .character-phone-header 樣式 ▼▼▼ */

.character-phone-header {
    flex-shrink: 0;
    margin: 10px 12px 10px; /* ★ 修改點1: 將上邊距 35px 改為 0，讓它貼頂 */
    height: 50px;           /* ★ 修改點2: 將高度從 48px 增加到 56px，讓它更高一點 */

    /* ★ 核心修改1：變成一個更圓潤的膠囊形狀 */
    border-radius: 24px; /* 將圓角從16px增加到24px，看起來更圓潤 */

    /* ★ 核心修改2：設置一個幾乎透明的、帶有毛玻璃效果的背景 */
    background-color: rgba(180, 180, 180, 0.2); /* 降低不透明度，營造透明感 */
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);

    /* ★ 核心修改3：讓邊框和陰影更精緻，以適應透明感 */
    border: 1px solid rgba(255, 255, 255, 0.2); /* 邊框也調得更透明 */
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);   /* 陰影稍微調整，更柔和 */

    /* ★ 核心修改4：強制文字和圖示顏色變為白色，並加上陰影以保證清晰 */
    color: #ffffff; /* 標題文字變為白色 */
    text-shadow: 0 1px 3px rgba(0,0,0,0.3); /* 給文字加一點陰影，防止背景太亮看不清 */

    /* 佈局部分保持不變 */
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 12px;
    box-sizing: border-box;
    font-size: 16px;
}


/* ★★★【重要】為了確保所有圖示都變成白色，請把下面這段新代碼也加到<style>裡 ★★★ */
.character-phone-header .action-btn svg,
.character-phone-header .back-btn svg {
    color: #ffffff !important;
}

/* ▲▲▲ 替換結束 ▲▲▲ */

/* ★★★【重要】為了確保所有圖示都變成白色，請把下面這段新代碼也加到<style>裡 ★★★ */
.character-phone-header .action-btn svg,
.character-phone-header .back-btn svg {
    color: #ffffff !important;
}

/* ▲▲▲ 替換結束 ▲▲▲ */

.character-phone-header .action-btn svg,
.character-phone-header .back-btn svg {
    color: var(--accent-color);
}
#character-chat-history-messages {
     background-color: var(--secondary-bg) !important; /* 使用變數 */      /* ★★★ 移除背景圖片 ★★★ */
}
/* ▲▲▲ 樣式修正結束 ▲▲▲ */

/* ▼▼▼ 【V5最終修復版】角色手機APP圖示佈局修正 ▼▼▼ */
/* ▼▼▼ 找到 #character-app-grid.app-grid-standard，修改其中的 padding-top 屬性 ▼▼▼ */

#character-app-grid.app-grid-standard {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 20px 15px;
    padding: 20px;
    padding-top: 95px; /* ★★★ 把 50px 改成 95px，為新頂欄留出空間 ★★★ */
    box-sizing: border-box;
    width: 100%;
    flex-direction: initial; 
    align-items: initial;
}

/* ▲▲▲ 修改結束 ▲▲▲ */

/* ▲▲▲ 樣式修正結束 ▲▲▲ */


/* ▼▼▼ 【全新】角色手機微信風格聊天氣泡樣式 ▼▼▼ */

/* 1. 聊天記錄介面的背景色 */
#character-chat-history-messages {
    /* 移除之前版本可能存在的背景圖片 */
    background-image: none;
}

/* 2. 消息氣泡的通用容器樣式 */
.character-chat-bubble-container {
    display: flex;
    gap: 10px;
    align-items: flex-start;
    margin-bottom: 12px;
    max-width: 80%; /* 限制氣泡最大寬度 */
}

/* 3. 氣泡的內容區域 */
.character-chat-bubble {
    position: relative;
    padding: 8px 12px;
    line-height: 1.5;
    word-break: break-word;
    border-radius: 6px;
    font-size: 15px;
}

/* 4. 頭像樣式 */
.character-chat-avatar {
    width: 36px;
    height: 36px;
    border-radius: 6px; /* 微信風格的圓角矩形頭像 */
    flex-shrink: 0;
}

/* --- 我方（角色自己）的氣泡 --- */
.character-chat-bubble-container.sent {
    align-self: flex-end; /* 整體靠右 */
    flex-direction: row-reverse; /* 佈局反轉：內容 -> 頭像 */
}
.character-chat-bubble-container.sent .character-chat-bubble {
    background-color: #95ec69; /* 微信綠 */
    color: #000;
}
/* 我方氣泡的小尾巴 */
.character-chat-bubble-container.sent .character-chat-bubble::after {
    content: "";
    position: absolute;
    right: -4px;
    top: 10px;
    width: 0;
    height: 0;
    border: 4px solid transparent;
    border-left-color: #95ec69;
    border-right: 0;
}

/* --- 對方（NPC或用戶）的氣泡 --- */
.character-chat-bubble-container.received {
    align-self: flex-start; /* 整體靠左 */
}
/* 對方氣泡的小尾巴 */
.character-chat-bubble-container.received .character-chat-bubble::before {
    content: "";
    position: absolute;
    left: -4px;
    top: 10px;
    width: 0;
    height: 0;
    border: 4px solid transparent;
    border-right-color: #ffffff;
    border-left: 0;
}
/* ▼▼▼ 在這裡添加下面這塊新代碼 ▼▼▼ */
.character-chat-bubble-container.received .character-chat-bubble {
    background-color: #ffffff; /* 微信白 */
    color: #000;
}
/* ▲▲▲ 添加結束 ▲▲▲ */

/* --- 功能性重置：針對圖片/表情包，讓氣泡“消失” --- */
.character-chat-bubble-container .character-chat-bubble:has(img.sticker-image) {
    background: transparent !important;
    padding: 0 !important;
    border-radius: 0;
}
.character-chat-bubble-container .character-chat-bubble:has(img.sticker-image)::before,
.character-chat-bubble-container .character-chat-bubble:has(img.sticker-image)::after {
    content: none !important;
}
/* ▲▲▲ 樣式添加結束 ▲▲▲ */
/* ▼▼▼ 【全新】角色手機新增APP頁面樣式 ▼▼▼ */

/* 1. 相冊頁面的網格佈局 */
#character-album-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /* 每行3張圖 */
    gap: 4px;
    padding: 4px;
}
.character-album-item {
    aspect-ratio: 1 / 1; /* 保持正方形 */
    background-color: #e0e0e0;
    cursor: pointer;
}
.character-album-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

/* 2. 銀行頁面的餘額顯示 */
.character-bank-balance-card {
    margin: 15px;
    padding: 20px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    color: white;
    border-radius: 12px;
    text-align: center;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
}
.character-bank-balance-card .label {
    font-size: 14px;
    opacity: 0.8;
}
.character-bank-balance-card .amount {
    font-size: 32px;
    font-weight: 600;
    margin-top: 5px;
}

/* 3. 銀行交易記錄的顏色 */
.character-data-item .transaction-amount {
    font-weight: 600;
}
.character-data-item .transaction-amount.income {
    color: #4CAF50; /* 收入為綠色 */
}
.character-data-item .transaction-amount.expense {
    color: #F44336; /* 支出為紅色 */
}

/* ▲▲▲ 樣式添加結束 ▲▲▲ */

/* ▼▼▼ 【V5修正版】角色手機相冊網格佈局 ▼▼▼ */
#character-album-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /* 每行3張圖 */
    gap: 4px;
    padding: 4px;
}
.character-album-item {
    aspect-ratio: 1 / 1; /* 保持正方形 */
    background-color: #e0e0e0;
    cursor: pointer;
}
.character-album-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}
/* ▲▲▲ 樣式修正結束 ▲▲▲ */

/* ▼▼▼ 【全新】Markdown渲染增強樣式 ▼▼▼ */

/* 1. 為角色手機裡的所有Markdown內容設置基礎樣式 */
.character-data-item .content h1,
.character-data-item .content h2,
.character-data-item .content h3,
.character-data-item .content p {
    margin: 0 0 10px 0; /* 統一標題和段落的下邊距 */
}
.character-data-item .content h1 { font-size: 1.5em; font-weight: 600; }
.character-data-item .content h2 { font-size: 1.3em; font-weight: 600; }
.character-data-item .content h3 { font-size: 1.1em; font-weight: 600; }

/* 2. 刪除線樣式 */
.character-data-item .content del {
    color: #8a8a8a;
}

/* 3. 遮擋/劇透效果 */
.character-data-item .content .spoiler {
    background-color: #333;
    color: #333; /* 文字和背景一個色，實現隱藏 */
    padding: 0 4px;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}
/* 點擊或滑鼠懸停時顯示內容 */
.character-data-item .content .spoiler:hover,
.character-data-item .content .spoiler:active {
    background-color: #f0f0f0;
    color: #000;
}

/* ▲▲▲ 樣式添加結束 ▲▲▲ */

/* ▼▼▼ 【全新】角色手機日記美化與刪除功能樣式 ▼▼▼ */

/* 1. 讓日記列表有更好的邊距 */
#character-diary-list {
    padding: 10px;
    display: flex;
    flex-direction: column;
    gap: 12px; /* 增加日記之間的間距 */
}

/* 2. 美化單篇日記卡片 */
#character-diary-list .character-data-item {
    background-color: #fffaf0; /* 溫暖的米黃色背景 */
    border-left: 4px solid #ffc107; /* 左側加一條裝飾線 */
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    position: relative; /* 為了定位刪除按鈕 */
    padding-bottom: 35px; /* 為底部的日期留出空間 */
}

/* 3. 美化日期顯示，把它放到右下角 */
#character-diary-list .character-data-item .meta {
    position: absolute;
    bottom: 8px;
    right: 12px;
    border-top: none; /* 移除原來的上邊框 */
    padding-top: 0;
    font-size: 11px;
    color: #bfa87a;
}

/* 4. 刪除按鈕的樣式 */
.diary-delete-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 26px;
    height: 26px;
    border-radius: 50%;
    background-color: rgba(0,0,0,0.05);
    color: #bfa87a;
    border: none;
    cursor: pointer;
    font-size: 20px;
    line-height: 26px;
    text-align: center;
    opacity: 0; /* 默認隱藏 */
    transition: opacity 0.2s ease-in-out;
}
/* 滑鼠懸停在日記上時顯示按鈕 */
#character-diary-list .character-data-item:hover .diary-delete-btn {
    opacity: 1;
}
.diary-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}
/* ▲▲▲ 樣式添加結束 ▲▲▲ */

/* ▼▼▼ 【V6最終修復版】角色手機相冊佈局防溢出 ▼▼▼ */

/* 1. 【核心】為相冊網格的容器強制禁止水準滾動 */
#character-album-grid.list-container {
    overflow-x: hidden;
}

/* 2. 重新定義網格佈局 */
#character-album-grid {
    display: grid;
    /* 【核心】每行3個，但這次我們用calc()精確計算寬度 */
    grid-template-columns: repeat(3, calc(33.333% - 4px)); 
    gap: 6px; /* 稍微增大間隙，讓calc有計算空間 */
    padding: 6px; /* 內邊距和間隙保持一致 */
    box-sizing: border-box; /* 確保內邊距和邊框被包含在總寬度內 */
    align-content: start; /* <--- 就是加上這一行！ */
}

/* 3. 稍微縮小圖片，確保它們不會撐破容器 */
.character-album-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block; /* 移除圖片下方的微小空隙 */
}

/* ▲▲▲ 樣式修正結束 ▲▲▲ */

/* ▼▼▼ 【V6獨家定制】角色手機信紙風格日記樣式 ▼▼▼ */

/* 1. 【核心】重塑日記卡片，讓它像一張信紙 */
#character-diary-list .character-data-item {
    background-color: #fdfaf2; /* 溫暖、柔和的米白/淺黃色，模擬信紙 */
    border: 1px solid #eaddc7;  /* 淡淡的紙張邊緣色 */
    border-left: 3px solid #d4bda5; /* 左側加一條稍深的線，像裝訂線 */
    box-shadow: 2px 2px 6px rgba(0,0,0,0.06); /* 更柔和的陰影 */
    position: relative;
    padding: 20px 15px 15px 20px; /* 調整內邊距，給“小東西”留出空間 */
    font-family: Georgia, 'Times New Roman', 'Kaiti TC', 'STKaiti', serif; /* 使用更典雅的襯線字體 */
}

/* 2. 【小東西】用偽元素在左上角添加一個精緻的紙夾 */
#character-diary-list .character-data-item::before {
    content: '📎'; /* 這是一個Emoji紙夾，簡單又有效 */
    position: absolute;
    top: -12px;
    left: 15px;
    font-size: 24px;
    transform: rotate(-25deg); /* 讓紙夾有一個隨意的角度 */
    opacity: 0.8;
}

/* 3. 【核心】重置Markdown內容的字體，確保它們繼承信紙的字體 */
#character-diary-list .character-data-item .content,
#character-diary-list .character-data-item .content h1,
#character-diary-list .character-data-item .content h2,
#character-diary-list .character-data-item .content h3 {
    font-family: inherit; /* 強制繼承父元素的字體 */
    color: #4a443b; /* 使用深棕色文字，更有質感 */
}

#character-diary-list .character-data-item .content p {
    margin: 0 0 12px 0;
}

/* 4. 將日期移動到右上角，像信紙的落款日期 */
#character-diary-list .character-data-item .meta {
    position: absolute;
    top: 10px;
    right: 12px;
    font-size: 11px;
    color: #ae9c82; /* 匹配信紙風格的日期顏色 */
    font-style: italic; /* 斜體更有手寫感 */
    border-top: none;
    padding-top: 0;
}

/* 5. 美化刪除按鈕，讓它更融入信紙風格 */
#character-diary-list .character-data-item .diary-delete-btn {
    background-color: transparent;
    color: #c9bbae;
    font-size: 22px;
    transition: all 0.2s ease;
}

#character-diary-list .character-data-item .diary-delete-btn:hover {
    background-color: #e44d44;
    color: white;
    transform: scale(1.1);
}

/* ▲▲▲ 樣式添加結束 ▲▲▲ */

/* ▼▼▼ 【全新】角色手機全APP美化樣式 ▼▼▼ */

/* --- 1. 購物車樣式 --- */
.character-cart-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 15px;
    border-bottom: 1px solid #f0f0f0;
}
.character-cart-item:last-child {
    border-bottom: none;
}
.cart-item-icon {
    width: 40px;
    height: 40px;
    flex-shrink: 0;
    background-color: #f0f2f5;
    border-radius: 8px;
    display: flex;
    justify-content: center;
    align-items: center;
    color: var(--text-secondary);
}
.cart-item-info {
    flex-grow: 1;
}
.cart-item-info .title {
    font-weight: 500;
}
.cart-item-info .store {
    font-size: 12px;
    color: var(--text-secondary);
}
.cart-item-price {
    font-weight: 600;
    font-size: 15px;
}

/* --- 2. 流覽器歷史樣式 --- */
.character-browser-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 14px 15px;
    border-bottom: 1px solid #f0f0f0;
    cursor: pointer;
    transition: background-color 0.2s;
}
.character-browser-item:hover {
    background-color: #f9f9f9;
}
.browser-item-icon {
    font-size: 20px;
    color: var(--text-secondary);
}

/* --- 3. 銀行交易明細樣式 --- */
.character-bank-transaction {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 14px 15px;
    border-bottom: 1px solid #f0f0f0;
}
.transaction-details {
    display: flex;
    align-items: center;
    gap: 12px;
}
.transaction-icon {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 18px;
    color: white;
}

/* --- 4. 行動軌跡 (時間線) 樣式 --- */
.character-trajectory-list {
    padding: 20px 15px 20px 30px; /* 左側留出時間線的空間 */
}
.character-trajectory-item {
    position: relative;
    padding-bottom: 25px;
}
/* 時間軸的分隔號 */
.character-trajectory-item::before {
    content: '';
    position: absolute;
    top: 5px;
    left: -18px;
    width: 2px;
    height: 100%;
    background-color: #e0e0e0;
}
.character-trajectory-item:last-child::before {
    display: none; /* 最後一個條目沒有線 */
}
/* 時間軸的圓點 */
.character-trajectory-item::after {
    content: '';
    position: absolute;
    top: 5px;
    left: -23px;
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background-color: var(--accent-color);
    border: 2px solid white;
    box-shadow: 0 0 0 2px var(--accent-color);
}
.trajectory-item-content .meta {
    margin-top: 4px; /* 讓時間和地點離標題近一點 */
}

/* --- 5. APP使用記錄 (進度條) 樣式 --- */
.character-app-usage-item {
    padding: 15px;
    border-bottom: 1px solid #f0f0f0;
}
.app-usage-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
    font-size: 14px;
}
.app-usage-header .name {
    font-weight: 500;
}
.app-usage-header .duration {
    color: var(--text-secondary);
}
.app-usage-bar-container {
    width: 100%;
    height: 6px;
    background-color: #e9ecef;
    border-radius: 3px;
    overflow: hidden;
}
.app-usage-bar {
    height: 100%;
    background-color: var(--accent-color);
    border-radius: 3px;
    transition: width 0.5s ease-in-out;
}
/* ▼▼▼ 【全新】後臺活動設置介面樣式 ▼▼▼ */
.char-list-item {
    display: flex;
    align-items: center;
    padding: 8px 5px;
    border-bottom: 1px solid #eee;
}
.char-list-item:last-child {
    border-bottom: none;
}
.char-list-item input[type="checkbox"] {
    margin-right: 10px;
    width: 18px;
    height: 18px;
}
.char-list-item .char-name {
    flex-grow: 1;
}
.char-list-item .char-freq-badge {
    font-size: 11px;
    font-weight: bold;
    padding: 3px 8px;
    border-radius: 10px;
    color: white;
}
.char-freq-badge.low { background-color: #28a745; }
.char-freq-badge.medium { background-color: #fd7e14; }
.char-freq-badge.high { background-color: #dc3545; }
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 的末尾 ▼▼▼ */

/* === 【全新】視頻通話視覺化介面樣式 === */

/* 1. 視覺化介面的總容器，確保它能覆蓋整個螢幕 */
#visual-call-interface {
    width: 100%;
    height: 100%;
    position: relative; /* 讓內部元素可以相對於它定位 */
    overflow: hidden; /* 防止內容溢出 */
    background-color: #1c1c1e; /* 深色背景 */
    display: flex; /* 使用flex佈局，方便內容排列 */
    flex-direction: column;
}

/* 2. 視頻背景層，用於放置大小圖 */
.video-background {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1; /* 確保它在最底層 */
}

/* 3. 大小圖的通用容器樣式 */
.video-container {
    position: absolute;
    background-color: #000;
    overflow: hidden;
    transition: all 0.3s ease-in-out; /* 為切換鏡頭添加動畫 */
}
.video-container img {
    width: 100%;
    height: 100%;
    object-fit: cover; /* 保證圖片填滿容器且不變形 */
}

/* 4. 大圖樣式 (預設占滿全屏) */
#video-main-view {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}

/* 5. 小圖樣式 (畫中畫) */
#video-pip-view {
    top: 60px; /* 距離頂部一段距離 */
    right: 15px;
    width: 100px; /* 小窗寬度 */
    height: 178px; /* 小窗高度 (保持豎屏比例) */
    border-radius: 10px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
    cursor: pointer; /* 提示用戶可以點擊 */
}

/* 6. 聊天氣泡區域 (覆蓋在視頻之上) */
#video-call-messages-visual {
    position: relative;
    z-index: 5; /* 層級比視頻高 */
    flex-grow: 1; /* 佔據除了頂部和底部欄之外的所有空間 */
    padding: 15px;
    overflow-y: auto; /* 內容多了可以滾動 */
    display: flex;
    flex-direction: column;
    gap: 15px;
    /* 關鍵：為了不讓捲軸影響美觀，把它隱藏掉 */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none;  /* IE 10+ */
}
#video-call-messages-visual::-webkit-scrollbar {
    display: none; /* Chrome, Safari, Opera*/
}

/* ▼▼▼ 用這【一小塊】代碼，替換掉舊的氣泡樣式，實現【無模糊】效果 ▼▼▼ */

/* 7. 【無模糊】高清透明聊天氣泡 */
.visual-call-bubble {
    padding: 8px 12px;
    border-radius: 18px;
    max-width: 80%;
    line-height: 1.5;
    word-break: break-word;
    color: white;

    /* ★ 核心修改：徹底移除 backdrop-filter (模糊) 效果 */

    /* ★ 核心修改：提供一個簡單的半透明黑色背景，以襯托文字 */
    background-color: rgba(0, 0, 0, 0.3); /* 這是一個關鍵值，可以在 0.2 (更透) 到 0.4 (更深) 之間微調 */

    /* ★ 核心修改：使用更清晰的邊框來定義氣泡輪廓 */
    border: 1px solid rgba(255, 255, 255, 0.25);

    /* ★ 核心修改：強化文字陰影，確保在任何清晰背景下都絕對可讀 */
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.9);
}

.visual-call-bubble.user {
    align-self: flex-end;
    /* ★ 核心修改：用戶氣泡也使用無模糊的半透明背景 */
    background-color: rgba(40, 160, 70, 0.3); /* 使用一個更深的綠色來保證對比度 */
    border-color: rgba(255, 255, 255, 0.3);
}

/* ▲▲▲ 替換結束 ▲▲▲ */



.visual-call-bubble.ai {
    align-self: flex-start; /* AI的發言靠左 */
}

/* 8. 頂部和底部欄的層級要最高 */
#visual-call-interface .video-call-top-bar,
#visual-call-interface .video-call-controls {
    z-index: 10;
}

/* 9. 新增的控制按鈕圖示 (使用SVG) */
.control-btn.reroll-btn {
    background-color: rgba(255,255,255,0.2);
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>');
    background-size: 50%;
}
.control-btn.switch-camera-btn {
    background-color: rgba(255,255,255,0.2);
    background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 4H4a2 2 0 0 0-2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>');
    background-size: 50%;
}

/* 10. 掛斷按鈕需要一個新ID來區分 */
#hang-up-btn-visual {
    /* 樣式繼承自 .hangup-btn，無需額外添加 */
}

/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【最終修復版】世界書選擇器清單樣式 ▼▼▼ */

/* 1. 分類資料夾行樣式：用gap創建固定間距，超穩定 */
.wb-category-header {
    display: flex;
    align-items: center;
    gap: 8px; /* 箭頭、核取方塊、文字之間的固定間距 */
    padding: 10px 12px;
    cursor: pointer;
    background-color: #f0f2f5;
    font-weight: 600;
    overflow: hidden; /* 防止任何意外 */
}

/* 2. 分類資料夾裡的文字樣式：只負責截斷，不負責佈局 */
.wb-category-header > span:last-of-type {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 3. 【核心修復】為分類資料夾和書目裡的核取方塊“解綁”全域樣式！ */
.wb-category-header input[type="checkbox"],
.wb-book-container input[type="checkbox"] {
    width: auto !important; /* 讓它恢復自己的天然大小，!important確保最高優先順序 */
    flex-shrink: 0;         /* 防止它被壓縮 */
}

/* 4. 具體書目行的樣式：強制從左邊開始排列，解決iOS問題 */
.wb-book-container label {
    display: flex;
    align-items: center;
    justify-content: flex-start; /* 強制所有內容從左邊開始！*/
    padding: 8px 12px;
    gap: 10px; /* 核取方塊和文字的間距 */
    overflow: hidden;
}

/* 5. 具體書目的文字樣式 */
.wb-book-container label .wb-book-name {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    text-align: left;
}

/* 6. 夜間模式適配 */
#phone-screen.dark-mode .wb-category-header {
    background-color: #2c2c2e;
}

/* 7. 小箭頭的樣式（保持不變） */
.wb-category-header .arrow {
    font-size: 12px;
    transition: transform 0.2s ease;
}
.wb-category-header.collapsed .arrow {
    transform: rotate(-90deg);
}

/* 8. 書籍容器的樣式（保持不變） */
.wb-book-container {
    padding-left: 20px;
    max-height: 1000px;
    overflow: hidden;
    transition: max-height 0.3s ease-in-out;
}
.wb-book-container.collapsed {
    max-height: 0;
}

/* ▲▲▲ 黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】字體預設功能樣式 ▼▼▼ */

#font-preset-container {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 15px; /* 卡槽之間的間距 */
}

.font-preset-slot {
    border: 1px solid var(--border-color);
    border-radius: 12px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

#phone-screen.dark-mode .font-preset-slot {
    border-color: #38383a;
}

.font-preset-slot.empty {
    justify-content: center;
    align-items: center;
    min-height: 80px;
    border-style: dashed;
}

.font-preview-text {
    font-size: 22px;
    padding: 10px;
    border-radius: 8px;
    text-align: center;
    min-height: 30px;
    transition: font-family 0.3s ease;
}

#phone-screen.dark-mode .font-preview-text {
    background-color: #2c2c2e;
    color: #fff;
}

.font-preset-info {
    font-size: 14px;
    color: var(--text-secondary);
    font-weight: 500;
}

.font-preset-actions {
    display: flex;
    gap: 10px;
    width: 100%;
}

.preset-btn {
    flex: 1;
    padding: 10px;
    border: none;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    background-color: var(--accent-color);
    color: white;
}

.preset-btn.secondary {
    background-color: #e9ecef;
    color: var(--text-primary);
    border: 1px solid var(--border-color);
}
#phone-screen.dark-mode .preset-btn.secondary {
    background-color: #3e3e42;
    border-color: #545458;
}

.preset-btn.delete {
    background-color: #ffdde5;
    color: #ff3b30;
    border: 1px solid #ffc2d1;
    max-width: 80px; /* 讓刪除按鈕窄一點 */
    flex: 0 0 auto;
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* 【美化 V2】讓後臺活動設置的按鈕更圓潤、更立體 */
#background-activity-details .form-button-secondary {
    border-radius: 20px; /* 大幅增加圓角，形成膠囊形狀 */
    padding-top: 10px;   /* 增加頂部內邊距，讓按鈕更高 */
    padding-bottom: 10px;/* 增加底部內邊距，讓按鈕更高 */
    font-weight: 500;    /* 字體稍微加粗一點 */
    transition: all 0.2s ease; /* 添加平滑的過渡效果 */
}

/* 為按鈕添加一個微妙的點擊效果 */
#background-activity-details .form-button-secondary:active {
    transform: scale(0.96); /* 點擊時輕微縮小 */
    opacity: 0.8;         /* 點擊時稍微變淡 */
}
/* ▼▼▼ 【全新】BGM搜索結果彈窗樣式 ▼▼▼ */

/* ▼▼▼ 在這裡添加下面這段新樣式 ▼▼▼ */
#music-search-results-modal .modal-content {
    z-index: 220; /* 這個值比播放清單的 210 要高 */
}
/* ▲▲▲ 添加結束 ▲▲▲ */

.search-result-item {
    display: flex;
    flex-direction: column;
    padding: 12px 18px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background-color 0.2s;
}

/* ▼▼▼ 【全新】BGM搜索結果彈窗樣式 ▼▼▼ */

.search-result-item {
    display: flex;
    flex-direction: column;
    padding: 12px 18px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background-color 0.2s;
}

.search-result-item:hover {
    background-color: rgba(0, 0, 0, 0.1);
}

#phone-screen.dark-mode .search-result-item:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

.search-result-item .title {
    font-weight: 500;
    font-size: 15px;
    color: var(--text-primary);
}

.search-result-item .artist {
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px;
}

.search-result-item .source {
    font-size: 10px;
    color: var(--accent-color);
    background-color: rgba(0, 123, 255, 0.1);
    padding: 2px 6px;
    border-radius: 4px;
    font-weight: bold;
    margin-left: 8px;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】BGM搜索源選擇彈窗樣式 ▼▼▼ */
#music-source-selector-modal .modal-body label {
    font-size: 16px;
    display: flex;
    align-items: center;
    gap: 10px;
}
#music-source-selector-modal .modal-body input[type="radio"] {
    width: 18px;
    height: 18px;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 用這整塊【佈局微調版】樣式，替換掉上一次的舊樣式 ▼▼▼ */

/* 1. 閃爍動畫 (保持不變) */
@keyframes flash-char {
    0%, 100% { opacity: 1; transform: scale(1); box-shadow: 0 0 3px rgba(255,192,203, 0); }
    50% { opacity: 0.8; transform: scale(1.08); box-shadow: 0 0 12px rgba(255,192,203, 0.9); }
}
@keyframes flash-user {
    0%, 100% { opacity: 1; transform: scale(1); box-shadow: 0 0 3px rgba(173,216,230, 0); }
    50% { opacity: 0.8; transform: scale(1.08); box-shadow: 0 0 12px rgba(173,216,230, 0.9); }
}

/* 2. 【核心修改】調整頭像容器的下邊距 */
#music-avatars-container {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 8px; /* <<<< 從 25px 減小到 8px，讓它和下面的文字更近 */
    position: relative;
    z-index: 5;
}

/* 3. 單個頭像樣式 (保持不變) */
#music-avatars-container img {
    width: 35px;
    height: 35px;
    border-radius: 50%;
    object-fit: cover;
    border: 2px solid rgba(255, 255, 255, 0.8);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
}

/* 4. 分開閃爍動畫 (保持不變) */
#music-avatars-container.flashing #music-char-avatar {
    animation: flash-char 2.2s infinite ease-in-out;
}
#music-avatars-container.flashing #music-user-avatar {
    animation: flash-user 2.2s infinite ease-in-out 0.3s;
}

/* 5. 心電圖樣式 (保持不變) */
#heartbeat-line {
    width: 80px;
    height: 30px;
    overflow: visible;
    margin: 0 -15px;
    opacity: 0;
    transition: opacity 0.5s;
}
#music-avatars-container.flashing #heartbeat-line {
    opacity: 1;
}
.heartbeat-path {
    stroke: #FFC0CB;
    stroke-width: 1.5;
    fill: none;
    stroke-dasharray: 100;
    stroke-dashoffset: 100;
    animation: draw-line 2.2s infinite linear;
    filter: drop-shadow(0 0 3px #FFC0CB); 
}
.heartbeat-heart {
    display: none;
}
@keyframes draw-line {
    to { stroke-dashoffset: 0; }
}

/* 6. 【核心修改】調整“一起聽了”文字的樣式和邊距 */
#music-time-counter {
    margin-bottom: 20px; /* <<<< 現在由它來負責和下面的封面拉開距離 */
    font-size: 11px;
    color: #666; /* 顏色稍微加深一點 */
    text-align: center;
}

/* 7. 唱片旋轉動畫 (保持不變) */
@keyframes spin-record {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

/* 8. 封面和歌詞的切換容器 (保持不變) */
#music-display-area {
    width: 192px;
    height: 192px;
    margin-bottom: 15px;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    transition: transform 0.3s ease;
}
#music-display-area:active {
    transform: scale(0.98);
}

/* 9. 歌曲封面 (保持不變) */
#music-album-cover {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%;
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    display: block;
}
#music-album-cover.rotating {
    animation: spin-record 10s linear infinite;
}
#music-album-cover.paused {
    animation-play-state: paused;
}

/* 10. 其他樣式 (保持不變) */
#music-lyrics-container { display: none; }
#music-display-area.show-lyrics #music-album-cover { display: none; }
#music-display-area.show-lyrics #music-lyrics-container { display: block; }
#music-player-song-title { margin-bottom: 2px; }
#music-player-artist { margin-bottom: 10px; }
.music-player-window { min-height: 480px; }

/* ▲▲▲ 佈局微調版樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 【最終修復版】提升搜索相關彈窗的層級 ▼▼▼ */
#music-source-selector-modal,
#custom-modal-overlay {
    z-index: 250 !important; /* 這個值必須高於播放清單(210)，!important確保它擁有最高優先順序 */
}
/* ▲▲▲ 黏貼結束 ▲▲▲ */
/* ▼▼▼ 步驟 1：把這一整塊全新的CSS，黏貼到 <style> 的末尾 ▼▼▼ */

/* --- 1. 隱藏舊的主螢幕元素 --- */
/* 我們不再需要舊的鎖屏時鐘和圖示網格了，新的佈局會完全取代它們 */
#home-screen #clock-container,
#home-screen .app-grid {
    display: none !important;
}

/* --- 2. 【核心】重新定義主螢幕佈局 --- */
/* 
   這將把你的主螢幕從一個簡單的垂直列表，變成一個撐滿全屏、
   使用Flexbox佈局的強大容器，為新的“桌面式”佈局打下基礎。
*/
/* --- 2. 【核心】重新定義主螢幕佈局 --- */
#home-screen {
    /* 使用一個漂亮的線性漸變作為預設背景，當然你可以在“外觀設置”裡隨時換掉它 */
    background: linear-gradient(135deg, #6DD5FA, #2980B9);
    background-size: cover;
    background-position: center;
    
    /* 適配iPhone劉海和底部安全區 */
    padding-top: calc(20px + env(safe-area-inset-top));
    padding-bottom: calc(20px + env(safe-area-inset-bottom));
    
    /* ▼▼▼ 在這裡添加下面這兩行 ▼▼▼ */
    padding-left: 0;
    padding-right: 0;
    /* ▲▲▲ 添加結束 ▲▲▲ */

    /* 使用Flexbox讓內容區和Dock欄上下分離 */
    display: flex;
    flex-direction: column;
    justify-content: space-between; 
    align-items: center;
    height: 100%; /* 確保它撐滿螢幕 */
}


/* --- 3. 中間主要內容區 (個人資料卡 + 小元件 + App圖示) --- */
#main-content-area {
    width: 100%;
    display: flex;
    flex-direction: column;
    gap: 30px; /* 卡片和下方圖示的間距 */
    align-items: center;
    margin-top: 20px; /* 距離螢幕頂部一點距離 */
}

/* --- 4. 個人資料卡片 (這是視覺核心) --- */

/* 4a. 卡片外層容器：這是所有內部元素定位的“錨點” */
#profile-widget {
    position: relative; /* 關鍵：讓內部的頭像和偽元素可以相對於它進行絕對定位 */
    width: 100%;
    max-width: 380px;
    flex-shrink: 0;
}

/* 4b. 背景頭圖：只給頂部設置圓角 */
#profile-banner-img {
    display: block; 
    width: 100%;
    height: 150px;
    object-fit: cover;
    border-radius: 24px 24px 0 0; /* 只給頂部設置圓角 */
    position: relative;
    z-index: 1; /* 層級1：在最下方 */
}

/* 4c. 頭像容器：精確定位，使其中心線與頭圖底部對齊 */
#profile-widget .profile-avatar-container {
    position: absolute;
    top: 80px; /* 從頂部向下偏移，讓它一半在頭圖上，一半在下面 */
    left: 50%;
    transform: translateX(-50%);
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background-color: white; /* 白色背景板，讓頭像更突出 */
    padding: 4px; /* 白色邊框的效果 */
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    z-index: 3; /* 層級3：最高層，壓住一切 */
}

#profile-avatar-img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}

/* 4d. 白色資訊卡片：使用負外邊距實現無縫拼接 */
#profile-widget .profile-info {
  /* 【修改後】白色到透明的漸變背景，並加上一層柔和的陰影 */
background: linear-gradient(to bottom, rgba(255, 255, 255, 0.85) 20%, rgba(255, 255, 255, 0));
box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    border-radius: 24px;
    
    /* 核心魔法：使用負外邊距，將卡片向上移動，與頭圖和頭像重疊 */
    margin-top: -24px; 
    
    /* 同時，為上移的頭像留出精確的空間，避免文字壓住頭像 */
    padding-top: 54px; /* 頭像半徑(40px) + 額外間距(14px) */
    
    min-height: 120px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding-left: 15px;
    padding-right: 15px;
    padding-bottom: 15px;
    text-align: center;
    color: #1c1c1e;
    position: relative;
    z-index: 2; /* 層級2：在頭圖之上，但在頭像之下 */
}

/* 4e. 個人資料內部的文字樣式 */
#profile-username { font-size: 18px; font-weight: 600; margin: 0 0 2px 0; }
#profile-sub-username { font-size: 13px; color: #8a8a8a; margin: 0 0 10px 0; }
#profile-bio { font-size: 14px; margin: 0 0 12px 0; color: #333; }
#profile-location {
    font-size: 12px; color: #8a8a8a; margin: 0 auto; display: inline-flex;
    align-items: center; gap: 4px; background-color: rgba(0,0,0,0.05);
    padding: 3px 9px; border-radius: 10px;
}

/* --- 5. 桌面式佈局 (小元件 + App圖示) --- */
#desktop-layout {
    display: grid; /* 使用Grid佈局，輕鬆實現兩列 */
    grid-template-columns: 1fr 1.1fr; /* 左窄右寬的兩列 */
    gap: 20px;
    width: 100%;
    align-items: start;
}
#desktop-widget-column {
    display: flex;
    flex-direction: row;
    justify-content: space-between; /* 【核心修改】將 space-around 改為 space-between */
    align-items: start;
    width: 100%;
}

/* 右側App圖示容器 */
#desktop-app-container {
    display: grid;
    grid-template-columns: 1fr 1fr; /* 兩列圖示 */
    gap: 25px;
    align-content: start;
}
.desktop-app-icon {
    display: flex; flex-direction: column; align-items: center; gap: 8px; cursor: pointer; text-align: center;
}
.icon-bg-desktop {
    width: 55px; height: 55px; border-radius: 14px; background-color: #f0f2f5; justify-content: center; box-shadow: 0 4px 10px rgba(0,0,0,0.1); transition: transform 0.2s ease; overflow: hidden;
}
.icon-bg-desktop img { width: 100%; height: 100%; object-fit: cover; border-radius: 0; }
.desktop-app-icon .label { color: #333; font-size: 13px; font-weight: 500; }
.desktop-app-icon:active .icon-bg-desktop { transform: scale(0.9); }


/* --- 6. 底部 Dock 欄 --- */
#desktop-dock {
    background-color: rgba(255, 255, 255, 0.15); /* 玻璃擬態背景 */
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-radius: 20px;
    padding: 15px 25px;
    display: flex;
    justify-content: center;
    gap: 30px;
    width: fit-content; /* 寬度自我調整內容 */
    flex-shrink: 0;
}

/* --- 7. 【核心功能】為可編輯元素添加視覺回饋 --- */
.editable-text, .editable-image {
    cursor: pointer;
    transition: all 0.2s ease-in-out;
}

/* 滑鼠懸停時，顯示一個半透明的虛線外框，並輕微變暗，提示用戶這裡可以點 */
.editable-text:hover, .editable-image:hover {
    outline: 2px dashed rgba(0, 0, 0, 0.4);
    opacity: 0.85;
    border-radius: 4px; /* 讓外框也有一點圓角 */
}

/* --- 8. 【鎖屏相容】讓鎖屏和主螢幕可以堆疊 --- */
#lock-screen, #home-screen {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
}
#lock-screen {
    z-index: 999; /* 確保鎖屏在最上層 */
}
/* ▼▼▼ 這是新增的桌面小元件樣式 ▼▼▼ */

/* 單個小組件的總容器 */
.custom-widget-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px; /* 各個元素之間的垂直間距 */
}

.widget-bubble {
    position: relative;
    background-color: rgba(255, 255, 255, 0.9);
    color: #333;
    padding: 8px 12px;
    border-radius: 20px; /* 【核心修改】增加圓角，實現膠囊感 */
    font-size: 13px;
    font-weight: 500;
    /* 【核心修改】移除 min-width，讓寬度自我調整內容 */
    text-align: center;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}


/* 用偽元素給氣泡加一個小尾巴，指向下面的圓形圖片 */
.widget-bubble::after {
    content: '';
    position: absolute;
    bottom: -6px; /* 尾巴在氣泡下方 */
    left: 50%;
    transform: translateX(-50%);
    border-width: 6px 6px 0;
    border-style: solid;
    border-color: rgba(255, 255, 255, 0.9) transparent transparent transparent;
}

.widget-circle-uploader {
    width: 65px; /* 從 80px 縮小 */
    height: 65px; /* 從 80px 縮小 */
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.5);
    box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    padding: 3px;
    background-color: transparent; /* 【核心修改】將背景色改為透明 */ 
    box-sizing: border-box;
}


/* 這是替換後的第二塊 */
.widget-circle-uploader img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%; /* 【核心】讓圖片也變成圓形，完美適應內邊距 */
}


/* 下方的透明文字區域 */
.widget-subtext {
    background: transparent;
    border: none;
    color:  #333;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5); /* 加一點文字陰影更清晰 */
    font-size: 13px;
    font-weight: 500;
    text-align: center;
}

/* ▲▲▲ 新增樣式結束 ▲▲▲ */
/* ▼▼▼ 【V3最終美化版】主螢幕美化預設功能樣式 ▼▼▼ */
.preset-manager-container {
    width: 100%;
    margin-top: 20px;
    padding-top: 20px;
    border-top: 1px solid var(--border-color);
}
#phone-screen.dark-mode .preset-manager-container {
    border-top-color: #3a3a3c;
}
.preset-manager-container .form-group {
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.preset-manager-controls {
    display: grid;
    grid-template-columns: 1fr 1fr; /* 【核心】2x2 網格佈局 */
    gap: 12px; /* 按鈕間距 */
    width: 100%;
}
.preset-btn-capsule {
    padding: 12px 15px; /* 增加垂直內邊距，讓按鈕更高更可愛 */
    border: none;
    border-radius: 25px; /* 更大的圓角，膠囊感更強 */
    font-size: 14px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 3px 6px rgba(0,0,0,0.08); /* 增加一點立體陰影 */
}
.preset-btn-capsule:active {
    transform: scale(0.96);
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}
.preset-btn-capsule:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    box-shadow: none;
    background-color: #e9ecef !important; /* 禁用時統一用灰色 */
    color: #adb5bd !important;
    border-color: #dee2e6 !important;
}
#phone-screen.dark-mode .preset-btn-capsule:disabled {
    background-color: #3a3a3c !important;
    color: #545458 !important;
}
.preset-btn-apply {
    background-color: var(--accent-color); /* 應用按鈕使用主題色 */
    color: white;
    grid-column: 1 / -1; /* 【核心】讓應用按鈕獨佔一行，更突出 */
}
.preset-btn-save {
    background-color: #4cd964; /* 保存用綠色，代表創建 */
    color: white;
}
.preset-btn-secondary {
    background-color: #f8f9fa;
    color: var(--text-primary);
    border: 1px solid var(--border-color);
}
#phone-screen.dark-mode .preset-btn-secondary {
    background-color: #3a3a3c;
    border-color: #545458;
}
.preset-btn-delete {
    background-color: #ffdde5;
    color: #ff3b30;
}
#phone-screen.dark-mode .preset-btn-delete {
    background-color: #5c2b2b;
    color: #ff8a80;
}
/* ▲▲▲ 樣式黏貼結束 ▲▲▲ */



/* ▼▼▼ 【V6最終修復版】夜間模式終極適配 (已修復所有頁面適配問題) ▼▼▼ */

/* 核心：當 #phone-screen 擁有 .dark-mode 類時，啟動以下所有樣式 */

/* 1. 全域重新定義顏色變數 */
#phone-screen.dark-mode {
  --secondary-bg: #1c1c1e;
  --border-color: #38383a;
  --text-primary: #ffffff;
  --text-secondary: #8e8e93;
  --status-bar-text-color: #ffffff;
}

/* 2. 【基礎】為所有螢幕和主要容器設置基礎深色背景 */
#phone-screen.dark-mode,
#phone-screen.dark-mode .screen,
#phone-screen.dark-mode #chat-list,
#phone-screen.dark-mode #world-book-list,
#phone-screen.dark-mode .list-container,
#phone-screen.dark-mode .form-container,
#phone-screen.dark-mode #chat-messages {
    background-color: #000000 !important;
}

/* 3. 【主螢幕】專屬樣式 (從被刪除的代碼中恢復並整合) */
#phone-screen.dark-mode #home-screen {
    background: #111827; /* 深藍色背景 */
}
#phone-screen.dark-mode #desktop-dock {
    background-color: rgba(55, 65, 81, 0.5); /* Dock欄深灰色玻璃效果 */
}
#phone-screen.dark-mode .desktop-app-icon .label,
#phone-screen.dark-mode .widget-subtext {
    color: #e5e7eb; /* 桌面文字變為淺灰色 */
    text-shadow: 0 1px 2px rgba(0,0,0,0.7); /* 加強陰影 */
}
#phone-screen.dark-mode #profile-widget .profile-info {
    background: linear-gradient(to bottom, rgba(28, 28, 30, 0.85) 20%, rgba(28, 28, 30, 0)); /* 資訊卡片深灰色漸變 */
    color: #f9fafb;
}
#phone-screen.dark-mode #profile-username,
#phone-screen.dark-mode #profile-bio,
#phone-screen.dark-mode #profile-location span {
    color: #f9fafb; /* 資訊卡片主文字白色 */
}
#phone-screen.dark-mode #profile-sub-username,
#phone-screen.dark-mode #profile-location {
    color: #9ca3af; /* 資訊卡片次要文字灰色 */
}
#phone-screen.dark-mode #profile-location {
    background-color: rgba(255,255,255,0.1); /* 地點背景變亮 */
}
#phone-screen.dark-mode .widget-bubble {
    background-color: rgba(55, 65, 81, 0.9); /* 小組件氣泡深灰色 */
    color: #e5e7eb; /* 小元件文字淺灰色 */
}
#phone-screen.dark-mode .widget-bubble::after {
    border-top-color: rgba(55, 65, 81, 0.9); /* 小尾巴顏色同步 */
}

/* 4. 【修復】適配所有頁面的頭部Header */
#phone-screen.dark-mode .header,
#phone-screen.dark-mode .qzone-header {
    background-color: rgba(28, 28, 30, 0.85) !important;
    border-bottom-color: var(--border-color) !important;
    color: var(--text-primary) !important; 
}

/* 5. 【修復】適配所有萬用群組件 (彈窗、輸入框等) */
#phone-screen.dark-mode #chat-input-area,
#phone-screen.dark-mode #chat-list-bottom-nav {
    background-color: rgba(28, 28, 30, 0.85);
    border-top-color: var(--border-color);
}
#phone-screen.dark-mode #chat-input {
    background-color: var(--secondary-bg);
    color: var(--text-primary);
}
#phone-screen.dark-mode .modal-content,
#phone-screen.dark-mode #custom-modal {
    background-color: #2c2c2e;
}
#phone-screen.dark-mode .modal-header, 
#phone-screen.dark-mode .modal-footer,
#phone-screen.dark-mode .custom-modal-footer {
    border-color: var(--border-color);
}
#phone-screen.dark-mode .form-group input,
#phone-screen.dark-mode .form-group select,
#phone-screen.dark-mode .form-group textarea {
    background-color: var(--secondary-bg);
    color: var(--text-primary);
    border-color: var(--border-color);
}
#phone-screen.dark-mode .list-item,
#phone-screen.dark-mode .chat-list-item-swipe-container:not(:last-child) {
    border-bottom-color: var(--border-color);
}
#phone-screen.dark-mode .list-item:hover,
#phone-screen.dark-mode .chat-list-item:hover {
    background-color: #2c2c2e;
}

/* 6. 【解決】字體預設 & 外觀設置頁面深度適配 */
#phone-screen.dark-mode #font-settings-screen,
#phone-screen.dark-mode #wallpaper-screen {
    background-color: #000000;
}
#phone-screen.dark-mode .font-preset-slot,
#phone-screen.dark-mode #font-preview,
#phone-screen.dark-mode #wallpaper-preview {
    background-color: var(--secondary-bg);
    border-color: var(--border-color);
}
#phone-screen.dark-mode .preset-btn.secondary {
    background-color: #3e3e42;
    border-color: #545458;
}

/* 7. 【解決】“查手機”功能所有內部頁面深度適配 */
#phone-screen.dark-mode #character-phone-container {
    background-color: #000000;
}
#phone-screen.dark-mode .character-phone-frame {
    background-color: #111;
}
#phone-screen.dark-mode .character-phone-inner-screen,
#phone-screen.dark-mode .character-phone-page {
    background-color: #000000;
}
#phone-screen.dark-mode .character-phone-header {
    background-color: rgba(28, 28, 30, 0.85) !important;
    border-bottom: 1px solid #38383a !important;
}
#phone-screen.dark-mode #character-app-grid .label {
    color: #e5e7eb;
}
#phone-screen.dark-mode .character-chat-list .chat-list-item:hover {
    background-color: #1c1c1e;
}
#phone-screen.dark-mode #character-chat-history-messages {
    background-color: #0e0e0e !important;
}
#phone-screen.dark-mode .character-chat-bubble.received {
    background-color: #2c2c2e;
}
#phone-screen.dark-mode .character-data-item,
#phone-screen.dark-mode .character-bank-transaction,
#phone-screen.dark-mode .character-cart-item,
#phone-screen.dark-mode .character-browser-item {
    background-color: #1c1c1e;
    border-color: #38383a;
}
#phone-screen.dark-mode .character-data-item .title,
#phone-screen.dark-mode .character-data-item .content,
#phone-screen.dark-mode .cart-item-price {
    color: var(--text-primary);
}
#phone-screen.dark-mode .character-bank-balance-card {
    background: linear-gradient(135deg, #3a3a3c, #1c1c1e);
}
#phone-screen.dark-mode #character-diary-list .character-data-item {
    background-color: #1a1510;
    border-color: #4a443b;
    border-left-color: #8c7d6b;
}
#phone-screen.dark-mode #character-select-item .name {
    color: #80CBC4 !important; /* 柔和的青色 */
}

/* 8. 【新增】修復聊天列表分組標題的背景色 */
#phone-screen.dark-mode .chat-group-header {
    background-color: #1c1c1e;
}
#phone-screen.dark-mode .chat-list-item-content.pinned {
    background-color: #3a3a3c;
}

/* ▲▲▲ CSS 代碼黏貼結束 ▲▲▲ */
/* ▼▼▼ 步驟 1.1：將這整塊【終極修復版】CSS黏貼到 <style> 的末尾 ▼▼▼ */

/* 核心修復：使用 !important 強制提升優先順序，覆蓋掉所有搗亂的內聯樣式 */

/* 1. 為所有需要適配的螢幕強制設置純黑背景 */
#phone-screen.dark-mode #wallpaper-screen,
#phone-screen.dark-mode #font-settings-screen,
#phone-screen.dark-mode #api-settings-screen,
#phone-screen.dark-mode #character-selection-screen,
#phone-screen.dark-mode #world-book-screen,
#phone-screen.dark-mode #world-book-editor-screen,
#phone-screen.dark-mode .form-container, /* 確保所有表單容器也適配 */
#phone-screen.dark-mode .list-container { /* 確保所有列表容器也適配 */
    background-color: #000000 !important;
}

/* 2. 為“查手機”內部的所有頁面強制設置純黑背景 */
#phone-screen.dark-mode .character-phone-inner-screen,
#phone-screen.dark-mode .character-phone-page {
    background-color: #000000 !important;
}
#phone-screen.dark-mode #character-chat-history-messages {
    background-color: #0e0e0e !important; /* 聊天記錄用深灰色 */
}

/* 3. 修復頁面內部元件的背景色 */
#phone-screen.dark-mode #font-preview,
#phone-screen.dark-mode #wallpaper-preview {
    background-color: #1c1c1e !important;
    border-color: #38383a !important;
}

/* 4. 修復“查手機”裡對方的聊天氣泡顏色 */
#phone-screen.dark-mode .character-chat-bubble.received {
    background-color: #2c2c2e !important;
}
/* ▼▼▼ 【最終修復版】提升所有彈窗的層級 ▼▼▼ */
#music-source-selector-modal,
#music-search-results-modal {
    z-index: 250 !important; /* 這個值高於播放清單(210)，!important確保它擁有最高優先順序 */
}
/* ▲▲▲ 黏貼結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 的末尾 ▼▼▼ */

/* 【全新美化版】通用操作功能表按鈕 */
#preset-actions-modal .custom-modal-footer button {
    width: 100%;
    border: none; /* 移除邊框 */
    border-radius: 20px; /* ★★★ 修改這裡！把 12px 改成了 20px ★★★ */
    padding: 14px;
    font-size: 16px; /* 字體稍微縮小一點，更精緻 */
    font-weight: 500;
    margin-bottom: 8px; /* 按鈕之間的垂直間距 */
    background-color: #f0f0f0; /* 統一的淺灰色背景 */
    color: var(--text-primary);
    transition: background-color 0.2s, transform 0.1s; /* 添加動畫 */
}

/* 滑鼠懸停和點擊效果 */
#preset-actions-modal .custom-modal-footer button:hover {
    background-color: #e0e0e0;
}
#preset-actions-modal .custom-modal-footer button:active {
    transform: scale(0.98); /* 點擊時輕微縮小 */
}

/* 單獨美化“刪除”按鈕 */
#preset-actions-modal .custom-modal-footer button.btn-danger {
    background-color: #ffe5e5;
    color: #ff3b30;
}
#preset-actions-modal .custom-modal-footer button.btn-danger:hover {
    background-color: #ffcccc;
}

/* 美化“取消”按鈕 */
#preset-actions-modal .custom-modal-footer button:last-child {
    background-color: #e9ecef;
    margin-top: 4px; /* 和上面的按鈕稍微拉開一點距離 */
}
#preset-actions-modal .custom-modal-footer button:last-child:hover {
    background-color: #dcdfe3;
}

/* 移除按鈕之間的分割線 */
#preset-actions-modal .custom-modal-footer button {
    border-bottom: none !important;
}

/* ▲▲▲ 黏貼結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 的末尾 ▼▼▼ */

/* 【核心修正】提升通用操作功能表的層級，確保它能覆蓋播放清單 */
#preset-actions-modal {
    z-index: 220; /* 這個值比播放清單(210)更高，就不會被擋住了 */
}

/* ▲▲▲ 黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是為“查手機”內容添加的刪除按鈕樣式 ▼▼▼ */
.character-data-item, .character-cart-item, .character-browser-item, .character-bank-transaction, .character-trajectory-item, .character-app-usage-item, .character-album-item {
    position: relative; /* 讓刪除按鈕可以相對於它定位 */
    padding-right: 35px; /* 在右邊給刪除按鈕留出位置 */
}

.item-delete-btn {
    position: absolute;
    top: 50%;
    right: 10px;
    transform: translateY(-50%);
    width: 24px;
    height: 24px;
    background-color: #f0f0f0;
    color: #888;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    font-size: 18px;
    line-height: 24px;
    text-align: center;
    transition: all 0.2s ease;
}

.item-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}
/* ▲▲▲ 新增樣式結束 ▲▲▲ */
/* ▼▼▼ 【全新】角色手機微信消息刪除按鈕樣式 ▼▼▼ */
.character-chat-bubble-container {
    position: relative; /* 讓刪除按鈕可以相對於它定位 */
}

.message-delete-btn {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    background-color: rgba(0, 0, 0, 0.1);
    color: #555;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    font-size: 16px;
    line-height: 22px;
    text-align: center;
    opacity: 0; /* 默認隱藏 */
    transition: all 0.2s ease;
}

.character-chat-bubble-container:hover .message-delete-btn {
    opacity: 1; /* 滑鼠懸停時顯示 */
}

.message-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}

/* 根據消息是左是右，調整刪除按鈕的位置 */
.character-chat-bubble-container.sent .message-delete-btn {
    left: -28px;
}
.character-chat-bubble-container.received .message-delete-btn {
    right: -28px;
}
/* ▲▲▲ 新增樣式結束 ▲▲▲ */

/* ▲▲▲ CSS 黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新添加】強制修正所有設置頁面的底部安全區 ▼▼▼ */
#font-settings-screen .form-container,
#wallpaper-screen .form-container,
#api-settings-screen .form-container,
#css-editor-screen .form-container {
    padding-bottom: calc(20px + env(safe-area-inset-bottom));
}
/* ▲▲▲ 添加結束 ▲▲▲ */


/* ▼▼▼ 【全新】iOS風格的滑動開關樣式 ▼▼▼ */

.toggle-switch-label {
    display: flex;
    align-items: center;
    justify-content: space-between; /* 讓文字和開關兩端對齊 */
    cursor: pointer;
    user-select: none;
    width: 100%;
    padding: 10px 0; /* 增加一點上下間距 */
}

.toggle-switch-text {
    font-weight: 500;
    color: var(--text-primary);
}

/* 隱藏原始的 checkbox */
.toggle-switch-label input[type="checkbox"] {
    opacity: 0;
    width: 0;
    height: 0;
    position: absolute;
}

/* 開關的軌道 */
.toggle-switch-slider {
    position: relative;
    display: inline-block;
    width: 51px;
    height: 31px;
    background-color: #e9e9eb;
    border-radius: 34px;
    transition: background-color 0.2s;
    flex-shrink: 0; /* 防止被壓縮 */
}

/* 開關的滑塊 (那個白色圓點) */
.toggle-switch-slider::before {
    content: "";
    position: absolute;
    height: 27px;
    width: 27px;
    left: 2px;
    bottom: 2px;
    background-color: white;
    border-radius: 50%;
    transition: transform 0.2s;
    box-shadow: 0 1px 3px rgba(0,0,0,0.15);
}

/* 當 checkbox 被選中時，改變軌道的顏色 */
.toggle-switch-label input:checked + .toggle-switch-slider {
    background-color: #34c759; /* iOS 風格的綠色 */
}

/* 當 checkbox 被選中時，移動滑塊 */
.toggle-switch-label input:checked + .toggle-switch-slider::before {
    transform: translateX(20px);
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 這是為你新增的顏色樣式 ▼▼▼ */

/* 1. 把時間的顏色強制設置為黑色 */
#status-bar-time {
    color: #000000 !important; /* !important 確保它優先順序最高 */
}

/* 2. 把電池容器內的所有東西（圖示邊框、電量條、百分比文字）都設置為綠色 */
#status-bar-battery {
    color: #4CAF50 !important; /* 這是一個很好看的綠色 */
}

/* ▲▲▲ 新增樣式結束 ▲▲▲ */
/* ▼▼▼ 這是步驟1需要黏貼的新樣式 ▼▼▼ */

/* 讓每一條評論都變成可點擊的 */
.comment-item {
    cursor: pointer; /* 滑鼠懸停時顯示為小手形狀 */
    transition: background-color 0.2s; /* 添加一個平滑的背景色過渡動畫 */
    border-radius: 4px; /* 給一點點圓角，更好看 */
    padding: 2px 5px; /* 增加一點內邊距，讓點擊區域更大 */
    margin: 0 -5px; /* 把上面的內邊距抵消掉，保持對齊 */
}
.comment-item:hover {
    background-color: #f0f2f5; /* 滑鼠放上去時，給一個淡淡的背景色 */
}
#phone-screen.dark-mode .comment-item:hover {
    background-color: #2c2c2e; /* 夜間模式下的懸停顏色 */
}

/* “回復”這兩個字的樣式 */
.comment-item .reply-text {
    color: var(--text-secondary);
    margin: 0 4px; /* 和兩邊的名字拉開一點距離 */
}

/* 被回復者的名字樣式 */
.comment-item .reply-target-name {
    font-weight: 600;
    color: var(--accent-color);
    cursor: pointer;
    margin-right: 5px;
}
/* ▼▼▼ 【全新】聊天記錄搜索功能樣式 ▼▼▼ */

/* 搜索結果列表 */
#chat-search-results-list {
    flex-grow: 1; /* 佔據剩餘所有空間 */
    overflow-y: auto; /* 內容多了可以滾動 */
}

/* 單條搜索結果的樣式 */
.search-result-item {
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    display: flex;
    gap: 12px; /* 頭像和內容的間距 */
    align-items: flex-start;
}
.search-result-item:hover {
    background-color: #f5f5f5;
}
#phone-screen.dark-mode .search-result-item:hover {
    background-color: #2c2c2e;
}

/* 結果中的頭像 */
.search-result-item .avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    flex-shrink: 0;
}

/* 結果右側資訊（名字、時間、內容） */
.search-result-info {
    display: flex;
    flex-direction: column;
    gap: 4px; /* 資訊內部的垂直間距 */
    overflow: hidden; /* 防止內容過長溢出 */
}

/* 名字和時間的容器 */
.search-result-meta {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: var(--text-secondary);
}

.search-result-meta .name {
    font-weight: 600;
    color: var(--text-primary);
    font-size: 14px;
}

/* 消息內容 */
.search-result-content {
    font-size: 14px;
    line-height: 1.5;
    word-break: break-all; /* 確保長文本能換行 */
}

/* 【核心】關鍵字高亮樣式 */
.highlight {
    background-color: #FFDE5C; /* 亮黃色背景 */
    color: #5D4037; /* 深棕色文字，對比更清晰 */
    font-weight: bold;
    padding: 1px 3px;
    border-radius: 3px;
}

/* 跳轉後消息的閃爍動畫 */
@keyframes flash-highlight {
    0% { background-color: transparent; }
    25% { background-color: rgba(255, 222, 92, 0.7); }
    100% { background-color: transparent; }
}
.message-bubble.flash {
    animation: flash-highlight 1.5s ease-out;
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 【最終修復】解決搜索結果看不見的問題 ▼▼▼ */
#chat-search-screen .form-container {
    padding-bottom: 20px; /* 給底部一點空間 */
}

#search-results-list {
    flex-grow: 1; /* 核心：讓結果列表佔據所有剩餘的垂直空間 */
    overflow-y: auto; /* 核心：如果結果太多，讓它自己出現捲軸 */
    min-height: 0; /* 一個神奇的CSS屬性，用於解決flex佈局下的溢出問題 */
    border-top: 1px solid var(--border-color); /* 在結果和按鈕之間加一條分割線，更美觀 */
    margin-top: 15px; /* 和上面的按鈕拉開距離 */
    padding-top: 10px; /* 列表頂部的內邊距 */
}
/* ▲▲▲ 修復結束 ▲▲▲ */
/* ▼▼▼ 把這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */

/* 統一樣式，讓圖示和文字按鈕對齊 */
#music-playlist-panel .playlist-header .panel-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
}

/* ▼▼▼ 用這塊新代碼替換舊的垃圾桶樣式 ▼▼▼ */

/* 設置垃圾桶圖示的預設樣式 */
#delete-expired-songs-btn svg {
    color: inherit; /* 核心修改1: 平時顏色繼承父元素，和"本地"等文字顏色一樣，保持低調 */
    transition: color 0.2s, transform 0.2s; /* 添加transform過渡效果 */
    transform: translateY(3px); /* 核心修改2: 讓圖示整體下移3圖元，視覺上更對齊 */
}

/* 設置滑鼠懸停/點擊時的樣式 */
#delete-expired-songs-btn:hover svg,
#delete-expired-songs-btn:active svg {
    color: #ff3b30; /* 核心修改3: 滑鼠放上去或點擊時，才變為醒目的紅色 */
}

/* ▲▲▲ 替換結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 的末尾 ▼▼▼ */

/* 【核心】專門為角色手機裡的日記刪除按鈕，重新定義位置 */
#character-diary-list .character-data-item .item-delete-btn {
    top: auto;         /* 解除頂部的定位 */
    right: auto;       /* 解除右側的定位 */
    bottom: 8px;       /* 定位到距離底部8圖元 */
    left: 8px;         /* 定位到距離左側8圖元 */
    opacity: 0;        /* 保持默認隱藏 */
    transition: opacity 0.2s ease; /* 保持淡入淡出動畫 */
}

/* 【美化】滑鼠懸停在整張日記卡片上時，才顯示這個按鈕 */
#character-diary-list .character-data-item:hover .item-delete-btn {
    opacity: 1;
}

/* ▲▲▲ 黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】心聲功能樣式 ▼▼▼ */

/* 1. 跳動的心動畫 */
@keyframes heartbeat {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
}
#char-heart-btn svg {
    animation: heartbeat 1.5s infinite ease-in-out;
}

/* 2. 心聲面板主內容樣式 (已修復) */
#inner-voice-avatar-wrapper::after {
    content: '';
    position: absolute;
    top: -3px;
    left: -3px;
    right: -3px;
    bottom: -3px;
    border: 1.5px solid transparent; /* 默認是透明邊框，看不見 */
    border-radius: 50%;
    pointer-events: none;
    transition: border-color 0.2s ease-in-out; /* 添加平滑過渡 */
}
/* 【核心】僅當沒有頭像框時(.has-border)，才顯示紅線 */
#inner-voice-avatar-wrapper.has-border::after {
    border-color: #ff8a80; /* 你想要的紅色輪廓線 */
}

#inner-voice-content-area p {
    white-space: pre-wrap; /* 讓分行符號和空格生效 */
    word-break: break-word; /* 防止長單詞溢出 */
}

/* 3. 歷史記錄面板樣式 */
.inner-voice-history-item {
    background-color: #fff;
    margin: 10px;
    padding: 12px;
    border-radius: 8px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.08);
}
.history-item-timestamp {
    font-size: 11px;
    color: #999;
    border-bottom: 1px solid #eee;
    padding-bottom: 8px;
    margin-bottom: 8px;
}
.history-item-content p {
    margin: 0 0 8px 0;
    font-size: 13px;
    line-height: 1.5;
    color: #444;
}
.history-item-content strong {
    font-size: 12px;
}
/* ▲▲▲ 心聲功能樣式結束 ▲▲▲ */
/* 【全新】心聲歷史記錄單條刪除按鈕樣式 */
.inner-voice-history-item {
    position: relative; /* 讓刪除按鈕可以相對於它定位 */
}

.history-item-delete-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    background-color: #f0f0f0;
    color: #888;
    border: none;
    cursor: pointer;
    font-size: 18px;
    line-height: 24px;
    text-align: center;
    transition: all 0.2s ease;
}

.history-item-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}
/* ▼▼▼ 在這裡開始複製：【主題色版】可愛圓潤按鈕樣式 ▼▼▼ */

/* --- 1. 再次設置通用的“可愛基礎” --- */
#save-theme-btn,
#save-as-new-theme-btn,
#export-theme-btn,
#import-theme-btn,
#rename-theme-btn,
#delete-theme-btn {
    border: none;
    border-radius: 25px; /* 可愛的膠囊形狀 */
    padding: 12px 18px;
    font-weight: 600;
    cursor: pointer;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);
    transition: all 0.2s ease-in-out;
    margin-top: 5px !important;
}

/* --- 2. 可愛的“按下”效果 --- */
#save-theme-btn:active,
#save-as-new-theme-btn:active,
#export-theme-btn:active,
#import-theme-btn:active,
#rename-theme-btn:active,
#delete-theme-btn:active {
    transform: scale(0.97);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

/* --- 3. 【核心修改】為不同功能的按鈕設置配套顏色 --- */

/* “保存” 和 “另存為”：使用全域主題色！ */
#save-theme-btn,
#save-as-new-theme-btn {
    background-color: var(--accent-color); /* 這就是你的主題色！ */
    color: white;
}

/* “匯出”、“導入”、“重命名”：使用柔和的次要樣式 */
#export-theme-btn,
#import-theme-btn,
#rename-theme-btn {
    background-color: #f0f2f5;           /* 淡淡的灰色背景 */
    color: var(--accent-color);          /* 文字使用主題色 */
    border: 1px solid var(--accent-color); /* 再加一個主題色的邊框，更精緻 */
}

/* “刪除”按鈕：還是用可愛的粉紅色來提醒，防止誤觸 */
#delete-theme-btn {
    background-color: #ffdde5; /* 淡淡的櫻花粉背景 */
    color: #ff3b30;           /* 文字用醒目的紅色 */
    border: 1px solid #ffc2d1;
}

/* --- 4. 滑鼠放到不同按鈕上時的顏色變化 --- */
#save-theme-btn:hover,
#save-as-new-theme-btn:hover {
    opacity: 0.85; /* 主題色按鈕變淡一點點 */
}

#export-theme-btn:hover,
#import-theme-btn:hover,
#rename-theme-btn:hover {
    background-color: #e9ecef; /* 次要按鈕背景加深一點點 */
}

#delete-theme-btn:hover {
    background-color: #ffc2d1; /* 刪除按鈕背景加深一點點 */
}

/* ▲▲▲ 複製到這裡結束 ▲▲▲ */
/* ▼▼▼ 請將這段新CSS黏貼到 <style> 的末尾 ▼▼▼ */
.action-icon.summon-npc svg {
    stroke-width: 1.5; /* 讓圖示線條稍微粗一點，更清晰 */
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 請用下面這【一整塊帶有詳細注釋】的代碼，完整替換掉你舊的微博主頁佈局CSS ▼▼▼ */

/* 1. 個人主頁的滾動容器 (保持不變) */
#weibo-profile-page {
    flex-grow: 1;
    overflow-y: auto;
    background-color: #f0f2f5;
}

/* 2. 頭部容器：負責背景圖，並為下方內容留出空間 */
.weibo-profile-header {
    position: relative;
    height: 240px;
    /* 
      ★★★ 手動調整區：微博內容與上方區域的【上下間距】 ★★★
      這個值決定了你的第一條微博，和上方個人資訊區域的距離。
      - 數值越大，間距越大，微博內容離得越遠。
      - 數值越小，間距越小，微博內容離得越近。
      我已將它從 90px 減小到了 20px，你可以根據喜好再微調。
    */
    margin-bottom: -5px;/* ★ 修改這裡 ★ */
}

/* 3. 背景圖樣式 (保持不變) */
.weibo-background {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
}

/* 4. 頭像容器：實現懸浮效果的核心 */
.weibo-avatar-container {
    position: absolute;
    z-index: 3;
    width: 80px;
    height: 80px;
    border: 3px solid white;
    border-radius: 50%;
    box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    transform: none;

    /* ★★★ 手動調整區1: 頭像位置 (左右 + 上下) ★★★ */

    /* --- 左右位置 --- */
    /* 數值越大，越往右。數值越小，越往左。*/
    left: 15px; /* ★ 修改這裡 */

    /* --- 上下位置 --- */
    /* 數值越小 (比如 -50px), 越往下。數值越大 (比如 -30px), 越往上。*/
    bottom: 50px; /* ★ 修改這裡 */
}

.weibo-avatar {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
}


/* 5. 昵稱和職業資訊 */
/* ★★★ 手動調整區2: 昵稱位置 (左右 + 上下) ★★★ */
.weibo-nickname {
    position: absolute;
    z-index: 2;
    color: #1f1f1f;
    text-shadow: none;
    font-size: 18px;
    font-weight: 600;

    /* --- 左右位置 --- */
    /* 數值越大，越往右。數值越小，越往左。*/
    left: 35px; /* ★ 修改這裡 */

    /* --- 上下位置 --- */
    /* 數值越小 (比如 -60px), 越往下。數值越大 (比如 -50px), 越往上。*/
    bottom: 30px; /* ★ 修改這裡 */
}

/* ▼▼▼ 用這塊新CSS替換掉舊的 ▼▼▼ */
#weibo-user-profession-display {
    position: absolute;
    left: 35px;          /* 修改：從 left 改為 right，讓它靠右對齊 */
    bottom: -5px;        /* 修改：調整垂直位置，在頭像下方 */
    z-index: 2;
    font-size: 13px;
    color: #8a8a8a;
    text-shadow: none;
    text-align: right;    /* 新增：讓文字本身也靠右對齊，更美觀 */
    cursor: pointer;      /* 新增：滑鼠放上去時顯示為小手形狀 */
}








/* 6. 關注/粉絲/微博資料 */
/* ★★★ 手動調整區3: 關注/粉絲/微博 位置 (左右 + 上下) ★★★ */
.weibo-stats {
    position: absolute;
    z-index: 2;
    display: flex;
    gap: 20px;

    /* --- 左右位置 --- */
    /* 數值越大，越往右。數值越小，越往左。*/
    left: 35px; /* ★ 修改這裡 */

    /* --- 上下位置 --- */
    /* 數值越小 (比如 -90px), 這行資料越往下。數值越大 (比如 -70px), 越往上。*/
    bottom: 15px; /* ★ 修改這裡 */
}


/* 7. 單個資料項目樣式 (保持不變) */
.weibo-stat-item {
    display: flex;
    flex-direction: row;
    align-items: baseline;
    gap: 5px;
}
.weibo-stat-number {
    font-size: 14px;
    font-weight: 600;
    color: #333;
    text-shadow: none;
}
.weibo-stat-label {
    font-size: 13px;
    color: #888;
    text-shadow: none;
}

/* 8. 微博Feed列表 (保持不變) */
#my-weibo-feed-list {
    padding-top: 15px;
}

/* ▲▲▲ 微博樣式替換結束 ▲▲▲ */



/* ▼▼▼ 【全新】微博頁面框架和底部導航樣式 ▼▼▼ */
#weibo-screen {
    display: flex;
    flex-direction: column;
}
.weibo-view {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: none; /* 預設隱藏所有頁面 */
    flex-direction: column;
    background-color: #f0f2f5;
}
.weibo-view.active {
    display: flex; /* 只顯示啟動的頁面 */
}
/* ▼▼▼ 【佈局統一修復版】用這塊代碼完整替換掉你舊的 #weibo-bottom-nav 樣式 ▼▼▼ */
#weibo-bottom-nav {
    /* --- 核心修改 --- */
    position: absolute; /* 1. 改為絕對定位，讓它浮動起來 */
    bottom: 0;          /* 2. 固定在底部 */
    left: 0;            /* 3. 左側對齊 */
    width: 100%;        /* 4. 寬度撐滿 */
    
    /* --- 其他樣式保持不變 --- */
    z-index: 15;
    display: flex;
    border-top: 1px solid var(--border-color);
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    padding-bottom: env(safe-area-inset-bottom);
}
/* ▲▲▲ 替換結束 ▲▲▲ */

.weibo-nav-item {
    flex: 1;
    text-align: center;
    padding: 12px 0;
    font-size: 14px;
    color: var(--text-secondary);
    cursor: pointer;
}
.weibo-nav-item.active {
    color: var(--accent-color);
    font-weight: 600;
}
/* ▲▲▲ 微博框架樣式結束 ▲▲▲ */

/* ▼▼▼ 【全新】微博關注清單彈窗樣式 ▼▼▼ */
#weibo-following-list-container {
    height: 100%;
    overflow-y: auto; /* 【核心】內容超出時顯示垂直捲動條 */
}
.weibo-following-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    border-bottom: 1px solid #f0f0f0;
}
.weibo-following-item:last-child {
    border-bottom: none;
}
.weibo-following-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 12px;
    object-fit: cover;
}
.weibo-following-name {
    font-weight: 500;
    color: var(--text-primary);
}
/* ▲▲▲ 關注清單樣式結束 ▲▲▲ */

/* ▼▼▼ 【全新】讓個人主頁可編輯的元素有點擊手勢 ▼▼▼ */
#weibo-avatar-img,
#weibo-nickname,
#weibo-posts-item, /* 我們讓整個“微博”區域可點擊 */
#weibo-fans-item,  /* 整個“粉絲”區域可點擊 */
#weibo-background-img /* 背景圖也可點擊 */ {
    cursor: pointer;
    transition: opacity 0.2s;
}
#weibo-avatar-img:hover,
#weibo-nickname:hover,
#weibo-posts-item:hover,
#weibo-fans-item:hover,
#weibo-background-img:hover {
    opacity: 0.8; /* 滑鼠放上去時變淡一點，給用戶回饋 */
}
/* ▲▲▲ 點擊手勢樣式結束 ▲▲▲ */
/* ▼▼▼ 請用這塊新代碼替換舊的 #weibo-page-container 樣式 ▼▼▼ */
#weibo-page-container {
    flex-grow: 1;
    position: relative;
    overflow: hidden;
    /* 核心修改：為絕對定位的巡覽列預留出空間，防止內容被遮擋 */
    /* 50px 是巡覽列的大致高度，env() 用於適配iPhone底部的小黑條 */
    padding-bottom: calc(50px + env(safe-area-inset-bottom));
    box-sizing: border-box; /* 確保內邊距被正確計算在內 */
}
/* ▲▲▲ 替換結束 ▲▲▲ */

/* ▲▲▲ 替換結束 ▲▲▲ */

/* 確保個人主頁的內容可以滾動 */
#weibo-profile-page {
    overflow-y: auto;
    height: 100%;
}
/* ▲▲▲ 修復CSS結束 ▲▲▲ */

/* ▲▲▲ 修復CSS結束 ▲▲▲ */
/* ▼▼▼ 【最終修復】提升微博關注列表彈窗的層級 ▼▼▼ */
#weibo-following-modal {
    z-index: 1001; /* 確保它能覆蓋在其他頁面之上 */
}
/* ▲▲▲ 修復結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的微博帖子樣式，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* ▼▼▼ 把這一整塊全新的微博帖子樣式，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* === 微博帖子專屬樣式 (已和動態分離) === */
/* === 微博帖子專屬樣式 (圓角卡片版) === */
.weibo-post-item {
    background-color: var(--secondary-bg);
    border-radius: 12px; /* ★ 修改這裡，增加圓角，讓它變得圓潤可愛 */
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.06); /* ★ 新增柔和的陰影，營造卡片懸浮感 */
    /* ★ 舊的 border-bottom 分割線已經被移除了，現在由父容器的 gap 屬性負責間距 */
}
.weibo-post-item:last-child {
    /* 這個規則現在也不需要了，但保留著也沒關係 */
    border-bottom: none;
}

.weibo-post-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 12px;
}

.weibo-post-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    object-fit: cover;
}

.weibo-post-info {
    display: flex;
    flex-direction: column;
}

.weibo-post-nickname {
    font-weight: 600;
    font-size: 15px;
    color: var(--text-primary);
}

.weibo-post-timestamp {
    font-size: 12px;
    color: var(--text-secondary);
}

.weibo-post-content {
    font-size: 15px; /* 微博正文字體稍大 */
    line-height: 1.7;
    color: #333;
    white-space: pre-wrap;
    word-break: break-word;
    margin-bottom: 10px;
}

.weibo-post-image {
    width: 100%;
    max-height: 400px;
    object-fit: cover;
    border-radius: 8px;
    margin-bottom: 10px;
}

.weibo-post-footer {
    border-top: 1px solid #f0f0f0;
    padding-top: 8px;
    margin-top: 10px;
}

.weibo-post-actions {
    display: flex;
    justify-content: space-around; /* 三個按鈕均分空間 */
    margin-bottom: 10px;
}

.weibo-action-btn {
    display: flex;
    align-items: center;
    gap: 6px;
    color: var(--text-secondary);
    cursor: pointer;
    font-size: 14px;
}
.weibo-action-btn.liked {
    color: #ff5252; /* 點贊後變紅 */
}
.weibo-action-btn svg {
    width: 20px;
    height: 20px;
}

.weibo-comments-container {
    padding: 10px;
    background-color: #f7f7f7;
    border-radius: 8px;
    font-size: 13px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-bottom: 10px;
}

.weibo-comment-item .weibo-commenter-name {
    font-weight: 600;
    color: var(--accent-color);
}
.weibo-comment-item .weibo-comment-reply-tag {
    color: var(--text-secondary);
    margin: 0 4px;
}

.weibo-comment-input-area {
    display: flex;
    gap: 8px;
}

.weibo-comment-input {
    flex-grow: 1;
    border: none;
    background-color: #f0f2f5;
    border-radius: 14px;
    padding: 8px 12px;
    font-size: 13px;
}

.weibo-comment-send-btn {
    background-color: var(--accent-color);
    color: white;
    border: none;
    border-radius: 14px;
    padding: 0 15px;
    font-size: 13px;
    cursor: pointer;
}
/* ▲▲▲ 微博專屬樣式結束 ▲▲▲ */
/* ▲▲▲ 黏貼結束 ▲▲▲ */
/* ▼▼▼ 把這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */

/* 單條評論的容器，現在需要相對定位，並為刪除按鈕留出空間 */
.weibo-comment-item {
    position: relative;
    padding-right: 25px; 
}

/* 評論刪除按鈕的樣式 */
.comment-delete-btn {
    position: absolute;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    line-height: 22px;
    text-align: center;
    border-radius: 50%;
    color: var(--text-secondary);
    background-color: transparent; /* 背景透明 */
    border: none; /* 無邊框 */
    font-size: 20px; /* 放大"×"號 */
    cursor: pointer;
    transition: all 0.2s ease;
    opacity: 0; /* 默認隱藏 */
}

/* 滑鼠懸停在整條評論上時，才顯示刪除按鈕 */
.weibo-comment-item:hover .comment-delete-btn {
    opacity: 1;
}

/* 滑鼠懸停在刪除按鈕上時，給一點回饋效果 */
.comment-delete-btn:hover {
    background-color: #f0f0f0;
    color: #ff3b30; /* 變紅色 */
}

#phone-screen.dark-mode .comment-delete-btn:hover {
    background-color: #3a3a3c; /* 夜間模式下的懸停背景色 */
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的微博熱搜樣式，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* === 微博熱搜清單樣式 === */
#weibo-hot-search-list {
    background-color: var(--secondary-bg);
}

.hot-search-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
    transition: background-color 0.2s;
}

.hot-search-item:hover {
    background-color: #f5f5f5;
}
#phone-screen.dark-mode .hot-search-item:hover {
    background-color: #2c2c2e;
}

.hot-search-rank {
    width: 30px;
    font-size: 16px;
    font-weight: bold;
    color: var(--text-secondary);
    text-align: center;
    flex-shrink: 0;
}
/* 前三名用不同的顏色突出顯示 */
.hot-search-item[data-rank="1"] .hot-search-rank { color: #f44336; }
.hot-search-item[data-rank="2"] .hot-search-rank { color: #ff9800; }
.hot-search-item[data-rank="3"] .hot-search-rank { color: #ffc107; }

.hot-search-content {
    flex-grow: 1;
    display: flex;
    align-items: center;
    gap: 8px;
    overflow: hidden;
}

.hot-search-topic {
    font-size: 15px;
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.hot-search-tag {
    font-size: 10px;
    color: white;
    padding: 2px 6px;
    border-radius: 4px;
    flex-shrink: 0;
}
.hot-search-tag.hot { background-color: #f44336; }
.hot-search-tag.new { background-color: #ff9800; }
.hot-search-tag.rec { background-color: #2196f3; }

/* ▲▲▲ 微博熱搜樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* 1. 讓帖子頭部成為刪除按鈕的定位參考點 */
.weibo-post-header {
    position: relative; /* 關鍵！ */
}

/* 2. 刪除按鈕的樣式 */
.weibo-post-delete-btn {
    position: absolute; /* 絕對定位，讓它浮動起來 */
    top: 10px;          /* 距離頂部10圖元 */
    right: 15px;         /* 距離右側15圖元 */
    width: 26px;
    height: 26px;
    background-color: rgba(0, 0, 0, 0.08); /* 半透明的背景 */
    color: var(--text-secondary); /* 使用全域的次要文字顏色 */
    border: none;
    border-radius: 50%; /* 圓形 */
    font-size: 20px;    /* "×"號的大小 */
    line-height: 26px;  /* 讓"×"號垂直居中 */
    text-align: center;
    cursor: pointer;
    transition: all 0.2s ease; /* 添加平滑的動畫效果 */
}

/* 滑鼠放上去時，變成醒目的紅色 */
.weibo-post-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
    transform: scale(1.1); /* 輕微放大 */
}

/* ▲▲▲ 黏貼結束 ▲▲▲ */
/* ▼▼▼ 【微博佈局終極修復】真正解決所有頁面滾動不到底的問題 ▼▼▼ */

/* 1. 外層容器不再需要“墊子”，它的任務只是撐開空間 */
#weibo-page-container {
    flex-grow: 1;
    position: relative;
    overflow: hidden; /* 保持不變 */
}

/* 2. 【核心】把“墊子”加到真正滾動的列表自己身上！ */
#weibo-profile-page,
#weibo-following-feed-list,
#weibo-hot-search-list,
#weibo-plaza-feed-list,
#weibo-hottopic-feed-list {
    flex-grow: 1;
    overflow-y: auto;
    
    /* 
       魔法就在這裡！我們為每個列表的底部，
       都加上一個和巡覽列一樣高的內邊距（“墊子”）。
       這樣列表滾動到底時，最後一條評論就會被這個內邊距向上推，
       正好顯示在底部巡覽列的上方，不會再被擋住了！
    */
    padding-bottom: calc(50px + env(safe-area-inset-bottom));
    box-sizing: border-box; /* 確保內邊距被正確計算 */
}

/* ▲▲▲ 修復結束 ▲▲▲ */

/* ▼▼▼ 把這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */
#post-visibility-groups label {
    display: block;
    padding: 5px 0;
}
#post-visibility-groups input {
    margin-right: 8px;
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 【微博佈局終極修復】解決所有頁面滾動不到底的問題 ▼▼▼ */

/* 1. 移除外層容器上錯誤的多餘“墊子” */
#weibo-page-container {
    padding-bottom: 0 !important;
}

/* 2. 【核心】把“墊子”（padding-bottom）加到真正滾動的列表自己身上！*/
#weibo-profile-page,
#weibo-following-feed-list,
#weibo-hot-search-list,
#weibo-plaza-feed-list,
#weibo-hottopic-feed-list {
    /* 
       魔法就在這裡！我們為每個列表的底部，
       都加上一個和巡覽列一樣高的內邊距（“墊子”）。
       calc(50px + env(safe-area-inset-bottom)) 會自動計算巡覽列高度和iPhone底部安全區高度。
    */
    padding-bottom: calc(50px + env(safe-area-inset-bottom)) !important;
    box-sizing: border-box; /* 確保內邊距被正確計算 */
}
/* ▼▼▼ 【問題1修復】微博編輯資料按鈕強制顯示 ▼▼▼ */
/* 請將這段代碼黏貼到 <style> 標籤的最末尾 */
#edit-weibo-profile-btn {
    display: flex !important; /* 強制顯示為flex容器 */
    align-items: center;
    justify-content: center;
    color: var(--accent-color) !important; /* 強制使用主題色 */
}
#edit-weibo-profile-btn svg {
    stroke: currentColor !important; /* 確保SVG圖示繼承上面的顏色 */
}
/* ▲▲▲ 修復結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 的末尾 ▼▼▼ */

/* 1. 讓關注列表的每一行都能容納新按鈕 */
.weibo-following-item {
    align-items: center; /* 確保頭像、名字和按鈕垂直居中對齊 */
}

/* 2. 這是你新增的“操作”按鈕的樣式 */
.weibo-action-trigger-btn {
    margin-left: auto; /* 核心：讓按鈕自動靠到最右邊 */
    padding: 5px 8px;
    cursor: pointer;
    border-radius: 50%; /* 圓形按鈕，更美觀 */
    transition: background-color 0.2s;
}
.weibo-action-trigger-btn:hover {
    background-color: #e0e0e0;
}
#phone-screen.dark-mode .weibo-action-trigger-btn:hover {
    background-color: #3a3a3c;
}
.weibo-action-trigger-btn svg {
    width: 20px;
    height: 20px;
    stroke: var(--text-secondary); /* 圖示顏色跟隨主題 */
    display: block; /* 解決一些對齊問題 */
}

/* 3. 為操作彈窗裡的選項按鈕美化一下 */
#weibo-action-type-select label {
    display: block;
    padding: 8px;
    border-radius: 6px;
    transition: background-color 0.2s;
}
#weibo-action-type-select label:hover {
    background-color: #f0f2f5;
}
#phone-screen.dark-mode #weibo-action-type-select label:hover {
    background-color: #2c2c2e;
}

/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【彈窗層級修復】黏貼這段代碼到樣式末尾 ▼▼▼ */
#weibo-action-modal {
    z-index: 1002; /* 這個值比關注列表(1001)更高，就不會被蓋住了 */
}
/* ▼▼▼ 【全新】論壇/小組功能樣式 ▼▼▼ */

/* 1. 小組清單卡片樣式 */
.forum-group-item {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
}
.forum-group-item:hover {
    transform: translateY(-5px);
    box-shadow: 0 6px 15px rgba(0,0,0,0.12);
}
.forum-group-icon {
    font-size: 28px;
    margin-bottom: 10px;
}
.forum-group-name {
    font-weight: 600;
    font-size: 15px;
    margin-bottom: 5px;
}
.forum-group-desc {
    font-size: 12px;
    color: var(--text-secondary);
}

/* 2. 帖子清單項樣式 */
.forum-post-item {
    padding: 15px;
    border-bottom: 1px solid var(--border-color);
    cursor: pointer;
}
.forum-post-item:hover {
    background-color: #f5f5f5;
}
#phone-screen.dark-mode .forum-post-item:hover {
    background-color: #2c2c2e;
}
.post-item-title {
    font-weight: 500;
    font-size: 16px;
    margin-bottom: 8px;
}
.post-item-meta {
    font-size: 12px;
    color: var(--text-secondary);
    display: flex;
    justify-content: space-between;
}

/* ▼▼▼ 請用這塊新代碼替換舊的 #post-detail-content 樣式 ▼▼▼ */
#post-detail-content {
    flex-grow: 1;      /* 核心：讓它佔據所有可用的垂直空間 */
    overflow-y: auto;  /* 核心：如果內容超出，則允許自身滾動 */
    display: flex;
    flex-direction: column;
    padding: 20px;     /* 保留舒適的內邊距 */
    /* 不再需要為絕對定位的輸入框留出額外的padding-bottom */
}
/* ▲▲▲ 替換結束 ▲▲▲ */
.post-detail-header h1 {
    font-size: 22px;
    margin: 0 0 10px 0;
}
.post-detail-meta {
    font-size: 13px;
    color: var(--text-secondary);
    margin-bottom: 20px;
}
.post-detail-body {
    font-size: 16px;
    line-height: 1.7;
    white-space: pre-wrap;
    word-break: break-word;
    padding-bottom: 20px;
    border-bottom: 1px solid var(--border-color);
}
.post-comments-section {
    padding-top: 20px;
}
.post-comments-section h3 {
    font-size: 16px;
    margin: 0 0 15px 0;
    border-left: 3px solid var(--accent-color);
    padding-left: 10px;
}
.post-comment-item {
    padding: 12px 0;
    border-bottom: 1px solid #f0f0f0;
}
#phone-screen.dark-mode .post-comment-item {
    border-bottom-color: #2c2c2e;
}
.comment-author {
    font-weight: 600;
    color: var(--accent-color);
    margin-bottom: 5px;
}
.comment-content {
    font-size: 14px;
    line-height: 1.6;
}

/* 4. 帖子頁底部輸入框 */
/* ▼▼▼ 請用這塊新代碼替換舊的 #post-comment-input-area 樣式 ▼▼▼ */
#post-comment-input-area {
    /* 
      我們移除了 position: absolute; 和相關的 bottom, left 屬性，
      讓它從一個“浮動層”變回一個正常的塊級元素，自然地排在內容下方。
      其他的樣式會從 .chat-input-area 類繼承，無需擔心。
    */
    width: 100%;
    box-sizing: border-box;
}
/* ▲▲▲ 替換結束 ▲▲▲ */


/* ▲▲▲ 論壇樣式結束 ▲▲▲ */
/* ▼▼▼ 請將這段【全新】的論壇美化CSS，黏貼到<style>標籤的末尾 ▼▼▼ */

/* 1. 美化帖子詳情頁底部的評論輸入區域 */
#post-comment-input-area {
    padding: 10px 15px; /* 增加內邊距，讓它不貼邊 */
    background-color: rgba(247, 247, 247, 0.9);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    border-top: 1px solid var(--border-color);
    /* 適配iPhone底部安全區 */
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
}

/* 2. 【核心】美化評論輸入框本身 */
#post-comment-input-area #post-comment-input {
    background-color: #f0f2f5; /* 淺灰色背景，更有層次感 */
    border: none;
    border-radius: 18px; /* 圓角，更柔和 */
    padding: 10px 15px;
    font-size: 14px;
    resize: none; /* 禁止用戶拖拽大小 */
}

/* 夜間模式適配 */
#phone-screen.dark-mode #post-comment-input-area #post-comment-input {
    background-color: #2c2c2e;
}

/* 3. 美化發送按鈕 */
#post-comment-input-area #send-post-comment-btn {
    height: 36px;
    border-radius: 18px; /* 和輸入框保持一致的圓角 */
    padding: 0 20px;
}

/* 4. 【新增】AI生成評論按鈕的樣式 */
.generate-comments-container {
    padding: 10px 20px 0 20px;
    border-bottom: 8px solid #f0f2f5;
}

#phone-screen.dark-mode .generate-comments-container {
    border-bottom-color: #000;
}

#generate-forum-comments-btn {
    width: 100%;
    padding: 10px;
    border: none;
    border-radius: 8px;
    background-color: #e9f5ff;
    color: var(--accent-color);
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s;
}

#generate-forum-comments-btn:hover {
    background-color: #d4eaff;
}
/* ▲▲▲ 論壇美化CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】論壇帖子/評論頭像與樓層樣式 ▼▼▼ */

/* 1. 帖子作者區域：使用flex佈局讓頭像和名字並排 */
#post-detail-content .post-detail-header {
    display: flex;
    align-items: center;
    gap: 12px; /* 頭像和右側信息的間距 */
    padding-bottom: 20px;
    border-bottom: 1px solid var(--border-color);
    margin-bottom: 20px;
}

/* 2. 帖子作者的頭像樣式 */
.post-author-avatar {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0; /* 防止被壓縮 */
}

/* 3. 包裹作者名字和時間的容器 */
.post-author-info {
    display: flex;
    flex-direction: column;
}

/* 4. 移除舊的標題和meta外邊距，因為flex佈局會處理間距 */
#post-detail-content .post-detail-header h1,
#post-detail-content .post-detail-meta {
    margin: 0;
}
#post-detail-content .post-detail-header h1 {
    font-size: 18px; /* 標題可以稍微小一點，更協調 */
    margin-bottom: 4px;
}

/* 5. 評論區每一條評論的佈局 */
.post-comment-item {
    display: flex;
    gap: 10px; /* 頭像和右側內容的間距 */
    padding: 12px 0;
    border-bottom: 1px solid #f0f0f0;
}
#phone-screen.dark-mode .post-comment-item {
    border-bottom-color: #2c2c2e;
}

/* 6. 評論者的小頭像 */
.comment-avatar-small {
    width: 35px;
    height: 35px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}

/* 7. 包裹評論所有文字內容的容器 */
.comment-details {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
}

/* 8. 評論的頭部：包含名字和樓層 */
.comment-header-line {
    display: flex;
    justify-content: space-between; /* 讓名字靠左，樓層靠右 */
    align-items: center;
    margin-bottom: 5px;
}

/* 9. 評論樓層號的樣式 */
.comment-floor {
    font-size: 12px;
    color: var(--text-secondary);
    font-weight: 500;
}

/* 10. 移除舊的評論作者外邊距 */
.post-comment-item .comment-author {
    margin-bottom: 0;
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 這是修復論壇評論區寬度問題的新增代碼 ▼▼▼ */
#post-comment-input-area #post-comment-input {
    flex-grow: 1; /* ★★★ 核心代碼就是這行！讓輸入框自動伸展，占滿所有可用寬度 ★★★ */
    
    /* 下面這些是美化樣式，讓它和其他輸入框風格統一，這次沒有修改高度哦 */
    border: none;
    background-color: #f0f2f5; 
    border-radius: 18px;       
    padding: 10px 15px;        
    font-size: 14px;
    resize: none;             
    box-sizing: border-box;    
}

/* 夜間模式適配 */
#phone-screen.dark-mode #post-comment-input-area #post-comment-input {
    background-color: #2c2c2e;
}
/* ▲▲▲ 新增代碼結束 ▲▲▲ */
/* ▼▼▼ 用這一整塊全新的CSS，替換掉你舊的所有塔羅牌相關CSS ▼▼▼ */

/* 1. 占卜結果彈窗內的樣式（純文字版） */
#tarot-result-display {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
}
.tarot-result-question {
    font-size: 14px;
    font-weight: 500;
    color: var(--text-secondary);
    background-color: #f0f2f5;
    padding: 8px 12px;
    border-radius: 8px;
    width: 95%;
    text-align: center;
}
#phone-screen.dark-mode .tarot-result-question {
    background-color: #2c2c2e;
}
.tarot-spread-container {
    width: 100%;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 10px;
}
.tarot-card-wrapper {
    background-color: #fff;
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 8px;
    min-width: 120px;
    text-align: center;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
#phone-screen.dark-mode .tarot-card-wrapper {
    background-color: #1c1c1e;
}
.tarot-card-position {
    font-size: 12px;
    font-weight: 600;
    color: var(--accent-color);
    margin-bottom: 4px;
}
.tarot-card-name {
    font-size: 14px;
}

/* 3. 歷史記錄樣式 (保持不變) */
#tarot-history-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
}
.tarot-history-item {
    background-color: #f9f9f9;
    border-radius: 8px;
    padding: 12px;
    position: relative;
    border: 1px solid var(--border-color);
}
#phone-screen.dark-mode .tarot-history-item {
    background-color: #2c2c2e;
}
.tarot-history-item .question { font-weight: 600; margin-bottom: 8px; }
.tarot-history-item .details { font-size: 13px; color: var(--text-secondary); white-space: pre-wrap; }
.tarot-history-delete-btn {
    position: absolute;
    top: 5px; right: 5px; width: 24px; height: 24px;
    background-color: #e0e0e0; color: #888; border-radius: 50%;
    border: none; cursor: pointer; font-size: 18px; line-height: 24px; text-align: center;
}
#phone-screen.dark-mode .tarot-history-delete-btn {
    background-color: #3e3e42;
}
/* ▼▼▼ 第1步：從這裡開始複製替換 ▼▼▼ */

#lovers-space-screen {
    background-color: #f0f2f5;   /* 保留一個備用背景色 */
    background-size: cover;      /* 背景圖覆蓋整個區域 */
    background-position: center; /* 背景圖居中顯示 */
    background-repeat: no-repeat;/* 背景圖不重複 */
}

/* 頭部 */
#ls-header {
    height: 220px;
    position: relative;
    /* 【核心修改】移除了 background-size 和 background-position */
    color: white;
    flex-shrink: 0;
    background-color: transparent; /* 【核心修改】讓頭部背景變透明，以顯示下方的全屏背景 */
}

/* ▲▲▲ 第1步：複製替換到這裡結束 ▲▲▲ */

/* --- 【最終修復版】修復情侶空間頂部按鈕無法點擊的問題 --- */
/* --- 【最終修復版】修復遮罩層攔截點擊的問題 --- */

.ls-header-overlay {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: linear-gradient(to bottom, rgba(0,0,0,0.4), transparent, rgba(0,0,0,0.2));
    
    /* ▼▼▼ 核心修復：讓這個遮罩層對滑鼠事件“透明”！ ▼▼▼ */
    pointer-events: none; 
    /* ▲▲▲ 修復結束 ▲▲▲ */
}


/* --- 【已修復】情侶空間頂部欄層級問題 --- */

.ls-header-top-bar {
    position: relative;
    z-index: 3; /* ★★★ 核心修改：將層級從 2 提升到 3 ★★★ */
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 15px;
    padding-top: calc(15px + env(safe-area-inset-top));
}

#ls-char-name {
    font-size: 18px;
    font-weight: 600;
}
#ls-switch-char-btn { font-size: 16px; }

.ls-header-avatars {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 15px;
    z-index: 2;
}
.ls-header-avatars img {
    width: 65px;
    height: 65px;
    border-radius: 50%;
    border: 2px solid white;
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
}
.ls-header-avatars .heart-icon {
    font-size: 28px;
    color: #ff4d6d;
    text-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
}

/* ▼▼▼ 請用這【一整塊】全新的代碼，完整替換舊的 #ls-tab-bar 和 .ls-tab-item 樣式 ▼▼▼ */

/* 頁簽欄 (V2 - 懸浮撐滿版) */
/* ▼▼▼ 請用這塊【懸浮膠囊最終版】代碼，完整替換掉你舊的 #ls-tab-bar 樣式 ▼▼▼ */
#ls-tab-bar {
    display: flex;
    flex-shrink: 0;
    position: relative;
    z-index: 5;

    /* --- 核心修改在這裡 --- */
    /* 1. 使用 margin 實現上下左右的邊距，營造懸浮感 */
   margin: -20px 5px 10px 5px; /* 把左右的 15px 改成了 5px */
    
    /* 2. 為所有四個角都設置圓角，形成可愛的膠囊形狀 */
    border-radius: 25px; 

    background-color: var(--secondary-bg);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1); /* 陰影可以讓懸浮感更強 */
}
/* ▲▲▲ 替換結束 ▲▲▲ */

/* 單個頁簽項目 (V2) */
.ls-tab-item {
    flex: 1;
    text-align: center;
    /* 核心修改：padding 從 12px 增加到 15px，讓巡覽列【拉長一點】(更高) */
    padding: 15px 0;
    font-weight: 500;
    color: var(--text-secondary);
    cursor: pointer;
    position: relative;
    /* 新增：為圖示的縮放和顏色變化添加平滑過渡 */
    transition: color 0.2s ease;
}

/* 啟動狀態的頁簽 (V2) */
.ls-tab-item.active {
    color: var(--accent-color);
}

/* 啟動狀態的底線指示器 (保持不變) */
.ls-tab-item.active::after {
    content: '';
    position: absolute;
    bottom: 8px; /* 微調位置以適應更高的巡覽列 */
    left: 50%;
    transform: translateX(-50%);
    width: 28px;
    height: 3px;
    background-color: var(--accent-color);
    border-radius: 1.5px;
}

/* ▲▲▲ 替換結束 ▲▲▲ */


/* ▼▼▼ 【全新】這是為SVG圖示新增的樣式，請把它也黏貼到<style>裡 ▼▼▼ */
.ls-tab-item svg {
    width: 24px;
    height: 24px;
    /* 為圖示的大小和粗細變化添加平滑過渡 */
    transition: all 0.2s ease-in-out;
}

/* 啟動狀態的圖示，會變得更粗、更大一點，非常醒目 */
.ls-tab-item.active svg {
    stroke-width: 2.5;
    transform: scale(1.1);
}
/* ▲▲▲ 新增樣式結束 ▲▲▲ */

/* 內容區域 */
#ls-content-area {
    flex-grow: 1;
    position: relative;
    overflow: hidden;
}
.ls-view {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    overflow-y: auto;
    display: none;
    padding: 15px;
    box-sizing: border-box;
}
.ls-view.active {
    display: block;
}

/* 浮動添加按鈕 */
/* ▼▼▼ 請用這塊【終極居中修復版】代碼，替換舊的 .ls-fab-btn 樣式 ▼▼▼ */
/* ▼▼▼ 這是SVG適配版的最終代碼 ▼▼▼ */
.ls-fab-btn {
    position: fixed;
    bottom: calc(30px + env(safe-area-inset-bottom));
    right: 30px;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: var(--accent-color);
    color: white;
    border: none;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    cursor: pointer;
    z-index: 10;
    
    /* 依然使用Flexbox來居中SVG圖示 */
    display: flex;
    justify-content: center;
    align-items: center;

    /* 移除所有與字體相關的屬性 */
    /* font-size: 28px; (已移除) */
    /* line-height: normal; (已移除) */
}

/* (可選) 如果你覺得SVG有點小或大，可以微調它的大小 */
.ls-fab-btn svg {
    width: 24px;
    height: 24px;
}
/* ▲▲▲ 替換結束 ▲▲▲ */


/* 說說卡片 */
#ls-moments-list {
    display: flex;
    flex-direction: column;
    gap: 15px;
}
/* 說說卡片 */
/* ... */
.ls-moment-card {
    position: relative; /* ★★★ 核心修復：就是加上這一行！ ★★★ */
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.08);
    display: flex;
    gap: 12px;
}
/* ... */

.ls-moment-card .avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    flex-shrink: 0;
}
.ls-moment-card .moment-main {
    display: flex;
    flex-direction: column;
}
.ls-moment-card .author {
    font-weight: 600;
    color: var(--text-primary);
}
.ls-moment-card .content {
    margin-top: 5px;
    font-size: 15px;
    line-height: 1.6;
    white-space: pre-wrap;
    word-break: break-word;
}
.ls-moment-card .timestamp {
    margin-top: 10px;
    font-size: 12px;
    color: var(--text-secondary);
}

/* 相簿清單 */
/* ▼▼▼ 用這塊新樣式替換舊的 #ls-album-list ▼▼▼ */
#ls-album-list {
    display: grid;
    /* 核心修改：從2列變為3列，間距從15px縮小為5px */
    grid-template-columns: repeat(3, 1fr);
    gap: 5px;
}
/* ▲▲▲ 替換結束 ▲▲▲ */
.ls-album-item {
    cursor: pointer;
}
.ls-album-item .cover {
    width: 100%;
    aspect-ratio: 1 / 1;
    background-color: #e9ecef;
    background-size: cover;
    background-position: center;
    border-radius: 8px;
    margin-bottom: 8px;
}
.ls-album-item .name {
    font-weight: 500;
    text-align: center;
}

/* 照片上傳預覽 */
#ls-photo-preview-container {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    margin-bottom: 15px;
}
.ls-photo-preview-item {
    position: relative;
    aspect-ratio: 1 / 1;
}
.ls-photo-preview-item img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 6px;
}
.ls-photo-preview-item .remove-btn {
    position: absolute;
    top: -5px; right: -5px;
    width: 20px; height: 20px;
    background-color: #ff3b30;
    color: white;
    border-radius: 50%;
    border: none;
    line-height: 20px;
    text-align: center;
    cursor: pointer;
}

/* 情書和分享列表 */
.ls-list-item {
    background-color: var(--secondary-bg);
    border-radius: 8px;
    padding: 12px 15px;
    margin-bottom: 10px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    cursor: pointer;
}
.ls-list-item .title {
    font-weight: 500;
    margin-bottom: 5px;
}
.ls-list-item .meta {
    font-size: 12px;
    color: var(--text-secondary);
}
.ls-share-item .share-type {
    display: inline-block;
    padding: 2px 6px;
    font-size: 10px;
    border-radius: 4px;
    margin-right: 8px;
    color: white;
}
.share-type.song { background-color: #28a745; }
.share-type.movie { background-color: #fd7e14; }
.share-type.book { background-color: #6f42c1; }
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* 【核心修復】讓標題絕對居中，不再受兩邊按鈕數量影響 */
#ls-header #ls-char-name {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    width: 60%; /* 限制最大寬度，防止與按鈕重疊 */
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 【新增】頭像和計數器的總容器，負責整體定位 */
.ls-avatar-and-counter-wrapper {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 2;
    display: flex;
    flex-direction: column; /* 讓頭像和計數器垂直排列 */
    align-items: center; /* 水準居中 */
    gap: 10px; /* 頭像和計數器之間的垂直間距 */
}

/* 【修改】移除舊的頭像絕對定位，因為它現在被新容器管理了 */
.ls-header-avatars {
    position: static; /* 改為靜態定位 */
    transform: none;
    bottom: auto;
    left: auto;
    /* 其他樣式（如頭像大小、邊框等）保持不變 */
}

/* 【修改】移除舊的計數器定位樣式，讓它在新容器裡自然排列 */
#ls-days-counter {
    position: static;
    margin-top: 0;
    /* 其他樣式（如字體顏色、陰影等）保持不變 */
}

/* ▲▲▲ 黏貼結束 ▲▲▲ */
/* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */

/* 1. 讓相冊專案成為刪除按鈕的定位參考點 */
.ls-album-item .cover {
    position: relative; /* 關鍵！ */
    overflow: hidden; /* 防止刪除按鈕溢出圓角 */
}

/* 2. 刪除按鈕的樣式 */
.ls-photo-delete-btn {
    position: absolute;
    top: 5px;
    right: 5px;
    width: 24px;
    height: 24px;
    background-color: rgba(0, 0, 0, 0.6);
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 18px;
    line-height: 24px; /* 確保 "×" 垂直居中 */
    text-align: center;
    cursor: pointer;
    opacity: 0; /* 默認隱藏 */
    transition: opacity 0.2s ease;
    z-index: 5; /* 確保在最上層 */
}

/* 3. 滑鼠懸停在封面上時，顯示刪除按鈕 */
.ls-album-item .cover:hover .ls-photo-delete-btn {
    opacity: 1;
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 這是為情侶空間“說說”新增的樣式 ▼▼▼ */

/* 說說卡片底部的互動區（評論輸入、刪除按鈕等） */
.ls-moment-footer {
    margin-top: 12px;
    padding-top: 10px;
    border-top: 1px solid #f0f0f0; /* 和內容區分隔開 */
}

/* 評論列表的容器 */
.ls-moment-comments-container {
    display: flex;
    flex-direction: column;
    gap: 8px; /* 每條評論之間的間距 */
    font-size: 14px;
    margin-bottom: 10px;
}

/* 每一條評論的樣式 */
.ls-comment-item {
    position: relative; /* 為了定位刪除按鈕 */
    padding-right: 25px; /* 給刪除按鈕留出空間 */
    line-height: 1.5;
}

.ls-comment-item .commenter-name {
    font-weight: 600;
    color: var(--accent-color); /* 使用主題色 */
    margin-right: 5px;
}

/* 評論的刪除按鈕 */
.ls-comment-delete-btn {
    position: absolute;
    top: 50%;
    right: 0;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    line-height: 22px;
    text-align: center;
    border-radius: 50%;
    color: var(--text-secondary);
    font-size: 18px;
    cursor: pointer;
    opacity: 0; /* 默認隱藏 */
    transition: all 0.2s ease;
}

/* 滑鼠放上去才顯示刪除按鈕 */
.ls-comment-item:hover .ls-comment-delete-btn {
    opacity: 1;
}
.ls-comment-delete-btn:hover {
    background-color: #f0f0f0;
    color: #ff3b30;
}

/* 評論輸入區域的樣式 */
.ls-comment-input-area {
    display: flex;
    gap: 8px;
    align-items: center;
}

.ls-comment-input-area input {
    flex-grow: 1;
    border: none;
    background-color: #f0f2f5;
    border-radius: 15px;
    padding: 8px 12px;
    font-size: 14px;
}

.ls-comment-input-area button {
    background-color: var(--accent-color);
    color: white;
    border: none;
    border-radius: 15px;
    padding: 8px 15px;
    font-size: 14px;
    cursor: pointer;
    flex-shrink: 0; /* 防止按鈕被壓縮 */
}

/* 說說卡片本身的刪除按鈕 */
.ls-moment-delete-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 24px;
    height: 24px;
    background-color: rgba(0, 0, 0, 0.08);
    color: var(--text-secondary);
    border-radius: 50%;
    border: none;
    cursor: pointer;
    font-size: 18px;
    line-height: 24px;
    text-align: center;
    opacity: 0; /* 默認隱藏 */
    transition: all 0.2s ease;
}
.ls-moment-card:hover .ls-moment-delete-btn {
    opacity: 1; /* 滑鼠放上去才顯示 */
}
.ls-moment-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}

/* ▲▲▲ 新增樣式結束 ▲▲▲ */

/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* ▼▼▼ 用這塊【信紙美化版】代碼，完整替換掉上一版的所有情書CSS ▼▼▼ */

/* --- 【全新美化版】情侶空間情書功能樣式 --- */

/* 1. 情書列表為空時的提示 (不變) */
#ls-letters-list .ls-empty-placeholder {
    text-align: center;
    color: var(--text-secondary);
    padding: 50px 0;
}

/* 2. 單個情書卡片的樣式 (已修改) */
.ls-love-letter-item {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.07);
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    display: flex;
    gap: 12px;
    align-items: center;
}
.ls-love-letter-item:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.1);
}

/* 3. 情書圖示的樣式 (不變) */
.ls-love-letter-item .letter-icon {
    flex-shrink: 0;
    width: 45px;
    height: 45px;
    color: #ff8fab;
}

/* 4. 情書主要資訊區 (已修改，加入頭像) */
.ls-love-letter-item .letter-info {
    flex-grow: 1;
    overflow: hidden;
}
/* 【核心修改】收件人區域現在包含頭像和名字 */
.ls-love-letter-item .letter-recipient {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 15px;
    font-weight: 600;
    margin-bottom: 5px;
}
.ls-love-letter-item .letter-recipient .avatar {
    width: 24px;
    height: 24px;
    border-radius: 50%;
}
.ls-love-letter-item .letter-preview {
    font-size: 13px;
    color: var(--text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* 5. 發信人資訊 (不變) */
.ls-love-letter-item .letter-sender {
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    font-size: 11px;
    color: var(--text-secondary);
}
.ls-love-letter-item .letter-sender .avatar {
    width: 30px;
    height: 30px;
    border-radius: 50%;
}

/* 6. 【全新】情書詳情檢視器 (信紙樣式) */
#ls-letter-viewer-modal {
    z-index: 1001; /* 確保在最上層 */
}
.ls-letter-viewer-content {
    background-color: #fdfaef; /* 溫馨的米黃色信紙背景 */
    width: 90%;
    max-width: 340px;
    height: 75%;
    border-radius: 15px;
    box-shadow: 0 8px 30px rgba(0,0,0,0.15);
    display: flex;
    flex-direction: column;
    font-family: 'Kaiti', 'STKaiti', serif; /* 使用更典雅的楷體 */
}
.letter-viewer-header {
    padding: 15px;
    border-bottom: 1px dashed #e0d9c7;
    display: flex;
    align-items: center;
    gap: 10px;
    color: #5d4037;
}
.letter-viewer-header .meta-avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
}
.letter-viewer-header .recipient-info .label {
    font-size: 13px;
    color: #a1887f;
}
.letter-viewer-header .recipient-info .name {
    font-size: 16px;
    font-weight: 600;
}
.letter-viewer-body {
    flex-grow: 1;
    padding: 20px;
    font-size: 16px;
    line-height: 2; /* 更大的行高，模擬手寫信的舒適感 */
    color: #4a443b;
    overflow-y: auto;
    white-space: pre-wrap;
    word-break: break-word;
}
.letter-viewer-footer {
    padding: 15px;
    border-top: 1px dashed #e0d9c7;
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
}
.letter-viewer-footer .sender-info {
    font-size: 14px;
    color: #5d4037;
    font-weight: 600;
}
.letter-viewer-footer .sender-info .timestamp {
    font-size: 11px;
    color: #a1887f;
    font-weight: normal;
}
.letter-viewer-footer .letter-actions {
    display: flex;
    gap: 10px;
}
.letter-viewer-footer .letter-actions button {
    padding: 8px 15px;
    border-radius: 15px;
    border: 1px solid #d4bda5;
    background-color: transparent;
    color: #8c7b6c;
    cursor: pointer;
    font-size: 14px;
}
.letter-viewer-footer .letter-actions button.primary {
    background-color: #ff8fab;
    color: white;
    border-color: #ff8fab;
}

/* ▲▲▲ 樣式替換結束 ▲▲▲ */
/* ▼▼▼ 這是為情書新增的樣式 ▼▼▼ */

/* 1. 讓情書卡片可以作為刪除按鈕的定位參考點 */
.ls-love-letter-item {
    position: relative; /* 關鍵！ */
}

/* 2. 刪除按鈕的樣式 */
.ls-letter-delete-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    width: 24px;
    height: 24px;
    background-color: rgba(0, 0, 0, 0.1);
    color: #888;
    border: none;
    border-radius: 50%;
    font-size: 18px;
    line-height: 24px;
    text-align: center;
    cursor: pointer;
    opacity: 0; /* 默認隱藏 */
    transition: all 0.2s ease;
    z-index: 5; /* 確保在最上層 */
}

/* 3. 滑鼠懸停在整張卡片上時，才顯示刪除按鈕 */
.ls-love-letter-item:hover .ls-letter-delete-btn {
    opacity: 1;
}

/* 4. 滑鼠懸停在刪除按鈕上時，給一點回饋效果 */
.ls-letter-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* --- 【全新】情侶空間-情侶提問樣式 --- */

#ls-questions-list {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.ls-question-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    overflow: hidden; /* 防止內部元素溢出圓角 */
}

.ls-question-section,
.ls-answer-section {
    padding: 15px;
    display: flex;
    gap: 12px;
    align-items: flex-start;
}

.ls-question-section {
    border-bottom: 1px dashed var(--border-color);
}

.ls-question-card .qa-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    flex-shrink: 0;
}

.ls-question-card .qa-main {
    display: flex;
    flex-direction: column;
    width: 100%;
}

.ls-question-card .qa-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
}

.ls-question-card .qa-author {
    font-weight: 600;
}

.ls-question-card .qa-timestamp {
    font-size: 11px;
    color: var(--text-secondary);
}

.ls-question-card .qa-content {
    font-size: 15px;
    line-height: 1.6;
    white-space: pre-wrap;
    word-break: break-word;
}

.ls-answer-placeholder {
    padding: 20px;
    text-align: center;
}

.ls-answer-btn {
    padding: 8px 20px;
    border: 1px solid var(--accent-color);
    background-color: transparent;
    color: var(--accent-color);
    border-radius: 20px;
    cursor: pointer;
    font-weight: 500;
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是為“情侶提問”新增的刪除按鈕樣式 ▼▼▼ */

/* 1. 讓提問卡片可以作為刪除按鈕的定位參考點 */
.ls-question-card {
    position: relative; /* 關鍵！ */
}

/* 2. 刪除按鈕的樣式 */
.ls-question-delete-btn {
    position: absolute; /* 絕對定位，讓它浮動起來 */
    top: 10px;
    right: 10px;
    width: 24px;
    height: 24px;
    background-color: rgba(0, 0, 0, 0.08); /* 半透明的背景 */
    color: var(--text-secondary); /* 使用全域的次要文字顏色 */
    border: none;
    border-radius: 50%; /* 圓形 */
    font-size: 18px;    /* "×"號的大小 */
    line-height: 24px;  /* 讓"×"號垂直居中 */
    text-align: center;
    cursor: pointer;
    opacity: 0; /* 默認隱藏 */
    transition: all 0.2s ease; /* 添加平滑的動畫效果 */
    z-index: 5; /* 確保在最上層 */
}

/* 3. 滑鼠懸停在整張卡片上時，才顯示刪除按鈕 */
.ls-question-card:hover .ls-question-delete-btn {
    opacity: 1;
}

/* 4. 滑鼠懸停在刪除按鈕上時，給一點回饋效果 */
.ls-question-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}
/* ▲▲▲ 新增樣式結束 ▲▲▲ */
/* ▼▼▼ 這是為“分享”功能新增的樣式 ▼▼▼ */

.ls-share-item .title {
    font-weight: 600; /* 標題加粗 */
}

/* ▼▼▼ 用這塊【已修復換行問題】的代碼，替換掉舊的 .ls-share-item .summary 樣式 ▼▼▼ */
.ls-share-item .summary {
    font-size: 14px;
    color: #666;
    margin-top: 8px;
    line-height: 1.6;
    /* --- 核心修改：允許文字自動換行 --- */
    white-space: normal;     /* <--- 允許換行 */
    overflow: visible;       /* <--- 允許內容溢出容器（即顯示多行） */
    text-overflow: clip;     /* <--- 禁用省略號 */
    word-break: break-word;  /* <--- 防止超長單詞或連結撐破佈局 */
}
/* ▲▲▲ 替換結束 ▲▲▲ */


#phone-screen.dark-mode .ls-share-item .summary {
    color: #a0a0a0;
}

/* ▲▲▲ 新增樣式結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是情侶空間專屬音樂播放機的CSS樣式 ▼▼▼ */

/* 播放機主窗口的遮罩層 */
#ls-music-player-overlay {
    background-color: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(5px);
    -webkit-backdrop-filter: blur(5px);
}

/* 播放清單面板的樣式 (直接複用現有的) */
#ls-music-playlist-panel {
    /* 我們直接使用 .music-playlist-panel 的現有樣式，省去重複代碼 */
}

/* ▲▲▲ CSS樣式黏貼結束 ▲▲▲ */
/* 【新增】隱藏情侶空間播放機中不需要的按鈕 */
#ls-music-player-overlay #ls-playlist-btn,
#ls-music-player-overlay #ls-prev-btn,
#ls-music-player-overlay #ls-next-btn {
    display: none;
}

/* 【新增】居中播放/暫停按鈕 */
#ls-music-player-overlay .music-controls {
    justify-content: center; /* 讓剩下的按鈕居中 */
}

/* ▲▲▲ CSS代碼替換結束 ▲▲▲ */
/* 【新增】情侶空間播放機封面/歌詞切換樣式 */
#ls-display-area.show-lyrics #ls-album-cover {
    display: none; /* 當有 show-lyrics 類時，隱藏封面 */
}
#ls-display-area.show-lyrics #ls-lyrics-container {
    display: block !important; /* 當有 show-lyrics 類時，顯示歌詞 */
}

/* 【新增】歌詞行樣式 */
#ls-lyrics-container .lyric-line {
    padding: 4px 0;
    font-size: 14px;
    color: #666;
    opacity: 0.7;
    transition: all 0.5s ease;
}
#ls-lyrics-container .lyric-line.active {
    font-size: 16px;
    color: #000;
    opacity: 1;
    font-weight: 600;
}
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* --- 【全新】情侶空間-情侶番茄鐘樣式 --- */

/* 主頁佈局 */
#ls-pomodoro-home {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

#ls-pomodoro-start-btn-container {
    padding: 20px;
    background-color: var(--secondary-bg);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    text-align: center;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
}
#ls-pomodoro-start-btn-container:hover {
    transform: translateY(-5px);
    box-shadow: 0 6px 15px rgba(0,0,0,0.12);
}
#ls-pomodoro-start-icon {
    font-size: 32px;
    color: var(--accent-color);
    line-height: 1;
}
#ls-pomodoro-start-btn-container p {
    margin: 8px 0 0 0;
    font-weight: 500;
    color: var(--text-primary);
}

/* 歷史記錄清單 */
#ls-pomodoro-history-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.pomodoro-history-item {
    background-color: var(--secondary-bg);
    border-radius: 8px;
    padding: 12px 15px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    cursor: pointer;
}
.pomodoro-history-item:hover {
    background-color: #f9f9f9;
}
.pomodoro-history-item .task {
    font-weight: 500;
    margin-bottom: 5px;
}
.pomodoro-history-item .meta {
    font-size: 12px;
    color: var(--text-secondary);
}

/* ▼▼▼ 把下面這整塊【鎖機全屏版】代碼，替換掉你舊的 #ls-pomodoro-timer-active 樣式 ▼▼▼ */
#ls-pomodoro-timer-active {
    /* 核心修改1：將定位方式從 absolute 改為 fixed */
    /* 這會讓計時器介面脫離原來的“情侶空間”頁面，浮動在整個手機螢幕的最頂層！*/
    position: fixed; 
    
    /* 核心修改2：用這四個屬性讓它撐滿整個螢幕 */
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    
    /* 核心修改3：設置一個超高的層級，確保它能蓋住所有東西，實現“鎖機”效果 */
    z-index: 2000; 
    
    background-size: cover;
    background-position: center;
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    align-items: center;
    padding: 50px 20px;
    box-sizing: border-box;
    text-shadow: 0 2px 8px rgba(0,0,0,0.5);

    /* (可選優化) 為iPhone的劉海和底部小黑條留出安全距離，讓介面更美觀 */
    padding-top: calc(50px + env(safe-area-inset-top));
    padding-bottom: calc(50px + env(safe-area-inset-bottom));
}
/* ▲▲▲ 替換結束 ▲▲▲ */

/* ▼▼▼ 用這段新代碼替換 ▼▼▼ */
.pomodoro-char-avatar-container {
    position: relative;
    text-align: center;
    width: 100%; /* <-- 就是新增了這一行！ */
}
/* ▲▲▲ 替換結束 ▲▲▲ */
#pomodoro-char-avatar {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    border: 3px solid rgba(255,255,255,0.8);
    cursor: pointer;
    transition: transform 0.2s;
}
#pomodoro-char-avatar:active {
    transform: scale(0.9);
}
/* ▼▼▼ 用這段【最終修復版】代碼完整替換舊的 #pomodoro-char-log 樣式 ▼▼▼ */
#pomodoro-char-log {
    position: absolute;
    top: 100%;
    margin-top: 12px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0, 0, 0, 0.65);
    padding: 8px 12px;
    border-radius: 10px;
    font-size: 14px;
    max-width: 80%; /* <-- 核心修改在這裡！讓氣泡可以變得更寬 */
    width: max-content; /* <-- 新增！確保氣泡寬度根據內容自我調整，但不會超過80% */
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s, margin-top 0.3s; /* margin-top讓動畫更平滑 */
    pointer-events: none;
    white-space: pre-wrap;
    box-sizing: border-box; /* 新增！防止內邊距導致佈局問題 */
}
/* ▲▲▲ 替換結束 ▲▲▲ */


#pomodoro-char-log::after {
    content: '';
    position: absolute;
    bottom: 100%; /* <-- 修改這裡 */
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border: 6px solid transparent;
    border-bottom-color: rgba(0,0,0,0.65); /* <-- 修改這裡 */
}


#pomodoro-char-log.visible {
    opacity: 1;
    visibility: visible; /* 新增 */
    margin-bottom: 22px; /* 核心修復3: 顯示時向上移動一點，有一個“冒出來”的動畫效果 */
}
/* ▲▲▲ 替換結束 ▲▲▲ */



/* 時間和任務顯示 */
.pomodoro-timer-display {
    text-align: center;
}
#pomodoro-current-task {
    font-size: 20px;
    font-weight: 500;
    margin-bottom: 10px;
}
#pomodoro-time {
    font-size: 72px;
    font-weight: 200;
    letter-spacing: 2px;
}

/* 結束按鈕 */
#pomodoro-end-btn {
    padding: 12px 30px;
    font-size: 16px;
    font-weight: 600;
    border: 2px solid white;
    background-color: rgba(255,255,255,0.2);
    color: white;
    border-radius: 25px;
    cursor: pointer;
}

/* 歷史詳情彈窗內的聊天氣泡 */
#pomodoro-history-viewer-content {
    display: flex;
    flex-direction: column;
    gap: 15px;
}
.pomodoro-log-bubble {
    padding: 8px 12px;
    border-radius: 12px;
    max-width: 80%;
    background-color: #f0f0f0;
    align-self: flex-start;
    line-height: 1.5;
}
#phone-screen.dark-mode .pomodoro-log-bubble {
    background-color: #2c2c2e;
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */

/* --- 修復新增功能導致的捲軸問題 --- */

/* 1. 強制隱藏你不要的“情侶空間播放清單” */
#ls-music-playlist-panel {
    display: none !important;
}

/* 2. 確保主螢幕容器絕對不會出現捲軸，實現固定效果 */
#phone-screen {
    overflow: hidden !important;
}



/* === 【圈子評論區終極修復 - 覆蓋繼承版】 === */

/* 
   問題根源：圈子評論區(#post-comment-input-area)錯誤地繼承了
   主聊天輸入區(.chat-input-area)的樣式，導致佈局錯亂。
   以下代碼將針對圈子螢幕(#post-screen)下的評論區進行強制覆蓋。
*/

/* 1. 強制重置評論區容器的佈局，讓它水準排列、垂直居中 */
#post-screen #post-comment-input-area {
    display: flex !important;
    flex-direction: row !important; /* 強制橫向排列 */
    align-items: center !important;  /* 強制垂直居中，實現平行 */
    gap: 10px !important;            /* 設置輸入框和按鈕的間距 */
}

/* 2. 確保內層容器也正確伸展 */
#post-screen #post-comment-input-area .chat-input-main-row {
    flex-grow: 1 !important;
    display: flex !important;
    align-items: center !important;
    gap: 10px !important;
}

/* 3. 強制輸入框的樣式，並讓它填滿空間 */
#post-screen #post-comment-input {
    flex-grow: 1 !important; /* 解決右側空白的關鍵！ */
    min-height: 40px;
    background-color: #f0f2f5 !important;
    border-radius: 20px !important;
    border: none !important;
    padding: 10px 15px !important;
    font-size: 14px !important;
    line-height: 1.5;
    resize: none;
    box-sizing: border-box;
}

/* 4. 強制發送按鈕的樣式 */
#post-screen #send-post-comment-btn {
    height: 40px !important;
    padding: 0 20px !important;
    border-radius: 20px !important;
    background-color: var(--accent-color) !important;
    color: white !important;
    font-weight: 600 !important;
    font-size: 14px !important;
    border: none !important;
    flex-shrink: 0; /* 防止按鈕被壓縮 */
}

/* 夜間模式適配 */
#phone-screen.dark-mode #post-screen #post-comment-input {
    background-color: #2c2c2e !important;
}
/* ▼▼▼ 這是新增的主螢幕滑動樣式 ▼▼▼ */

/* 主螢幕滑動容器 */
.home-screen-slider {
    width: 100%;
    height: 100%; /* 確保它能撐滿父容器 */
    display: flex; /* 讓兩頁並排站好 */
    overflow-x: auto; /* 允許水準滾動 */
    overflow-y: hidden; /* 禁止垂直捲動 */
    scroll-snap-type: x mandatory; /* 這就是滑動的魔法！讓它自動吸附到每一頁 */
    -webkit-overflow-scrolling: touch; /* 在iOS上實現更平滑的滾動 */
    scrollbar-width: none; /* 隱藏捲軸 (Firefox) */
    -ms-overflow-style: none;  /* 隱藏捲軸 (IE) */
}
.home-screen-slider::-webkit-scrollbar {
    display: none; /* 隱藏捲軸 (Chrome, Safari) */
}

.home-page {
    width: 100%; /* 每一頁都占滿整個螢幕寬度 */
    height: 100%;
    flex-shrink: 0; /* 防止頁面被壓縮變形 */
    scroll-snap-align: start; /* 確保每次都對齊頁面的開始位置 */
    
    /* 讓頁面內部的內容可以滾動 */
    overflow-y: auto;
    padding: 0 20px; /* 保持和你原來一樣的左右邊距 */
    box-sizing: border-box;
    position: relative; /* ★★★ 在這裡添加這一行！ ★★★ */
}


/* 分頁小圓點的容器 */
.pagination-dots {
    position: absolute;
    bottom: calc(100px + env(safe-area-inset-bottom)); /* 放在Dock欄上方 */
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 8px; /* 圓點之間的間距 */
}

/* 單個小圓點 */
.pagination-dots .dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.4); /* 未選中時的顏色 */
    transition: background-color 0.3s ease; /* 添加一個平滑的顏色過渡動畫 */
}

/* 被選中的小圓點 */
.pagination-dots .dot.active {
    background-color: rgba(255, 255, 255, 0.9); /* 選中時變得更亮 */
}

/* ▲▲▲ 新增樣式結束 ▲▲▲ */
/* ▼▼▼ 把這段新樣式黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* 這是第二頁佈局的全新樣式 (V2 美化版) */

/* 1. 把頭像小組件定位到左半屏的中間 */
#second-page-left-widget {
    position: absolute;
    top: 50px; 
    left: 25%; 
    transform: translateX(-50%); 
}

/* ★★★ 這是為頭像小組件新增的放大和細邊框樣式 ★★★ */
#second-page-left-widget .widget-circle-uploader {
    width: 65px;  /* 頭像寬度從 65px 放大到 80px */
    height: 65px; /* 頭像高度從 65px 放大到 80px */
    border-width: 1px; /* 輪廓線從 2px 減小到 1px，變得很細 */
    padding: 1px; /* ★★★ 在這裡添加這一行，把縫隙減小到1圖元 ★★★ */
}
/* 2. 把右上角的圖示改為並排排列 */
#second-page-top-right-apps {
    position: absolute;
    top: 50px;
    right: 30px;
    display: flex;
    gap: 30px; /* ★★★ 圖示間距從 25px 增加到 30px，拉開距離 ★★★ */
}

/* 3. 文字顏色樣式保持不變 */
#second-page-top-right-apps .desktop-app-icon .label {
    color: white;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
}
/* ▼▼▼ 把這段新樣式黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* ▼▼▼ 請用這【一整塊新代碼】完整替換掉你上次添加的、關於第二頁頭像的所有CSS ▼▼▼ */

/* 1. 容器：移除元素間距，讓頭像和氣泡靠攏 (保持不變) */
#second-page-left-widget {
    /* ★★★ 在這裡新增一個寬度，作為“主寬度” ★★★ */
    width: 150px;
    gap: 0;
}

#second-page-bubble {
    margin-top: -10px;
    padding: 10px 15px;
    border-radius: 30px;
    /* ★★★ 修改點1：移除 min-width 和 display: inline-block ★★★ */
    /* min-width: 140px; */
    /* display: inline-block; */

    /* ★★★ 修改點2：添加下面這三行，讓它占滿父容器寬度並居中 ★★★ */
    width: 100%;
    box-sizing: border-box; /* 確保 padding 不會撐破佈局 */
    text-align: center;     /* 讓文字在變寬的容器裡居中 */
    
    background-color: rgba(255, 255, 255, 0.4);
    color: #1c1c1e;
    text-shadow: none;
    box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    position: relative;
    z-index: 1;
}



/* ★★★ 修改點2：在這裡明確移除那個不想要的尖角 ★★★ */
#second-page-bubble::after {
    content: none; /* 強制移除繼承自 .widget-bubble 的尖角偽元素 */
}

/* 3. 提升頭像層級 (保持不變) */
#second-page-left-widget .widget-circle-uploader {
    position: relative; 
    z-index: 2;         
}

/* ▲▲▲ 替換結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* 1. 新增氣泡的容器，負責整體佈局和寬度 */
#new-bubbles-container {
    display: flex;
    align-items: center;
    gap: 8px;
    /* ★★★ 核心修改：將固定的 180px 改為 100%，讓它自動跟隨父容器 ★★★ */
    width: 100%;
    margin-top: 8px;
}


/* ▼▼▼ 用這塊【全新的代碼】替換舊的 #flat-capsule-bubble 樣式 ▼▼▼ */
/* ▼▼▼ 用這塊【修改後】的代碼替換舊的 #flat-capsule-bubble 樣式 ▼▼▼ */
#flat-capsule-bubble {
    flex-grow: 1;
    min-width: auto;
    /* ★★★ 修改點1：高度從 44px 減小到 38px ★★★ */
    height: 35px;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0 15px;
    /* ★★★ 修改點2：新增背景色，將透明度從 0.4 提升到 0.6，讓它更不透明 ★★★ */
    background-color: rgba(255, 255, 255, 0.4);
}
/* ▲▲▲ 替換結束 ▲▲▲ */

#flat-capsule-bubble::after {
    content: none; /* 移除繼承來的小尾巴 */
}


/* ▼▼▼ 用這塊【修改後】的代碼替換舊的 #circular-bubble 樣式 ▼▼▼ */
#circular-bubble {
    flex-shrink: 0;
    /* ★★★ 修改點1：寬度和高度都從 44px 減小到 38px ★★★ */
    width: 35px;
    height: 35px;
    border-radius: 50%;
    padding: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    min-width: auto;
    /* ★★★ 修改點2：新增背景色，與膠囊氣泡保持一致，更不透明 ★★★ */
    background-color: rgba(255, 255, 255, 0.4);
}
/* ▲▲▲ 替換結束 ▲▲▲ */

/* 4. 移除圓形氣泡的小尾巴 */
#circular-bubble::after {
    content: none;
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */

/* 1. 新頭像組件的定位：中間偏上 */
#second-page-center-avatar {
    position: absolute;
    top: 235px; /* 控制上下位置，數值越小越靠上 */
    transform: translateX(-50%); /* 水準居中 */
    z-index: 5; /* 確保它在其他元素之上 */
}

/* 2. 新頭像的尺寸和樣式：比第一個大，且沒有輪廓線 */
#second-page-center-avatar .widget-circle-uploader {
    width: 85px;  /* 比第一個頭像(65px)大一圈 */
    height: 85px; /* 保持正圓 */
    border: none; /* 移除輪廓線 */
    padding: 0;   /* 移除內邊距，讓圖片填滿 */
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* 1. 這是包裹頭像和所有新氣泡的總容器 (V2 加大版) */
/* 1. 這是包裹頭像和所有新氣泡的總容器 (V2 加大版) */
#center-avatar-wrapper {
    position: absolute;
    /* ★ 核心修改：將固定值改為可調節的變數，並提供一個預設值 190px */
    top: var(--second-page-center-avatar-top-offset, 190px); 
    transform: translateX(-55%);
    z-index: 5;
    
    /* ★ 修改點：把這個“看不見的盒子”的尺寸變大 */
    width: 300px;  /* 從 250px 增加到了 300px */
    height: 180px; /* 從 150px 增加到了 180px */
}





/* 2. 把你原來的頭像在總容器裡居中，這樣它的位置看起來和原來一模一樣 */
#second-page-center-avatar {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    /* 我們不再需要它自己來定位了，所以把舊的定位樣式移除 */
}

#avatar-subtitle {
    position: absolute;
    bottom:  20px; /* ★ 修改點：把它從容器外面移到裡面，位置更協調 */
    left: 50%;
    transform: translateX(-50%);
    
    background-color: transparent;
    border: none;
    outline: none;
    
    color: white;
    font-size: 14px;
    font-weight: 500;
    text-align: center;
    text-shadow: 0 1px 3px rgba(0,0,0,0.6);
    cursor: pointer;
    padding: 2px 8px;
}


/* 這是四個角落氣泡的通用樣式 */
.corner-bubble {
    position: absolute;
    background-color: rgba(255, 255, 255, 0.25);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 12px;
    padding: 8px 12px;
    color: white;
    font-size: 12px;
    font-weight: 500;
    text-align: center;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    min-width: 80px; 
    cursor: pointer;
}

/* ▼▼▼ 在這裡分別修改四個角落的位置 ▼▼▼ */

/* 5. 分別定位四個角落的氣泡 */
#bubble-top-left {
    top: 40px;    /* 控制上下位置，數值越大越【往下】移 */
    left: -15px;   /* 控制左右位置，數值越大越【往右】移 */
}

#bubble-top-right {
    top: 40px;    /* 控制上下位置，數值越大越【往下】移 */
    right: -15px;  /* 控制左右位置，數值越大越【往左】移 */
}

#bubble-bottom-left {
    bottom: 40px; /* 控制上下位置，數值越大越【往上】移 */
    left: -15px;   /* 控制左右位置，數值越大越【往右】移 */
}

#bubble-bottom-right {
    bottom: 40px; /* 控制上下位置，數值越大越【往上】移 */
    right: -15px;  /* 控制左右位置，數值越大越【往左】移 */
}
/* ▼▼▼ 【這是修改後的版本】請用這整塊代碼替換舊的 ▼▼▼ */

/* 1. 總容器：移除了頂部的內邊距 */
#new-custom-widget {
    position: absolute;
    bottom: 30px;
    right: 20px;
    width: 50%;
    display: flex;
    flex-direction: column;
    align-items: flex-end;
    gap: 6px;
    /* padding-top: 50px;  <-- 這行已經被刪掉了 */
}

/* 2. 【全新】頭部容器：負責讓月份和頭像水準排列 */
/* 這是頭部容器：負責讓月份和頭像水準排列 */
#new-widget-header {
    width: 100%;
    display: flex;
    justify-content: flex-end; /* 修改：讓所有內容都靠右對齊 */
    align-items: center;
    gap: 70px; /* 新增：在月份和頭像之間加一點間距 */
    margin-bottom: 5px;
}



/* 3. 月份：移除了絕對定位，現在是普通的flex項目 */
#widget-month-display {
    font-size: 25px;
    font-weight: 300;
    color: rgba(255, 255, 255, 0.85);
    text-shadow: 0 0 6px rgba(255, 255, 255, 0.6);
    line-height: 1;
}

/* 4. 頭像：移除了不必要的樣式，因為佈局由父容器控制了 */
#new-custom-widget #new-widget-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: none;
    outline: none;
}

/* 5. 可編輯文字和分割線 (保持不變) */
#new-custom-widget .new-widget-text {
    background: transparent;
    border: none;
    outline: none;
    padding: 2px 4px;
    border-radius: 3px;
    color: rgba(255, 255, 255, 0.85);
    text-shadow: 0 0 6px rgba(255, 255, 255, 0.6);
    font-size: 13px;
    text-align: right;
    width: 100%;
    box-sizing: border-box;
}

#new-custom-widget .new-widget-divider {
    width: 60%;
    height: 1px;
    border-top: 1px dashed rgba(255, 255, 255, 0.3);
}
/* ▲▲▲ 替換結束 ▲▲▲ */
/* ▼▼▼ 【精緻版】請用這整塊代碼替換舊的論壇帖子刪除按鈕樣式 ▼▼▼ */

/* 1. 帖子清單項樣式 (保持不變，只是確保右側有足夠空間) */
.forum-post-item {
    position: relative;
    padding-right: 40px; 
}

/* 2. 刪除按鈕的新樣式 - 小巧精緻版 */
.forum-post-delete-btn {
    position: absolute;
    top: 50%;
    right: 12px; /* 離邊緣稍微近一點 */
    transform: translateY(-50%);

    /* --- 核心修改：尺寸變小 --- */
    width: 24px;
    height: 24px;

    /* --- 核心修改：外觀更精緻 --- */
    background-color: transparent; /* 默認背景透明，不突兀 */
    color: var(--text-secondary);  /* 預設顏色使用次要文字的灰色，更柔和 */
    border: none;
    border-radius: 50%;
    font-size: 18px;      /* 減小 "×" 的大小 */
    line-height: 24px;    /* 確保 "×" 垂直居中 */
    text-align: center;
    cursor: pointer;
    
    /* --- 核心修改：交互動效 --- */
    transition: all 0.2s ease; /* 為所有變化添加平滑過渡 */
}

/* 3. 滑鼠懸停時的回饋效果 */
.forum-post-delete-btn:hover {
    background-color: #ff3b30; /* 懸停時才顯示醒目的紅色背景 */
    color: white;              /* "×" 變為白色 */
    transform: translateY(-50%) scale(1.1); /* 輕微放大，更有動感 */
}

/* ▲▲▲ 替換結束 ▲▲▲ */
/* 1. 定義一個通用的、控制所有主螢幕文字顏色的變數 (保持不變) */
#phone-screen {
    --home-icon-widget-text-color: #FFFFFF;
}

/* 2. 【核心】創建一個“超級選擇器”，一次性選中所有需要變色的文字 */
/* 這次我們加入了頂部狀態列和底部Dock欄的圖示文字 */
.desktop-app-icon .label,                        /* ▼▼▼ 核心修改：移除了前面的ID限定，讓它能同時選中主螢幕和Dock欄的圖示文字 ▼▼▼ */
#desktop-widget-column .widget-bubble,           
#desktop-widget-column .widget-subtext,        
#second-page-left-widget .widget-bubble,           
#second-page-left-widget .widget-subtext,        
#avatar-subtitle,                                
.corner-bubble,                                   
#new-custom-widget .new-widget-text,              
#widget-month-display,
#status-bar                                     /* ★★★ 新增：頂部狀態列 ★★★ */
{
    color: var(--home-icon-widget-text-color) !important;
    text-shadow: 0 1px 4px rgba(0,0,0,0.6) 
}
/* ▼▼▼ 【全新】去除主螢幕字型陰影的樣式 ▼▼▼ */
#phone-screen.no-home-font-shadow .app-icon .label,
#phone-screen.no-home-font-shadow .desktop-app-icon .label,
#phone-screen.no-home-font-shadow .widget-bubble,
#phone-screen.no-home-font-shadow .widget-subtext,
#phone-screen.no-home-font-shadow #avatar-subtitle,
#phone-screen.no-home-font-shadow .corner-bubble,
#phone-screen.no-home-font-shadow .new-widget-text,
#phone-screen.no-home-font-shadow #widget-month-display,
#phone-screen.no-home-font-shadow #profile-username,
#phone-screen.no-home-font-shadow #profile-sub-username,
#phone-screen.no-home-font-shadow #profile-bio,
#phone-screen.no-home-font-shadow #profile-location,
#phone-screen.no-home-font-shadow #clock-container {
    text-shadow: none !important;
}
/* ▲▲▲ 新增樣式結束 ▲▲▲ */

/* ▼▼▼ 【全新】這是微博主頁頭像框的專屬樣式 ▼▼▼ */
.weibo-avatar-container .weibo-avatar-frame{
    position: absolute;
    width: 121%; /* 相對大小，你可以微調 */
    height: 121%;
    /* 使用transform進行精確定位，確保完美居中 */
    transform: translate(-50%, -57%);
    top: 50%;
    left: 50%;
    z-index: 4; /* 確保在頭像之上 */
    pointer-events: none; /* 讓滑鼠事件可以穿透它 */
}


/* ▼▼▼ 【全新】這是微博帖子作者頭像框的專屬樣式 ▼▼▼ */

/* 這是帖子頭部，頭像和框的總容器 */
.weibo-post-header .avatar-with-frame {
    position: relative;
    /* 核心：尺寸和原來的頭像保持一致 */
    width: 40px;
    height: 40px;
    flex-shrink: 0;
}

/* 容器內的頭像圖片 */
.weibo-post-header .avatar-with-frame .avatar-img {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1; /* 確保在框的下面 */
}

/* 容器內的頭像框圖片 */
.weibo-post-header .avatar-with-frame .avatar-frame {
    position: absolute;
    width: 121%; /* 相對大小，你可以微調 */
    height: 121%;
    /* 使用transform進行精確定位，確保完美居中 */
    transform: translate(-50%, -57%);
    top: 50%;
    left: 50%;
    z-index: 4; /* 確保在頭像之上 */
    pointer-events: none; /* 讓滑鼠事件可以穿透它 */
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */

/* ▼▼▼ 【全新】這是主螢幕頭像框的專屬樣式 ▼▼▼ */
#profile-widget .profile-avatar-container .weibo-avatar-frame {
    position: absolute;
    width: 121%; /* 相對大小，你可以微調 */
    height: 121%;
    /* 使用transform進行精確定位，確保完美居中 */
    transform: translate(-50%, -57%);
    top: 50%;
    left: 50%;
    z-index: 4; /* 確保在頭像之上 */
    pointer-events: none; /* 讓滑鼠事件可以穿透它 */
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */


/* ▼▼▼ 把這段全新的CSS，黏貼到你 <style> 標籤的最末尾 ▼▼▼ */

.weibo-background {
    /* 核心代碼：使用 mask-image 創建一個從上到下的漸變蒙版 */
    
    /* a. -webkit- 首碼是為了相容舊版的 Chrome 和 Safari 流覽器 */
    -webkit-mask-image: linear-gradient(
        to bottom,          /* 漸變方向：從上到下 */
        
        /* ★★★ 這裡是你可以自己調整的地方 ★★★ */
        black 60%,          /* 前60%的部分是完全不透明的 (黑色=不透明) */
        transparent 100%    /* 從60%的位置開始，到底部(100%)，逐漸過渡到完全透明 */
    );
    
    /* b. 這是標準語法，相容現代流覽器 */
    mask-image: linear-gradient(
        to bottom,
        black 60%,
        transparent 100%
    );
}

/* ▲▲▲ 黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】圈子分類標籤樣式 ▼▼▼ */
.category-tag-container {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 8px;
}
.category-tag {
    font-size: 11px;
    font-weight: 500;
    color: var(--accent-color);
    background-color: #e7f3ff;
    padding: 3px 8px;
    border-radius: 10px;
}
#phone-screen.dark-mode .category-tag {
    background-color: rgba(10, 132, 255, 0.2);
    color: #0A84FF;
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】圈子/小組分類篩選功能樣式 ▼▼▼ */

/* 篩選圖示的樣式 */
.header .filter-btn {
    font-size: 20px; /* 圖示大小 */
    cursor: pointer;
    color: var(--accent-color); /* 跟隨主題色 */
    position: relative; /* 為了定位小紅點 */
}

/* 當篩選生效時，圖示上顯示一個小點提示 */
.header .filter-btn.active::after {
    content: '';
    position: absolute;
    top: 0;
    right: 0;
    width: 8px;
    height: 8px;
    background-color: #ff3b30;
    border-radius: 50%;
    border: 1.5px solid var(--secondary-bg);
}

/* 篩選彈窗內的分類列表 */
#forum-filter-category-list {
    display: flex;
    flex-wrap: wrap; /* 自動換行 */
    gap: 10px; /* 標籤之間的間距 */
    padding: 10px;
}

#forum-filter-category-list label {
    display: inline-flex;
    align-items: center;
    background-color: #f0f2f5;
    padding: 6px 12px;
    border-radius: 15px;
    cursor: pointer;
    font-size: 14px;
    transition: all 0.2s ease;
}

#phone-screen.dark-mode #forum-filter-category-list label {
    background-color: #3a3a3c;
}

#forum-filter-category-list input[type="checkbox"] {
    display: none; /* 隱藏原始的核取方塊 */
}

/* 選中後的樣式 */
#forum-filter-category-list input[type="checkbox"]:checked + span {
    color: white;
    font-weight: 500;
}

/* 默認給標籤一個好看的顏色迴圈 */
#forum-filter-category-list label:nth-of-type(6n+1) input:checked + span { background-color: #007bff; }
#forum-filter-category-list label:nth-of-type(6n+2) input:checked + span { background-color: #28a745; }
#forum-filter-category-list label:nth-of-type(6n+3) input:checked + span { background-color: #fd7e14; }
#forum-filter-category-list label:nth-of-type(6n+4) input:checked + span { background-color: #6f42c1; }
#forum-filter-category-list label:nth-of-type(6n+5) input:checked + span { background-color: #dc3545; }
#forum-filter-category-list label:nth-of-type(6n+6) input:checked + span { background-color: #ffc107; }

/* 標籤內的文字部分，也需要設置樣式，特別是選中後的背景色 */
#forum-filter-category-list label span {
    padding: 6px 12px;
    margin: -6px -12px; /* 抵消label的padding，讓背景色填滿 */
    border-radius: 15px;
    transition: all 0.2s ease;
}
/* ▲▲▲ 樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】遊戲大廳樣式 ▼▼▼ */
#game-hall-grid {
    display: grid;
    grid-template-columns: 1fr; /* 每行一個遊戲 */
    gap: 15px; /* 遊戲卡片之間的間距 */
}

.game-card {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    display: flex;
    align-items: center;
    gap: 15px;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
}

.game-card:hover {
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.1);
}

.game-card .game-icon {
    font-size: 32px;
    width: 50px;
    height: 50px;
    flex-shrink: 0;
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #f0f2f5;
    border-radius: 10px;
}

#phone-screen.dark-mode .game-card .game-icon {
    background-color: #2c2c2e;
}

.game-card .game-info .game-title {
    font-weight: 600;
    font-size: 16px;
    color: var(--text-primary);
}

.game-card .game-info .game-desc {
    font-size: 13px;
    color: var(--text-secondary);
    margin-top: 4px;
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】狼人殺遊戲樣式 ▼▼▼ */

/* 遊戲設置頁的玩家選擇列表 */
.player-selection-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    border-bottom: 1px solid var(--border-color);
}
.player-selection-item:last-child {
    border-bottom: none;
}
.player-selection-item input[type="checkbox"] {
    width: 20px;
    height: 20px;
    margin-right: 15px;
}
.player-selection-item img {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    margin-right: 10px;
}
.player-selection-item .name {
    font-weight: 500;
}
.player-selection-item .type-tag {
    font-size: 11px;
    color: var(--text-secondary);
    background-color: #f0f0f0;
    padding: 2px 6px;
    border-radius: 4px;
    margin-left: auto;
}

/* 遊戲主介面佈局 */
#werewolf-game-content {
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
    padding: 10px;
    box-sizing: border-box;
}

/* 玩家座位網格 */
#werewolf-players-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
    gap: 10px;
    padding: 10px;
    flex-shrink: 0;
}

.player-seat {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 5px;
}
.player-seat .player-avatar {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    border: 3px solid transparent;
    object-fit: cover;
    transition: all 0.3s ease;
}
.player-seat .player-avatar.speaking {
    border-color: #4cd964; /* 綠色邊框表示正在發言 */
    box-shadow: 0 0 10px #4cd964;
}
.player-seat .player-avatar.dead {
    filter: grayscale(100%);
    opacity: 0.5;
}
.player-seat .player-name {
    font-size: 12px;
    font-weight: 500;
    text-align: center;
    max-width: 60px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.player-seat .player-role-indicator {
    position: absolute;
    top: -2px;
    right: -2px;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background-color: #ff3b30; /* 紅色代表狼人 */
    color: white;
    font-size: 12px;
    font-weight: bold;
    display: none; /* 默認隱藏 */
    justify-content: center;
    align-items: center;
    border: 1px solid white;
}

/* 遊戲日誌區域 */
#werewolf-log-container {
    flex-grow: 1;
    background-color: rgba(0,0,0,0.05);
    border-radius: 10px;
    padding: 10px;
    overflow-y: auto;
    margin: 10px 0;
    min-height: 0; /* flex佈局下滾動的關鍵 */
}
.log-entry {
    padding: 6px;
    border-bottom: 1px solid rgba(0,0,0,0.05);
    font-size: 14px;
    line-height: 1.5;
}
.log-entry.system {
    color: var(--accent-color);
    font-weight: bold;
    text-align: center;
    background-color: rgba(0, 123, 255, 0.05);
    border-radius: 5px;
}
.log-entry.speech .speaker {
    font-weight: 600;
}

/* 玩家操作區 */
#werewolf-action-area {
    flex-shrink: 0;
    padding: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 15px;
    min-height: 50px;
}
#werewolf-action-area button {
    padding: 10px 20px;
}
#werewolf-action-area .vote-target-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
}
#werewolf-action-area .vote-target-btn {
    padding: 8px 12px;
    font-size: 13px;
    background-color: #e9ecef;
    color: var(--text-primary);
    border: 1px solid var(--border-color);
}
#werewolf-action-area .vote-target-btn.selected {
    background-color: var(--accent-color);
    color: white;
    border-color: var(--accent-color);
}
/* ▲▲▲ 狼人殺樣式結束 ▲▲▲ */
/* ▼▼▼ 【全新】狼人殺發言日誌美化樣式 ▼▼▼ */

/* 包含頭像和文字的總容器 */
.log-entry.speech {
    display: flex;
    align-items: flex-start; /* 頂部對齊 */
    gap: 10px;               /* 頭像和文字的間距 */
    padding: 8px 6px;
    border-bottom: 1px solid rgba(0,0,0,0.05); /* 每條發言之間的分割線 */
}

/* 發言者的圓形小頭像 */
.speech-avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%; /* 完美圓形 */
    flex-shrink: 0;     /* 防止頭像被壓縮 */
    object-fit: cover;
}

/* 包裹名字和發言內容的新容器 */
.speech-content {
    display: flex;
    flex-direction: column; /* 名字和內容垂直排列 */
    gap: 2px;
}

/* 發言者名字的樣式 */
.speech-content .speaker {
    font-weight: 600;
    font-size: 13px;
    color: var(--text-secondary); /* 使用次要文字顏色，不那麼刺眼 */
}

/* 發言內容的樣式 */
.speech-content .speech-text {
    word-break: break-word; /* 確保長篇發言能正確換行 */
    line-height: 1.6;
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */



/* ▼▼▼ 【這是為你新增的X社交App圖示樣式】黏貼到 <style> 的末尾 ▼▼▼ */
#second-page-x-social-app {
    position: absolute;
    /* 控制上下位置。我把值調大了，讓它更靠下，和“圈子”圖示對齊 */
    top: 100px;  /* ★ 修改這裡 ★ */
    
    /* 控制左右位置。我把值調小了，讓它更靠右，和“情侶空間”圖示對齊 */
    right: 0px; /* ★ 修改這裡 ★ */
}

/* 把新圖示的文字也變成白色，和其他圖示統一 */
#second-page-x-social-app .label {
    color: white;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
}
/* ▲▲▲ 新增樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】海龜湯遊戲樣式 ▼▼▼ */

.sts-log-entry {
    padding: 8px 10px;
    margin-bottom: 8px;
    border-radius: 8px;
    line-height: 1.6;
}

/* 系統消息 (謎面、提示等) */
.sts-log-entry.system {
    background-color: #e9ecef;
    color: var(--text-secondary);
    text-align: center;
    font-weight: 500;
}
#phone-screen.dark-mode .sts-log-entry.system {
    background-color: #2c2c2e;
}

/* 玩家提問 */
.sts-log-entry.question {
    background-color: #fff;
    border: 1px solid var(--border-color);
}
#phone-screen.dark-mode .sts-log-entry.question {
    background-color: #1c1c1e;
}
.sts-log-entry .speaker {
    font-weight: 600;
    color: var(--accent-color);
}

/* ▼▼▼ 【全新】海龜湯 - 出題人回答氣泡美化 ▼▼▼ */
.sts-log-entry.answer {
    text-align: right;
}
.sts-log-entry.answer .answer-text {
    display: inline-block;
    padding: 8px 12px; /* 增加內邊距，讓氣泡更飽滿 */
    border-radius: 18px; /* 增加圓角 */
    font-weight: 500; /* 字體不用太粗 */
    background-color: #f0f2f5; /* 統一的、中性的淺灰色背景 */
    color: var(--text-primary); /* 文字顏色使用主題的主色，適配夜間模式 */
    box-shadow: 0 1px 2px rgba(0,0,0,0.08); /* 稍微調整陰影 */
}

/* 移除舊的、按顏色區分的樣式，確保所有回答都用上面的新樣式 */
.sts-log-entry.answer .answer-text.yes,
.sts-log-entry.answer .answer-text.no,
.sts-log-entry.answer .answer-text.irrelevant {
    background-color: #f0f2f5; /* 確保所有都用這個顏色 */
}

/* 夜間模式適配 */
#phone-screen.dark-mode .sts-log-entry.answer .answer-text,
#phone-screen.dark-mode .sts-log-entry.answer .answer-text.yes,
#phone-screen.dark-mode .sts-log-entry.answer .answer-text.no,
#phone-screen.dark-mode .sts-log-entry.answer .answer-text.irrelevant {
     background-color: #3a3a3c; /* 夜間模式下的深灰色 */
}
/* ▲▲▲ 替換結束 ▲▲▲ */


/* AI猜測 */
.sts-log-entry.guess {
    font-style: italic;
    color: #fd7e14;
    border-left: 3px solid #fd7e14;
    padding-left: 12px;
}

/* 玩家座位上的身份指示器 */
.player-seat .player-role-indicator.riddle-master {
    background-color: #ffc107; /* 黃色代表出題人 */
    display: flex;
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】海龜湯聊天日誌美化樣式 ▼▼▼ */
.sts-log-entry.question,
.sts-log-entry.answer,
.sts-log-entry.guess {
    display: flex;
    align-items: flex-start; /* 頭像和氣泡頂部對齊 */
    gap: 10px;
    max-width: 85%;
    margin-bottom: 12px;
}

/* 提問和猜測靠左 */
.sts-log-entry.question,
.sts-log-entry.guess {
    align-self: flex-start;
}

/* 回答靠右 */
.sts-log-entry.answer {
    align-self: flex-end;
    flex-direction: row-reverse; /* 關鍵：讓頭像在右邊 */
}

/* 頭像樣式 */
.sts-log-avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}

/* ▼▼▼ 【全新】海龜湯聊天日誌美化樣式 (氣泡透明版) ▼▼▼ */
.sts-log-entry.question .sts-log-content,
.sts-log-entry.guess .sts-log-content {
    background-color: transparent; /* <-- 修改點1：背景改為透明 */
    border-radius: 8px;
    padding: 8px 12px;
    border: none; /* <-- 修改點2：移除邊框，讓它徹底“消失” */
}

#phone-screen.dark-mode .sts-log-entry.question .sts-log-content,
#phone-screen.dark-mode .sts-log-entry.guess .sts-log-content {
    background-color: #1c1c1e;
}

/* 修正回答氣泡的樣式，因為它不是一個完整的塊 */
.sts-log-entry.answer .answer-text {
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
.player-seat .player-avatar.active-turn {
    border-color: #007bff; /* 使用主題色作為邊框顏色 */
    box-shadow: 0 0 15px rgba(0, 123, 255, 0.7); /* 添加發光效果 */
    animation: sts-pulse-glow 1.5s infinite ease-in-out; /* 應用動畫 */
}

@keyframes sts-pulse-glow {
    0%, 100% {
        box-shadow: 0 0 15px rgba(0, 123, 255, 0.7);
    }
    50% {
        box-shadow: 0 0 25px rgba(0, 123, 255, 1);
    }
}
/* ▼▼▼ 【海龜湯佈局修復】請將這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */
#sts-game-log {
    display: flex;
    flex-direction: column;
}
/* ▲▲▲ 修復結束 ▲▲▲ */
/* ▼▼▼ 【全新】海龜湯聊天日誌美化樣式 ▼▼▼ */
.sts-log-entry.question,
.sts-log-entry.answer,
.sts-log-entry.guess {
    display: flex;
    align-items: flex-start; /* 頭像和氣泡頂部對齊 */
    gap: 10px;
    max-width: 85%;
    margin-bottom: 12px;
    /* 移除舊的背景和邊框，因為現在由子元素處理 */
    background-color: transparent;
    border: none;
}

/* 提問和猜測（猜題方）靠左 */
.sts-log-entry.question,
.sts-log-entry.guess {
    align-self: flex-start;
}

/* 回答（出題人）靠右 */
.sts-log-entry.answer {
    align-self: flex-end;
    flex-direction: row-reverse; /* 關鍵：讓頭像在右邊 */
}

/* 頭像樣式 */
.sts-log-avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    object-fit: cover;
    flex-shrink: 0;
}

/* 包含發言人和內容的氣泡 */
.sts-log-entry.question .sts-log-content,
.sts-log-entry.guess .sts-log-content {
    background-color: #fff;
    border-radius: 8px;
    padding: 8px 12px;
    border: 1px solid var(--border-color);
}

#phone-screen.dark-mode .sts-log-entry.question .sts-log-content,
#phone-screen.dark-mode .sts-log-entry.guess .sts-log-content {
    background-color: #1c1c1e;
}

/* 修正回答氣泡的樣式，因為它不是一個完整的塊 */
.sts-log-entry.answer .answer-text {
    box-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

/* 讓日誌容器支援flex佈局的對齊 */
#sts-game-log {
    display: flex;
    flex-direction: column;
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 【海龜湯輸入區終極修復版】 ▼▼▼ */

/* 1. 強制重置整個輸入區域的佈局為“橫向排列”並“垂直居中” */
#sts-action-area {
    display: flex !important;
    flex-direction: row !important;
    align-items: center !important; /* 核心修正：從 flex-end 改為 center，實現垂直居中 */
    gap: 8px !important;
}

/* 2. 強制內部的 main-row 也垂直居中，並讓它填滿空間 */
#sts-action-area .chat-input-main-row {
    flex-grow: 1 !important;
    display: flex !important;
    align-items: center !important; /* 核心修正：內部也保持垂直居中 */
    gap: 8px !important;
}

/* 3. 美化輸入框本身，並讓它自動撐滿寬度 */
#sts-action-area #sts-question-input {
    flex-grow: 1; 
    border: none;
    padding: 10px 15px;
    border-radius: 20px;
    background-color: var(--secondary-bg);
    font-size: 16px;
    resize: none;
    max-height: 100px; 
    line-height: 1.5;
}

/* 4. 統一所有按鈕的高度和樣式，讓它們和輸入框完美適配 */
#sts-action-area #guess-sts-answer-btn,
#sts-action-area #send-sts-question-btn {
    height: 40px; 
    border-radius: 20px;
    padding: 0 15px;
    flex-shrink: 0;
    font-size: 14px;
    font-weight: 600;
}

/* 5. 夜間模式適配 */
#phone-screen.dark-mode #sts-action-area #sts-question-input {
    background-color: #2c2c2e;
    color: var(--text-primary);
}
/* ▲▲▲ 修復結束 ▲▲▲ */
/* ▼▼▼ 【全新】劇本殺遊戲樣式 ▼▼▼ */

/* 遊戲主介面佈局 */
#script-kill-game-content {
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
    padding: 10px;
    box-sizing: border-box;
}

/* 玩家座位區 (複用狼人殺的樣式) */
#script-kill-players-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
    gap: 10px;
    padding: 10px;
    flex-shrink: 0;
}

/* 遊戲日誌區 (複用狼人殺的樣式) */
#script-kill-log-container {
    flex-grow: 1;
    background-color: rgba(0,0,0,0.05);
    border-radius: 10px;
    padding: 10px;
    overflow-y: auto;
    margin: 10px 0;
    min-height: 0; /* flex佈局下滾動的關鍵 */
}

/* 玩家操作區 (複用狼人殺的樣式) */
#script-kill-action-area {
    flex-shrink: 0;
    padding: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 15px;
    min-height: 50px;
}
#script-kill-action-area button {
    padding: 10px 20px;
}

/* 投票選項樣式 */
#sk-vote-options-list label {
    display: block;
    padding: 8px;
    border-radius: 6px;
    cursor: pointer;
}
#sk-vote-options-list label:hover {
    background-color: #f0f2f5;
}
#phone-screen.dark-mode #sk-vote-options-list label:hover {
    background-color: #2c2c2e;
}

/* 線索卡片樣式 */
.sk-evidence-card {
    background-color: var(--secondary-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 12px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
}
.sk-evidence-card .source {
    font-size: 12px;
    color: var(--text-secondary);
    margin-bottom: 8px;
}
.sk-evidence-card .description {
    font-size: 14px;
    line-height: 1.6;
}

/* ▲▲▲ 劇本殺樣式結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* 【全新】劇本殺視覺化編輯器樣式 */

/* 角色/線索卡片的容器 */
.sk-item-container {
    display: flex;
    flex-direction: column;
    gap: 10px;
    background-color: #f0f2f5;
    padding: 10px;
    border-radius: 8px;
    min-height: 50px;
    border: 1px solid var(--border-color);
}
#phone-screen.dark-mode .sk-item-container {
    background-color: #2c2c2e;
}

/* 單個角色/線索的卡片 */
.sk-editor-item {
    background-color: var(--secondary-bg);
    padding: 10px 15px;
    border-radius: 6px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.08);
    position: relative;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.sk-editor-item .item-info .item-name {
    font-weight: 600;
}
.sk-editor-item .item-info .item-meta {
    font-size: 12px;
    color: var(--text-secondary);
}

/* 卡片上的編輯/刪除按鈕 */
.sk-editor-item .item-actions {
    display: flex;
    gap: 8px;
}
.sk-editor-item .item-actions button {
    padding: 4px 8px;
    font-size: 13px;
    border-radius: 5px;
    cursor: pointer;
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】“你說我猜”遊戲樣式 ▼▼▼ */

/* 遊戲日誌區域 */
#guess-what-game-log {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

/* 單條日誌條目 */
.guess-log-entry {
    padding: 8px 12px;
    border-radius: 12px;
    line-height: 1.6;
    max-width: 90%;
    word-break: break-word;
}

/* 系統提示，例如遊戲開始、誰的回合 */
.guess-log-entry.system {
    background-color: #e9ecef;
    color: var(--text-secondary);
    text-align: center;
    font-weight: 500;
    font-size: 13px;
    align-self: center;
}
#phone-screen.dark-mode .guess-log-entry.system {
    background-color: #2c2c2e;
}

/* 玩家發言的氣泡（通用） */
.guess-log-entry.user-turn,
.guess-log-entry.ai-turn {
    display: flex;
    gap: 10px;
    align-items: flex-start;
}

/* 玩家發言內容 */
.guess-log-entry .bubble {
    background-color: #fff;
    padding: 8px 12px;
    border-radius: 8px;
    border: 1px solid var(--border-color);
}
#phone-screen.dark-mode .guess-log-entry .bubble {
    background-color: #2c2c2e;
}

/* AI發言氣泡（靠左） */
.guess-log-entry.ai-turn {
    align-self: flex-start;
}

/* 用戶發言氣泡（靠右） */
.guess-log-entry.user-turn {
    align-self: flex-end;
    flex-direction: row-reverse; /* 頭像在右邊 */
}
.guess-log-entry.user-turn .bubble {
    background-color: #dcf8c6; /* 類似微信的綠色 */
}
#phone-screen.dark-mode .guess-log-entry.user-turn .bubble {
    background-color: #3b5b32; /* 夜間模式下的綠色 */
}

/* 氣泡內的頭像 */
.guess-log-entry .avatar {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    flex-shrink: 0;
}

/* 氣泡內的名字和內容 */
.guess-log-entry .name {
    font-size: 12px;
    font-weight: 600;
    color: var(--text-secondary);
    margin-bottom: 4px;
}

/* 遊戲輸入區美化 */
#guess-what-action-area {
    display: flex !important;
    flex-direction: row !important;
    align-items: center !important; /* 保持垂直居中 */
    gap: 8px !important;
    width: 100%; /* 新增：讓整個容器撐滿寬度 */
    box-sizing: border-box; /* 新增：確保內邊距和邊框被正確計算在內 */
}


#guess-what-action-area #guess-what-user-input {
    flex-grow: 1;
    border: none;
    padding: 10px 15px;
    border-radius: 20px;
    background-color: var(--secondary-bg);
    font-size: 16px;
    resize: none;
    max-height: 100px;
    line-height: 1.5;
}
#guess-what-action-area #send-guess-what-input-btn {
    height: 40px;
    border-radius: 20px;
    padding: 0 15px;
    flex-shrink: 0;
    font-size: 14px;
    font-weight: 600;
}
#phone-screen.dark-mode #guess-what-action-area #guess-what-user-input {
    background-color: #2c2c2e;
    color: var(--text-primary);
}

/* ▲▲▲ “你說我猜”遊戲樣式結束 ▲▲▲ */
/* ▼▼▼ 【劇本殺AI生成器佈局修復】請將這整塊全新的CSS黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* 1. 【核心】讓整個彈窗的內容區(modal-body)能夠正確地撐滿剩餘空間並滾動 */
#sk-ai-generator-modal .modal-body {
    flex-grow: 1;      /* 允許內容區佔據 header 和 footer 之間的所有可用垂直空間 */
    min-height: 0;     /* 解決flex佈局中一個常見的捲軸失效問題，非常關鍵 */
    /* overflow-y: auto;  <-- 這個屬性你的 .modal-body 已經有了，所以不用重複寫 */
}

/* 2. 【核心】指定包含“預覽框”的那個 form-group 也需要能夠彈性增長 */
/* 我們用 :last-of-type 精准定位到最後一個 .form-group */
#sk-ai-generator-modal .modal-body .form-group:last-of-type {
    flex-grow: 1;       /* 讓它吃掉所有剩餘的垂直空間 */
    min-height: 0;      /* 同樣是為了相容性 */
    display: flex;        /* 把它自己也變成flex容器 */
    flex-direction: column; /* 讓它裡面的 label 和 preview 垂直排列 */
}

/* 3. 【核心】最後，確保預覽框本身能夠撐滿它的父容器，並且在內容過多時自己滾動 */
#sk-ai-result-preview {
    flex-grow: 1;      /* 撐滿父容器(.form-group)的空間 */
    overflow-y: auto;  /* 當代碼超出時，顯示它自己的捲軸，而不是讓整個彈窗滾動 */
    
    /* (可選美化) 給一個最小高度，防止在沒內容時完全塌陷 */
    min-height: 100px; 
}

/* ▲▲▲ 黏貼結束 ▲▲▲ */


/* ▼▼▼ 【遊戲輸入區終極修復版】 ▼▼▼ */

/* 1. 強制重置兩個遊戲輸入區域的容器佈局 */
#sts-action-area,
#guess-what-action-area {
    display: flex !important;
    flex-direction: row !important; /* 關鍵：從縱向改為橫向 */
    align-items: center !important;  /* 關鍵：讓所有子元素垂直居中 */
    gap: 8px !important;            /* 設置元素之間的間距 */
    width: 100%;                     /* 新增：讓整個容器寬度撐滿 */
    box-sizing: border-box;          /* 新增：確保內邊距和邊框被正確計算 */
}

/* 2. 強制內部的 .chat-input-main-row 也能正確伸展和對齊 */
#sts-action-area .chat-input-main-row,
#guess-what-action-area .chat-input-main-row {
    flex-grow: 1 !important;
    display: flex !important;
    align-items: center !important;
    gap: 8px !important;
}

/* 3. 美化輸入框本身，並讓它自動撐滿寬度 */
#sts-action-area #sts-question-input,
#guess-what-action-area #guess-what-user-input {
    flex-grow: 1; /* 核心：讓輸入框自動伸展，占滿所有可用寬度 */
    min-height: 40px; /* 保證最小高度 */
    border: none;
    padding: 10px 15px;
    border-radius: 20px;
    background-color: var(--secondary-bg);
    font-size: 16px;
    resize: none;
    max-height: 100px;
    line-height: 1.5;
    box-sizing: border-box;
}

/* 4. 統一所有按鈕的高度和樣式，讓它們和輸入框完美適配 */
#sts-action-area button,
#guess-what-action-area button {
    height: 40px; 
    border-radius: 20px;
    padding: 0 15px;
    flex-shrink: 0; /* 防止按鈕被壓縮 */
    font-size: 14px;
    font-weight: 600;
}

/* 5. 夜間模式適配 */
#phone-screen.dark-mode #sts-action-area #sts-question-input,
#phone-screen.dark-mode #guess-what-action-area #guess-what-user-input {
    background-color: #2c2c2e;
    color: var(--text-primary);
}
/* ▲▲▲ 修復結束 ▲▲▲ */
/* === 【獨家定制】隱藏遊戲大廳返回按鈕的 "退出" 文字 === */
#exit-werewolf-game-btn,
#exit-sts-game-btn,
#exit-script-kill-game-btn,
#exit-guess-what-game-btn,
#exit-ludo-game-btn { /* <--- 修改在這裡 */
    font-size: 0 !important;
    color: transparent !important;
}

#exit-werewolf-game-btn::before,
#exit-sts-game-btn::before,
#exit-script-kill-game-btn::before,
#exit-guess-what-game-btn::before,
#exit-ludo-game-btn::before { /* <--- 還有這裡 */
    content: '‹';
    font-size: 24px !important;
    color: var(--accent-color) !important;
}
/* ▼▼▼ 【V2升級版】遊戲發言輸入區通用美化樣式 ▼▼▼ */

/* 1. 讓兩個遊戲的發言區域容器都變成橫向排列的Flex佈局 */
#werewolf-action-area.speaking-mode,
#script-kill-action-area.speaking-mode {
    display: flex;
    flex-direction: row;
    align-items: center;
    gap: 8px;
    width: 100%;
    padding: 0;
}

/* 2. 美化兩個遊戲的發言輸入框 */
#werewolf-action-area.speaking-mode #user-speech-input,
#script-kill-action-area.speaking-mode #user-sk-speech-input {
    flex-grow: 1;
    border: none;
    padding: 10px 15px;
    border-radius: 20px;
    background-color: var(--secondary-bg);
    font-size: 16px;
    resize: none;
    max-height: 100px;
    line-height: 1.5;
    width: auto !important; 
    height: auto !important;
}

/* 3. 美化兩個遊戲的“結束發言”按鈕 */
#werewolf-action-area.speaking-mode #end-speech-btn,
#script-kill-action-area.speaking-mode #sk-end-speech-btn {
    height: 40px;
    border-radius: 20px;
    padding: 0 15px;
    flex-shrink: 0;
    font-size: 14px;
    font-weight: 600;
    margin: 0 !important; 
    width: auto !important;
    background-color: var(--accent-color);
    color: white;
    border: none;
}

/* 4. 夜間模式適配 */
#phone-screen.dark-mode #werewolf-action-area.speaking-mode #user-speech-input,
#phone-screen.dark-mode #script-kill-action-area.speaking-mode #user-sk-speech-input {
    background-color: #2c2c2e;
    color: var(--text-primary);
}

/* ▲▲▲ 升級版樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】寵物功能樣式 ▼▼▼ */

#chat-pet {
    transition: transform 0.2s ease-out; /* 為拖動添加一點平滑過渡 */
}

#chat-pet:active {
    cursor: grabbing;
    transform: scale(1.1); /* 拖動時稍微放大，給用戶回饋 */
    filter: brightness(0.9);
}

#chat-pet img {
    width: 100%;
    height: 100%;
    object-fit: contain; /* 自訂圖片等比縮放 */
    -webkit-user-drag: none; /* 防止圖片被意外拖動 */
    user-drag: none;
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】寵物數值面板樣式 ▼▼▼ */

#pet-stats-area {
    display: flex;
    flex-direction: column;
    gap: 12px; /* 每個數值條之間的間距 */
    margin-bottom: 20px;
    padding: 15px;
    background-color: #f9f9f9;
    border-radius: 8px;
    border: 1px solid var(--border-color);
}

#phone-screen.dark-mode #pet-stats-area {
    background-color: #2c2c2e;
}

.stat-bar-container {
    display: flex;
    align-items: center;
    gap: 8px;
}

.stat-bar-container .stat-label {
    width: 60px; /* 固定標籤寬度，讓進度條對齊 */
    font-size: 14px;
    font-weight: 500;
    flex-shrink: 0;
}

.stat-bar {
    flex-grow: 1;
    height: 18px;
    background-color: #e9ecef;
    border-radius: 9px;
    overflow: hidden;
    position: relative;
}

#phone-screen.dark-mode .stat-bar {
    background-color: #3e3e42;
}

.stat-bar-fill {
    height: 100%;
    border-radius: 9px;
    transition: width 0.5s ease-in-out;
    display: flex;
    justify-content: center;
    align-items: center;
    color: white;
    font-size: 10px;
    font-weight: bold;
    text-shadow: 0 0 2px rgba(0,0,0,0.5);
}

/* 為不同的數值條設置不同的顏色 */
#pet-hunger-bar .stat-bar-fill {
    background: linear-gradient(135deg, #fd7e14, #ffc107);
}
#pet-happiness-bar .stat-bar-fill {
    background: linear-gradient(135deg, #28a745, #20c997);
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】寵物親密度進度條顏色 ▼▼▼ */
#pet-intimacy-user-bar .stat-bar-fill {
    background: linear-gradient(135deg, #ff8fab, #ffc3a0); /* 對你：溫暖的粉橙色 */
}
#pet-intimacy-char-bar .stat-bar-fill {
    background: linear-gradient(135deg, #a1c4fd, #c2e9fb); /* 對Ta：柔和的天藍色 */
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】寵物聊天介面樣式 ▼▼▼ */
#pet-chat-messages .message-wrapper {
    max-width: 85%;
}

#pet-chat-messages .message-bubble {
    display: flex;
    align-items: flex-start;
    gap: 10px;
}

#pet-chat-messages .message-bubble .avatar {
    width: 34px;
    height: 34px;
    border-radius: 50%;
}

#pet-chat-messages .message-bubble .content {
    padding: 8px 12px;
    border-radius: 10px;
    line-height: 1.5;
}

#pet-chat-messages .message-wrapper.user {
    align-self: flex-end;
}
#pet-chat-messages .message-wrapper.user .message-bubble {
    flex-direction: row-reverse;
}
#pet-chat-messages .message-wrapper.user .content {
    background-color: #dcf8c6;
}

#pet-chat-messages .message-wrapper.pet {
    align-self: flex-start;
}
#pet-chat-messages .message-wrapper.pet .content {
    background-color: #fff;
}

#phone-screen.dark-mode #pet-chat-messages {
    background-color: #000;
}
#phone-screen.dark-mode #pet-chat-messages .message-wrapper.user .content {
    background-color: #26491d;
}
#phone-screen.dark-mode #pet-chat-messages .message-wrapper.pet .content {
    background-color: #2c2c2e;
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 【佈局終極修復】用這整塊代碼替換你上一次添加的寵物聊天輸入框樣式 ▼▼▼ */

/* 1. 讓彈窗內容區適配新佈局 (保持不變) */
#pet-chat-modal .modal-content {
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* 2. 消息區域 (保持不變) */
#pet-chat-modal #pet-chat-messages {
    flex-grow: 1;
    min-height: 0;
    overflow-y: auto;
    padding: 20px 15px;
    background-color: #f0f2f5;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

/* 3. 氣泡樣式 (保持不變) */
#pet-chat-modal .message-bubble .content { padding: 0; background: transparent; box-shadow: none; border: none; }
#pet-chat-modal .message-wrapper.user .content { background-color: #007AFF; color: white; padding: 10px 14px; border-radius: 18px 18px 4px 18px; max-width: 100%; }
#pet-chat-modal .message-wrapper.pet .content { background-color: #ffffff; color: #1c1c1e; padding: 10px 14px; border-radius: 18px 18px 18px 4px; max-width: 100%; box-shadow: 0 1px 2px rgba(0,0,0,0.05); }

/* --- ▼▼▼ 核心修復區域 ▼▼▼ --- */

/* 4. 重置輸入區域的背景和邊框 (保持不變) */
#pet-chat-modal #pet-chat-input-area {
    border-top: 1px solid #e0e0e0;
    background-color: #f7f7f7;
    padding: 10px 12px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
}

/* 5. 【核心修復】讓輸入框和發送按鈕的容器變成 Flex 佈局 */
#pet-chat-modal #pet-chat-input-area .chat-input-main-row {
    display: flex;           /* 關鍵：讓內部元素橫向排列 */
    align-items: center;     /* 關鍵：讓輸入框和按鈕垂直居中對齊，實現“平行” */
    gap: 8px;                /* 輸入框和按鈕之間的間距 */
}

/* 6. 美化輸入框，並【讓它撐滿寬度】 */
#pet-chat-modal #pet-chat-input {
    flex-grow: 1;            /* 關鍵：讓輸入框佔據所有剩餘的寬度 */
    background-color: white;
    border: 1px solid #ddd;
    border-radius: 18px;
    padding: 8px 15px;
    line-height: 1.5;
    min-height: 38px;
    max-height: 100px;
    resize: none;            /* 禁止用戶手動拖拽大小 */
    box-sizing: border-box;  /* 確保padding不會撐破佈局 */
}

/* 7. 美化發送按鈕，並固定其大小 */
#pet-chat-modal #send-to-pet-btn {
    flex-shrink: 0;          /* 防止按鈕被壓縮 */
    background-color: #007AFF;
    color: white;
    border: none;
    border-radius: 18px;
    height: 38px;
    padding: 0 20px;
    font-weight: 600;
    cursor: pointer;         /* 滑鼠放上去時顯示小手 */
}

/* 8. 夜間模式適配 (保持不變) */
#phone-screen.dark-mode #pet-chat-modal #pet-chat-messages { background-color: #000; }
#phone-screen.dark-mode #pet-chat-modal .message-wrapper.pet .content { background-color: #2c2c2e; }
#phone-screen.dark-mode #pet-chat-modal #pet-chat-input-area { background-color: #1c1c1e; border-top-color: #38383a; }
#phone-screen.dark-mode #pet-chat-modal #pet-chat-input { background-color: #2c2c2e; border-color: #38383a; color: white; }

/* ▲▲▲ 修復結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* --- 【全新】情侶空間-情緒日記樣式 --- */

/* 日記視圖主容器 */
#ls-diary-view {
    display: flex;
    flex-direction: column;
    gap: 20px;
}

/* 日曆容器 */
.ls-calendar-wrapper {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
}

.ls-calendar-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    font-size: 16px;
    font-weight: 600;
}

.ls-calendar-header button {
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    color: var(--accent-color);
}

.ls-calendar-weekdays {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    text-align: center;
    font-size: 12px;
    color: var(--text-secondary);
    margin-bottom: 10px;
}

.ls-calendar-grid {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 5px;
}

.ls-calendar-day {
    aspect-ratio: 1 / 1;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: center;
    border-radius: 6px;
    cursor: pointer;
    transition: background-color 0.2s;
    position: relative;
    padding-top: 4px;
}
.ls-calendar-day:hover {
    background-color: #f0f2f5;
}
.ls-calendar-day.empty {
    cursor: default;
    pointer-events: none;
}
.ls-calendar-day.today .day-number {
    background-color: var(--accent-color);
    color: white;
    border-radius: 50%;
    width: 22px;
    height: 22px;
    line-height: 22px;
}

.ls-calendar-day .day-number {
    font-size: 13px;
    font-weight: 500;
    margin-bottom: 4px;
}

.ls-calendar-day .mood-emojis {
    display: flex;
    gap: 4px;
    font-size: 16px;
    position: absolute;
    bottom: 5px;
}

/* 心情罐子 */
.ls-mood-jar-wrapper {
    background-color: var(--secondary-bg);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    text-align: center;
}

.ls-mood-jar-wrapper h3 {
    margin: 0 0 15px 0;
    font-size: 16px;
}

/* ▼▼▼ 用這塊【修復後】的代碼替換舊的 .ls-mood-jar 樣式 ▼▼▼ */
.ls-mood-jar {
    width: 100%;
    max-width: 100%;           /* ★ 核心修改1: 使用max-width防止溢出 */
    box-sizing: border-box;    /* ★ 核心修改2: 確保padding不會導致寬度計算錯誤 */
    min-height: 80px;
    background-color: #f0f2f5;
    border-radius: 8px;
    padding: 10px;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-content: flex-start;
    justify-content: center;
    overflow: auto; /* ★ 核心修改3 (保險): 如果內容實在太多，就用捲軸兜底 */
}
/* ▲▲▲ 替換結束 ▲▲▲ */


.ls-mood-jar .mood-emoji-item {
    font-size: 22px;
}

/* 日記編輯彈窗 */
#ls-emoji-selector .emoji-option {
    padding: 5px;
    border-radius: 8px;
    transition: background-color 0.2s;
}
#ls-emoji-selector .emoji-option.selected {
    background-color: #e0e0e0;
    transform: scale(1.2);
}

/* 日記查看彈窗 */
.ls-diary-entry-block {
    background-color: #f9f9f9;
    border-radius: 8px;
    padding: 15px;
    border-left: 4px solid var(--accent-color);
}
.ls-diary-entry-block .entry-header {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 10px;
}
.ls-diary-entry-block .entry-header .mood-emoji {
    font-size: 32px;
}
.ls-diary-entry-block .entry-header .author {
    font-weight: 600;
    font-size: 16px;
}
.ls-diary-entry-block .entry-content {
    line-height: 1.7;
    white-space: pre-wrap;
    word-break: break-word;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* --- 【全新】情侶空間-日記通知卡片樣式 --- */

/* 1. 讓包裹卡片的氣泡本身變透明 */
.message-bubble.is-ls-diary-notification .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

/* 2. 卡片主體樣式 */
.ls-diary-notification-card {
    width: 220px; /* 卡片寬度 */
    background: linear-gradient(135deg, #fff5f8, #ffebee); /* 溫柔的粉色漸變背景 */
    border-radius: 12px;
    padding: 15px;
    cursor: pointer;
    border: 1px solid #ffdde1; /* 淡淡的粉色邊框 */
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    position: relative;
    overflow: hidden; /* 隱藏溢出的裝飾元素 */
    transition: transform 0.2s, box-shadow 0.2s; /* 添加點擊動效 */
}
.ls-diary-notification-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

/* 3. 卡片右上角的裝飾性圖示 */
.ls-diary-notification-card::before {
    content: '💌';
    position: absolute;
    top: -5px;
    right: 10px;
    font-size: 30px;
    opacity: 0.1;
    transform: rotate(15deg);
}

/* 4. 卡片頭部（圖示和標題） */
.ls-diary-card-header {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 15px;
    font-weight: 600;
    color: #c85c7c; /* 稍深的粉色，保證清晰度 */
    margin-bottom: 10px;
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(200, 92, 124, 0.2);
}

/* 5. 卡片正文 */
.ls-diary-card-body p {
    font-size: 14px;
    color: #5c474b; /* 深棕色，易於閱讀 */
    margin: 0 0 12px 0;
    line-height: 1.6;
}

/* 6. 卡片底部提示文字 */
.ls-diary-card-footer {
    font-size: 12px;
    color: #c85c7c;
    text-align: right;
    font-weight: 500;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */


/* ▼▼▼ 【獨家定制】寵物互動按鈕 2x2 網格佈局 (最終加強版) ▼▼▼ */

/* 1. 使用 !important 強制開啟網格佈局，對抗樣式衝突 */
#pet-interaction-area {
    display: grid !important;        /* 關鍵：強制使用 grid 佈局 */
    grid-template-columns: 1fr 1fr;  /* 兩列網格 */
    gap: 10px;                       /* 按鈕間距 */
    max-width: 220px;                /* 適當放寬最大寬度，給按鈕更多空間 */
    margin: 15px auto !important;    /* 強制居中 */
}

/* 2. 調整按鈕尺寸，並強制文字不換行 */
#pet-interaction-area button {
    /* 尺寸和文字 */
    padding: 8px 12px;
    font-size: 14px;
    white-space: nowrap;             /* 關鍵：強制文字在同一行顯示，防止換行 */
    
    /* 形狀和美化 */
    border-radius: 18px;
    width: 100%;
    font-weight: 600;
    background-color: #f0f2f5;
    color: var(--accent-color);
    border: 1.5px solid var(--accent-color);
    cursor: pointer;
    transition: all 0.2s ease-in-out;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

/* 3. 交互效果保持不變 */
#pet-interaction-area button:hover {
    background-color: var(--accent-color);
    color: white;
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}

#pet-interaction-area button:active {
    transform: translateY(0) scale(0.98);
    box-shadow: 0 1px 2px rgba(0,0,0,0.08);
}

/* ▲▲▲ 美化樣式結束 ▲▲▲ */


/* --- 【最終版】情侶空間右上角按鈕美化與獨立微調 --- */

/* 1. 收緊按鈕容器的整體間距 */
#ls-header .header-actions {
    gap: 0px; /* ★ 修改這裡：將按鈕間的間距減小到0，讓它們緊挨著 */
}

/* 2. 保持按鈕的基礎樣式（這部分不變） */
#ls-header .action-btn {
    padding: 8px; 
    border-radius: 50%;
    transition: background-color 0.2s;
}
#ls-header .action-btn:hover {
    background-color: rgba(255, 255, 255, 0.2);
}

/* 3. 【核心】為每個按鈕添加獨立的微調功能 */

/* “設置”按鈕的獨立位置 */
#ls-settings-btn {
    position: relative; /* 啟用相對定位，這是微調的關鍵 */
    top: 0px;           /* 【調上下】: 正數往下移，負數往上移 */
    left: 40px;          /* 【調左右】: 正數往右移，負數往左移 */
}

/* “更換背景”按鈕的獨立位置 */
#ls-change-bg-btn {
    position: relative;
    top: 0px;          
    left: 30px;          
}

/* “切換”按鈕的獨立位置 */
#ls-switch-char-btn {
    position: relative;
    top: -5px;
    left: 15px;
}

/* ▼▼▼ 【獨家定制】情侶空間心動音波圖示 ▼▼▼ */

/* 1. 移除舊的愛心字元和發光效果 */
.ls-header-avatars .heart-icon {
    font-size: 0; /* 讓'❤'字元消失 */
    text-shadow: none; /* 移除文字陰影 */
    
    /* 2. 為新圖示設置一個容器大小，您可以根據喜好微調 */
    width: 80px;
    height: 28px;
    
    /* 3. 【核心】將你圖片中的音波心動圖設置為背景 */
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='80' height='24' viewBox='0 0 80 24'%3E%3Cg fill='%23ff8fab'%3E%3Crect x='0' y='10' width='3' height='4' rx='1.5'/%3E%3Crect x='5' y='8' width='3' height='8' rx='1.5'/%3E%3Crect x='10' y='11' width='3' height='2' rx='1.5'/%3E%3Crect x='15' y='6' width='3' height='12' rx='1.5'/%3E%3Crect x='20' y='9' width='3' height='6' rx='1.5'/%3E%3Cpath transform='translate(25 0) scale(1.1)' d='M22 8.879c0-5.323-5.326-5.323-7.5-1.121C12.277 2.235 7 3.556 7 8.879 7 14.155 14.5 20 14.5 20S22 14.155 22 8.879z'/%3E%3Crect x='55' y='9' width='3' height='6' rx='1.5'/%3E%3Crect x='60' y='6' width='3' height='12' rx='1.5'/%3E%Crect x='65' y='11' width='3' height='2' rx='1.5'/%3E%3Crect x='70' y='8' width='3' height='8' rx='1.5'/%3E%3Crect x='75' y='10' width='3' height='4' rx='1.5'/%3E%3C/g%3E%3C/svg%3E");
    background-size: contain; /* 確保圖示完整顯示 */
    background-repeat: no-repeat;
    background-position: center;
    
    /* 4. （可選）微調垂直位置，讓它和頭像更對齊 */
    position: relative;
    top: -2px; 
}

/* ▲▲▲ 定制樣式結束 ▲▲▲ */

/* ▼▼▼ 這是為你新增的日曆居中修復代碼 ▼▼▼ */

/* 1. 強制讓每一天的格子內容都不要溢出，避免互相影響 */
.ls-calendar-day {
    overflow: hidden;
    text-align: center; /* 再次強調文本居中，更穩定 */
}

/* 2. 【核心修復】將藍圈本身也變成一個flex居中容器 */
/* 這能確保裡面的數位，無論如何都會在圈圈的正中間 */
.ls-calendar-day.today .day-number {
    display: flex;
    justify-content: center;
    align-items: center;
}

/* ▲▲▲ 修復結束 ▲▲▲ */

/* ▼▼▼ 【獨家定制】情侶空間返回按鈕美化 ▼▼▼ */
#ls-header .back-btn {
    /* 1. 核心修改：將箭頭顏色設為您想要的白色 */
    color: white;
    
    /* 2. 統一樣式：讓它和圈子返回按鈕一樣，擁有40x40px的圓形點擊區域 */
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background-color 0.2s ease;
    cursor: pointer;
}

/* 3. 為它添加與其他按鈕統一的、漂亮的懸停效果 */
#ls-header .back-btn:hover {
    background-color: rgba(255, 255, 255, 0.2);
}
/* ▲▲▲ 新增樣式結束 ▲▲▲ */
/* ▼▼▼ 【全新】記憶互通選擇框美化樣式 ▼▼▼ */

/* 1. 讓每個選項的標籤(label)成為一個flex容器 */
.memory-link-option {
    display: flex;
    align-items: center; /* 垂直居中對齊 */
    gap: 10px;           /* 元素之間的間距 */
    padding: 8px 12px !important;  /* 增加內邊距，!important確保生效 */
    cursor: pointer;
}

/* 2. 單獨為核取方塊設置樣式，防止被全域樣式影響 */
.memory-link-option input[type="checkbox"] {
    width: 18px !important;  /* 固定寬度 */
    height: 18px !important; /* 固定高度 */
    margin: 0 !important;    /* 移除外邊距 */
    flex-shrink: 0;          /* 防止被壓縮 */
}

/* 3. 設置頭像的樣式 */
.memory-link-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%; /* 圓形頭像 */
    object-fit: cover;  /* 保證圖片不變形 */
    flex-shrink: 0;     /* 防止被壓縮 */
}

/* 4. 設置名字的樣式 */
.memory-link-name {
    /* 預設樣式即可，它會自動填充剩餘空間 */
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】記憶互通選擇框美化樣式 ▼▼▼ */
#memory-link-checkboxes-container label {
    display: flex;           /* 1. 使用Flex佈局，讓頭像和文字橫向排列 */
    align-items: center;     /* 2. 垂直居中對齊 */
    gap: 10px;               /* 3. 在頭像、核取方塊和文字之間創建間距 */
    padding: 10px 12px;      /* 4. 增加內邊距，讓每一行更高、更易於點擊 */
    cursor: pointer;         /* 5. 滑鼠放上去時顯示小手圖示 */
    transition: background-color 0.2s; /* 6. 添加懸停效果 */
}

#memory-link-checkboxes-container label:hover {
    background-color: #f0f2f5; /* 7. 滑鼠懸停時給一個淡淡的背景色 */
}

#memory-link-checkboxes-container .avatar-preview {
    width: 30px;             /* 8. 設置頭像的尺寸 */
    height: 30px;
    border-radius: 50%;      /* 9. 圓形頭像 */
    object-fit: cover;       /* 10. 確保圖片不變形 */
    flex-shrink: 0;          /* 11. 防止頭像在空間不足時被壓縮 */
}

#memory-link-checkboxes-container input[type="checkbox"] {
    /* 12. 調整核取方塊的大小和位置，使其更協調 */
    width: 18px;
    height: 18px;
    margin: 0;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */

/* ▼▼▼ 【V6 最終修正版】心聲面板（邊框問題修復） ▼▼▼ */

/* 1. 基礎佈局 (保持不變) */
#inner-voice-modal .modal-body { position: relative; min-height: 450px; }
#inner-voice-avatar-wrapper,
#inner-voice-char-name,
#inner-voice-adopter-info { position: absolute; transition: all 0.3s ease; }

/* 2. 角色主頭像的容器：在這裡添加 padding 和 background-color */
#inner-voice-avatar-wrapper {
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    width: 65px;
    height: 65px;
    border-radius: 50%;
    
    /* --- ▼▼▼ 核心修改在這裡 ▼▼▼ --- */
    padding: 4px; /* ★ 新增：向內擠壓4圖元，為紅線留出空間。你可以自己調整這個數值，比如3px或5px */
    background-color: #fff; /* ★ 新增：讓內邊距的區域顯示為白色，形成一個“白環” */
    box-sizing: border-box; /* ★ 新增：確保padding不會把容器撐大，這很重要 */
    /* --- ▲▲▲ 修改結束 ▲▲▲ --- */

    box-shadow: 0 0 0 1.5px transparent;
    transition: box-shadow 0.2s ease-in-out;
}

/* 當需要顯示邊框時，改變 box-shadow 的顏色 (已修改為粉色) */
#inner-voice-avatar-wrapper.has-border {
    box-shadow: 0 0 0 1.5px #ff8fab; /*  <-- 就是修改這裡！*/
}


/* 4. 移除之前製造衝突的 ::after 偽元素 (保持不變) */
#inner-voice-avatar-wrapper::after {
    display: none;
}

/* 角色主頭像的圖片樣式（保持不變） */
#inner-voice-avatar-wrapper #inner-voice-avatar {
    width: 100%;
    height: 100%;
    border-radius: 50%;
    object-fit: cover;
    border: none; 
}

/* 頭像框的樣式（保持不變） */
/* ▼▼▼ 【最終微調版】請用這整塊代碼，替換掉舊的聊天和心聲頭像框規則 ▼▼▼ */

.avatar-with-frame .avatar-frame,
#inner-voice-avatar-frame {
    position: absolute;
    width: 110%;
    height: 115%;
    transform: translate(-50%, -56%);
    top: 50%;
    left: 50%;
    z-index: 2;
    pointer-events: none;
}


/* ▲▲▲ 替換結束 ▲▲▲ */


/* 5. 角色名字和領養人資訊的位置 (保持不變) */
#inner-voice-char-name {
    top: 95px; left: 50%; transform: translateX(-50%); font-weight: 600; font-size: 16px; color: #333; text-align: center;
}
#inner-voice-adopter-info {
    top: 125px; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 8px; font-size: 13px; color: #666;
}
#inner-voice-adopter-info img { width: 24px; height: 24px; border-radius: 50%; }

/* 6. 內容區距離 (保持不變) */
#inner-voice-content-area { margin-top: 165px; }

/* 7. 卡片和標題的樣式 (保持不變) */
#inner-voice-content-area > div { background-color: rgba(255, 255, 255, 0.7); border-radius: 16px; padding: 15px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); border: 1px solid rgba(255, 255, 255, 0.9); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); }
#inner-voice-content-area strong { padding: 3px 10px; border-radius: 12px; color: white !important; text-shadow: 0 1px 2px rgba(0,0,0,0.2); }
#inner-voice-content-area div:nth-of-type(1) strong { background-color: #f0a1a8; }
#inner-voice-content-area div:nth-of-type(2) strong { background-color: #81c784; }
#inner-voice-content-area div:nth-of-type(3) strong { background-color: #64b5f6; }
#inner-voice-content-area div:nth-of-type(4) strong { background-color: #ba68c8; }

/* ▲▲▲ 定制樣式結束 ▲▲▲ */

/*
  【獨家定制】單獨修改心聲頭像框的大小和位置
  使用說明：
  1. 將下面這整塊代碼黏貼到 <style> 標籤的最末尾。
  2. 修改下面的 width, height, top, left 的數值來調整頭像框。
*/
#inner-voice-avatar-frame {
    /*
     * 控制大小：數值越大，頭像框越大。
     * 例如：120% (比原來小), 150% (比原來大)
     */
    width: 100%; 
    height: 100%; 

    /*
     * 控制位置：以頭像中心為原點 (50%, 50%) 進行微調
     */

    /* 控制【上下】位置：小於50%則上移，大於50%則下移 */
    top: 43%; /* 示例：稍微向上移動了一點 */

    /* 控制【左右】位置：小於50%則左移，大於50%則右移 */
    left: 50%; /* 示例：保持水準居中 */
    
    /* 
      以下為保持居中和顯示效果必須的屬性，請勿修改 
    */
    position: absolute;
    transform: translate(-50%, -50%);
    z-index: 2;
    pointer-events: none;
}
/* ▼▼▼ 【全新】這是微博私信功能的所有新樣式，請黏貼到 <style> 的末尾 ▼▼▼ */

/* --- 私信清單頁面 --- */
#weibo-dm-list .dm-list-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    cursor: pointer;
    border-bottom: 1px solid var(--border-color);
}
#weibo-dm-list .dm-list-item:hover {
    background-color: #f5f5f5;
}
#phone-screen.dark-mode #weibo-dm-list .dm-list-item:hover {
    background-color: #2c2c2e;
}
#weibo-dm-list .dm-avatar {
    width: 45px;
    height: 45px;
    border-radius: 50%;
    margin-right: 12px;
    object-fit: cover;
}
#weibo-dm-list .dm-info {
    flex-grow: 1;
    overflow: hidden;
}
#weibo-dm-list .dm-name {
    font-weight: 500;
    font-size: 16px;
    margin-bottom: 4px;
}
#weibo-dm-list .dm-last-msg {
    font-size: 13px;
    color: var(--text-secondary);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* --- 私信詳情頁面 --- */
#weibo-dm-messages {
    background-color: #f0f2f5 !important;
}
#phone-screen.dark-mode #weibo-dm-messages {
    background-color: #000000 !important;
}

/* 複用主聊天介面的氣泡樣式，但為粉絲和角色定義特定對齊方式 */
#weibo-dm-messages .message-wrapper.fan {
    align-self: flex-start;
}
#weibo-dm-messages .message-wrapper.fan .message-bubble {
    flex-direction: row;
}
#weibo-dm-messages .message-wrapper.fan .content {
    background-color: #ffffff;
    border-radius: 2px 18px 18px 18px;
}

#weibo-dm-messages .message-wrapper.char {
    align-self: flex-end;
}
#weibo-dm-messages .message-wrapper.char .message-bubble {
    flex-direction: row-reverse;
}
#weibo-dm-messages .message-wrapper.char .content {
    background-color: #ff8200; /* 微博橙色 */
    color: white;
    border-radius: 18px 2px 18px 18px;
}

#phone-screen.dark-mode #weibo-dm-messages .message-wrapper.fan .content {
    background-color: #2c2c2e;
}
#phone-screen.dark-mode #weibo-dm-messages .message-wrapper.char .content {
    background-color: #e67300;
}

/* ★★★ 這是你需要的【刪除按鈕】的樣式 ★★★ */
.dm-message-delete-btn {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 22px;
    height: 22px;
    background-color: rgba(0, 0, 0, 0.1);
    color: #555;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    font-size: 16px;
    line-height: 22px;
    text-align: center;
    opacity: 0; /* 默認隱藏 */
    transition: all 0.2s ease;
}
/* 滑鼠懸停在消息上時顯示按鈕 */
#weibo-dm-messages .message-wrapper:hover .dm-message-delete-btn {
    opacity: 1;
}
.dm-message-delete-btn:hover {
    background-color: #ff3b30;
    color: white;
}
/* 調整按鈕位置，讓它出現在氣泡旁邊 */
#weibo-dm-messages .message-wrapper.fan .dm-message-delete-btn {
    right: -28px; /* 修改：從 left 改為 right，把它放到右邊 */
    left: auto;   /* 新增：取消左側定位，確保 right 生效 */
}
#weibo-dm-messages .message-wrapper.char .dm-message-delete-btn {
    right: -28px;
}
/* ▼▼▼ 【全新】聊天總結功能樣式 ▼▼▼ */

/* 總結管理彈窗內的列表 */
#summary-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

/* 單條總結卡片 */
.summary-item-card {
    background-color: #f9f9f9;
    border-radius: 8px;
    padding: 12px;
    border: 1px solid var(--border-color);
    position: relative;
}

#phone-screen.dark-mode .summary-item-card {
    background-color: #2c2c2e;
}

.summary-item-card .summary-content {
    font-size: 14px;
    line-height: 1.6;
    white-space: pre-wrap;
    word-break: break-word;
    max-height: 100px;
    overflow: hidden;
    text-overflow: ellipsis;
}

.summary-item-card .summary-meta {
    font-size: 11px;
    color: var(--text-secondary);
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
}

.summary-item-card .summary-actions {
    position: absolute;
    top: 8px;
    right: 8px;
    display: flex;
    gap: 8px;
}

.summary-item-card .summary-actions button {
    background: none;
    border: none;
    cursor: pointer;
    font-size: 18px;
    color: var(--text-secondary);
    padding: 5px;
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 把這段新樣式黏貼到 <style> 的末尾 ▼▼▼ */

/* 聊天總結彈窗底部按鈕的美化 */
#summary-viewer-modal .modal-footer button {
    width: auto; /* 讓寬度自我調整 */
    margin-top: 0; /* 移除頂部外邊距 */
}

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* --- “桃寶”App 整體佈局 --- */
#taobao-screen {
    background-color: #f0f2f5;
}

/* 頂部頁簽 */
.taobao-tabs {
    display: flex;
    flex-shrink: 0;
    border-bottom: 1px solid var(--border-color);
    background-color: var(--secondary-bg);
}
.taobao-tab {
    flex: 1;
    padding: 12px 0;
    text-align: center;
    font-weight: 500;
    color: var(--text-secondary);
    border: none;
    background: none;
    cursor: pointer;
    position: relative;
}
.taobao-tab.active {
    color: #FF5722; /* 淘寶橙 */
}
.taobao-tab.active::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 40px;
    height: 3px;
    background-color: #FF5722;
    border-radius: 1.5px;
}

/* 內容區域 */
.taobao-content {
    flex-grow: 1;
    position: relative;
    overflow: hidden;
}
.taobao-view {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    overflow-y: auto;
    display: none;
    padding: 15px;
    box-sizing: border-box;
}
.taobao-view.active {
    display: block;
}

/* --- 首頁/商品視圖 --- */
#product-category-tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
    overflow-x: auto;
    padding-bottom: 5px; /* for scrollbar */
    scrollbar-width: none;
    -ms-overflow-style: none;
}
#product-category-tabs::-webkit-scrollbar { display: none; }

#product-category-tabs .category-tab-btn {
    padding: 6px 12px;
    border-radius: 15px;
    border: 1px solid var(--border-color);
    background-color: var(--secondary-bg);
    white-space: nowrap;
    cursor: pointer;
}
#product-category-tabs .category-tab-btn.active {
    background-color: #FFEFE9;
    color: #FF5722;
    border-color: #FF5722;
}

.product-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
}
.product-card {
    background-color: var(--secondary-bg);
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 1px 4px rgba(0,0,0,0.08);
    cursor: pointer;
}
.product-card .product-image {
    width: 100%;
    aspect-ratio: 1 / 1;
    object-fit: cover;
    background-color: #f0f2f5;
}
.product-card .product-info {
    padding: 8px;
}
.product-card .product-name {
    font-size: 14px;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    min-height: 2.8em; /* 保證兩行的高度 */
}
.product-card .product-price {
    font-size: 16px;
    font-weight: bold;
    color: #FF5722;
    margin-top: 5px;
}
.product-card .product-price::before {
    content: '¥';
    font-size: 12px;
    margin-right: 2px;
}

/* --- 我的/餘額視圖 --- */
#user-balance-container {
    background: linear-gradient(135deg, #FF9A8B 0%, #FF6A88 100%);
    color: white;
    padding: 30px 20px;
    border-radius: 12px;
    text-align: center;
    text-shadow: 0 1px 3px rgba(0,0,0,0.2);
}
#user-balance-container h2 {
    font-size: 40px;
    margin: 10px 0 20px 0;
}
#top-up-btn {
    background-color: rgba(255,255,255,0.9);
    color: #FF5722;
}

/* --- 訂單/物流視圖 --- */
.order-list {
    display: flex;
    flex-direction: column;
    gap: 15px;
}
.order-item {
    background-color: var(--secondary-bg);
    border-radius: 8px;
    padding: 12px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    display: flex;
    gap: 12px;
}
.order-item .product-image {
    width: 70px;
    height: 70px;
    border-radius: 6px;
    flex-shrink: 0;
}
.order-item .order-info {
    flex-grow: 1;
}
.order-item .product-name {
    font-weight: 500;
}
.order-item .order-status {
    font-size: 13px;
    color: #28a745;
    margin-top: 8px;
    font-weight: 500;
}
.order-item .order-time {
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px;
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* --- “桃寶”App 搜索欄樣式 --- */
.taobao-search-bar {
    display: flex;
    gap: 10px;
    padding: 0 0 15px 0; /* 只在下方留出間距 */
}

#product-search-input {
    flex-grow: 1;
    border: 1px solid #FF5722;
    padding: 10px 15px;
    border-radius: 20px;
    font-size: 14px;
    outline: none;
}

#product-search-btn {
    background-color: #FF5722;
    color: white;
    border: none;
    border-radius: 20px;
    padding: 0 20px;
    font-weight: 500;
    cursor: pointer;
}

/* --- AI生成結果彈窗內的樣式 --- */
#ai-product-results-grid .product-card {
    position: relative; /* 為了定位“添加”按鈕 */
    padding-bottom: 40px; /* 為按鈕留出空間 */
    cursor: default; /* 在彈窗裡，卡片本身不可點擊 */
}

.add-to-my-page-btn {
    position: absolute;
    bottom: 8px;
    left: 8px;
    right: 8px;
    width: calc(100% - 16px);
    padding: 8px 0;
    background-color: #4CAF50; /* 綠色，代表添加 */
    color: white;
    border: none;
    border-radius: 6px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s;
}

.add-to-my-page-btn:hover {
    background-color: #45a049;
}

.add-to-my-page-btn:disabled {
    background-color: #cccccc;
    cursor: not-allowed;
}


/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* --- 購物車頁簽上的小紅點 --- */
.taobao-tab {
    position: relative;
}
#cart-item-count-badge {
    position: absolute;
    top: 5px;
    right: 15px;
    min-width: 18px;
    height: 18px;
    padding: 0 5px;
    background-color: #FF5722;
    color: white;
    font-size: 11px;
    border-radius: 9px;
    line-height: 18px;
}

/* --- 商品卡片上的“加入購物車”按鈕 --- */
.product-card .add-cart-btn {
    position: absolute;
    bottom: 5px;
    right: 5px;
    width: 28px;
    height: 28px;
    background-color: #FF5722;
    color: white;
    border: none;
    border-radius: 50%;
    font-size: 18px;
    line-height: 28px;
    text-align: center;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    transition: transform 0.2s;
}
.product-card .add-cart-btn:active {
    transform: scale(0.9);
}

/* --- 購物車列表 --- */
#cart-item-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
    padding-bottom: 70px; /* 為底部的結算欄留出空間 */
}
.cart-item {
    background-color: var(--secondary-bg);
    border-radius: 8px;
    padding: 12px;
    display: flex;
    align-items: center;
    gap: 12px;
}
.cart-item .product-image {
    width: 80px;
    height: 80px;
    border-radius: 6px;
    flex-shrink: 0;
    cursor: pointer; /* 讓圖片可點擊 */
}
.cart-item .cart-item-info {
    flex-grow: 1;
    cursor: pointer; /* 讓信息區也可點擊 */
}
.cart-item .product-name {
    font-weight: 500;
}
.cart-item .product-price {
    color: #FF5722;
    font-weight: bold;
    margin-top: 8px;
}
.cart-item .quantity-controls {
    display: flex;
    align-items: center;
    gap: 8px;
}
.cart-item .quantity-controls button {
    width: 24px;
    height: 24px;
    border: 1px solid #ccc;
    background-color: #f0f0f0;
    border-radius: 50%;
    cursor: pointer;
}
.cart-item .delete-cart-item-btn {
    width: 30px;
    height: 30px;
    border: none;
    background: none;
    color: #999;
    font-size: 24px;
    cursor: pointer;
    flex-shrink: 0;
}

/* --- 購物車結算欄 --- */
#cart-checkout-bar {
    position: fixed; /* ★★★ 核心修改：從 absolute 改為 fixed ★★★ */
    bottom: 0;
    left: 0;
    right: 0; /* (推薦) 配合 left:0 自動撐滿寬度，更穩妥 */
    /* width: 100%; (可以保留或刪除) */
    z-index: 10; /* (推薦) 確保它始終在最上層 */
    padding: 10px 15px;
    padding-bottom: calc(10px + env(safe-area-inset-bottom));
    background-color: var(--secondary-bg);
    border-top: 1px solid var(--border-color);
    display: flex;
    justify-content: space-between;
    align-items: center;
    box-sizing: border-box;
}

#cart-checkout-bar .total-price {
    font-weight: bold;
}
#cart-checkout-bar #cart-total-price {
    color: #FF5722;
    font-size: 18px;
}
#cart-checkout-bar #checkout-btn {
    background-color: #FF5722;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 20px;
    font-weight: 500;
    cursor: pointer;
}

/* --- 商品詳情彈窗 --- */
#product-detail-body {
    text-align: center;
}
#product-detail-body .product-image {
    width: 80%;
    max-width: 250px;
    border-radius: 8px;
    margin-bottom: 15px;
}
#product-detail-body .product-name {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 10px;
}
#product-detail-body .product-price {
    font-size: 24px;
    font-weight: bold;
    color: #FF5722;
    margin-bottom: 20px;
}
#product-detail-body .product-price::before {
    content: '¥';
    font-size: 16px;
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* --- 商品詳情彈窗 - 評價區 --- */
#product-reviews-section {
    padding: 0 15px 15px 15px; /* 和主體內容保持一致的內邊距 */
    border-top: 1px solid var(--border-color);
    margin-top: 15px;
}
#product-reviews-section h3 {
    font-size: 16px;
    margin: 15px 0;
}
#product-reviews-list {
    display: flex;
    flex-direction: column;
    gap: 15px;
    max-height: 150px; /* 給一個最大高度，內容多了可以滾動 */
    overflow-y: auto;
    margin-bottom: 15px;
}
.product-review-item {
    font-size: 14px;
    line-height: 1.6;
    border-bottom: 1px solid #f0f0f0;
    padding-bottom: 10px;
}
.product-review-item .review-author {
    font-weight: 500;
    color: var(--text-secondary);
    margin-bottom: 5px;
}
#generate-reviews-btn {
    width: 100%;
    margin-top: 10px;
    background-color: #fff7e6;
    color: #fa8c16;
    border-color: #ffd591;
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 標籤的最末尾 ▼▼▼ */

/* --- 餘額明細清單樣式 --- */
.transaction-item {
    background-color: var(--secondary-bg);
    border-radius: 8px;
    padding: 12px 15px;
    margin-bottom: 10px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.06);
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.transaction-info .description {
    font-weight: 500;
}
.transaction-info .timestamp {
    font-size: 12px;
    color: var(--text-secondary);
    margin-top: 4px;
}
.transaction-amount {
    font-weight: bold;
    font-size: 16px;
}
.transaction-amount.income {
    color: #4CAF50; /* 收入為綠色 */
}
.transaction-amount.expense {
    color: #F44336; /* 支出為紅色 */
}

/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是為物流詳情頁新增的樣式，請黏貼到 <style> 的末尾 ▼▼▼ */

#logistics-content-area {
    padding: 20px;
    background-color: #f5f5f5;
}

#phone-screen.dark-mode #logistics-content-area {
    background-color: #121212;
}

/* 頂部商品資訊卡片 */
.logistics-product-summary {
    display: flex;
    gap: 15px;
    padding: 15px;
    margin-bottom: 20px;
    background-color: var(--secondary-bg);
    border-radius: 12px;
    box-shadow: 0 2px 5px rgba(0,0,0,0.08);
}

.logistics-product-summary .product-image {
    width: 60px;
    height: 60px;
    border-radius: 8px;
    flex-shrink: 0;
}

.logistics-product-summary .info .name {
    font-weight: 600;
    font-size: 15px;
}

.logistics-product-summary .info .status {
    font-size: 13px;
    color: #FF5722; /* 淘寶橙 */
    margin-top: 5px;
    font-weight: 500;
}

/* 時間軸容器 */
.logistics-timeline {
    position: relative;
    padding-left: 25px; /* 為時間軸的分隔號和圓點留出空間 */
    background-color: var(--secondary-bg);
    padding: 20px 20px 20px 30px;
    border-radius: 12px;
}

/* 時間軸的分隔號 */
.logistics-timeline::before {
    content: '';
    position: absolute;
    left: 15px;
    top: 20px;
    bottom: 20px;
    width: 2px;
    background-color: #e0e0e0;
}

#phone-screen.dark-mode .logistics-timeline::before {
    background-color: #38383a;
}

/* 每一個物流步驟 */
.logistics-step {
    position: relative;
    margin-bottom: 25px;
}

.logistics-step:last-child {
    margin-bottom: 0;
}

/* 時間軸上的圓點 */
.logistics-step::before {
    content: '';
    position: absolute;
    left: -22px; 
    top: 5px;
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background-color: #ccc;
    border: 2px solid var(--secondary-bg);
    z-index: 1;
}

/* 最新的一條物流狀態，讓它的圓點更突出 */
.logistics-step:first-child::before {
    background-color: #FF5722;
    transform: scale(1.3);
}

.logistics-step-content .status-text {
    font-weight: 500;
    font-size: 14px;
    margin-bottom: 5px;
    line-height: 1.5;
}

.logistics-step-content .timestamp {
    font-size: 12px;
    color: var(--text-secondary);
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是為“分享給Ta代付”按鈕新增的樣式 ▼▼▼ */
#share-cart-to-char-btn {
    background-color: #FF9800; /* 使用一個溫暖的橙色，區別于結算按鈕 */
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 20px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s; /* 添加懸停效果 */
}
#share-cart-to-char-btn:hover {
    background-color: #F57C00;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是為“購物車代付請求”新增的卡片樣式 ▼▼▼ */

/* 1. 讓包裹卡片的氣泡本身變透明 */
.message-bubble.is-cart-share-request .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

/* 2. 卡片主體樣式 */
.cart-share-card {
    width: 230px;
    border-radius: 12px;
    background-color: #fff;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    overflow: hidden;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    border: 2px solid transparent; /* 為不同狀態準備的邊框 */
    transition: all 0.3s ease;
}

/* 3. 卡片頭部 */
.cart-share-header {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 12px 15px;
    background-color: #FFF8E1; /* 溫暖的米黃色 */
    color: #FFA000;
}
.cart-share-header .icon {
    font-size: 24px;
    font-weight: bold;
}
.cart-share-header .title {
    font-size: 16px;
    font-weight: 600;
}

/* 4. 卡片內容區域 */
.cart-share-body {
    padding: 15px;
    text-align: center;
}
.cart-share-body .label {
    font-size: 13px;
    color: #888;
}
.cart-share-body .amount {
    font-size: 32px;
    font-weight: 700;
    color: #FF5722; /* 淘寶橙 */
    margin: 5px 0 15px 0;
}
.cart-share-body .status-text {
    font-weight: 500;
    color: var(--accent-color);
}

/* 5. 不同狀態下的樣式 */
.cart-share-card.paid {
    border-color: #4CAF50; /* 綠色 */
}
.cart-share-card.paid .status-text {
    color: #4CAF50;
}
.cart-share-card.rejected {
    border-color: #F44336; /* 紅色 */
    opacity: 0.8;
}
.cart-share-card.rejected .status-text {
    color: #F44336;
}
/* ▲▲▲ 新增CSS結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是為“為Ta購買”和禮物通知卡片新增的樣式 ▼▼▼ */

/* 1. “為Ta購買”按鈕的樣式 */
#buy-for-char-btn {
    background-color: #4CAF50; /* 使用一個代表“禮物”的綠色 */
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 20px;
    font-weight: 500;
    cursor: pointer;
    transition: background-color 0.2s;
}
#buy-for-char-btn:hover {
    background-color: #45a049;
}

/* 2. 讓包裹禮物卡片的氣泡變透明 */
.message-bubble.is-gift-notification .content {
    padding: 0;
    background: transparent;
    box-shadow: none;
    border: none;
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}

/* 3. 禮物通知卡片主體樣式 */
.gift-card {
    width: 230px;
    border-radius: 12px;
    background-color: #fff;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    overflow: hidden;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
}
.gift-card-header {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 12px 15px;
    background-color: #e8f5e9; /*淡淡的綠色背景*/
    color: #2e7d32;
}
.gift-card-header .icon {
    font-size: 24px;
    font-weight: bold;
}
.gift-card-header .title {
    font-size: 16px;
    font-weight: 600;
}
.gift-card-body {
    padding: 15px;
}
.gift-card-body .greeting {
    font-size: 14px;
    margin-bottom: 10px;
}
.gift-card-items {
    font-size: 13px;
    color: #555;
    max-height: 60px;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-bottom: 10px;
}
.gift-card-footer {
    padding-top: 10px;
    border-top: 1px solid #f0f0f0;
    text-align: right;
    font-weight: bold;
}
.gift-card-footer .total-price {
    color: #FF5722;
}
/* ▲▲▲ 新增樣式結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的CSS，黏貼到 <style> 的末尾 ▼▼▼ */

/* 1. 讓角色主頁的內容區可以獨立滾動 */
#weibo-char-profile-page {
    flex-grow: 1;
    overflow-y: auto;
    background-color: #f0f2f5;
}

/* 2. 修正夜間模式下主頁和新頁面的背景色 */
#phone-screen.dark-mode #weibo-profile-page,
#phone-screen.dark-mode #weibo-char-profile-page {
    background-color: #000;
}

/* 3. 為角色主頁上的職業顯示添加樣式 (已修改) */
#weibo-char-profession-display {
    position: absolute;
    /* 定位：從右側標籤改為與“關注”資料左對齊 */
    left: 35px;
    /* 垂直位置：放在“關注”資料行的下方，-5px會讓它更靠下一點 */
    bottom: -5px;
    right: auto; /* 清除掉舊的 right 定位，避免衝突 */
    z-index: 2;
    
    /* 外觀：從半透明標籤改為和你主頁一致的灰色普通文字 */
    font-size: 13px;
    color: #8a8a8a;
    text-shadow: none;
    background-color: transparent;
    padding: 0;
    border-radius: 0;
}


/* 4. 給關注清單的“查看主頁”按鈕添加樣式 */
.weibo-following-item .view-profile-btn {
    margin-left: auto; /* 讓按鈕自動靠右 */
    padding: 5px 10px;
    font-size: 13px;
    font-weight: 500;
    color: var(--accent-color);
    background-color: #e7f3ff;
    border: none;
    border-radius: 12px;
    cursor: pointer;
}
#phone-screen.dark-mode .weibo-following-item .view-profile-btn {
    background-color: rgba(0, 123, 255, 0.2);
}

/* ▲▲▲ 新增CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【層級修復】請將這段新CSS黏貼到 <style> 的末尾 ▼▼▼ */

/* 強制提升頭像框選擇彈窗的層級，確保它能覆蓋在其他彈窗之上 */
#avatar-frame-modal {
    z-index: 1005; 
}

/* ▲▲▲ 修復結束 ▲▲▲ */
/* ▼▼▼ 這是新增的樣式 ▼▼▼ */

/* 這是我們新加的、包裹頭像的可點擊區域的樣式 */
.weibo-post-avatar-clickable {
    cursor: pointer; /* 滑鼠放上去時顯示為小手形狀 */
    transition: opacity 0.2s ease-in-out; /* 添加一個平滑的過渡動畫 */
}

/* 滑鼠懸停時，讓頭像稍微變暗一點，給用戶一個明確的回饋 */
.weibo-post-avatar-clickable:hover {
    opacity: 0.85;
}

/* ▲▲▲ 新增樣式結束 ▲▲▲ */
/* ▼▼▼ 【全新】語音播放動畫樣式 ▼▼▼ */
.message-bubble.is-voice-message.playing .voice-waveform div {
    animation: wave-play 1s ease-in-out infinite;
}

@keyframes wave-play {
  0%, 100% { height: 2px; }
  25% { height: 12px; }
  50% { height: 6px; }
  75% { height: 18px; }
}
/* ▲▲▲ 樣式黏貼結束 ▲▲▲ */


/* ============ “查手機”功能美化代碼 v2.0 (支援自訂圖片) 開始 ============ */

/* --- 步驟1: 縮小圖示尺寸 (保持不變) --- */
#character-app-grid .app-icon .icon-bg {
    width: 50px !important;
    height: 50px !important;
    border-radius: 13px !important;
}
#character-app-grid .app-icon .label {
    font-size: 12px;
}

/* --- 步驟2: 將容器改為自由定位的“桌面”佈局 (保持不變) --- */
#character-app-grid {
    display: block !important;
    grid-template-columns: none !important;
    gap: 0 !important;
    position: relative !important;
    height: 100% !important;
}

/* --- 步驟3: 讓所有App圖示“浮”起來 (保持不變) --- */
#character-app-grid .app-icon {
    position: absolute !important;
}

/* --- 步驟4: 【核心修改】為我們新的圖片位元設置樣式 --- */
.char-phone-widget {
    position: absolute;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15); /* 加個陰影更好看 */
    border: 2px solid rgba(255,255,255,0.5); /* 加個白邊更有質感 */
    overflow: hidden; /* 防止圖片溢出圓角 */
    cursor: pointer; /* 滑鼠放上去是小手形狀，提示可以點擊 */
    transition: transform 0.2s ease; /* 添加點擊動效 */
    background-color: #e0e0e0; /* 圖片載入前的占位元顏色 */
}
.char-phone-widget:active {
    transform: scale(0.95); /* 點擊時縮小一點點 */
}
.char-phone-widget img {
    width: 100%;
    height: 100%;
    object-fit: cover; /* 保證圖片填滿且不變形 */
}

/* ============================================== */
/* === ★★★ 手動精調區：在這裡修改位置和大小 ★★★ === */
/* ============================================== */

/* --- 左上角的圖片位元 --- */
#char-phone-widget-1 {
    /* --- 在這裡調整【上下位置】(數字越大越往下)--- */
    top: 60px;
    /* --- 在這裡調整【左右位置】(數字越大越往右)--- */
    left: 20px;
    /* --- 在這裡調整【大小】--- */
    width: 110px;
    height: 110px;
    border-radius: 22px; /* 圓角 (建議是寬度的1/5左右) */
}

/* --- 右下角的圖片位元 --- */
#char-phone-widget-2 {
    /* --- 在這裡調整【上下位置】(數字越大越往上)--- */
    bottom: 60px;
    /* --- 在這裡調整【左右位置】(數字越大越往左)--- */
    right: 20px;
    /* --- 在這裡調整【大小】--- */
    width: 110px;
    height: 110px;
    border-radius: 22px; /* 圓角 */
}

/* --- APP 圖示位置調整 (這部分保持不變) --- */
#character-app-grid .app-icon:nth-child(1) { top: 70px; left: 150px; }
#character-app-grid .app-icon:nth-child(2) { top: 70px; left: 215px; }
#character-app-grid .app-icon:nth-child(3) { top: 155px; left: 30px; }
#character-app-grid .app-icon:nth-child(4) { top: 155px; left: 95px; }
#character-app-grid .app-icon:nth-child(5) { top: 155px; left: 160px; }
#character-app-grid .app-icon:nth-child(6) { top: 240px; left: 225px; }
#character-app-grid .app-icon:nth-child(7) { top: 240px; left: 30px; }
#character-app-grid .app-icon:nth-child(8) { top: 240px; left: 95px; }
#character-app-grid .app-icon:nth-child(9) { top: 325px; left: 30px; }
#character-app-grid .app-icon:nth-child(10) { top: 325px; left: 95px; }

/* ============ “查手機”功能美化代碼 結束 ============ */

/* ▼▼▼ 【最終修復版】只為“微博”和“粉絲”增加點擊區域 ▼▼▼ */

/*
 * 核心原理不變，但這次我們使用了更精確的 ID 選擇器，
 * 只選中 #weibo-posts-item (微博) 和 #weibo-fans-item (粉絲) 這兩個元素。
 */
#weibo-posts-item,
#weibo-fans-item {
    padding: 8px 10px;
    margin: -8px -10px;
    border-radius: 8px;
    transition: background-color 0.2s;
}

/* 為這兩個按鈕添加點擊時的背景色回饋 */
#weibo-posts-item:active,
#weibo-fans-item:active {
    background-color: rgba(0, 0, 0, 0.08); /* 點擊時給一個淡淡的灰色背景 */
}

/* 在夜間模式下的點擊回饋顏色 */
#phone-screen.dark-mode #weibo-posts-item:active,
#phone-screen.dark-mode #weibo-fans-item:active {
    background-color: rgba(255, 255, 255, 0.1);
}
/* ▲▲▲ 最終修復版樣式結束 ▲▲▲ */


/* ======================================================================= /
/ === ★★★ 角色手機桌面美化佈局 v16.0 (垂直居中偏移版) ★★★ === /
/ ======================================================================= */

/* --- 1. 總控制台 & 佈局變數 --- */
#character-phone-screen {
    position: relative !important;
    
    /* --- ★★★ 唯一的【垂直位置】總控制器 ★★★ --- */
    /* 調整這個值，就能讓所有圖示和小元件一起上下移動 */
    /* 增加數值 = 整體下移；減小數值 = 整體上移 */
    /* 我幫你設置了一個看起來比較居中的初始值 */
    --global-vertical-offset: 10px;
    
    /* (水準居中部分，保持不變) */
    --grid-width: 345px;
    --grid-left-edge: calc((100% - var(--grid-width)) / 2);
}

/* --- 2. 準備工作 (保持不變) --- */
#character-app-grid {
    position: absolute !important; top: 0; left: 0; width: 100%; height: 100%;
    display: block !important; grid-template-columns: none !important; gap: 0 !important;
}
#character-app-grid .app-icon,
#char-phone-widget-1,
#char-phone-widget-2 {
    position: absolute !important;
}

/* --- 3. App圖示樣式 (保持不變) --- */
#character-app-grid .app-icon .icon-bg {
    width: 40px !important; height: 40px !important;
    background: transparent !important; box-shadow: none !important; border: none !important;
}
#character-app-grid .app-icon .label {
    font-size: 12px; color: #fff; padding-top: 8px;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
}

/* --- 4. 小組件位置和尺寸 (★核心修改: 應用全域偏移) --- */
#char-phone-widget-1 {
    top: calc(var(--global-vertical-offset) + 90px); /* 90px 是你固定的值 */
    left: calc(var(--grid-left-edge) + 30px);
    width: 135px; height: 135px; border-radius: 22px;
}
#char-phone-widget-2 {
    top: calc(var(--global-vertical-offset) + 480px); /* 480px 是你固定的值 */
    left: calc(var(--grid-left-edge) + 180px);
    width: 135px; height: 135px; border-radius: 22px;
}

/* --- 5. App圖示位置 (★核心修改: 應用全域偏移) --- */
/* 第1行 */
#character-app-grid .app-icon:nth-child(1) { top: calc(var(--global-vertical-offset) + 155px); left: calc(var(--grid-left-edge) + 185px); }
#character-app-grid .app-icon:nth-child(2) { top: calc(var(--global-vertical-offset) + 155px); left: calc(var(--grid-left-edge) + 250px); }
/* 第2行 */
#character-app-grid .app-icon:nth-child(3) { top: calc(var(--global-vertical-offset) + 270px); left: calc(var(--grid-left-edge) + 30px); }
#character-app-grid .app-icon:nth-child(4) { top: calc(var(--global-vertical-offset) + 270px); left: calc(var(--grid-left-edge) + 105px); }
#character-app-grid .app-icon:nth-child(5) { top: calc(var(--global-vertical-offset) + 270px); left: calc(var(--grid-left-edge) + 180px); }
/* 第3行 */
#character-app-grid .app-icon:nth-child(6) { top: calc(var(--global-vertical-offset) + 375px); left: calc(var(--grid-left-edge) + 105px); }
#character-app-grid .app-icon:nth-child(7) { top: calc(var(--global-vertical-offset) + 375px); left: calc(var(--grid-left-edge) + 185px); }
#character-app-grid .app-icon:nth-child(8) { top: calc(var(--global-vertical-offset) + 375px); left: calc(var(--grid-left-edge) + 250px); }
/* 第4行 */
#character-app-grid .app-icon:nth-child(9) { top: calc(var(--global-vertical-offset) + 480px); left: calc(var(--grid-left-edge) + 30px); }
#character-app-grid .app-icon:nth-child(10) { top: calc(var(--global-vertical-offset) + 480px); left: calc(var(--grid-left-edge) + 105px); }


/* ▼▼▼ 【查手機功能 | 圖示對齊終極修復 V4】 ▼▼▼ */
/*
 * 解決方案：
 * 1. (保留) 使用負外邊距，將應用名(.label)向上拉，使其緊貼圖示。
 * 2. (新增) 對包含預設SVG圖示的整個.app-icon元素，也使用一個負的margin-top，
 *    使其整體向上移動，從而和其他自訂圖示在垂直方向上完美對齊。
 */

/* 步驟1：讓文字緊貼圖示 (這是上次的成功修復，我們保留它) */
#character-app-grid .app-icon:has(.icon-bg > svg) .label {
    margin-top: -7px !important;
    padding-top: 0px !important;
}

/* 步驟2：讓圖示和文字作為一個整體，向上移動 */
#character-app-grid .app-icon:has(.icon-bg > svg) {
    margin-top: -8px; /* 這個負值會把整個圖示+文字的組合向上拉 */
}
/* ▲▲▲ 修復代碼結束 ▲▲▲ */
/* ▼▼▼ 這是步驟1需要黏貼的新樣式 ▼▼▼ */

/* 讓每一條評論都變成可點擊的，並增加懸停效果 */
.weibo-comment-item {
    cursor: pointer; /* 滑鼠懸停時顯示為小手形狀 */
    transition: background-color 0.2s; /* 添加一個平滑的背景色過渡動畫 */
    border-radius: 4px; /* 給一點點圓角，更好看 */
    padding: 2px 5px; /* 增加一點內邊距，讓點擊區域更大 */
    margin: 0 -5px; /* 把上面的內邊距抵消掉，保持對齊 */
}
.weibo-comment-item:hover {
    background-color: #f0f2f5; /* 滑鼠放上去時，給一個淡淡的背景色 */
}
#phone-screen.dark-mode .weibo-comment-item:hover {
    background-color: #2c2c2e; /* 夜間模式下的懸停顏色 */
}

/* “回復”這兩個字的樣式，讓它更柔和 */
.weibo-comment-item .weibo-comment-reply-tag {
    color: var(--text-secondary);
    margin: 0 4px; /* 和兩邊的名字拉開一點距離 */
}

/* 被回復者的名字樣式，讓它和普通評論者名字一樣可以點擊 */
.weibo-comment-item .reply-target-name {
    font-weight: 600;
    color: var(--accent-color);
    cursor: pointer;
    margin-right: 5px;
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】角色手機App內壁紙樣式 ▼▼▼ */

/* 當內部螢幕有壁紙時，設置背景圖的顯示方式 */
.character-phone-inner-screen.has-app-wallpaper {
    background-size: cover;
    background-position: center;
}

/* 關鍵：讓所有App頁面的內容清單背景變透明 */
.character-phone-inner-screen.has-app-wallpaper .list-container,
.character-phone-inner-screen.has-app-wallpaper #character-chat-history-messages {
    background-color: transparent !important;
}

/* 為了保證文字的可讀性，我們給清單項和卡片加上半透明的背景 */
.character-phone-inner-screen.has-app-wallpaper .character-data-item,
.character-phone-inner-screen.has-app-wallpaper .character-cart-item,
.character-phone-inner-screen.has-app-wallpaper .character-browser-item,
.character-phone-inner-screen.has-app-wallpaper .character-bank-transaction,
.character-phone-inner-screen.has-app-wallpaper .chat-list-item {
    background-color: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.2);
}

/* 同樣為聊天氣泡增加半透明效果 */
.character-phone-inner-screen.has-app-wallpaper .character-chat-bubble-container.received .character-chat-bubble {
    background-color: rgba(255, 255, 255, 0.85);
}
.character-phone-inner-screen.has-app-wallpaper .character-chat-bubble-container.sent .character-chat-bubble {
    background-color: rgba(149, 236, 105, 0.85); /* 微信綠，但帶一點透明 */
}

/* 適配夜間模式的半透明顏色 */
#phone-screen.dark-mode .character-phone-inner-screen.has-app-wallpaper .character-data-item,
#phone-screen.dark-mode .character-phone-inner-screen.has-app-wallpaper .chat-list-item {
     background-color: rgba(28, 28, 30, 0.7);
}
#phone-screen.dark-mode .character-phone-inner-screen.has-app-wallpaper .character-chat-bubble-container.received .character-chat-bubble {
    background-color: rgba(44, 44, 46, 0.85);
}
#phone-screen.dark-mode .character-phone-inner-screen.has-app-wallpaper .character-chat-bubble-container.sent .character-chat-bubble {
     background-color: rgba(48, 93, 32, 0.85); /* 夜間模式的綠色 */
}
/* ▲▲▲ 新CSS黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】這是為“遊戲分享”新增的顏色樣式 ▼▼▼ */
.share-type.game {
    background-color: #9c27b0; /* 一個代表遊戲的神秘紫色 */
}
/* ▲▲▲ 新增樣式結束 ▲▲▲ */
/* ▼▼▼ 【全新】心動飛行棋樣式 ▼▼▼ */

/* --- 遊戲主介面佈局 --- */
#ludo-game-content {
    display: flex;
    flex-direction: column;
    height: 100%;
    overflow: hidden;
    padding: 15px;
    box-sizing: border-box;
    gap: 15px;
    background-color: #fff0f5; /* 溫柔的淡粉色背景 */
}

#phone-screen.dark-mode #ludo-game-content {
    background-color: #2c1e22; /* 夜間模式下的深粉紫色 */
}

/* --- 棋盤容器與棋盤本身 --- */
#ludo-board-container {
    position: relative;
    width: 100%;
    height: 280px; /* 給棋盤一個固定的高度 */
    flex-shrink: 0;
    background-color: rgba(255, 255, 255, 0.5);
    border-radius: 10px;
    padding: 10px;
    box-sizing: border-box;
}

#ludo-board {
    display: grid;
    grid-template-columns: repeat(10, 1fr); /* 10x6的網格佈局 */
    grid-template-rows: repeat(6, 1fr);
    width: 100%;
    height: 100%;
    gap: 3px;
}

/* --- 棋盤格子樣式 --- */
.ludo-cell {
    border-radius: 4px;
    background-color: rgba(255, 192, 203, 0.3); /* 淡淡的粉色格子 */
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 14px;
    font-weight: bold;
    color: #db7093;
}

/* 起點和終點格子 */
.ludo-cell.start { background-color: #90ee90; color: #2e8b57; }
.ludo-cell.end { background-color: #ffd700; color: #b8860b; }

/* 特殊事件格子 */
.ludo-cell.event-truth { background-color: #ffb6c1; } /* 真心話 */
.ludo-cell.event-dare { background-color: #add8e6; }  /* 大冒險 */
.ludo-cell.event-kiss { background-color: #ff69b4; }  /* 親親 */
.ludo-cell.event-hug { background-color: #ffdab9; }   /* 抱抱 */

.ludo-cell .cell-number {
    font-size: 10px;
    position: absolute;
    top: 2px;
    left: 3px;
    color: rgba(0,0,0,0.2);
}

/* --- 棋子樣式 --- */
.ludo-piece {
    position: absolute;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background-size: cover;
    background-position: center;
    border: 2px solid white;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
    transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
    z-index: 10;
}
.ludo-piece.user { border-color: #87cefa; }
.ludo-piece.char { border-color: #ffc0cb; }

/* --- 遊戲日誌 --- */
#ludo-log-container {
    flex-grow: 1;
    background-color: rgba(255, 255, 255, 0.5);
    border-radius: 10px;
    padding: 10px;
    overflow-y: auto;
    min-height: 0;
}
#ludo-game-log .log-entry {
    padding: 6px 8px;
    font-size: 14px;
    border-bottom: 1px solid rgba(0,0,0,0.05);
    line-height: 1.5;
}
#ludo-game-log .log-entry.system {
    color: #db7093;
    font-style: italic;
    text-align: center;
}
#ludo-game-log .log-entry.user { color: #007bff; }
#ludo-game-log .log-entry.char { color: #e83e8c; }
#ludo-game-log .log-entry strong { font-weight: 900; }


/* --- 操作區與骰子動畫 --- */
#ludo-action-area {
    flex-shrink: 0;
    padding: 10px 0;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 60px;
}
#ludo-dice-container {
    perspective: 1000px;
}
.dice {
    width: 50px;
    height: 50px;
    position: relative;
    transform-style: preserve-3d;
    transition: transform 1s;
    cursor: pointer;
}
.dice.rolling { animation: roll-dice 1.5s ease-out; }
@keyframes roll-dice {
    0% { transform: rotateX(0deg) rotateY(0deg); }
    100% { transform: rotateX(1080deg) rotateY(720deg); }
}
.dice .face {
    position: absolute;
    width: 50px;
    height: 50px;
    border: 1px solid #ccc;
    background: white;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 24px;
    font-weight: bold;
}
.face.front  { transform: rotateY(0deg) translateZ(25px); }
.face.back   { transform: rotateY(180deg) translateZ(25px); }
.face.right  { transform: rotateY(90deg) translateZ(25px); }
.face.left   { transform: rotateY(-90deg) translateZ(25px); }
.face.top    { transform: rotateX(90deg) translateZ(25px); }
.face.bottom { transform: rotateX(-90deg) translateZ(25px); }

/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】飛行棋問題類型標籤樣式 ▼▼▼ */
.question-type-tag {
    font-size: 10px;
    font-weight: bold;
    padding: 3px 8px;
    border-radius: 10px;
    color: white;
    margin-left: 10px;
    flex-shrink: 0;
}
.question-type-tag.both-answer {
    background-color: #ff8fab; /* 粉色代表共同回答 */
}
.question-type-tag.single-answer {
    background-color: #87ceeb; /* 藍色代表一人回答 */
}
/* ▲▲▲ 新樣式黏貼結束 ▲▲▲ */
/* ▼▼▼ 【全新】飛行棋結算卡片樣式 ▼▼▼ */
#ludo-summary-content h3 {
    text-align: center;
    color: var(--accent-color);
    margin-bottom: 15px;
    font-size: 20px;
    font-weight: bold;
}
#ludo-summary-content .ludo-qa-log {
    margin-top: 20px;
    padding-top: 15px;
    border-top: 1px solid var(--border-color);
    max-height: 300px; /* 給問答記錄檔一個最大高度，內容多了可以滾動 */
    overflow-y: auto;
}
#ludo-summary-content h4 {
    margin-bottom: 10px;
    color: var(--text-primary);
}
#ludo-summary-content .qa-item {
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px dashed #eee;
}
#ludo-summary-content .qa-item:last-child {
    border-bottom: none;
}
#ludo-summary-content .qa-question {
    font-weight: 600;
    color: #db7093; /* 一個可愛的粉紫色 */
    margin-bottom: 8px;
}
#ludo-summary-content .qa-answer {
    padding-left: 15px;
    font-size: 14px;
    color: var(--text-secondary);
}
#ludo-summary-content .qa-answer strong {
    color: var(--text-primary);
}
#phone-screen.dark-mode #ludo-summary-content .qa-answer {
    color: #bbb;
}


/* ▼▼▼ 【獨家定制】角色手機消息清單 - 可愛磨砂透明圓角版 v3.0 ▼▼▼ */

/* 1. 給消息清單容器增加內邊距和間距，為卡片留出呼吸空間 */
#character-chat-list.list-container {
    padding: 15px 10px;
    display: flex;
    flex-direction: column;
    gap: 15px; /* “我”的卡片和“其他人”卡片之間的間距 */
}

/* 2. 重置所有清單項的基礎樣式，移除舊的邊框 */
#character-chat-list .chat-list-item {
    border-bottom: none !important;
}

/* 3. 【你的專屬】單獨設置“我的消息”(第一個)的可愛膠囊樣式 */
#character-chat-list > .chat-list-item {
    background-color: rgba(255, 255, 255, 0.1); /* 超級透明的白色背景 */
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 25px; /* 可愛的膠囊圓角 */
    border: 1px solid rgba(255, 255, 255, 0.15); /* 淡淡的亮邊，增加質感 */
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1); /* 柔和的陰影，營造懸浮感 */
    padding: 15px; /* 增加內邊距，讓內容更舒服 */
    color: white; /* 文字顏色也變成白色 */
    text-shadow: 0 1px 2px rgba(0,0,0,0.3); /* 給文字加一點陰影保證清晰度 */
}
#character-chat-list > .chat-list-item .last-msg {
    color: rgba(255, 255, 255, 0.7); /* 預覽消息的文字顏色淡一點 */
}


/* 4. 【你的專屬】設置“其他人消息”容器的樣式 */
.npc-chat-group {
    background-color: rgba(255, 255, 255, 0.1); /* 同樣超級透明 */
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border-radius: 25px; /* 容器本身也是圓角 */
    border: 1px solid rgba(255, 255, 255, 0.15);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    overflow: hidden; /* 關鍵！讓內部的列表項嚴格遵守容器的圓角 */
    padding: 5px 0; /* 容器內部的上下留白 */
}

/* 5. 設置容器內部單個消息的樣式 */
.npc-chat-group .chat-list-item {
    background-color: transparent !important; /* 內部的項完全透明 */
    border-bottom: 1px solid rgba(255, 255, 255, 0.1) !important; /* 用淡淡的亮線分隔 */
    padding: 12px 15px;
    color: white; /* 文字顏色也是白色 */
    text-shadow: 0 1px 2px rgba(0,0,0,0.3);
}
.npc-chat-group .chat-list-item .last-msg {
    color: rgba(255, 255, 255, 0.7);
}

/* 6. 移除容器內【最後一個】消息的底線，讓卡片底部更乾淨 */
.npc-chat-group .chat-list-item:last-child {
    border-bottom: none !important;
}
/* ▲▲▲ 定制結束 ▲▲▲ */



/* ======================================================================= */
/* ===         修復“查手機-外觀設置”中預覽圖過大的問題 v1.0         === */
/* ======================================================================= */

/* 1. 修復手機壁紙和App內壁紙的預覽 */
/* 
   問題原因：之前的樣式是 background-size: cover，會強制圖片填滿預覽框，導致裁剪。
   解決方案：改為 background-size: contain，讓圖片在框內完整顯示。
*/
#char-phone-wallpaper-preview,
#char-phone-app-wallpaper-preview {
    background-size: contain !important; 
    background-repeat: no-repeat !important; /* 防止圖片在無法填滿時重複平鋪 */
}

/* 2. 修復兩個桌面小元件的圖片預覽 */
/* 
   問題原因：和上面類似，但對於<img>標籤，控制顯示方式的屬性是 object-fit。
   解決方案：同樣將 cover 改為 contain。
*/
#char-phone-widget-preview-1,
#char-phone-widget-preview-2 {
    object-fit: contain !important;
    /* (可選美化) 為沒有圖片時的預覽框加個底色，更好看 */
    background-color: #f0f2f5; 
}
/* ======================================================================= */
/* ===         【V2 最終修復】修複查手機-小元件預覽圖過大問題         === */
/* ======================================================================= */

#char-phone-widget-preview-1,
#char-phone-widget-preview-2 {
    background-size: contain !important;      /* 核心：讓背景圖完整顯示 */
    background-repeat: no-repeat !important; /* 防止圖片重複平鋪 */
    background-position: center !important;  /* 確保圖片居中 */
}


/* ▼▼▼ 【獨家定制】心動飛行棋輸入框 - 粉色按鈕版 v1.0 ▼▼▼ */

/* 1. 輸入區域的容器樣式 (保持不變) */
#ludo-action-area {
    display: flex !important;
    flex-direction: row !important;
    align-items: center !important;
    gap: 8px !important;
    padding: 10px 12px !important;
}

/* 2. 文本輸入框的樣式 (保持不變) */
#ludo-action-area #ludo-user-speech-input {
    flex-grow: 1; 
    border: none;
    padding: 10px 15px;
    border-radius: 20px;
    background-color: var(--secondary-bg);
    font-size: 16px;
    resize: none;
    max-height: 100px; 
    line-height: 1.5;
    box-sizing: border-box;
}

/* 3. “確認回答”按鈕的樣式 (已修改為粉色) */
#ludo-action-area .form-button {
    width: auto !important;
    height: 40px; 
    border-radius: 20px;
    padding: 0 20px;
    flex-shrink: 0; 
    font-size: 14px;
    font-weight: 600;
    margin: 0 !important;
    border: none;
    cursor: pointer;
    
    /* ★★★ 核心修改：使用可愛的粉色漸變和陰影 ★★★ */
    background: linear-gradient(135deg, #ff8fab, #fb6f92);
    color: white;
    box-shadow: 0 4px 10px rgba(251, 111, 146, 0.3);
    transition: all 0.2s ease-in-out;
}

/* ★★★ 新增：為按鈕添加更生動的交互效果 ★★★ */
#ludo-action-area .form-button:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(251, 111, 146, 0.4);
}
#ludo-action-area .form-button:active {
    transform: translateY(0) scale(0.98);
    box-shadow: 0 2px 5px rgba(251, 111, 146, 0.3);
}

/* 4. 夜間模式適配 (保持不變) */
#phone-screen.dark-mode #ludo-action-area #ludo-user-speech-input {
    background-color: #2c2c2e;
    color: var(--text-primary);
}
/* ▲▲▲ 美化代碼結束 ▲▲▲ */



    </style>
    <!-- ▼▼▼ 在這裡添加下面這行 ▼▼▼ -->
    <style id="custom-theme-style"></style>
</head>
<body>
        <div id="phone-screen">
            <div id="status-bar">
                <span id="status-bar-time">12:00</span>
                <div id="status-bar-battery" class="battery-container">
                    <span class="battery-text">--%</span>
                    <div class="battery-icon">
                        <div class="battery-level"></div>
                    </div>
                </div>
            </div>
            <div id="notification-bar"><img id="notification-avatar" src=""><div id="notification-content"><div class="name"></div><div class="message"></div></div></div>

<!-- ▼▼▼ 【全新】在這裡黏貼懸浮歌詞欄的代碼 ▼▼▼ -->
<div id="floating-lyrics-bar">
    <span id="floating-lyric-text">♪</span>
    <!-- 【問題4修復】用包含SVG的div替換舊的span -->
    <div id="lyrics-settings-btn" style="cursor: pointer; display: flex; align-items: center; justify-content: center;">
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="3"></circle>
            <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
        </svg>
    </div>
    <span class="close-btn">×</span>
</div>
<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 在這裡黏貼下面這行新代碼 ▼▼▼ -->
<div id="lock-screen-background-blur" style="display: none;"></div>
<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
            
<!-- ▼▼▼ 用下面這【一整塊】修改後的代碼，替換掉你舊的 <div id="home-screen"...>...</div> ▼▼▼ -->
<div id="home-screen" class="screen active">
    
    <!-- 我們用一個滑動容器把頁面包起來 -->
    <div class="home-screen-slider">
        <!-- 這是你的第一頁，我們把原來的內容都放進來 -->
        <div class="home-page">
            <div id="main-content-area">
                <div id="profile-widget">
                    <img id="profile-banner-img" src="https://i.postimg.cc/k495F4W5/profile-banner.jpg" class="editable-image">
                    <!-- ▼▼▼ 用下面這整塊代碼，替換舊的 profile-avatar-container ▼▼▼ -->
<div class="profile-avatar-container">
    <img id="profile-avatar-img" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image">
    <!-- ▼▼▼ 我們在這裡新增了一個用於顯示頭像框的img元素 ▼▼▼ -->
    <img id="profile-avatar-frame" class="weibo-avatar-frame" src="" style="display: none;">
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->

                    <div class="profile-info">
                        <p id="profile-username" class="editable-text">你的昵稱</p>
                        <p id="profile-sub-username" class="editable-text">@your_id</p>
                        <p id="profile-bio" class="editable-text">點擊這裡編輯你的個性簽名</p>
                        <p id="profile-location" class="editable-text" data-placeholder="點擊編輯地點"><svg width="12" height="12" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path></svg><span>點擊編輯地點</span></p>
                    </div>
                </div>
                <div id="desktop-layout">
                    <div id="desktop-widget-column">
                        <div class="custom-widget-container">
                            <div id="widget-bubble-1" class="widget-bubble editable-text" contenteditable="true">點擊編輯文字</div>
                            <div class="widget-circle-uploader">
                                <img id="widget-image-1" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image" title="點擊更換圖片">
                            </div>
                            <div id="widget-subtext-1" class="widget-subtext editable-text" contenteditable="true">點擊編輯文字</div>
                        </div>
                        <div class="custom-widget-container">
                            <div id="widget-bubble-2" class="widget-bubble editable-text" contenteditable="true">點擊編輯文字</div>
                            <div class="widget-circle-uploader">
                                <img id="widget-image-2" src="https://i.postimg.cc/k495F4W5/profile-banner.jpg" class="editable-image" title="點擊更換圖片">
                            </div>
                            <div id="widget-subtext-2" class="widget-subtext editable-text" contenteditable="true">點擊編輯文字</div>
                        </div>
                    </div>
                    <div id="desktop-app-container">
                        <div class="desktop-app-icon" onclick="showScreen('chat-list-screen')"><div class="icon-bg-desktop"><img id="icon-img-qq" src="https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg" alt="QQ"></div><span class="label">QQ</span></div>
                        <div class="desktop-app-icon" onclick="showScreen('world-book-screen')"><div class="icon-bg-desktop"><img id="icon-img-world-book" src="https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg" alt="世界書"></div><span class="label">世界書</span></div>
                        <div id="check-phone-btn" class="desktop-app-icon">
                            <div class="icon-bg-desktop"><img id="icon-img-check-phone" src="https://i.postimg.cc/RVwpwr0r/IMG-8348.jpg" alt="查手機"></div>
                            <span class="label">查手機</span>
                        </div>
                        <div class="desktop-app-icon" id="weibo-app-icon">
                            <div class="icon-bg-desktop"><img id="icon-img-weibo" src="https://i.postimg.cc/PqBY5wBq/weibo-icon.png" alt="微博"></div>
                            <span class="label">微博</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

<!-- 這是我們新增的第二頁，現在是自訂佈局 -->
<div class="home-page">
<!-- 這是左半邊的頭像小組件 -->
<div id="second-page-left-widget" class="custom-widget-container">
    <div class="widget-circle-uploader">
        <img id="widget-image-3" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image" title="點擊更換圖片">
    </div>
    
    <!-- ▼▼▼ 這是我們新增的可編輯膠囊氣泡 ▼▼▼ -->
    <div id="second-page-bubble" class="widget-bubble editable-text" contenteditable="true">
        點擊編輯文字
    </div>
    <!-- ▲▲▲ 新增結束 ▲▲▲ -->
<!-- ▼▼▼ 在這裡添加下面這段全新的HTML代碼 ▼▼▼ -->
<div id="new-bubbles-container">
    <div id="flat-capsule-bubble" class="widget-bubble editable-text" contenteditable="true">可編輯</div>
    <div id="circular-bubble" class="widget-bubble editable-text" contenteditable="true">文字</div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->

</div>
    <!-- 這是右上角的兩個並排圖示 -->
    <div id="second-page-top-right-apps">
        <div class="desktop-app-icon" onclick="showScreen('forum-screen')">
            <div class="icon-bg-desktop"><img id="icon-img-forum" src="https://i.postimg.cc/pr0T3WfC/douban-icon.png" alt="圈子"></div>
            <span class="label">圈子</span>
        </div>
        <div class="desktop-app-icon" id="lovers-space-app-icon">
            <div class="icon-bg-desktop"><img id="icon-img-lovers-space" src="https://i.postimg.cc/d1wZ39xW/lovers-space-icon.png" alt="情侶空間"></div>
            <span class="label">情侶空間</span>
        </div>

<!-- 這是你現在的代碼 -->
<div id="second-page-x-social-app" class="desktop-app-icon" onclick="showScreen('x-social-screen')">
    <div class="icon-bg-desktop"><img id="icon-img-x-social" src="https://i.postimg.cc/8P1H0vQ8/x-logo.png" alt="X社交"></div>
    <span class="label">X社交</span>
</div>



<!-- ▼▼▼ 用下面這整塊【修復後】的代碼，替換掉你舊的 id="center-avatar-wrapper" 的那個 div ▼▼▼ -->
<div id="center-avatar-wrapper">
    <!-- 這是你原來的頭像，我們把它放在了新容器的中心 -->
    <div id="second-page-center-avatar" class="custom-widget-container">
        <div class="widget-circle-uploader">
            <img id="widget-image-4" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image" title="點擊更換圖片">
        </div>
    </div>
    
    <!-- 這是修復後的、頭像下方的可編輯文字框 -->
    <div id="avatar-subtitle" class="editable-text">點擊編輯文字</div>

    <!-- 這是修復後的、頭像四個角的可編輯氣泡 -->
    <div class="corner-bubble editable-text" id="bubble-top-left">左上角</div>
    <div class="corner-bubble editable-text" id="bubble-top-right">右上角</div>
    <div class="corner-bubble editable-text" id="bubble-bottom-left">左下角</div>
    <div class="corner-bubble editable-text" id="bubble-bottom-right">右下角</div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->
 <!-- ▼▼▼ 在第二個 <div class="home-page"> 的閉合標籤前，黏貼下面這段代碼 ▼▼▼ -->
<div style="position: absolute; top: 100px; right: 85px;">
    <div class="desktop-app-icon" onclick="showScreen('game-hall-screen')">
        <div class="icon-bg-desktop">
            <img id="icon-img-game-hall" src="https://i.postimg.cc/P5gL5z2g/game-controller-icon.png" alt="遊戲大廳">
        </div>
        <span class="label">遊戲大廳</span>
    </div>
</div>
<!-- ▲▲▲ 新增圖示代碼結束 ▲▲▲ -->
    </div>
<!-- ▼▼▼ 【這是修改後的版本】請用這整塊代碼，完整替換掉舊的 id="new-custom-widget" ▼▼▼ -->
<div id="new-custom-widget">
    <!-- 我們用一個新的容器把月份和頭像包起來 -->
    <div id="new-widget-header">
        <div id="widget-month-display"></div>
        <img id="new-widget-avatar" src="https://i.postimg.cc/qRqpK5kP/anime-avatar.jpg" class="editable-image">
    </div>
    <div id="new-widget-text-1" class="new-widget-text editable-text" contenteditable="true">可編輯文字</div>
    <div class="new-widget-divider"></div>
    <div id="new-widget-text-2" class="new-widget-text editable-text" contenteditable="true">可編輯文字</div>
    <div class="new-widget-divider"></div>
    <div id="new-widget-text-3" class="new-widget-text editable-text" contenteditable="true">可編輯文字</div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->
<!-- ▼▼▼ 把下面這一整塊【全新的代碼】，黏貼到第二個 <div class="home-page"> 的【內部】最底部 ▼▼▼ -->
<!-- 這是我們新增的“桃寶”App圖示 -->
<div style="position: absolute; bottom: 75px; left: 35px;">
    <div class="desktop-app-icon" id="taobao-app-icon">
        <div class="icon-bg-desktop"><img id="icon-img-taobao" src="https://i.postimg.cc/k47tXg1j/taologo.png" alt="桃寶"></div>
        <span class="label" style="color: white; text-shadow: 0 1px 3px rgba(0,0,0,0.5);">桃寶</span>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->


<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
</div>
    </div>
    
    <!-- 底部 Dock 欄保持不變 -->
    <div id="desktop-dock">
        <div class="desktop-app-icon" onclick="showScreen('api-settings-screen')"><div class="icon-bg-desktop"><img id="icon-img-api-settings" src="https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg" alt="API設置"></div><span class="label">API設置</span></div>
        <div class="desktop-app-icon" onclick="showScreen('font-settings-screen')"><div class="icon-bg-desktop"><img id="icon-img-font" src="https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg" alt="字體"></div><span class="label">字體</span></div>
        <div class="desktop-app-icon" onclick="showScreen('wallpaper-screen')">
            <div class="icon-bg-desktop"><img id="icon-img-wallpaper" src="https://i.postimg.cc/T1j03pQr/IMG-6440.jpg" alt="外觀設置"></div>
            <span class="label">外觀設置</span>
        </div>
    </div>

    <!-- 這是我們新增的小圓點 -->
    <div class="pagination-dots">
        <span class="dot active"></span>
        <span class="dot"></span>
    </div>
</div>
<!-- ▲▲▲ HTML 替換結束 ▲▲▲ -->

<!-- ▼▼▼ 用下面這【一整塊功能最全】的代碼，完整替換掉你舊的 id="weibo-screen" 的整個 div ▼▼▼ -->
<div id="weibo-screen" class="screen">
    <!-- 這個容器將存放微博的所有頁面 -->
    <div id="weibo-page-container">

        <!-- 頁面1: 我的首頁 (已改造) -->
        <div id="weibo-my-profile-view" class="weibo-view active">
            <!-- 頭部 -->
            <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
                <span>我的首頁</span>
                <div class="header-actions">
                    <!-- 【核心修改】我們在這裡新增了一個“編輯”按鈕 -->
                    <span class="action-btn" id="edit-weibo-profile-btn" title="編輯資料">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 20h9"></path>
                            <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                        </svg>
                    </span>
                    <span class="action-btn" id="create-weibo-post-btn" style="font-size: 28px; font-weight: 300;">+</span>
                </div>
            </div>
            <!-- 主頁內容區 -->
            <div id="weibo-profile-page">
                <div class="weibo-profile-header">
                    <img id="weibo-background-img" src="https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg" class="weibo-background">
                  <!-- ▼▼▼ 用下面這整塊代碼，替換舊的 weibo-avatar-container ▼▼▼ -->
<div class="weibo-avatar-container">
    <img id="weibo-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" class="weibo-avatar">
    <!-- ▼▼▼ 我們在這裡新增了一個用於顯示頭像框的img元素 ▼▼▼ -->
    <img id="weibo-avatar-frame" class="weibo-avatar-frame" src="" style="display: none;">
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->

                    <div class="weibo-nickname" id="weibo-nickname">你的昵稱</div>
                    <!-- 【核心修改】在這裡新增一個顯示職業的地方 -->
                    <!-- ▼▼▼ 用這行新代碼替換掉舊的 ▼▼▼ -->
<div id="weibo-user-profession-display">點擊設置職業</div>

                    <div class="weibo-stats">
                        <div id="weibo-following-btn" class="weibo-stat-item">
                            <span id="weibo-following-count" class="weibo-stat-number">0</span>
                            <span class="weibo-stat-label">關注</span>
                        </div>
                        <div id="weibo-posts-item" class="weibo-stat-item">
                            <span id="weibo-posts-count" class="weibo-stat-number">0</span>
                            <span class="weibo-stat-label">微博</span>
                        </div>
                        <div id="weibo-fans-item" class="weibo-stat-item">
                            <span id="weibo-fans-count" class="weibo-stat-number">0</span>
                            <span class="weibo-stat-label">粉絲</span>
                        </div>
                    </div>
                </div>
                <div id="my-weibo-feed-list" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
                    <!-- “我的微博”清單將由JS動態生成在這裡 -->
                </div>
            </div>
        </div>

        <!-- 頁面2: 關注的人 (保持不變) -->
        <div id="weibo-following-view" class="weibo-view">
            <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
                <span>關注的人</span>
                <span class="action-btn" id="clear-following-feed-btn" style="font-size: 16px; font-weight: 500;">清空</span>
            </div>
            <div id="weibo-following-feed-list" style="flex-grow: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 15px;">
                <!-- 關注的人的微博清單將由JS動態生成在這裡 -->
            </div>
        </div>
        
        <!-- 頁面3: 熱搜 (保持不變) -->
        <div id="weibo-hot-search-view" class="weibo-view">
             <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
                <span>熱搜</span>
                <div class="header-actions">
                    <span class="action-btn" id="generate-hot-search-btn" title="生成熱搜">
                        <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                    </span>
                </div>
            </div>
            <div id="weibo-hot-search-list" style="flex-grow: 1; overflow-y: auto;">
                <p style="text-align:center; color: #8a8a8a; margin-top: 50px;">點擊右上角放大鏡生成熱搜</p>
            </div>
        </div>

        <!-- 頁面4: 廣場 (保持不變) -->
        <div id="weibo-plaza-view" class="weibo-view">
            <div class="header">
                <span class="back-btn" onclick="showScreen('home-screen')"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
                <span>廣場</span>
                <div class="header-actions">
                    <span class="action-btn" id="generate-plaza-feed-btn" title="生成廣場動態">
                        <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>
                    </span>
                </div>
            </div>
            <div id="weibo-plaza-feed-list" style="flex-grow: 1; overflow-y: auto; padding: 0;">
                 <p style="text-align:center; color: #8a8a8a; margin-top: 50px;">點擊右上角放大鏡生成廣場動態</p>
            </div>
        </div>

        <!-- 頁面5: 熱搜詳情頁 (保持不變) -->
        <div id="weibo-hottopic-feed-view" class="weibo-view">
            <div class="header">
                <span class="back-btn" id="back-from-hottopic-btn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg></span>
                <span id="weibo-hottopic-title">熱搜話題</span>
                <div class="header-actions">
                     <span class="action-btn" id="refresh-hottopic-feed-btn" title="換一批">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
                    </span>
                </div>
            </div>
            <div id="weibo-hottopic-feed-list" style="flex-grow: 1; overflow-y: auto; padding: 0;">
                <!-- 熱搜微博清單將由JS動態生成 -->
            </div>
        </div>
    </div>

    <!-- 底部巡覽列 -->
    <div id="weibo-bottom-nav">
        <div class="weibo-nav-item" data-view="weibo-hot-search-view">熱搜</div>
        <div class="weibo-nav-item" data-view="weibo-plaza-view">廣場</div>
        <div class="weibo-nav-item" data-view="weibo-following-view">關注的人</div>
        <div class="weibo-nav-item active" data-view="weibo-my-profile-view">我的微博</div>
    </div>
</div>
<!-- ▲▲▲ HTML 替換結束 ▲▲▲ -->
   
<!-- ▼▼▼ 請用這整塊【最終版】代碼，完整替換掉你舊的 id="world-book-screen" 的 div ▼▼▼ -->
<div id="world-book-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>世界書</span>
        <div class="header-actions">
            
            <!-- ★★★ 核心修改就在這裡 ★★★ -->
            <!-- 我們把 "導入" 兩個字，換成了一段SVG代碼，並加上了 title 提示 -->
            <span class="action-btn" id="import-world-book-btn" title="導入世界書">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="17 8 12 3 7 8"></polyline>
                    <line x1="12" y1="3" x2="12" y2="15"></line>
                </svg>
            </span>
            <!-- ▲▲▲ 修改結束 ▲▲▲ -->

            <span class="action-btn" id="manage-world-book-categories-btn">管理分類</span>
            <span class="action-btn" id="add-world-book-btn">+</span>
        </div>
    </div>
    <div id="world-book-list"></div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->


            <div id="world-book-editor-screen" class="screen">
                <div class="header">
                    <span class="back-btn" onclick="showScreen('world-book-screen')">‹</span>
                    <span id="world-book-editor-title">編輯世界書</span>
                    <span class="save-btn" id="save-world-book-btn">保存</span>
                </div>
                <div class="form-container">
                    <div class="form-group">
                        <label for="world-book-name-input">書名</label>
                        <input type="text" id="world-book-name-input" placeholder="請輸入世界書的名稱...">
                    </div>

        <!-- ▼▼▼ 【全新】在這裡添加分類選擇 ▼▼▼ -->
        <div class="form-group">
            <label for="world-book-category-select">分類</label>
            <select id="world-book-category-select">
                <!-- 選項將由JS動態生成 -->
            </select>
        </div>
        <!-- ▲▲▲ 添加結束 ▲▲▲ -->

                    <div class="form-group" style="height: 100%;">
                        <label for="world-book-content-input">內容</label>
                        <textarea id="world-book-content-input" placeholder="在此處輸入詳細的世界觀設定..."></textarea>
                    </div>
                </div>
            </div>

            <div id="api-settings-screen" class="screen"><div class="header"><span class="back-btn" onclick="showScreen('home-screen')">‹</span><span>API 設置</span><span style="width: 30px;"></span></div><div class="form-container"><p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;">提示: 若要使用“發送圖片”功能, 請務必選擇支援Vision(視覺)的模型, 如<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4o</code>或<code style="background-color: #e0e0e0; padding: 2px 4px; border-radius: 4px;">gpt-4-vision-preview</code>。</p>
</div><div class="form-group"><label for="api-url">API 地址（后缀不用添加/v1）</label><input type="url" id="api-url" name="url" placeholder="选择服务商可自动填写" required></div><div class="form-group"><label for="api-key">密钥 (Key)</label><input type="password" id="api-key" name="key" placeholder="请输入你的API密钥" required></div><button type="button" class="btn btn-secondary" id="fetch-models-btn"><span class="btn-text">点击拉取模型</span><div class="spinner"></div></button><div class="form-group"><label for="api-model">选择模型</label><select id="api-model" name="model" required><option value="">请先拉取模型列表</option></select></div>
<div class="form-group"><label for="api-key">金鑰 (直連輪詢用英文逗號隔開)</label><input type="password" id="api-key" placeholder="sk-..."></div><div class="form-group"><label for="model-select">模型</label><select id="model-select"></select></div>
<!-- ▼▼▼ 請將這段【全新的HTML代碼】黏貼到 “模型” 下拉清單的 form-group 之後 ▼▼▼ -->
<div class="form-group">
    <label>API 預設</label>
    <div class="bubble-preset-manager"> <!-- 複用現有樣式 -->
        <select id="api-preset-select" class="form-group select"></select>
        <button id="manage-api-presets-btn" class="action-btn">管理</button>
    </div>
</div>
<!-- ▲▲▲ 新代碼黏貼結束 ▲▲▲ -->
<button class="form-button" id="fetch-models-btn">拉取模型</button>

<!-- ▼▼▼ 從這裡開始，是全新的後臺活動設置區 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">

<!-- 1. 總開關 -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
    <label for="background-activity-switch" style="margin-bottom: 0;">
        啟用後臺角色活動 (總開關)
        <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px;">
            警告：開啟後會顯著增加API調用和費用！
        </p>
    </label>
    <!-- 【重要】我們把原來的 checkbox 換成了更美觀的 iOS 風格開關 -->
    <label class="toggle-switch">
        <input type="checkbox" id="background-activity-switch">
        <span class="slider"></span>
    </label>
</div>

<!-- 2. 後臺活動詳細設置 (預設隱藏，由總開關控制) -->
<div id="background-activity-details" style="display: none;">
    <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
        <label for="background-interval-input" style="margin-bottom: 0;">
            後臺活動檢測間隔 (秒)
            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                建議值 60-300。值越大，費用越低，但角色反應越慢。
            </p>
        </label>
        <input type="number" id="background-interval-input" min="30" value="60" style="width: 80px; text-align: center;">
    </div>

    <!-- 3. 角色選擇與頻率設置 -->
    <div class="form-group">
        <label>設置角色活動頻率</label>
        <div id="background-activity-char-list" style="max-height: 150px; overflow-y: auto; background: #f9f9f9; padding: 10px; border-radius: 8px; border: 1px solid var(--border-color);">
            <!-- 角色清單將由JS動態生成在這裡 -->
        </div>
        <div style="display: flex; gap: 10px; margin-top: 10px;">
            <button id="bg-select-all-chars" class="form-button-secondary" style="flex:1; margin:0;">全選</button>
            <button id="bg-deselect-all-chars" class="form-button-secondary" style="flex:1; margin:0;">全不選</button>
        </div>
    </div>

    <div class="form-group">
    <label>為選中角色設置頻率</label>
    <div style="display: flex; gap: 10px;">
        <button class="form-button-secondary bg-freq-btn" data-freq="low" style="flex:1; margin:0; border-color: #28a745;">低</button>
        <button class="form-button-secondary bg-freq-btn" data-freq="medium" style="flex:1; margin:0; border-color: #fd7e14;">中</button>
        <button class="form-button-secondary bg-freq-btn" data-freq="high" style="flex:1; margin:0; border-color: #dc3545;">高</button>
        <!-- ▼▼▼ 就是新增了這個“關閉”按鈕 ▼▼▼ -->
        <button class="form-button-secondary bg-freq-btn" data-freq="none" style="flex:1; margin:0; border-color: #aaa;">關閉</button>
    </div>
    <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 8px;">
        頻率越高，角色主動行為的概率越大，費用也越高。
    </p>
</div>
</div>
<!-- ▲▲▲ 全新的後臺活動設置區結束 ▲▲▲ -->


<!-- ▼▼▼ 在這裡新增 ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
    <label for="block-cooldown-input" style="margin-bottom: 0;">
        AI被拉黑後冷靜期 (小時)
        <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
            被拉黑超過這個時間後，AI才有幾率重新申請好友。
        </p>
    </label>
    <input type="number" id="block-cooldown-input" min="0.1" step="0.1" value="1" style="width: 80px; text-align: center;">
</div>
<!-- ▲▲▲ 新增結束 ▲▲▲ -->
<!-- ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼ -->
<hr style="margin:20px 0; opacity:.3">
<p style="font-size: 14px; color: #666; background-color: #f0f0f0; padding: 10px; border-radius: 8px;">以下是 Minimax 語音（TTS）的設置，用於AI發送語音訊息。</p>
<div class="form-group">
    <label for="minimax-group-id">Minimax Group ID</label>
    <input type="text" id="minimax-group-id" placeholder="輸入你的 Minimax Group ID">
</div>
<div class="form-group">
    <label for="minimax-api-key">Minimax API Key</label>
    <input type="password" id="minimax-api-key" placeholder="輸入你的 Minimax API Key">
</div>
<hr style="margin:20px 0; opacity:.3">
<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
<button class="form-button" id="save-api-settings-btn">保存設置</button>
			<hr style="margin:20px 0; opacity:.3">

			<button class="form-button" id="export-data-btn">匯出數據</button>

<!-- ① 普通按鈕，和“匯出”一個 class -->
<button class="form-button" id="import-btn">導入備份檔案</button>

<!-- ② 真正的檔選擇器，完全隱藏 -->
<input id="import-data-input" type="file" accept="application/json" hidden>
</div></div>
<!-- ▼▼▼ 用下面這段代碼，完整替換掉你原來的 chat-list-screen ▼▼▼ -->
<div id="chat-list-screen" class="screen">
    
    <!-- 主頭部 (只在消息清單顯示) -->
    <div class="header" id="main-chat-list-header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
<span id="chat-list-title">消息</span>
        <div class="header-actions">
            <span class="action-btn" id="add-group-chat-btn" title="創建群聊"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17.5 17.5C19.1569 17.5 20.5 16.1569 20.5 14.5C20.5 12.8431 19.1569 11.5 17.5 11.5C15.8431 11.5 14.5 12.8431 14.5 14.5C14.5 16.1569 15.8431 17.5 17.5 17.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M21 21L19 19" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M8.5 11.5C10.1569 11.5 11.5 10.1569 11.5 8.5C11.5 6.84315 10.1569 5.5 8.5 5.5C6.84315 5.5 5.5 6.84315 5.5 8.5C5.5 10.1569 6.84315 11.5 8.5 11.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M12.5 14.5H4.5C3.39543 14.5 2.5 15.3954 2.5 16.5V18.5H12.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></span>
            <!-- ▼▼▼ 這是我們新加的導入按鈕 ▼▼▼ -->
<span class="action-btn" id="import-character-card-btn" title="導入角色卡">
    <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
        <polyline points="17 8 12 3 7 8"></polyline>
        <line x1="12" y1="3" x2="12" y2="15"></line>
    </svg>
</span>
<!-- ▲▲▲ 導入按鈕結束 ▲▲▲ -->
            <span class="action-btn" id="add-chat-btn">+</span>
        </div>
    </div>

    <!-- 消息清單視圖 -->
    <div id="messages-view" class="chat-list-view active">
        <div id="chat-list">
            <!-- JS會在這裡生成聊天列表 -->
        </div>
    </div>

    <!-- 動態介面視圖 -->
    <div id="qzone-screen" class="chat-list-view">
        <div class="qzone-header">
            <span class="back-btn" id="qzone-back-btn">‹</span> <!-- 這個按鈕現在只負責從動態返回 -->
            <span>好友動態</span>
        </div>
        <div class="qzone-content">
            <div class="qzone-profile-header">
                <div id="qzone-banner-container" class="qzone-banner-container">
                    <img id="qzone-banner-img" src="https://files.catbox.moe/r5heyt.gif" alt="背景">
                    <input type="file" id="qzone-banner-input" accept="image/*" hidden>
                </div>
                <div class="qzone-user-info">
                    <div id="qzone-avatar-container" class="qzone-avatar-container">
                        <img id="qzone-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" alt="頭像">
                        <input type="file" id="qzone-avatar-input" accept="image/*" hidden>
                    </div>
                    <span id="qzone-nickname">{{user}}</span>
                </div>
            </div>
            <div class="qzone-actions-bar">
                <div class="action-item" id="create-shuoshuo-btn"><span>說說</span></div>
                <div class="action-item" id="create-post-btn"><span>動態</span></div>
                <div class="action-item" id="open-album-btn"><span>相冊</span></div>
            </div>
            <div id="qzone-posts-list"></div>
        </div>
    </div>

    <!-- 收藏介面視圖 -->
    <div id="favorites-view" class="chat-list-view">
    <div class="header"> 
        <span class="back-btn" id="favorites-back-btn">‹</span>
        <span>我的收藏</span>
        <!-- 新增的編輯按鈕 -->
        <span class="action-btn" id="favorites-edit-btn">編輯</span>
    </div>

        <!-- 【新增】搜索欄容器 -->
        <div class="search-bar-container">
            <input type="search" id="favorites-search-input" placeholder="搜索收藏的標題、內容或作者...">
            <button id="favorites-search-clear-btn" class="search-clear-btn" style="display: none;">×</button>
        </div>

        <div id="favorites-list" class="list-container">
            <!-- 收藏內容將由JS動態生成在這裡 -->
        </div>

<!-- 新增：收藏頁底部操作欄 -->
<div id="favorites-action-bar" style="display: none;">
    <button id="favorites-delete-selected-btn" class="action-bar-btn">刪除 (0)</button>
</div>

    </div>

<!-- ▼▼▼ 【全新】回憶錄介面視圖 ▼▼▼ -->
<div id="memories-view" class="chat-list-view">
    <div class="header"> 
        <span class="back-btn" id="memories-back-btn">‹</span>
        <span>我們的回憶</span>
            <span class="action-btn" id="add-countdown-btn">+</span>
        </div>
    <div id="memories-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
        <!-- 回憶卡片將由JS動態生成在這裡 -->
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->

   
    <!-- 底部巡覽列 -->
<div id="chat-list-bottom-nav">
    <div class="nav-item active" data-view="messages-view">
        <span>消息</span>
    </div>
    <div class="nav-item" data-view="qzone-screen">
        <span>動態</span>
    </div>
    <!-- ▼▼▼ 在“動態”和“收藏”之間，加入這個新頁簽 ▼▼▼ -->
    <div class="nav-item" data-view="memories-view">
        <span>回憶</span>
    </div>
    <!-- ▲▲▲ 添加結束 ▲▲▲ -->
    <div class="nav-item" data-view="favorites-view">
        <span>收藏</span>
    </div>
</div>
</div>
<!-- ▲▲▲ 替換區域結束 ▲▲▲ -->

<!-- ▼▼▼ 請將這段新的 HTML 黏貼到 id="chat-list-screen" 的 div 之後 ▼▼▼ -->
<div id="album-screen" class="screen">
    <!-- 1. 頁面頭部，包含返回按鈕和標題 -->
    <div class="header">
        <span class="back-btn" id="album-back-btn">‹</span>
        <span>我的相冊</span>
        <span class="action-btn" id="create-album-btn-page">+</span>
    </div>
    
    <!-- 2. 頁面內容容器 -->
    <div class="list-container">
        <div id="album-grid-page">
            <!-- 相簿清單將由 JS 動態生成在這裡 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 新的 HTML 黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 請將這段新的 HTML 黏貼到 id="album-screen" 的 div 之後 ▼▼▼ -->
<div id="album-photos-screen" class="screen">
    <!-- 1. 頁面頭部 -->
    <div class="header">
        <span class="back-btn" id="album-photos-back-btn">‹</span>
        <span id="album-photos-title">相冊名稱</span>
        <span class="action-btn" id="album-upload-photo-btn">上傳</span>
    </div>
    
    <!-- 2. 頁面內容容器 -->
    <div class="list-container">
        <div id="photos-grid-page">
            <!-- 照片清單將由 JS 動態生成在這裡 -->
        </div>

<!-- ▼▼▼ 請將這段新的 HTML 黏貼到所有模態框的末尾 ▼▼▼ -->
<div id="photo-viewer-modal" class="modal">
    <!-- 1. 關閉按鈕 -->
    <button id="photo-viewer-close-btn">×</button>
    
    <!-- 2. 上一張照片按鈕 -->
    <button id="photo-viewer-prev-btn" class="nav-arrow">‹</button>
    
    <!-- 3. 圖片容器 -->
    <div class="photo-viewer-content">
        <img id="photo-viewer-image" src="" alt="全屏照片預覽">
    </div>
    
    <!-- 4. 下一張照片按鈕 -->
    <button id="photo-viewer-next-btn" class="nav-arrow">›</button>
</div>
<!-- ▲▲▲ 新的 HTML 黏貼結束 ▲▲▲ -->

    </div>
</div>
<!-- ▲▲▲ 新的 HTML 黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 黏貼到 #album-photos-screen 的 div 之後 ▼▼▼ -->
<input type="file" id="album-photo-input" accept="image/*" multiple hidden>
            
<!-- ▼▼▼ 請用這【一整塊】全新的代碼，完整替換掉您檔中舊的 #chat-interface-screen 及其所有內容 ▼▼▼ -->
<div id="chat-interface-screen" class="screen">

<div class="header">
    <!-- 預設控制項：包含標題、狀態列和常規按鈕 -->
    <div class="default-controls">
        <span class="back-btn" id="back-to-list-btn">‹</span>
        
        <!-- 標題和狀態的容器 -->
        <div id="chat-header-title-wrapper">
            <div id="chat-header-main-line">
                <span id="chat-header-title">聊天對象</span>
            </div>
            <div id="chat-header-status">
                <span class="status-dot"></span>
                <span class="status-text">線上</span>
            </div>
        </div>

        <div class="header-actions">
            <!-- 【正確位置】心聲按鈕在這裡 -->
            <span class="action-btn" id="char-heart-btn" title="心聲" style="display: none; cursor: pointer;">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="#ff4d6d" stroke="#ffc3d0" stroke-width="1.5">
                    <path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/>
                </svg>
            </span>
            <span class="action-btn" id="listen-together-btn" title="一起聽"><img src="https://i.postimg.cc/dV8sdNcx/210-20250618115221.png" alt="一起聽"></span>
            <span class="action-btn" id="chat-settings-btn" title="聊天設置"><img src="https://i.postimg.cc/bvPq64cv/CCA834-BA-5-A90-408-D-94-FA-7-EE156-B6-A765.png" alt="設置"></span>
        </div>
    </div>

    <!-- 多選模式控制項 -->
    <div class="selection-controls">
        <span id="selection-cancel-btn">取消</span>
        <span id="selection-count"></span>
        <div class="header-actions">
           <span id="selection-favorite-btn" class="action-btn">收藏</span>
           <span id="selection-share-btn" class="action-btn">分享</span> 
           <span id="selection-delete-btn" class="action-btn" style="color: #ff3b30;">刪除</span>
        </div>
    </div>
</div>
<!-- ▼▼▼ 在 #chat-interface-screen 內，header 的 div 之後添加 ▼▼▼ -->

<div id="chat-pet-container" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0; pointer-events: none; z-index: 10;">
    <div id="chat-pet" style="display: none; position: absolute; cursor: grab; user-select: none; pointer-events: all; font-size: 80px; line-height: 1; text-align: center;">
        <!-- 寵物會顯示在這裡 -->
    </div>
</div>

<!-- ▲▲▲ 添加結束 ▲▲▲ -->

    <!-- 聊天消息區域 (保持不變) -->
    <div id="chat-messages"><div id="typing-indicator">對方正在輸入...</div></div>

    <!-- 輸入區域 (這是修改後的最終版本) -->
    <div id="chat-input-area">
        <div id="reply-preview-bar">
            <div class="reply-preview-content">
                <div class="sender">回復 xxx:</div>
                <div class="text">被引用的消息內容...</div>
            </div>
            <span id="cancel-reply-btn">×</span>
        </div>
        <div id="chat-input-actions-top">
            <button id="open-sticker-panel-btn" class="chat-action-icon-btn action-button" title="表情面板"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                <line x1="12" y1="5" x2="12" y2="19"></line>
                <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg></button>
            
            <!-- “重新生成回復”按鈕的新家 -->
            <button id="reroll-btn" class="action-button" title="重新生成回復"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="23 4 23 10 17 10"></polyline>
                <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
            </svg></button>
            
            <button id="send-photo-btn" class="chat-action-icon-btn action-button" title="發送照片"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg></button>
            <button id="upload-image-btn" class="chat-action-icon-btn action-button" title="上傳圖片"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" ><path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></button>
            <button id="transfer-btn" class="chat-action-icon-btn action-button" title="轉帳">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M7 4L12 12L17 4M12 12V20M8 10H16M8 13H16"></path>
            </svg>
            </button>
            <button id="voice-message-btn" class="chat-action-icon-btn action-button" title="發送語音"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><path d="M12 19v4"/><path d="M8 23h8"/></svg></button>
            <button id="send-waimai-request-btn" class="chat-action-icon-btn action-button" title="發起外賣請求"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"/><line x1="3" y1="6" x2="21" y2="6"/><path d="M16 10a4 4 0 0 1-8 0"/></svg></button>
            <button id="video-call-btn" class="chat-action-icon-btn action-button" title="視頻通話"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg></button>
            <button id="group-video-call-btn" class="chat-action-icon-btn action-button" title="群視頻通話"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg></button>
            <button id="send-poll-btn" class="chat-action-icon-btn action-button" title="發起投票"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 6h10"/><path d="M6 6h.01"/><path d="M8 12h10"/><path d="M6 12h.01"/><path d="M8 18h10"/><path d="M6 18h.01"/></svg></button>
            <button id="share-link-btn" class="chat-action-icon-btn action-button" title="分享連結"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg></button>
            <button id="send-location-btn" class="chat-action-icon-btn action-button" title="發送定位">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                    <circle cx="12" cy="10" r="3"></circle>
                </svg>
            </button>
<!-- ▼▼▼ 用下面這整塊代碼，替換你原來的那個 <button id="open-tarot-btn">...</button> ▼▼▼ -->
<button id="open-tarot-btn" class="chat-action-icon-btn action-button" title="塔羅占卜">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <!-- 背景左側卡牌 -->
        <path d="M7 6.5L4 7.5V17.5L7 16.5V6.5Z" stroke="currentColor" stroke-width="2.6" stroke-linejoin="round"/>
        <!-- 背景右側卡牌 -->
        <path d="M17 6.5L20 7.5V17.5L17 16.5V6.5Z" stroke="currentColor" stroke-width="2.6" stroke-linejoin="round"/>
        <!-- 前方中心卡牌 -->
        <rect x="7" y="5" width="10" height="15" rx="1.5" stroke="currentColor" stroke-width="2.6"/>
        <!-- 中心卡牌的星星 -->
        <path d="M12 9.5L13.12 11.79L15.61 12.17L13.8 13.92L14.24 16.4L12 15.2L9.76 16.4L10.2 13.92L8.39 12.17L10.88 11.79L12 9.5Z" fill="currentColor"/>
    </svg>
</button>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->

<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
<!-- ▼▼▼ 【歪頭殺·滿分可愛貓】請用這塊代碼替換舊的寵物按鈕 <button> ▼▼▼ -->
<button id="pet-action-btn" class="chat-action-icon-btn action-button" title="我的寵物">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <!-- 主體輪廓: 耳朵不對稱，營造歪頭效果 -->
        <path d="M3.5 14.5C3.5 20.5 20.5 20.5 20.5 14.5C20.5 9 17.5 5.5 12.5 8.7C6.5 4.5 3.5 9 3.5 14.5Z" stroke="currentColor" stroke-width="2.6" stroke-linecap="round" stroke-linejoin="round"/>
        <!-- 眼睛 -->
        <circle cx="8.5" cy="15" r="1.5" fill="currentColor"/>
        <circle cx="15.5" cy="15" r="1.5" fill="currentColor"/>
        <!-- 左邊兩根小鬍鬚 -->
        <path d="M4.5 14.3L2.5 13.3" stroke="currentColor" stroke-width="2.6" stroke-linecap="round"/>
        <path d="M4.5 15.7L2.5 16.7" stroke="currentColor" stroke-width="2.6" stroke-linecap="round"/>
        <!-- 右邊兩根小鬍鬚 -->
        <path d="M19.5 14.3L21.5 13.3" stroke="currentColor" stroke-width="2.6" stroke-linecap="round"/>
        <path d="M19.5 15.7L21.5 16.7" stroke="currentColor" stroke-width="2.6" stroke-linecap="round"/>
    </svg>
</button>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->





        </div>
        <div id="chat-input-main-row">
            <textarea id="chat-input" rows="1" placeholder="輸入消息..."></textarea>
            <div id="input-actions-wrapper">
                <button id="wait-reply-btn" title="等待回復"><img src="https://i.postimg.cc/q72zq80N/ECE92-BBC-BE57-48-E9-BB2-C-345-B6019-C4-B2.png" alt="等待回復"></button>
                <button id="send-btn" class="action-button">發送</button>
            </div>
        </div>
    </div>
<!-- ▼▼▼ 在這裡新增 ▼▼▼ -->
<div id="chat-lock-overlay">
    <div id="chat-lock-content"></div>
</div>
<!-- ▲▲▲ 新增結束 ▲▲▲ -->

    <!-- 表情面板 (保持不變) -->
    <div id="sticker-panel">
        <div id="sticker-panel-header">
            <span class="panel-btn" id="close-sticker-panel-btn">取消</span>
            <span class="title">表情包</span>
            <div style="display: flex; gap: 10px;">
              <span class="panel-btn" id="add-sticker-btn">添加</span>
              <span class="panel-btn" id="upload-sticker-btn">上傳</span>
            </div>
        </div>
        <div id="sticker-grid"></div>
    </div>
<input type="file" id="sticker-upload-input" accept="image/*" style="display: none;" multiple>
    <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
    
    <!-- 音樂播放機 (保持不變) -->
<div id="music-player-overlay">
<div class="music-player-window">
    <!-- 1. 頂部頭像區域 -->
    <div id="music-avatars-container">
        <img id="music-char-avatar" src="" alt="角色頭像">
        <svg id="heartbeat-line" viewBox="0 0 80 30">
            <path class="heartbeat-path" d="M 5 15 Q 20 0 30 15 T 55 15 L 75 15"></path>
            <path class="heartbeat-heart" d="M 0 -2 a 2 2 0 0 1 4 0 v 2 a 2 2 0 0 1 -4 0 z"></path>
        </svg>
        <img id="music-user-avatar" src="" alt="用戶頭像">
    </div>
    
    <!-- ▼▼▼ 【核心修改】我們把這行文字移到了這裡 ▼▼▼ -->
    <div id="music-time-counter">已經一起聽了0.0小時</div>

    <!-- 2. 頂部操作按鈕 -->
    <div class="music-player-top-actions">
        <div class="top-left-cluster">
            <button id="music-return-btn">‹</button>
            <button id="music-exit-btn">×</button>
        </div>
        <span id="music-playlist-btn">☰</span>
    </div>

    <!-- 3. 封面和歌詞的切換容器 -->
    <div id="music-display-area">
        <img id="music-album-cover" src="https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png" alt="歌曲封面">
        <div id="music-lyrics-container">
            <div id="music-lyrics-list">
                <div class="lyric-line">♪ 暫無歌詞 ♪</div>
            </div>
        </div>
    </div>

    <!-- 4. 歌曲信息 -->
    <div id="music-player-song-title">請添加歌曲</div>
    <div id="music-player-artist">...</div>
    
    <!-- 5. 播放控制區 (保持不變) -->
    <div class="music-player-controls-wrapper">
        <div class="music-progress-bar-container">
            <div id="music-current-time" class="time-display">0:00</div>
            <div class="progress-bar">
                <div id="music-progress-fill" class="progress-bar-fill"></div>
            </div>
            <div id="music-total-time" class="time-display">0:00</div>
        </div>
        <div class="music-controls">
            <button id="music-prev-btn">◀</button>
            <button id="music-play-pause-btn" class="play-pause-btn">▶</button>
            <button id="music-next-btn">▶</button>
            <button id="music-mode-btn">順序</button>
            <button id="toggle-lyrics-bar-btn" title="桌面歌詞">懸浮</button>
        </div>
    </div>
</div>

    </div>
</div>
    
<!-- ▼▼▼ 請用這【一整塊】全新的代碼，替換掉你舊的 id="music-playlist-panel" 及其所有內部內容 ▼▼▼ -->
<div id="music-playlist-panel">
<!-- ▼▼▼ 用這整塊代碼替換 ▼▼▼ -->
<div class="playlist-header">
    <span class="panel-btn" id="close-playlist-btn">返回</span>
    <span>播放清單</span>
    <div>
        <!-- ▼▼▼ 我們把垃圾桶圖示移到了'本地'的左邊 ▼▼▼ -->
        <span class="panel-btn" id="delete-expired-songs-btn" title="清理失效的搜索歌曲">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M3 6H5H21" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M8 6V4C8 3.46957 8.21071 2.96086 8.58579 2.58579C8.96086 2.21071 9.46957 2 10 2H14C14.5304 2 15.0391 2.21071 15.4142 2.58579C15.7893 2.96086 16 3.46957 16 4V6M19 6V20C19 20.5304 18.7893 21.0391 18.4142 21.4142C18.0391 21.7893 17.5304 22 17 22H7C6.46957 22 5.96086 21.7893 5.58579 21.4142C5.21071 21.0391 5 20.5304 5 20V6H19Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </span>
        <span class="panel-btn" id="add-song-local-btn">本地</span>
        <span class="panel-btn" id="add-song-url-btn">URL</span>
        <span class="panel-btn" id="add-song-search-btn">搜索</span>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->


        <div class="playlist-body" id="playlist-body"></div>
    </div>
    <input type="file" id="local-song-upload-input" accept="audio/*" multiple style="display: none;">
<input type="file" id="lrc-upload-input" accept=".lrc" style="display: none;">
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->

<!-- ▼▼▼ 用這整塊代碼替換你原來的 id="wallpaper-screen" ▼▼▼ -->
<div id="wallpaper-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <!-- 【核心修改1】標題改為“外觀設置”，更通用 -->
        <span>外觀設置</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="form-container">
        <!-- 鎖屏壁紙設置 (全新) -->
        <div style="width:100%; text-align: left; margin-bottom: 5px;">
            <label style="font-weight: 500; color: var(--text-secondary);">鎖屏設置</label>
        </div>
        <div id="lockscreen-wallpaper-preview" class="wallpaper-preview">點擊下方上傳</div>
        <button class="form-button" onclick="document.getElementById('lockscreen-wallpaper-upload-input').click();">上傳鎖屏壁紙</button>
        <input type="file" id="lockscreen-wallpaper-upload-input" accept="image/*" hidden>
        
        <div class="form-group" style="width: 100%; margin-top: 15px;">
            <label for="password-set-input">鎖屏密碼 (留空則無密碼)</label>
            <input type="text" id="password-set-input" placeholder="設置你的解鎖密碼">
        </div>
        
        <hr style="width: 80%; opacity: 0.3; margin: 20px 0;">

        <!-- 主螢幕壁紙設置 (原有) -->
        <div style="width:100%; text-align: left; margin-bottom: 5px;">
            <label style="font-weight: 500; color: var(--text-secondary);">主螢幕設置</label>
        </div>
        <div id="wallpaper-preview">點擊下方上傳</div>
<!-- ▼▼▼ 請將這段新代碼黏貼到 wallpaper-preview 的 div 之後 ▼▼▼ -->
<div class="form-group">
    <label for="enable-lock-screen-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">啟用鎖屏介面</span>
        <input type="checkbox" id="enable-lock-screen-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
</div>
<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 在這裡黏貼新的“顯示狀態列”開關代碼 ▼▼▼ -->
<div class="form-group">
    <label for="show-status-bar-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">顯示狀態列</span>
        <input type="checkbox" id="show-status-bar-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
</div>
<!-- ▲▲▲ 新代碼黏貼結束 ▲▲▲ -->


        <button class="form-button" onclick="document.getElementById('wallpaper-upload-input').click();">上傳壁紙</button>
        <input type="file" id="wallpaper-upload-input" accept="image/*">

<!-- ▼▼▼ 將【下面整塊代碼】，完整替換為下面這段【全新的代碼】 ▼▼▼ -->
<div class="form-group" style="display: none;">
    <label for="theme-toggle-switch" style="margin-bottom: 0;">夜間模式</label>
    <label class="toggle-switch">
        <input type="checkbox" id="theme-toggle-switch">
        <span class="slider"></span>
    </label>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->

    <!-- === ▼▼▼ 以下是新增的美化功能UI ▼▼▼ === -->
    <div style="width:100%; text-align: left; margin-bottom: 15px;">
        <label style="font-weight: 500; color: var(--text-secondary);">手機美化 (CSS)</label>
    </div>

    <!-- 主題選擇和管理 -->
    <div class="form-group">
        <label for="theme-selector">選擇已存方案</label>
        <div style="display: flex; gap: 10px;">
            <select id="theme-selector" style="flex-grow: 1;"></select>
            <button id="rename-theme-btn" class="form-button-secondary" style="margin:0; padding: 0 10px;">重命名</button>
            <button id="delete-theme-btn" class="form-button-secondary" style="margin:0; padding: 0 10px; background-color: #ffdddd; color: #ff3b30;">刪除</button>
        </div>
    </div>

    <!-- CSS 代碼編輯區 -->
    <div class="form-group">
        <label for="theme-css-editor">美化代碼編輯區</label>
        <textarea id="theme-css-editor" rows="10" style="font-family: monospace; font-size: 12px; resize: vertical;" placeholder="在這裡黏貼或編輯美化代碼..."></textarea>
    </div>
    
    <!-- 操作按鈕 -->
    <button id="apply-theme-btn" class="form-button">應用當前代碼</button>
    <div style="display: flex; gap: 10px; margin-top: 10px;">
        <button id="save-theme-btn" class="form-button-secondary" style="flex:1;">保存</button>
        <button id="save-as-new-theme-btn" class="form-button-secondary" style="flex:1;">另存</button>
    </div>
    <div style="display: flex; gap: 10px; margin-top: 10px;">
        <button id="export-theme-btn" class="form-button-secondary" style="flex:1;">匯出方案</button>
        <button id="import-theme-btn" class="form-button-secondary" style="flex:1;">導入方案</button>
        <input type="file" id="import-theme-input" accept=".json" hidden>
    </div>
    <!-- === ▲▲▲ 新增UI結束 ▲▲▲ === -->
<!-- ▼▼▼ 【V3最終美化版】主螢幕美化預設功能UI ▼▼▼ -->
<div class="preset-manager-container">
    <div style="width:100%; text-align: left; margin-bottom: 15px;">
        <label style="font-weight: 500; color: var(--text-secondary);">主螢幕預設</label>
    </div>
    <div class="form-group">
        <select id="home-preset-selector" class="form-group select"></select>
        <div class="preset-manager-controls">
            <!-- 獨佔一行的應用按鈕 -->
            <button id="apply-home-preset-btn" class="preset-btn-capsule preset-btn-apply" disabled>應用</button>
            
            <!-- 2x2 網格按鈕 -->
            <button id="save-home-preset-btn" class="preset-btn-capsule preset-btn-save">保存</button>
            <!-- ▼▼▼ 就是在這裡新增了“更新”按鈕 ▼▼▼ -->
            <button id="update-home-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>更新</button>
            <button id="rename-home-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>重命名</button>
            <button id="import-home-preset-btn" class="preset-btn-capsule preset-btn-secondary">導入</button>
            <button id="export-home-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>匯出</button>
            <button id="delete-home-preset-btn" class="preset-btn-capsule preset-btn-delete" disabled>刪除</button>
            
            <input type="file" id="import-home-preset-input" accept=".json" hidden>
        </div>
    </div>
</div>
<!-- ▲▲▲ UI替換結束 ▲▲▲ -->
<!-- ▼▼▼ 步驟2：用這段新代碼替換舊的顏色選擇器HTML ▼▼▼ -->
<hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
<div style="width:100%; text-align: left; margin-bottom: 15px;">
    <label style="font-weight: 500; color: var(--text-secondary);">主螢幕圖示及小元件字體顏色</label>
</div>
<div class="form-group">
    <label for="home-icon-widget-text-color-picker">自訂字體顏色</label>
    <input type="color" id="home-icon-widget-text-color-picker" value="#FFFFFF" style="width: 100%; height: 40px; padding: 0; border-radius: 8px;">
</div>
<!-- ▲▲▲ 步驟2 HTML代碼替換結束 ▲▲▲ -->
 <!-- ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼ -->
<div class="form-group">
    <label for="remove-home-font-shadow-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">去除主螢幕字型陰影</span>
        <input type="checkbox" id="remove-home-font-shadow-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
</div>
<!-- ▲▲▲ 新代碼黏貼結束 ▲▲▲ -->

        <!-- 【核心修改2】新增圖示設置區域 -->
        <hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
        <div style="width:100%; text-align: left; margin-bottom: 15px;">
            <label style="font-weight: 500; color: var(--text-secondary);">App 圖示設置</label>
        </div>
        <div id="icon-settings-grid">
            <!-- 圖示設置項將由JS動態生成在這裡 -->
        </div>
<!-- ▼▼▼ 把下面這整塊全新的代碼，黏貼到“App圖示設置”的 div 之後 ▼▼▼ -->
<hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
<div style="width:100%; text-align: left; margin-bottom: 15px;">
    <label style="font-weight: 500; color: var(--text-secondary);">主螢幕 App 名稱</label>
</div>
<div id="icon-rename-grid" style="width: 100%; display: flex; flex-direction: column; gap: 15px;">
    <!-- App 名稱輸入框將由JS動態生成在這裡 -->
</div>
<!-- ▲▲▲ 新代碼黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 將這段新代碼，黏貼到“保存所有外觀設置”按鈕的【上方】 ▼▼▼ -->
<hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
<div style="width:100%; text-align: left; margin-bottom: 15px;">
    <label style="font-weight: 500; color: var(--text-secondary);">鈴聲設置</label>
</div>
<div class="form-group" style="width: 100%;">
    <label for="ringtone-url-input">來電鈴聲 URL (.mp3, .wav, etc.)</label>
    <input type="text" id="ringtone-url-input" placeholder="輸入音訊檔的網路連結...">
</div>
<!-- ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼ -->
<div class="form-group" style="width: 100%; margin-top: 15px;">
    <label for="notification-sound-url-input">消息提示音 URL (.mp3, .wav, etc.)</label>
    <input type="text" id="notification-sound-url-input" placeholder="輸入音訊檔的網路連結...">
</div>
<!-- ▲▲▲ 新代碼黏貼結束 ▲▲▲ -->

<!-- ▲▲▲ 新代碼黏貼結束 ▲▲▲ -->
<!-- ▼▼▼ 從這裡開始，把下面這一整塊全新的代碼，黏貼到“保存所有外觀設置”按鈕的【上方】 ▼▼▼ -->
<hr style="width: 80%; opacity: 0.3; margin: 30px 0;">
<div style="width:100%; text-align: left; margin-bottom: 15px;">
    <label style="font-weight: 500; color: var(--text-secondary);">全域聊天背景</label>
</div>
<div id="global-bg-preview" class="wallpaper-preview">點擊下方上傳</div>
<button class="form-button" onclick="document.getElementById('global-bg-upload-input').click();">上傳全域背景</button>
<input type="file" id="global-bg-upload-input" accept="image/*" hidden>
<button class="form-button form-button-secondary" id="remove-global-bg-btn" style="margin-top: 10px;">移除全域背景</button>
<button class="form-button form-button-secondary" id="clear-all-single-bgs-btn" style="margin-top: 10px; border-color: #ff3b30; color: #ff3b30;">一鍵清空所有單人聊天背景</button>
<!-- ▲▲▲ 黏貼到這裡結束 ▲▲▲ -->
        
        <!-- 【核心修改3】按鈕文字也改一下 -->
        <button class="form-button" id="save-wallpaper-btn" style="margin-top: 30px;">保存所有外觀設置</button>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】分享連結功能 HTML ▼▼▼ -->
<div id="browser-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="browser-back-btn">‹</span>
        <span id="browser-title"></span>
        <span style="width: 30px;"></span>
    </div>
    <div id="browser-content" class="list-container">
        <!-- 文章內容將由JS動態生成在這裡 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->

<div id="font-settings-screen" class="screen">
    <div class="header">
    <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
    <span>字體預設</span>
    <span style="width: 30px;"></span> <!-- 保留這個預留位置，讓標題能完美居中 -->
</div>
    <div class="form-container" style="gap: 20px;">
        <!-- 字體預設卡槽的容器 -->
        <div id="font-preset-container">
            <!-- 5個卡槽將由JavaScript動態生成在這裡 -->
        </div>

        <!-- 全域字體預覽區 -->
        <div class="form-group" style="width:100%;">
            <label>當前全域字體預覽</label>
            <div id="font-preview">
                <p style="font-size: 20px; margin: 0 0 10px 0;">你好世界 Hello World</p>
                <p style="margin: 0;">這是全域字體預覽效果，12345。</p>
            </div>
        </div>

        <button class="form-button form-button-secondary" id="reset-font-btn">恢復預設字體</button>
    </div>
</div>

<!-- 這個是隱藏的檔選擇器，用來處理本地上傳 -->
<input type="file" id="font-preset-local-upload" accept=".ttf,.otf,.woff,.woff2" style="display: none;">


<!-- ▼▼▼ 【全新】“查角色手機”功能的所有HTML介面 (V3終極版) ▼▼▼ -->

<!-- 1. 角色選擇螢幕 (保持不變) -->
<div id="character-selection-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>選擇要查看的手機</span>
        <span style="width: 30px;"></span>
    </div>
    <div id="character-selection-list" class="list-container"></div>
</div>

<!-- ▼▼▼ 請用這【一整塊】全新的代碼，完整替換掉你舊的 id="character-phone-container" 及其所有內容 ▼▼▼ -->
<div id="character-phone-container" class="screen">
    <div class="character-phone-frame">
        <div class="character-phone-notch"></div>
        <div class="character-phone-inner-screen">
            
            <!-- 1. 角色手機的主介面 -->
            <div id="character-phone-screen" class="character-phone-page active">
                <div class="header character-phone-header">
                    <span class="back-btn" data-target-screen="character-selection-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span id="character-phone-owner-name"></span>
                    <div class="header-actions">
                        <span class="action-btn" id="clear-character-data-btn" title="清空全部資料">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-character-data-btn" title="刷新全部資料">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 4v6h-6M1 20v-6h6"/><path d="M3.51 9a9 9 0 0114.85-3.36L20.5 10M3.5 14a9 9 0 0114.85 3.36L20.5 14"/></svg>
                        </span>
                    </div>
                </div>
                <!-- ▼▼▼ 在這裡黏貼下面這段全新的HTML代碼 ▼▼▼ -->
<!-- 這是左上角的小組件 -->
<div id="char-phone-widget-1" class="char-phone-widget">
    <img id="char-phone-widget-img-1" src="">
</div>
<!-- 這是右下角的小組件 -->
<div id="char-phone-widget-2" class="char-phone-widget">
    <img id="char-phone-widget-img-2" src="">
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
                <div id="character-app-grid" class="app-grid-standard" style="padding-top: 60px;"></div>
            </div>

            <!-- 2. 角色手機 - 聊天列表 -->
            <div id="character-chat-list-screen" class="character-phone-page">
                <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>消息</span>
                    <div class="header-actions">
                        <!-- ★ 新增：消息頁的刪除按鈕 ★ -->
                        <span class="action-btn" id="clear-npc-chats-btn" title="清空所有NPC聊天">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-chat-message-btn" title="生成新聊天">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                        </span>
                    </div>
                </div>
                <div id="character-chat-list" class="list-container" style="padding: 0;"></div>
            </div>

            <!-- 3. 角色手機 - 具體聊天記錄 -->
            <div id="character-chat-history-screen" class="character-phone-page">
                <div class="header character-phone-header">
                     <span class="back-btn" data-target-page="character-chat-list-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span id="character-chat-with-name"></span>
                </div>
                <div id="character-chat-history-messages" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px; background-color: #e5ddd5;"></div>
            </div>

            <!-- 4. 角色手機 - 購物車 -->
            <div id="character-shopping-cart-screen" class="character-phone-page">
                <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                         <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>購物車</span>
                    <div class="header-actions">
                        <!-- ★ 新增：購物車頁的刪除按鈕 ★ -->
                        <span class="action-btn" id="clear-cart-items-btn" title="清空購物車">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-cart-item-btn" title="添加新商品">
                            <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>
                        </span>
                    </div>
                </div>
                <div id="character-shopping-cart-list" class="list-container"></div>
            </div>

            <!-- 5. 角色手機 - 備忘錄 -->
            <div id="character-memos-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>備忘錄</span>
                    <div class="header-actions">
                        <!-- ★ 新增：備忘錄頁的刪除按鈕 ★ -->
                        <span class="action-btn" id="clear-memos-btn" title="清空備忘錄">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-memo-btn" title="寫新備忘錄">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                        </span>
                    </div>
                </div>
                <div id="character-memos-list" class="list-container"></div>
            </div>

            <!-- 6. 角色手機 - 流覽器 -->
            <div id="character-browser-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>流覽器</span>
                    <div class="header-actions">
                        <!-- ★ 新增：流覽器頁的刪除按鈕 ★ -->
                        <span class="action-btn" id="clear-browser-history-btn" title="清空歷史記錄">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-browser-history-btn" title="生成新歷史">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg>
                        </span>
                    </div>
                </div>
                <div id="character-browser-list" class="list-container"></div>
            </div>

            <!-- 7. 角色手機 - 流覽器搜索結果詳情 -->
            <div id="character-browser-detail-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-browser-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span id="character-browser-detail-title">搜索結果</span>
                </div>
                <div id="character-browser-detail-content" class="list-container" style="padding: 15px; line-height: 1.7;"></div>
            </div>

            <!-- 8. 角色手機 - 相冊 -->
            <div id="character-album-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>相冊</span>
                    <div class="header-actions">
                        <!-- ★ 新增：相冊頁的刪除按鈕 ★ -->
                        <span class="action-btn" id="clear-album-photos-btn" title="清空相冊">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-album-photo-btn" title="生成新照片">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                        </span>
                    </div>
                </div>
                <div id="character-album-grid" class="list-container"></div>
            </div>

            <!-- 9. 角色手機 - 銀行 -->
            <div id="character-bank-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>錢包</span>
                    <div class="header-actions">
                        <!-- ★ 新增：錢包頁的刪除按鈕 ★ -->
                        <span class="action-btn" id="clear-bank-transactions-btn" title="清空交易記錄">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-bank-transaction-btn" title="生成新交易">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path></svg>
                        </span>
                    </div>
                </div>
                <div id="character-bank-details" class="list-container"></div>
            </div>

            <!-- 10. 角色手機 - 行動軌跡 -->
            <div id="character-trajectory-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>足跡</span>
                    <div class="header-actions">
                        <!-- ★ 新增：足跡頁的刪除按鈕 ★ -->
                        <span class="action-btn" id="clear-trajectory-btn" title="清空足跡">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-trajectory-btn" title="生成新足跡">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>
                        </span>
                    </div>
                </div>
                <div id="character-trajectory-list" class="list-container"></div>
            </div>

            <!-- 11. 角色手機 - APP使用記錄 -->
            <div id="character-app-usage-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>螢幕使用時間</span>
                    <div class="header-actions">
                        <!-- ★ 新增：使用記錄頁的刪除按鈕 ★ -->
                        <span class="action-btn" id="clear-app-usage-btn" title="清空記錄">
                             <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-app-usage-btn" title="生成新記錄">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8v4l3 3m6-3a9 9 0 1 1-18 0 9 9 0 0 1 18 0z"></path></svg>
                        </span>
                    </div>
                </div>
                <div id="character-app-usage-list" class="list-container"></div>
            </div>

            <!-- 12. 角色手機 - 日記 -->
            <div id="character-diary-screen" class="character-phone-page">
                 <div class="header character-phone-header">
                    <span class="back-btn" data-target-page="character-phone-screen">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
                    </span>
                    <span>日記</span>
                    <div class="header-actions">
                        <!-- ★ 新增：日記頁的刪除按鈕 ★ -->
                        <span class="action-btn" id="clear-diary-entries-btn" title="清空日記">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/></svg>
                        </span>
                        <span class="action-btn" id="generate-diary-entry-btn" title="寫新日記">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"/></svg>
                        </span>
                    </div>
                </div>
                <div id="character-diary-list" class="list-container"></div>
            </div>
            <!-- ▼▼▼ 【全新】這是角色手機外觀設置的HTML介面，請黏貼到指定位置 ▼▼▼ -->
<div id="character-phone-appearance-screen" class="character-phone-page">
    <div class="header character-phone-header">
        <span class="back-btn" data-target-page="character-phone-screen">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><path d="M15 18l-6-6 6-6"/></svg>
        </span>
        <span>外觀設置</span>
        <span style="width: 30px;"></span>
    </div>
    <!-- 複用你已有的.form-container樣式，方便滾動和佈局 -->
    <div class="form-container" style="padding: 15px; gap: 25px;">
        <!-- 壁紙設置區 -->
        <div>
            <label style="font-weight: 500; color: var(--text-secondary);">手機壁紙</label>
            <div id="char-phone-wallpaper-preview" class="wallpaper-preview" style="height: 240px; width: 135px; margin: 10px auto; border-radius: 12px;">點擊下方上傳</div>
            <button id="upload-char-phone-wallpaper-btn" class="form-button">上傳壁紙</button>
            <button id="remove-char-phone-wallpaper-btn" class="form-button form-button-secondary" style="margin-top: 10px;">移除壁紙</button>
        </div>
        <!-- ▼▼▼ 在這裡黏貼下面這一整塊新代碼 ▼▼▼ -->
<hr style="width: 100%; opacity: 0.2;">

<div>
    <label style="font-weight: 500; color: var(--text-secondary);">App 內壁紙</label>
    <div id="char-phone-app-wallpaper-preview" class="wallpaper-preview" style="height: 240px; width: 135px; margin: 10px auto; border-radius: 12px;">點擊下方上傳</div>
    <button id="upload-char-phone-app-wallpaper-btn" class="form-button">上傳 App 內壁紙</button>
    <button id="remove-char-phone-app-wallpaper-btn" class="form-button form-button-secondary" style="margin-top: 10px;">移除 App 內壁紙</button>
</div>
<!-- ▲▲▲ 新代碼黏貼結束 ▲▲▲ -->

        <hr style="width: 100%; opacity: 0.2;">

        <!-- App圖示設置區 -->
        <div>
            <label style="font-weight: 500; color: var(--text-secondary);">App 圖示</label>
            <div id="char-phone-icon-settings-grid" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-top: 15px; text-align: center;">
                <!-- App圖示設置將由JS動態生成在這裡 -->
            </div>
        </div>

        <!-- ▼▼▼ 在這裡黏貼下面這一整塊新代碼 ▼▼▼ -->
        <hr style="width: 100%; opacity: 0.2;">
        <!-- 桌面小組件設置區 -->
        <div>
            <label style="font-weight: 500; color: var(--text-secondary);">桌面小組件</label>
            <!-- 小組件1: 左上角 -->
            <div class="form-group" style="margin-top: 15px;">
                <label>左上角小組件</label>
                <div class="avatar-upload">
                    <img id="char-phone-widget-preview-1" class="wallpaper-preview" style="height: 100px; width: 100px; margin-bottom: 0;">
                    <div style="display:flex; flex-direction: column; gap: 8px;">
                        <button class="form-button-secondary" id="upload-widget-1-btn" style="margin-top:0;">上傳圖片</button>
                        <button class="form-button-secondary" id="remove-widget-1-btn" style="margin-top:0; border-color: #ff3b30; color: #ff3b30;">移除圖片</button>
                    </div>
                </div>
            </div>
            <!-- 小組件2: 右下角 -->
            <div class="form-group" style="margin-top: 15px;">
                <label>右下角小組件</label>
                <div class="avatar-upload">
                    <img id="char-phone-widget-preview-2" class="wallpaper-preview" style="height: 100px; width: 100px; margin-bottom: 0;">
                     <div style="display:flex; flex-direction: column; gap: 8px;">
                        <button class="form-button-secondary" id="upload-widget-2-btn" style="margin-top:0;">上傳圖片</button>
                        <button class="form-button-secondary" id="remove-widget-2-btn" style="margin-top:0; border-color: #ff3b30; color: #ff3b30;">移除圖片</button>
                    </div>
                </div>
            </div>
        </div>
        <!-- ▲▲▲ 新代碼黏貼結束 ▲▲▲ -->
<!-- ▼▼▼ 把這一整塊全新的代碼，黏貼到角色手機外觀設置頁面的 .form-container 內部末尾 ▼▼▼ -->
<hr style="width: 100%; opacity: 0.2; margin-top: 25px;">
<div class="preset-manager-container">
    <div style="width:100%; text-align: left; margin-bottom: 15px;">
        <label style="font-weight: 500; color: var(--text-secondary);">外觀預設</label>
    </div>
    <div class="form-group">
        <select id="char-phone-preset-selector" class="form-group select"></select>
        <div class="preset-manager-controls">
            <!-- 獨佔一行的應用按鈕 -->
            <button id="apply-char-phone-preset-btn" class="preset-btn-capsule preset-btn-apply" disabled>應用</button>
            
            <!-- 2x2 網格按鈕 -->
            <button id="save-char-phone-preset-btn" class="preset-btn-capsule preset-btn-save">保存</button>
            <button id="update-char-phone-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>更新</button>
            <button id="rename-char-phone-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>重命名</button>
            <button id="import-char-phone-preset-btn" class="preset-btn-capsule preset-btn-secondary">導入</button>
            <button id="export-char-phone-preset-btn" class="preset-btn-capsule preset-btn-secondary" disabled>匯出</button>
            <button id="delete-char-phone-preset-btn" class="preset-btn-capsule preset-btn-delete" disabled>刪除</button>
            
            <input type="file" id="import-char-phone-preset-input" accept=".json" hidden>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML代碼結束 ▲▲▲ -->

    </div>
</div>
<!-- 隱藏的文件選擇器，用於處理上傳 -->
<input type="file" id="char-phone-wallpaper-upload-input" accept="image/*" hidden>
<input type="file" id="char-phone-icon-upload-input" accept="image/*" hidden>

<!-- ▼▼▼ 在這裡黏貼下面這兩行新的檔選擇器 ▼▼▼ -->
<input type="file" id="char-phone-widget-1-upload-input" accept="image/*" hidden>
<input type="file" id="char-phone-widget-2-upload-input" accept="image/*" hidden>
<input type="file" id="char-phone-app-wallpaper-upload-input" accept="image/*" hidden>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
        </div>
    </div>
</div>
<!-- ▲▲▲ HTML 替換結束 ▲▲▲ -->


<!-- 載入動畫遮罩層 (保持不變) -->
<div id="generation-overlay" class="modal" style="background-color: rgba(0,0,0,0.6); z-index: 2000;">
    <div style="text-align: center; color: white;">
        <div id="loading-spinner" style="width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
        <p>正在同步Ta的手機資料...</p>
        <p style="font-size: 12px; opacity: 0.7;">（這可能需要一些時間，並會消耗API額度）</p>
    </div>
</div>

<!-- ▲▲▲ “查角色手機”功能HTML結束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】選擇連絡人以創建群聊的螢幕 ▼▼▼ -->
<div id="contact-picker-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="cancel-contact-picker-btn">取消</span>
        <span>選擇連絡人</span>
        <span class="save-btn" id="confirm-contact-picker-btn">完成(0)</span>
    </div>
    <div class="list-container" id="contact-picker-list">
        <!-- 連絡人清單將由JS動態生成 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】群成員管理螢幕 ▼▼▼ -->
<div id="member-management-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-member-management">‹</span>
        <span>群成員管理</span>
        <span style="width: 30px;"></span>
    </div>
    <div class="list-container" id="member-management-list">
        <!-- 現有成員清單會在這裡動態生成 -->
    </div>
    <div id="member-management-actions">
        <button id="add-existing-contact-btn">從好友列表添加</button>
        <button id="create-new-member-btn">創建群內新成員</button>
    </div>
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】微博用戶人設與職業設置模態框 ▼▼▼ -->
<div id="weibo-user-settings-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>我的微博設定</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>預設方案</label>
                <div class="bubble-preset-manager"> <!-- 複用現有樣式 -->
                    <select id="weibo-user-preset-select" class="form-group select"></select>
                    <button id="manage-weibo-user-presets-btn" class="action-btn">管理</button>
                </div>
            </div>
            <div class="form-group">
                <label for="weibo-user-profession-modal-input">職業 (顯示在昵稱下方)</label>
                <input type="text" id="weibo-user-profession-modal-input" placeholder="例如：職業電競選手、美妝博主">
            </div>
            <div class="form-group">
                <label for="weibo-user-persona-modal-input">隱藏人設 (僅供AI生成評論時參考)</label>
                <textarea id="weibo-user-persona-modal-input" rows="4" placeholder="例如：性格高冷，少與粉絲互動，只回復贊助商的評論。"></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-weibo-user-settings-btn">取消</button>
            <button class="save" id="save-weibo-user-settings-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】這是微博手動操作的彈窗，黏貼到 </body> 前面 ▼▼▼ -->
<div id="weibo-action-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span id="weibo-action-modal-title">執行操作</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="weibo-action-actor-select">選擇操作者 (Actor)</label>
                <select id="weibo-action-actor-select" class="form-group select"></select>
            </div>
            <div class="form-group">
                <label>選擇操作類型</label>
<!-- ▼▼▼ 用這塊新代碼替換 ▼▼▼ -->
<div id="weibo-action-type-select" style="text-align: left;">
    <label><input type="radio" name="weibo_action_type" value="post" checked> 發佈一條新微博</label>
    <label><input type="radio" name="weibo_action_type" value="comment_plaza"> 評論廣場最新微博</label>
    <!-- ▼▼▼ 這是我們新增的選項 ▼▼▼ -->
    <label><input type="radio" name="weibo_action_type" value="comment_user"> 評論用戶最新微博</label>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->
            </div>
             <div class="form-group">
                <label for="weibo-action-prompt-input">關於... (可選, 簡要提示)</label>
                <textarea id="weibo-action-prompt-input" rows="2" placeholder="例如：今天比賽贏了很開心 or 回應最近的熱搜"></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-weibo-action-btn">取消</button>
            <button class="save" id="confirm-weibo-action-btn">執行</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
<!-- ▼▼▼ 第2步 第3處修改（新增HTML） ▼▼▼ -->
<!-- 【全新】角色表情包管理螢幕 -->
<div id="char-sticker-manager-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-sticker-manager">‹</span>
        <span id="sticker-manager-title">表情包管理</span>
    </div>
    <input type="file" id="char-sticker-upload-input" accept="image/*" style="display: none;" multiple>
    <div class="modal-body" style="padding: 0; display: flex; flex-direction: column;">
        <!-- 頁簽切換 -->
        <div class="frame-tabs">
            <div id="sticker-tab-exclusive" class="frame-tab active">專屬表情</div>
            <div id="sticker-tab-common" class="frame-tab">通用表情</div>
        </div>

        <!-- 專屬表情內容區 -->
        <div id="sticker-content-exclusive" class="frame-content">
            <div class="sticker-panel-header" style="justify-content: flex-end;">
                 <div style="display: flex; gap: 10px;">
                    <span class="panel-btn" id="add-exclusive-sticker-btn">批量添加</span>
                    <span class="panel-btn" id="upload-exclusive-sticker-btn">本地上傳</span>
                </div>
            </div>
            <div id="exclusive-sticker-grid" class="sticker-grid"></div>
        </div>

        <!-- 通用表情內容區 -->
        <div id="sticker-content-common" class="frame-content" style="display: none;">
             <div class="sticker-panel-header" style="justify-content: flex-end;">
                 <div style="display: flex; gap: 10px;">
                    <span class="panel-btn" id="add-common-sticker-btn">批量添加</span>
                    <span class="panel-btn" id="upload-common-sticker-btn">本地上傳</span>
                </div>
            </div>
            <div id="common-sticker-grid" class="sticker-grid"></div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】來電請求模態框 ▼▼▼ -->
<div id="incoming-call-modal" class="modal">
    <div class="incoming-call-content">
        <img id="caller-avatar" class="caller-avatar" src="">
        <div id="caller-name" class="caller-name"></div>
        <div class="caller-text">邀請你視頻通話</div>
        <div class="incoming-call-actions">
            <div class="action-button-wrapper">
                <button id="decline-call-btn" class="call-action-btn decline"></button>
                <span>拒絕</span>
            </div>
            <div class="action-button-wrapper">
                <button id="accept-call-btn" class="call-action-btn accept"></button>
                <span>接聽</span>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增結束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】這是BGM搜索結果的彈窗，請黏貼到body末尾 ▼▼▼ -->
<div id="music-search-results-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>搜索結果</span>
        </div>
        <div class="modal-body" id="search-results-list" style="padding: 0;">
            <!-- 搜索結果將由JS動態生成在這裡 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-music-search-btn" style="width: 100%;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->

<!-- ▼▼▼ 請用這段【全新群聊相容結構】的代碼，完整替換你舊的 #video-call-screen ▼▼▼ -->
<!-- ▼▼▼ 用下面這【一整塊】全新的代碼，替換掉你檔中舊的 #video-call-screen 及其所有內容 ▼▼▼ -->
<div id="video-call-screen" class="screen">
    <!-- 這個 screen 同時為兩種模式服務 -->

    <!-- ======================================================= -->
    <!-- 模式一：全新的【視覺化】視頻通話介面 -->
    <!-- ======================================================= -->
    <div id="visual-call-interface" style="display: none;"> <!-- 默認隱藏 -->
        <!-- 1. 視頻背景層 (大圖和小圖都在這裡) -->
        <div class="video-background">
            <!-- 大圖容器 -->
            <div id="video-main-view" class="video-container">
                <img src="" alt="主視頻畫面">
            </div>
            <!-- 小圖容器 (畫中畫) -->
            <div id="video-pip-view" class="video-container pip">
                <img src="" alt="小窗視頻畫面">
            </div>
        </div>

        <!-- 2. 頂部狀態列 -->
        <div class="video-call-top-bar">
            <span id="visual-call-timer">00:00</span>
        </div>

        <!-- 3. 聊天氣泡顯示區域 -->
        <div id="video-call-messages-visual" class="video-call-main">
            <!-- 聊天氣泡會由JS動態生成在這裡 -->
        </div>
<!-- ▼▼▼ 用下面這【一整塊】代碼，替換掉 id="visual-call-interface" 裡面那個舊的 video-call-controls 的 div ▼▼▼ -->
<div class="video-call-controls">
    <!-- 重-roll按鈕 -->
    <button id="reroll-call-btn" class="control-btn reroll-btn" title="重新生成"></button>
    <!-- 【核心新增】發言按鈕 -->
    <button id="user-speak-btn-visual" class="control-btn speak-btn" title="發言"></button>
    <!-- 切換鏡頭按鈕 -->
    <button id="switch-camera-btn" class="control-btn switch-camera-btn" title="切換鏡頭"></button>
    <!-- 掛斷按鈕 -->
    <button id="hang-up-btn-visual" class="control-btn hangup-btn"></button>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->

    </div>

    <!-- ======================================================= -->
    <!-- 模式二：你原來的【純文字】語音通話介面 (我們把它保留下來作為預設選項) -->
    <!-- ======================================================= -->
    <div id="text-call-interface" style="display: none;"> <!-- 默認隱藏 -->
        <div class="video-call-top-bar">
            <span id="call-timer">00:00</span>
        </div>
        <div class="video-call-avatar-area">
            <div id="participant-avatars-grid">
                <!-- JS會在這裡動態生成頭像 -->
            </div>
        </div>
        <div id="video-call-main" class="video-call-main">
            <!-- 對話內容會動態生成在這裡 -->
        </div>
        <div class="video-call-controls">
            <!-- 【新增】為舊模式也加上重roll按鈕 -->
            <button id="reroll-call-btn-text" class="control-btn reroll-btn" title="重新生成"></button>
            <button id="user-speak-btn" class="control-btn speak-btn"></button>
            <button id="hang-up-btn" class="control-btn hangup-btn"></button>
            <button id="join-call-btn" class="control-btn join-btn" style="display: none;"></button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->


<!-- ▼▼▼ 【全新添加】正在呼叫介面 ▼▼▼ -->
<div id="outgoing-call-screen" class="screen">
    <div class="outgoing-call-content">
        <img id="outgoing-call-avatar" class="caller-avatar" src="">
        <div id="outgoing-call-name" class="caller-name"></div>
        <div class="caller-text">正在呼叫...</div>
        <div class="outgoing-call-actions">
            <button id="cancel-call-btn" class="call-action-btn decline"></button>
            <span>取消</span>
        </div>
    </div>
</div>
<!-- ▲▲▲ 添加結束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】通話記錄頁面 ▼▼▼ -->
<div id="call-history-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="call-history-back-btn">‹</span>
        <span id="call-history-title">通話記錄</span>
        <span style="width: 30px;"></span> <!-- 預留位置，保持標題居中 -->
    </div>
    <div id="call-history-list" class="list-container" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
        <!-- 通話記錄卡片將由JS動態生成在這裡 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】這是聊天記錄搜索介面，請黏貼到 call-history-screen 的 div 之後 ▼▼▼ -->
<div id="chat-search-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="search-back-btn">‹</span>
        <span>查找聊天記錄</span>
        <span style="width: 30px;"></span> <!-- 預留位置 -->
    </div>
    <div class="form-container" style="padding-bottom: 0;">
        <!-- 搜索條件輸入區 -->
        <div class="form-group">
            <label for="keyword-search-input">關鍵字</label>
            <input type="text" id="keyword-search-input" placeholder="輸入要查找的關鍵字...">
        </div>
        <div class="form-group">
            <label for="sender-search-select">人物</label>
            <select id="sender-search-select">
                <!-- 選項將由JS動態生成 -->
            </select>
        </div>
        <div class="form-group">
            <label for="date-search-input">日期</label>
            <input type="date" id="date-search-input">
        </div>
        <button class="form-button" id="perform-search-btn">開始查找</button>
        
        <!-- 搜索結果顯示區 -->
        <div id="chat-search-results-list" class="list-container" style="margin-top: 15px; padding: 0;">
            <!-- 搜索結果將由JS動態生成在這裡 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->


            <!-- ▼▼▼ 請將下面這整塊【全新的HTML代碼】黏貼到這裡 ▼▼▼ -->
            <div id="lock-screen" class="screen">
                <div id="lock-clock-container">
                    <div id="lock-main-time">12:00</div>
                    <div id="lock-main-date">星期一, 1月1日</div>
                </div>
                <div id="unlock-hint">向上滑動解鎖</div>
            </div>

            <div id="password-modal-overlay" class="modal">
                <div class="password-modal-content">
                    <p>請輸入密碼</p>
                    <input type="password" id="password-input-field" maxlength="20">
                    <div class="password-actions">
                        <button id="password-cancel-btn">取消</button>
                        <button id="password-confirm-btn">進入</button>
                    </div>
                </div>
            </div>
            <!-- ▲▲▲ 新HTML代碼黏貼結束 ▲▲▲ -->

        </div>
    </div>
  <!-- ▼▼▼ 用這整塊代碼替換 ▼▼▼ -->
<div id="lovers-space-screen" class="screen">
    <!-- 頭部 -->
    <div id="ls-header">
        <div class="ls-header-overlay"></div>
        <div class="ls-header-top-bar">
            <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
            <span id="ls-char-name"></span>
            <div class="header-actions">
                <span class="action-btn" id="ls-settings-btn" title="空間設置">
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                </span>
                <span class="action-btn" id="ls-change-bg-btn" title="更換背景">
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
                </span>
                <span class="action-btn" id="ls-switch-char-btn">切換</span>
            </div>
        </div>
        <div class="ls-avatar-and-counter-wrapper">
            <div class="ls-header-avatars">
                <img id="ls-user-avatar" src="">
                <span class="heart-icon">❤</span>
                <img id="ls-char-avatar" src="">
            </div>
            <div id="ls-days-counter"></div>
        </div>
    </div>
<!-- ▼▼▼ 用這整塊【SVG圖示版】代碼，替換你舊的 ls-tab-bar ▼▼▼ -->
<div id="ls-tab-bar">
    <div class="ls-tab-item active" data-view="ls-moments-view" title="說說">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
    </div>
    <div class="ls-tab-item" data-view="ls-album-view" title="相冊">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
    </div>
    <div class="ls-tab-item" data-view="ls-letters-view" title="情書">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>
    </div>
    <div class="ls-tab-item" data-view="ls-shares-view" title="分享">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>
    </div>
    <div class="ls-tab-item" data-view="ls-questions-view" title="提問">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>
    </div>
    <div class="ls-tab-item" data-view="ls-diary-view" title="日記">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>
    </div>
    <div class="ls-tab-item" data-view="ls-pomodoro-view" title="番茄鐘">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
    </div>
</div>
<!-- ▲▲▲ HTML替換結束 ▲▲▲ -->
    <!-- 內容顯示區域 -->
    <div id="ls-content-area">
        <div id="ls-moments-view" class="ls-view active"><div id="ls-moments-list"></div><button id="ls-add-moment-btn" class="ls-fab-btn">
    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
        <line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
        <line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
    </svg>
</button>
</div>
        <div id="ls-album-view" class="ls-view">
    <div id="ls-album-list"></div>
    <button id="ls-add-album-btn" class="ls-fab-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
            <line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
        </svg>
    </button>
</div>

        <div id="ls-letters-view" class="ls-view">
    <div id="ls-letters-list"></div>
    <button id="ls-add-letter-btn" class="ls-fab-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
            <line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
        </svg>
    </button>
</div>

        <div id="ls-shares-view" class="ls-view"><div id="ls-shares-list"></div></div>
     <div id="ls-questions-view" class="ls-view">
    <div id="ls-questions-list"></div>
    <button id="ls-add-question-btn" class="ls-fab-btn">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <line x1="12" y1="5" x2="12" y2="19" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
            <line x1="5" y1="12" x2="19" y2="12" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
        </svg>
    </button>
</div>

        <!-- ▼▼▼ 在 id="ls-questions-view" 的 div 之後，黏貼下面這整塊新代碼 ▼▼▼ -->
<div id="ls-diary-view" class="ls-view">
    <!-- 日曆和心情罐子的內容將由JS動態生成在這裡 -->
</div>
<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
        <!-- ★★★ 這就是我們為番茄鐘準備的全新介面 ★★★ -->
        <div id="ls-pomodoro-view" class="ls-view">
            <!-- 番茄鐘主頁，顯示歷史記錄和開始按鈕 -->
            <div id="ls-pomodoro-home">
                <div id="ls-pomodoro-start-btn-container">
                    <div id="ls-pomodoro-start-icon">＋</div>
                    <p>開啟新的專注時光</p>
                </div>
                <div id="ls-pomodoro-history-list">
                    <!-- 歷史記錄會由JS生成在這裡 -->
                </div>
            </div>
            <!-- 正在計時的介面，預設隱藏 -->
            <div id="ls-pomodoro-timer-active" style="display: none;">
                <div class="pomodoro-char-avatar-container">
                    <img id="pomodoro-char-avatar" src="">
                    <div id="pomodoro-char-log"></div>
                </div>
                <div class="pomodoro-timer-display">
                    <div id="pomodoro-current-task"></div>
                    <div id="pomodoro-time">25:00</div>
                </div>
                <button id="pomodoro-end-btn">結束專注</button>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->
    <div id="chat-settings-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>聊天設置</span></div><div class="modal-body"><div class="form-group" id="chat-name-group"><label for="chat-name-input">備註名 / 群名</label><input type="text" id="chat-name-input"></div>

    <!-- ▼▼▼ 請將這段新代碼黏貼到“備註名”輸入框的 form-group 之後 ▼▼▼ -->
    <div class="form-group" id="assign-group-section" style="display: none;"> <!-- 預設隱藏，只對單聊顯示 -->
        <label for="assign-group-select">好友分組</label>
        <div style="display: flex; align-items: center; gap: 10px;">
            <select id="assign-group-select" style="flex-grow: 1;">
                <!-- 分組選項將由JS動態生成 -->
            </select>
            <button id="manage-groups-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px;">管理分組</button>
        </div>
    </div>
    <!-- ▲▲▲ 新代碼黏貼結束 ▲▲▲ -->

<div class="form-group" id="my-group-nickname-group"><label for="my-group-nickname-input">我的群昵稱</label><input type="text" id="my-group-nickname-input"></div><div class="form-group" id="group-avatar-group"><label>群頭像</label><div class="avatar-upload"><img id="group-avatar-preview"><button onclick="document.getElementById('group-avatar-input').click()">上傳群頭像</button><input type="file" id="group-avatar-input" accept="image/*"></div></div>
            <div class="form-group" id="world-book-link-group">
                <label>關聯世界書 (可多選)</label>
                <div class="custom-multiselect">
                    <div class="select-box">
                        <span class="selected-options-text">-- 點擊選擇 --</span>
                        <span class="arrow-down">▼</span>
                    </div>
                    <div id="world-book-checkboxes-container" class="checkboxes-container">
                    </div>
                </div>
            </div>
            <!-- ▼▼▼ 【全新】記憶互通設置 (持久化連結版) ▼▼▼ -->
<div class="form-group" id="memory-link-group">
    <label>記憶互通 (選擇要連結的聊天)</label>
    
    <!-- 複用世界書的多選框樣式 -->
    <div class="custom-multiselect" id="memory-link-multiselect">
        <div class="select-box">
            <span class="selected-options-text">-- 點擊選擇 --</span>
            <span class="arrow-down">▼</span>
        </div>
        <div id="memory-link-checkboxes-container" class="checkboxes-container">
            <!-- 聊天選項將由JS動態生成在這裡 -->
        </div>
    </div>
    
    <!-- 新增：記憶條數設置 -->
    <div class="form-group" style="margin-top: 10px;">
        <label for="link-memory-depth-input" style="font-weight: normal; color: var(--text-secondary); font-size: 13px;">互通記憶條數 (AI會看到對方最近的幾條消息)</label>
        <input type="number" id="link-memory-depth-input" value="5" min="1" max="20" style="padding: 8px;">
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
 <!-- ▼▼▼ 把這一整塊全新的HTML代碼，黏貼到 <div id="chat-settings-modal"> 的 <div class="modal-body"> 內部，例如“聊天背景”設置的上方 ▼▼▼ -->

<hr style="opacity: 0.2; margin: 20px 0;">

<!-- 1. 線下模式總開關 -->
<div class="form-group">
    <label for="offline-mode-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">
            開啟線下模式
            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                開啟後，AI將默認你們線上下見面，並以大段敘事的方式進行回應。
            </p>
        </span>
        <input type="checkbox" id="offline-mode-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
</div>

<!-- 2. 線下模式的詳細設置 (默認隱藏) -->
<div id="offline-mode-details" style="display: none; padding-left: 10px; border-left: 3px solid var(--accent-color); margin-top: 15px;">
    
    <!-- 2.1 預設管理 -->
    <div class="form-group">
        <label>線下模式預設</label>
        <div class="bubble-preset-manager">
            <select id="offline-preset-select" class="form-group select"></select>
            <button id="manage-offline-presets-btn" class="action-btn">管理</button>
        </div>
    </div>
    
    <!-- 2.2 提示詞輸入 -->
    <div class="form-group">
        <label for="offline-prompt-input">自訂提示詞 (Prompt)</label>
        <textarea id="offline-prompt-input" rows="4" placeholder="例如：你正在一家安靜的咖啡館裡和用戶約會..."></textarea>
    </div>
    
    <!-- 2.3 文風輸入 -->
    <div class="form-group">
        <label for="offline-style-input">自訂文風 (Style)</label>
        <textarea id="offline-style-input" rows="3" placeholder="例如：請使用第三人稱，詳細描寫角色的動作、神態和心理活動..."></textarea>
    </div>

    <!-- 2.4 字數設置 -->
    <div class="form-group">
        <label for="offline-word-count-input">期望回復字數</label>
        <input type="number" id="offline-word-count-input" value="300" min="50" step="50">
    </div>

</div>
<!-- ▼▼▼ 【全新】聊天總結設置區域 ▼▼▼ -->
<hr style="opacity: 0.2; margin: 20px 0;">

<div class="form-group">
    <label for="summary-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">
            開啟聊天總結
            <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                開啟後，AI會在對話達到一定長度時自動或手動進行總結，作為長期記憶。
            </p>
        </span>
        <input type="checkbox" id="summary-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
</div>

<div id="summary-details-container" style="display: none; padding-left: 10px; border-left: 3px solid var(--accent-color); margin-top: 15px;">
    <div class="form-group">
        <label>總結模式</label>
        <div style="display: flex; gap: 20px;">
            <label><input type="radio" name="summary-mode" value="auto" checked> 自動總結</label>
            <label><input type="radio" name="summary-mode" value="manual"> 手動總結</label>
        </div>
    </div>
    <div class="form-group">
        <label for="summary-count-input">觸發消息條數</label>
        <input type="number" id="summary-count-input" value="20" min="5">
    </div>
    <div class="form-group">
        <label for="summary-prompt-input">總結提示詞 (Prompt)</label>
        <textarea id="summary-prompt-input" rows="4"></textarea>
    </div>
    <button id="view-summaries-btn" class="form-button form-button-secondary" style="margin-top: 10px;">查看和管理總結</button>
        <!-- ▼▼▼ 在這裡黏貼下面的新按鈕 ▼▼▼ -->
    <button id="manual-summary-btn" class="form-button form-button-secondary" style="margin-top: 10px;">立即手動總結</button>
    <!-- ▲▲▲ 新按鈕黏貼結束 ▲▲▲ -->
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 在 id="summary-details-container" 的 </div> 之後黏貼 ▼▼▼ -->
<div class="form-group" style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
    <label style="margin-bottom: 0;">當前總聊天條數</label>
    <span id="total-message-count-display" style="color: var(--text-secondary); font-weight: 500;">--</span>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▲▲▲ 新增HTML代碼黏貼結束 ▲▲▲ -->

            <div class="form-group" id="ai-persona-group"><label for="ai-persona">對方人設 (AI Persona)</label><textarea id="ai-persona" rows="3"></textarea></div>
              <!-- ▼▼▼ 第2步 第2處修改（新增HTML） ▼▼▼ -->
            <div class="form-group" id="char-sticker-group">
                <button id="manage-char-stickers-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 5px;">
                    管理角色表情包
                </button>
            </div>
            <!-- ▲▲▲ 新增結束 ▲▲▲ -->
            <!-- ▼▼▼ 在這裡黏貼新代碼 ▼▼▼ -->
<div class="form-group" id="npc-library-group">
    <button id="manage-npcs-btn" class="form-button form-button-secondary" style="width: 100%; margin-top: 5px;">管理NPC庫</button>
</div>
<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
 <!-- ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼ -->
<div class="form-group" id="minimax-voice-id-group">
    <label for="minimax-voice-id-input">Minimax 語音ID</label>
    <input type="text" id="minimax-voice-id-input" placeholder="例如：male-01">
</div>
<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
 <!-- 【全新】微博人設與職業設置 -->
<div id="weibo-settings-for-user" style="display: none;">
    <hr style="opacity: 0.2; margin: 20px 0;">
    <div class="form-group">
        <label>我的微博設定</label>
        <div class="bubble-preset-manager">
            <select id="weibo-persona-preset-select" class="form-group select"></select>
            <button id="manage-weibo-presets-btn" class="action-btn">管理</button>
        </div>
    </div>
    <div class="form-group">
        <label for="weibo-user-profession-input">職業 (顯示在昵稱下方)</label>
        <input type="text" id="weibo-user-profession-input" placeholder="例如：職業電競選手、美妝博主">
    </div>
    <div class="form-group">
        <label for="weibo-user-persona-input">隱藏人設 (僅供AI參考)</label>
        <textarea id="weibo-user-persona-input" rows="3" placeholder="例如：性格高冷，少與粉絲互動，只回復贊助商的評論。"></textarea>
    </div>
</div>
<!-- 【全新】微博設置結束 -->
 <!-- ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼ -->
<div class="form-group" id="weibo-profession-group">
    <label for="weibo-profession-input">微博職業</label>
    <input type="text" id="weibo-profession-input" placeholder="例如：職業電競選手、美妝博主、演員...">
</div>
<div class="form-group" id="weibo-instruction-group">
    <label for="weibo-instruction-input">微博指令 (AI發微博/評論時將嚴格遵守)</label>
    <textarea id="weibo-instruction-input" rows="3" placeholder="例如：多發日常訓練和比賽的內容，性格高冷，少與粉絲互動，只回復贊助商的評論。"></textarea>
</div>
<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
 <!-- ▼▼▼ 把這一整塊全新的代碼，黏貼到“管理NPC庫”按鈕的 div 之後 ▼▼▼ -->
<hr style="opacity: 0.2; margin: 20px 0;">
<div class="form-group">
    <label for="time-perception-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">啟用即時時間感知</span>
        <input type="checkbox" id="time-perception-toggle" checked>
        <span class="toggle-switch-slider"></span>
    </label>
</div>
<div id="custom-time-container" class="form-group" style="display: none;">
    <label for="custom-time-input">自訂時間</label>
    <input type="datetime-local" id="custom-time-input" style="width: 95%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-color);">
</div>
<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
<div class="form-group" id="ai-avatar-group"><label>對方頭像</label>
  <!-- ▼▼▼ 把下面這【一整塊】代碼，黏貼到 id="ai-avatar-group" 的那個 div 之後 ▼▼▼ -->
<div class="form-group" id="video-call-settings-group">
    <hr style="opacity: 0.2; margin: 20px 0;">
    <label>視頻通話介面設置</label>
    
    <!-- 1. 功能開關 -->
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
        <span>啟用視覺化介面</span>
        <label class="toggle-switch">
            <input type="checkbox" id="visual-video-call-switch">
            <span class="slider"></span>
        </label>
    </div>

    <!-- 2. 圖片上傳區 (默認隱藏) -->
    <div id="video-call-image-uploads" style="display: none;">
        <div class="form-group">
            <label>對方的視頻畫面</label>
            <div class="avatar-upload">
                <img id="char-video-image-preview" style="border-radius: 8px; width: 80px; height: 142px;">
                <button onclick="document.getElementById('char-video-image-input').click()">上傳圖片</button>
                <input type="file" id="char-video-image-input" accept="image/*" hidden>
            </div>
        </div>
        <div class="form-group">
            <label>我的視頻畫面</label>
            <div class="avatar-upload">
                <img id="user-video-image-preview" style="border-radius: 8px; width: 80px; height: 142px;">
                <button onclick="document.getElementById('user-video-image-input').click()">上傳圖片</button>
                <input type="file" id="user-video-image-input" accept="image/*" hidden>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->

  <div class="avatar-upload">
    <img id="ai-avatar-preview">
    <button onclick="document.getElementById('ai-avatar-input').click()">上傳對方頭像</button>
    <button class="change-frame-btn" data-type="ai">更換頭像框</button>
    <button id="manage-ai-avatar-library-btn">管理頭像庫</button>
    <input type="file" id="ai-avatar-input" accept="image/*">
</div>
</div>
<!-- ▼▼▼ 步驟1：在這裡黏貼情侶頭像功能的新HTML代碼 ▼▼▼ -->
<div class="form-group">
    <label for="couple-avatar-toggle" class="toggle-switch-label">
        <span class="toggle-switch-text">情侶頭像開關</span>
        <input type="checkbox" id="couple-avatar-toggle">
        <span class="toggle-switch-slider"></span>
    </label>
    <div id="couple-avatar-desc-container" style="display: none; margin-top: 10px;">
         <label for="couple-avatar-description" style="font-size: 13px; color: var(--text-secondary);">情侶頭像描述 (可選)</label>
         <input type="text" id="couple-avatar-description" placeholder="例如：一隻小貓在看月亮">
    </div>
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
<div class="form-group" id="my-persona-group"><label for="my-persona">我的人設 (My Persona)</label><textarea id="my-persona" rows="3"></textarea></div><div class="form-group" id="my-avatar-group"><label>我的頭像</label><div class="avatar-upload"><img id="my-avatar-preview"><button onclick="document.getElementById('my-avatar-input').click()">上傳我的頭像</button>
<button class="change-frame-btn" data-type="my">更換頭像框</button> <!-- ← 加回這一行 -->
<button id="open-persona-library-btn">預設</button><input type="file" id="my-avatar-input" accept="image/*"></div></div><div class="form-group" id="group-members-group"><label>群成員人設</label><div id="group-members-settings"></div>


    <!-- 【新增】管理成員按鈕 -->
    <button id="manage-members-btn" class="form-button form-button-secondary" style="margin-top: 15px;">管理群成員</button></div>
    <!-- ▼▼▼ 【全新】群聊後臺活動設置 ▼▼▼ -->
<div class="form-group" id="group-background-activity-group" style="display: none;">
    <hr style="opacity: 0.2; margin: 20px 0;">
    <label class="toggle-switch-label">
        <span class="toggle-switch-text">
            群聊後臺即時活動
            <p style="font-size: 12px; font-weight: normal; color: #ff6b6b; margin-top: 5px;">
                警告：開啟後會增加API調用和費用！
            </p>
        </span>
        <input type="checkbox" id="group-background-activity-switch">
        <span class="toggle-switch-slider"></span>
    </label>

    <div id="group-background-interval-settings" style="display: none; margin-top: 15px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <label for="group-background-interval-input" style="margin-bottom: 0;">
                活動間隔期 (秒)
                <p style="font-size: 12px; font-weight: normal; color: #999; margin-top: 5px;">
                    建議值 120-600。值越大，費用越低，但群內互動越慢。
                </p>
            </label>
            <input type="number" id="group-background-interval-input" min="60" value="120" style="width: 80px; text-align: center;">
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->

<div class="form-group"><label for="max-memory">上下文記憶條數</label><input type="number" id="max-memory" value="10"></div><div class="form-group"><label>聊天氣泡主題 <button id="reset-theme-btn" type="button">重置</button></label><div class="theme-selector"><label><input type="radio" name="theme-select" value="default" id="theme-default"> 默認</label><label><input type="radio" name="theme-select" value="pink_blue"> 粉藍</label><label><input type="radio" name="theme-select" value="blue_white"> 藍白</label><label><input type="radio" name="theme-select" value="purple_yellow"> 紫黃</label><label><input type="radio" name="theme-select" value="black_white"> 黑白</label><label><input type="radio" name="theme-select" value="yellow_white"> 黃白</label><label><input type="radio" name="theme-select" value="red_black"> 紅黑</label><label><input type="radio" name="theme-select" value="blue_yellow"> 藍黃</label><label><input type="radio" name="theme-select" value="pink_yellow"> 粉黃</label><label><input type="radio" name="theme-select" value="pink_purple"> 粉紫</label><label><input type="radio" name="theme-select" value="gray_white"> 灰白</label><label><input type="radio" name="theme-select" value="blue_green"> 藍綠</label><label><input type="radio" name="theme-select" value="pink_white"> 粉白</label><label><input type="radio" name="theme-select" value="pink_black"> 粉黑</label><label><input type="radio" name="theme-select" value="pink_green"> 粉綠</label><label><input type="radio" name="theme-select" value="green_black"> 綠黑</label></div></div>

<!-- ▼▼▼ 請將這段新代碼黏貼到“聊天氣泡主題”的 form-group 之後 ▼▼▼ -->
<div class="form-group">
    <label for="font-size-slider">聊天字體大小 <span id="font-size-value">13px</span></label>
    <input type="range" id="font-size-slider" min="12" max="20" step="1" value="13" style="width: 100%; margin-top: 8px;">
</div>
<!-- ▲▲▲ 新代碼黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】氣泡樣式預設選擇器 (已添加導入匯出功能) ▼▼▼ -->
<div class="form-group">
    <label>氣泡樣式預設</label>
    <div class="bubble-preset-manager">
        <select id="bubble-style-preset-select" class="form-group select"></select>
        <button id="manage-bubble-presets-btn" class="action-btn">管理</button>
    </div>
    <!-- ▼▼▼ 這是我們新加的導入和匯出按鈕 ▼▼▼ -->
    <div style="display: flex; gap: 10px; margin-top: 10px;">
        <button id="export-bubble-preset-btn" class="form-button form-button-secondary" style="flex:1; margin:0;">匯出氣泡</button>
        <button id="import-bubble-preset-btn" class="form-button form-button-secondary" style="flex:1; margin:0;">導入氣泡</button>
    </div>
    <input type="file" id="import-bubble-preset-input" accept=".json" style="display: none;">
    <!-- ▲▲▲ 添加結束 ▲▲▲ -->
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->


<!-- ▼▼▼ 請將這段新代碼黏貼到“聊天字體大小”的 form-group 之後 ▼▼▼ -->
<div class="form-group">
    <label for="custom-css-input">
        自訂氣泡樣式 (CSS)
        <button id="reset-custom-css-btn" type="button" style="background: none; border: 1px solid #ccc; color: #555; font-size: 12px; padding: 2px 8px; border-radius: 5px; cursor: pointer; margin-left: 10px;">重置</button>
    </label>
    <textarea id="custom-css-input" rows="5" style="width: 100%; margin-top: 8px; font-family: monospace; font-size: 12px; resize: vertical;" placeholder="/* 示例：為“我”的氣泡添加漸變背景和陰影 */
.message-bubble.user .content {
  background: linear-gradient(135deg, #a1c4fd, #c2e9fb);
  box-shadow: 0 4px 10px rgba(0,0,0,0.1);
  border-radius: 15px 4px 15px 15px;
}"></textarea>
</div>
<!-- ▲▲▲ 新代碼黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 請將這段新代碼黏貼到自訂CSS輸入框的 form-group 之後 ▼▼▼ -->
<div class="form-group">
    <label>即時預覽</label>
    <div id="settings-preview-area">
        <!-- JS會在這裡生成預覽內容 -->
    </div>
</div>
<!-- ▲▲▲ 新代碼黏貼結束 ▲▲▲ -->

            <div class="form-group">
                <label>聊天背景</label>
                <div class="bg-upload-container">
                    <button type="button" class="form-button-secondary" style="width: auto; padding: 8px 12px; margin-top: 0;" onclick="document.getElementById('bg-input').click()">上傳背景圖</button>
                    <button type="button" id="remove-bg-btn">移除背景</button>
                </div>
                <img id="bg-preview" class="bg-preview-img">
                <input type="file" id="bg-input" accept="image/*" style="display: none;">
            </div>
<!-- ▼▼▼ 把這一整塊全新的代碼，黏貼到你剛剛刪除代碼的位置 ▼▼▼ -->

<!-- 記錄管理區 -->
<div class="form-group" style="display: flex; gap: 10px;">
    <button class="form-button form-button-secondary" id="import-chat-history-btn" style="flex: 1; margin: 0;">導入聊天記錄</button>
    <button class="form-button form-button-secondary" id="export-chat-history-btn" style="flex: 1; margin: 0;">匯出聊天記錄</button>
</div>
<input type="file" id="import-chat-history-input" accept="application/json" style="display: none;">
<button class="form-button form-button-secondary" id="search-chat-btn">查找聊天記錄</button>
<button class="form-button form-button-secondary" id="clear-chat-btn">清空聊天記錄</button>
<button class="form-button form-button-secondary" id="block-chat-btn" style="background-color: #ff3b30; color: white; border-color: #ff3b30;">拉黑對方</button>

<!-- ▲▲▲ 新代碼黏貼結束 ▲▲▲ -->

</div><div class="modal-footer"><button class="cancel" id="cancel-chat-settings-btn">取消</button><button class="save" id="save-chat-settings-btn">保存</button></div></div></div>
    
    <div id="persona-library-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>我的人設庫</span><button id="add-persona-preset-btn" class="action-button">添加</button></div><div class="modal-body"><div id="persona-library-grid"></div></div><div class="modal-footer"><button class="cancel" id="close-persona-library-btn">關閉</button></div></div></div>
    
<!-- ▼▼▼ 從這裡開始替換 ▼▼▼ -->
<div id="persona-editor-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span id="persona-editor-title">添加人設預設</span>
        </div>
        <div class="modal-body">
            <!-- 【新增】NPC名字輸入框 -->
            <div class="form-group" id="npc-editor-name-group">
                <label for="npc-editor-name-input">NPC 名字</label>
                <input type="text" id="npc-editor-name-input">
            </div>
            <div class="form-group">
                <label>頭像</label>
                <div class="avatar-upload">
                    <img id="preset-avatar-preview">
                    <button onclick="document.getElementById('preset-avatar-input').click()">上傳頭像</button>
                    <!-- 【新增】給這個按鈕一個ID，方便我們控制它 -->
                    <button id="persona-editor-change-frame-btn" class="change-frame-btn" data-type="member">更換頭像框</button>
                    <input type="file" id="preset-avatar-input" accept="image/*">
                </div>
            </div>
            <div class="form-group">
                <label for="preset-persona-input">人設</label>
                <textarea id="preset-persona-input" rows="4" placeholder="在此輸入這個人設的詳細設定..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-persona-editor-btn">取消</button>
            <button class="save" id="save-persona-preset-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替換到這裡結束 ▲▲▲ -->



    <div id="member-settings-modal" class="modal"><div class="modal-content"><div class="modal-header"><span>編輯群成員</span></div><div class="modal-body">
    <div class="form-group"><label for="member-name-input">名字</label><input type="text" id="member-name-input"></div>
    <div class="form-group"><label for="member-persona-input">人設</label><textarea id="member-persona-input" rows="4"></textarea></div>
    <div class="form-group"><label>頭像</label><div class="avatar-upload"><img id="member-avatar-preview"><button onclick="document.getElementById('member-avatar-input').click()">上傳頭像</button><input type="file" id="member-avatar-input" accept="image/*"></div></div>
    </div><div class="modal-footer"><button class="cancel" id="cancel-member-settings-btn">取消</button><button class="save" id="save-member-settings-btn">保存</button></div></div></div>
    
    <div id="custom-modal-overlay">
        <div id="custom-modal">
            <div class="custom-modal-header" id="custom-modal-title"></div>
            <div class="custom-modal-body" id="custom-modal-body"></div>
            <div class="custom-modal-footer">
                <button id="custom-modal-cancel">取消</button>
                <button id="custom-modal-confirm" class="confirm-btn">確定</button>
            </div>
        </div>
    </div>


    <div id="preset-actions-modal" class="modal">
        <div id="custom-modal" style="width: 250px;">
            <div class="custom-modal-footer">
                <button id="preset-action-edit">編輯預設</button>
                <button id="preset-action-delete" class="btn-danger">刪除預設</button>
                <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
            </div>
        </div>
    </div>

    <div id="transfer-modal">
        <div class="transfer-content">
            <div class="transfer-header">給Ta一個驚喜！</div>
            <div class="transfer-input-group">
                <label for="transfer-amount">轉帳金額</label>
                <input type="number" id="transfer-amount" placeholder="0.00" min="0" max="9999999999999" step="0.01">
            </div>
            <div class="transfer-input-group">
                <label for="transfer-note">備註 (可選)</label>
                <input type="text" id="transfer-note" placeholder="留下你的小心思~" maxlength="20">
            </div>
            <div class="transfer-actions">
                <button id="transfer-cancel-btn">取消</button>
                <button id="transfer-confirm-btn">確認轉帳</button>
            </div>
        </div>
    </div>

 <div id="battery-alert-modal">
    <div class="battery-alert-content">
        <img id="battery-alert-image" src="">
        <p id="battery-alert-text"></p>
    </div>
</div>

    <audio id="audio-player" style="display:none;"></audio>
<!-- ▼▼▼ 在這裡添加下面這行新的音訊元素 ▼▼▼ -->
<audio id="tts-audio-player" style="display:none;"></audio>
<!-- ▲▲▲ 添加結束 ▲▲▲ -->
<audio id="ringtone-player" loop></audio>
<audio id="notification-sound-player" preload="auto"></audio>
<!-- ▼▼▼ 用下面這【一整塊完整代碼】替換掉你舊的 id="create-post-modal" 的整個 div ▼▼▼ -->
<div id="create-post-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 90%;">
        <div class="modal-header">
            <span id="create-post-modal-title">發佈動態</span> <!-- 使用ID方便JS修改標題 -->
        </div>
        <div class="modal-body">
            <!-- 公開文字輸入區 -->
            <div class="form-group">
                <textarea id="post-public-text" rows="3" placeholder="分享新鮮事..."></textarea>
            </div>

            <!-- === 【新增】模式切換開關 === -->
            <div class="post-mode-switcher">
                <button id="switch-to-image-mode" class="mode-btn active">上傳圖片</button>
                <button id="switch-to-text-image-mode" class="mode-btn">使用文字圖</button>
            </div>

            <!-- === 【新增】圖片模式區域 === -->
            <div id="image-mode-content" class="post-mode-content active">
                <div class="form-group">
                    <div id="post-image-preview-container" class="post-image-preview-container">
                        <img id="post-image-preview" src="" alt="圖片預覽">
                        <button id="post-remove-image-btn">×</button>
                    </div>
                    <div class="post-image-upload-options">
                        <button id="post-upload-local-btn" class="form-button-secondary">本地上傳</button>
                        <button id="post-use-url-btn" class="form-button-secondary">網路URL</button>
                        <input type="file" id="post-local-image-input" accept="image/*" hidden>
                    </div>
                </div>
                <!-- 這個是給AI看的圖片描述，在微博模式下我們會用JS隱藏它 -->
                <div id="post-image-desc-group" class="form-group" style="display: none;">
                    <label>圖片描述 (必填，給AI看)</label>
                    <input type="text" id="post-image-description" placeholder="簡單描述圖片內容，説明AI理解">
                </div>
            </div>

            <!-- === 【新增】文字圖模式區域 === -->
            <div id="text-image-mode-content" class="post-mode-content">
                <div class="form-group">
                    <label>文字圖 (給AI理解用的描述，點擊圖片後可見)</label>
                    <textarea id="post-hidden-text" rows="4" placeholder="在這裡寫下圖片描述..."></textarea>
                </div>
            </div>

<!-- ▼▼▼ 在這裡黏貼下面這塊新代碼 ▼▼▼ -->
<div class="form-group" id="post-visibility-group">
    <label>可見範圍</label>
    <div style="display: flex; gap: 20px; margin-bottom: 10px;">
        <label><input type="radio" name="visibility" value="all" checked> 所有人可見</label>
        <label><input type="radio" name="visibility" value="groups"> 僅分組可見</label>
    </div>
    <div id="post-visibility-groups" style="display: none; max-height: 120px; overflow-y: auto; background-color: #f0f2f5; padding: 10px; border-radius: 8px;">
        <!-- 分組的多選框會由JS動態生成在這裡 -->
    </div>
</div>
<!-- ▲▲▲ 新代碼黏貼結束 ▲▲▲ -->
            <!-- 這個是動態功能的評論開關，在微博模式下我們會用JS隱藏它 -->
            <div class="form-group" id="post-comments-toggle-group" style="margin-top: 15px;">
                <label for="post-comments-toggle" class="toggle-switch-label">
                    <span class="toggle-switch-text">允許角色看見評論區</span>
                    <input type="checkbox" id="post-comments-toggle" checked>
                    <span class="toggle-switch-slider"></span>
                </label>
            </div>
            
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-post-btn">取消</button>
            <button class="save" id="confirm-create-post-btn">發佈</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->


<!-- ▼▼▼ 請將這個新的模態框HTML黏貼到所有其他模態框之後 ▼▼▼ -->
<div id="group-management-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>管理好友分組</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>新建分組</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="new-group-name-input" placeholder="輸入分組名..." style="flex-grow: 1;">
                    <button id="add-new-group-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
                </div>
            </div>
            <hr style="opacity: 0.2;">
            <div id="existing-groups-list" style="display: flex; flex-direction: column; gap: 10px;">
                <!-- 分組清單將由JS動態生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-group-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新代碼黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 請將這段新HTML黏貼到所有模態框的末尾 ▼▼▼ -->
<div id="message-actions-modal" class="modal">
    <div id="custom-modal" style="width: 250px;">
        <div class="custom-modal-footer">
            <!-- 新的操作按鈕 -->
            <button id="edit-message-btn">編輯消息</button>
            <button id="copy-message-btn">複製文本</button>
            <button id="recall-message-btn">撤回</button>
<button id="quote-message-btn">引用</button>
            <button id="select-message-btn">進入多選</button>
            <!-- 取消按鈕 -->
            <button id="cancel-message-action-btn" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 請將這段新HTML黏貼到所有模態框的末尾 ▼▼▼ -->
<div id="post-actions-modal" class="modal">
    <div id="custom-modal" style="width: 250px;">
        <div class="custom-modal-footer">
            <button id="edit-post-btn">編輯動態</button>
            <button id="copy-post-btn">複製內容</button>           
            <button id="cancel-post-action-btn">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】視覺化消息編輯器模態框 ▼▼▼ -->
<div id="message-editor-modal" class="modal">
    <div class="modal-content" style="height: 75%;">
        <div class="modal-header">
            <span>編輯與拆分消息</span>
        </div>
        <div class="modal-body" id="message-editor-body">
            <!-- 編輯器容器，JS會在這裡動態生成文字方塊 -->
            <div id="message-editor-container"></div>
            <!-- 添加新消息的按鈕 -->
            <button id="add-message-editor-block-btn" class="form-button form-button-secondary" style="margin-top: 15px;">
                [+] 添加下一條消息
            </button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-advanced-editor-btn">取消</button>
            <button class="save" id="save-advanced-editor-btn">保存更改</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】外賣請求模態框 ▼▼▼ -->
<div id="waimai-request-modal" class="modal">
    <div class="modal-content" style="width: 290px;">
        <div class="modal-header">
            <span>發起外賣代付</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="waimai-product-info">商品資訊</label>
                <input type="text" id="waimai-product-info" placeholder="例如：一杯楊枝甘露">
            </div>
            <div class="form-group">
                <label for="waimai-amount">代付金額 (元)</label>
                <input type="number" id="waimai-amount" placeholder="例如：21" min="0" step="0.01">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="waimai-cancel-btn">取消</button>
            <button class="save" id="waimai-confirm-btn">發起請求</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】新建約定/倒計時模態框 ▼▼▼ -->
<div id="create-countdown-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>新建約定</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="countdown-title-input">約定標題</label>
                <input type="text" id="countdown-title-input" placeholder="例如：我的生日">
            </div>
            <div class="form-group">
                <label for="countdown-date-input">約定日期與時間</label>
                <input type="datetime-local" id="countdown-date-input"style="width: 95%; padding: 8px; border-radius: 8px; border: 1px solid var(--border-color);">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-countdown-btn">取消</button>
            <button class="save" id="confirm-create-countdown-btn">保存約定</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】發紅包模態框 ▼▼▼ -->
<div id="red-packet-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>發紅包</span>
        </div>
        <div class="modal-body" style="padding: 0;">
<!-- 1. 頁簽切換 -->
<div class="frame-tabs">
    <div id="rp-tab-group" class="frame-tab active">拼手氣紅包</div>
    <div id="rp-tab-direct" class="frame-tab">專屬紅包</div>
</div>

            <!-- 2. 拼手氣紅包內容區 -->
            <div id="rp-content-group" class="frame-content" style="padding: 20px 15px;">
                <div class="form-group">
                    <label>總金額 (元)</label>
                    <input type="number" id="rp-group-amount" placeholder="0.00">
                </div>
                <div class="form-group">
                    <label>紅包個數</label>
                    <input type="number" id="rp-group-count" placeholder="填寫紅包個數">
                </div>
                <div class="form-group">
                    <label>祝福語</label>
                    <input type="text" id="rp-group-greeting" placeholder="恭喜發財，大吉大利！">
                </div>
                <p id="rp-group-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                <button id="send-group-packet-btn" class="form-button">塞錢進紅包</button>
            </div>

            <!-- 3. 專屬紅包內容區 -->
            <div id="rp-content-direct" class="frame-content" style="display: none; padding: 20px 15px;">
                <div class="form-group">
                    <label>發送給</label>
                    <select id="rp-direct-receiver"></select>
                </div>
                <div class="form-group">
                    <label>金額 (元)</label>
                    <input type="number" id="rp-direct-amount" placeholder="0.00">
                </div>
                <div class="form-group">
                    <label>祝福語</label>
                    <input type="text" id="rp-direct-greeting" placeholder="恭喜發財，大吉大利！">
                </div>
                 <p id="rp-direct-total" style="text-align: center; font-size: 24px; font-weight: bold; margin: 10px 0;">¥ 0.00</p>
                <button id="send-direct-packet-btn" class="form-button">塞錢進紅包</button>
            </div>
        </div>
        <div class="modal-footer" style="justify-content: center;">
             <button class="cancel" id="cancel-red-packet-btn" style="width: 100%;">取消</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】紅包詳情模態框 ▼▼▼ -->
<div id="red-packet-details-modal" class="modal">
    <div class="modal-content" style="width: 280px; height: auto; background-color: #f7f7f7;">
        <div class="modal-header" style="background-color: #F96259; color: white; border-bottom: none; padding-bottom: 5px;">
            <div style="text-align: center; width: 100%;">
                <div id="rp-details-sender" style="font-size: 16px;"></div>
                <div style="font-size: 13px; opacity: 0.8;">的紅包</div>
            </div>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <p id="rp-details-greeting" style="text-align: center; font-size: 20px; color: #333; margin: 0 0 20px 0;"></p>
            <div id="rp-details-my-amount" style="text-align: center; display: none; margin-bottom: 20px;">
                <span style="font-size: 40px; font-weight: bold; color: #E44D44;">0.00</span>
                <span style="font-size: 18px; color: #E44D44;">元</span>
            </div>
            <div id="rp-details-summary" style="font-size: 13px; color: #8a8a8a; border-top: 1px solid #e0e0e0; padding-top: 10px;"></div>
            <div id="rp-details-list" style="max-height: 150px; overflow-y: auto; margin-top: 10px;">
                <!-- 領取詳情將由JS動態生成在這裡 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-rp-details-btn" style="width: 100%;">關閉</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】創建投票模態框 ▼▼▼ -->
<div id="create-poll-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>發起投票</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="poll-question-input">投票問題</label>
                <textarea id="poll-question-input" rows="2" placeholder="例如：今晚我們看什麼電影？"></textarea>
            </div>
            <div class="form-group">
                <label>投票選項 (至少2項)</label>
                <div id="poll-options-container" style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- 投票選項將由JS動態生成在這裡 -->
                </div>
                <button id="add-poll-option-btn" class="form-button form-button-secondary" style="margin-top: 12px;">+ 添加選項</button>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-create-poll-btn">取消</button>
            <button class="save" id="confirm-create-poll-btn">發起投票</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】AI頭像庫管理模態框 ▼▼▼ -->
<div id="ai-avatar-library-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span id="ai-avatar-library-title">對方的頭像庫</span>
            <button id="add-ai-avatar-btn" class="action-button">添加</button>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <div id="ai-avatar-library-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px;">
                <!-- 頭像庫內容將由JS動態生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-ai-avatar-library-btn" style="width: 100%;">關閉</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】使用者分享連結模態框 ▼▼▼ -->
<div id="share-link-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto;">
        <div class="modal-header">
            <span>分享連結</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="link-title-input">標題</label>
                <input type="text" id="link-title-input" placeholder="輸入文章或連結的標題">
            </div>
            <div class="form-group">
                <label for="link-description-input">摘要 (可選)</label>
                <textarea id="link-description-input" rows="2" placeholder="簡單描述一下連結內容"></textarea>
            </div>
            <div class="form-group">
                <label for="link-source-input">來源名稱 (可選)</label>
                <input type="text" id="link-source-input" placeholder="例如：知乎日報、B站">
            </div>
            <div class="form-group">
                <label for="link-content-input">完整內容 (可選，用於流覽器內顯示)</label>
                <textarea id="link-content-input" rows="4" placeholder="黏貼或輸入完整的文章內容"></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-share-link-btn">取消</button>
            <button class="save" id="confirm-share-link-btn">分享</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】精緻版轉帳操作彈窗 ▼▼▼ -->
<div id="transfer-actions-modal" class="modal">
    <div class="transfer-actions-content">
        <div class="transfer-actions-header">請選擇操作</div>
        <div class="transfer-actions-body">
            <p>你收到了來自 <strong id="transfer-sender-name"></strong> 的一筆轉帳。</p>
        </div>
        <div class="transfer-actions-footer">
            <button id="transfer-action-decline" class="action-btn decline">殘忍拒絕</button>
            <button id="transfer-action-accept" class="action-btn accept">開心收下</button>
        </div>
        <button id="transfer-action-cancel" class="cancel-btn">×</button>
    </div>
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】通話記錄詳情模態框 ▼▼▼ -->
<div id="call-transcript-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span id="transcript-modal-title">通話詳情</span>
        </div>
        <div class="modal-body" id="transcript-modal-body" style="background-color: #f0f2f5;">
            <!-- 通話文字記錄將由JS動態生成在這裡 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="delete-transcript-btn" style="background-color: #ff3b30; color: white; border-color: #ff3b30;">刪除記錄</button>
            <button class="save" id="close-transcript-modal-btn" style="width: 100%;">關閉</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】分享目標選擇器模態框 ▼▼▼ -->
<div id="share-target-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
<div class="modal-header">
    <span id="share-target-modal-title">分享到...</span>
</div>
        <div class="modal-body" id="share-target-list" style="padding: 0;">
            <!-- 聊天清單將由JS動態生成在這裡 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-share-target-btn">取消</button>
            <button class="save" id="confirm-share-target-btn">確認分享</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】分享記錄檢視器模態框 ▼▼▼ -->
<div id="shared-history-viewer-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span id="shared-history-viewer-title">聊天記錄</span>
        </div>
        <div class="modal-body" id="shared-history-viewer-content" style="background-color: #f0f2f5;">
            <!-- 分享的聊天記錄氣泡將由JS動態生成在這裡 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-shared-history-viewer-btn" style="width:100%;">關閉</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】世界書分類管理模態框 ▼▼▼ -->
<div id="world-book-category-manager-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>管理世界書分類</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>新建分類</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="new-category-name-input" placeholder="輸入分類名..." style="flex-grow: 1;">
                    <button id="add-new-category-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
                </div>
            </div>
            <hr style="opacity: 0.2;">
            <div id="existing-categories-list" style="display: flex; flex-direction: column; gap: 10px;">
                <!-- 分類清單將由JS動態生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-category-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】角色專屬NPC庫管理介面 ▼▼▼ -->
<div id="npc-management-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-npc-management">‹</span>
        <span id="npc-management-title">NPC 庫管理</span>
        <span class="action-btn" id="add-new-npc-btn">+</span>
    </div>
    <div class="list-container" id="npc-management-list">
        <!-- NPC清單將由JS動態生成在這裡 -->
    </div>
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】在這裡黏貼所有論壇相關的HTML代碼 ▼▼▼ -->

<!-- 1. 論壇主螢幕 (顯示所有小組) -->
<div id="forum-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>圈子</span>
        <div class="header-actions">
                  <!-- ▼▼▼ 在這裡添加篩選圖示 ▼▼▼ -->
        <span class="action-btn filter-btn" id="forum-filter-btn" title="篩選">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>
        </span>
        <!-- ▲▲▲ 添加結束 ▲▲▲ -->
            <span class="action-btn" id="create-group-btn" style="font-size: 28px; font-weight: 300;">+</span>
        </div>
    </div>
    <div id="forum-group-list" class="list-container" style="padding: 15px; display: grid; grid-template-columns: 1fr 1fr; gap: 15px; align-content: start;">
        <!-- 小組清單將由JS動態生成在這裡 -->
    </div>
</div>

<!-- ▼▼▼ 用這整塊代碼替換舊的 id="group-screen" ▼▼▼ -->
<div id="group-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-to-forum-list">‹</span>
        <span id="group-screen-title">小組名稱</span>
        <div class="header-actions">
                  <!-- ▼▼▼ 在這裡添加篩選圖示 ▼▼▼ -->
        <span class="action-btn filter-btn" id="group-filter-btn" title="篩選">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>
        </span>
        <!-- ▲▲▲ 添加結束 ▲▲▲ -->
            <!-- 【核心修改】我們在這裡新增了一個通用的“生成內容”按鈕 -->
            <span class="action-btn" id="generate-group-content-btn" title="生成內容">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg>
            </span>
            <span class="action-btn" id="create-forum-post-btn" style="font-size: 28px; font-weight: 300;">+</span>
        </div>
    </div>
<!-- ▼▼▼ 用這塊新代碼替換 ▼▼▼ -->
<div id="fanfic-preference-bar" style="display: none; padding: 10px 15px; background-color: #f0f2f5; border-bottom: 1px solid var(--border-color); flex-shrink: 0;">
    <div class="form-group" style="margin: 0;">
        <label style="font-size: 14px; margin-bottom: 5px;">選擇CP偏好</label>
        <div style="display: flex; align-items: center; gap: 10px;">
            <select id="fanfic-char1-select" style="flex: 1;"></select>
            <span>&</span>
            <select id="fanfic-char2-select" style="flex: 1;"></select>
            <button id="trigger-fanfic-generation-btn" class="form-button" style="margin: 0; padding: 10px 15px; width: auto;">生成</button>
        </div>
    </div>
    <!-- 這是我們新加的世界觀輸入框 -->
    <div class="form-group" style="margin-top: 10px; margin-bottom: 0;">
        <label for="fanfic-worldview-input" style="font-size: 14px; margin-bottom: 5px;">世界觀偏好 (可選)</label>
        <input type="text" id="fanfic-worldview-input" placeholder="例如：ABO、哨向、現代大學AU...">
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->

    <div id="group-post-list" class="list-container" style="padding-top: 0;">
        <!-- 帖子清單將由JS動態生成在這裡 -->
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->


<!-- 3. 單個帖子頁面 (顯示帖子內容和評論) -->
<div id="post-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-to-group-screen">‹</span>
        <span>帖子詳情</span>
        <div class="header-actions">
            <span class="action-btn" id="repost-to-chat-btn">轉載</span>
        </div>
    </div>
    <div id="post-detail-content" class="list-container" style="padding: 20px;">
        <!-- 帖子和評論將由JS動態生成在這裡 -->
    </div>
    <!-- 帖子頁的評論輸入框 -->
    <div id="post-comment-input-area" class="chat-input-area" style="visibility: visible;">
         <div class="chat-input-main-row">
            <textarea id="post-comment-input" rows="1" placeholder="發佈你的評論..."></textarea>
            <button id="send-post-comment-btn" class="action-button">發送</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 【全新】這是為圈子分類篩選新增的彈窗 ▼▼▼ -->
<div id="forum-filter-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 60%;">
        <div class="modal-header">
            <span>按分類篩選</span>
        </div>
        <div class="modal-body">
            <div id="forum-filter-category-list">
                <!-- 分類標籤將由JS動態生成在這裡 -->
            </div>
        </div>
        <div class="modal-footer" style="justify-content: space-between;">
            <button class="cancel" id="reset-forum-filter-btn" style="width: 30%;">重置</button>
            <button class="cancel" id="cancel-forum-filter-btn" style="width: 30%;">取消</button>
            <button class="save" id="apply-forum-filter-btn" style="width: 30%;">應用</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->


<!-- ▲▲▲ 論壇相關HTML代碼黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】自訂頭像框管理模態框 ▼▼▼ -->
<div id="custom-frame-manager-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>管理我的頭像框</span>
            <button id="upload-custom-frame-btn" class="action-button">上傳</button>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <div id="custom-frame-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px;">
                <!-- 自訂頭像框將由JS動態生成在這裡 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-frame-manager-btn" style="width: 100%;">關閉</button>
        </div>
    </div>
</div>
<input type="file" id="custom-frame-upload-input" accept="image/png, image/gif" hidden multiple>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->

<!-- ▼▼▼ 【已修改】頭像框選擇模態框 ▼▼▼ -->
<div id="avatar-frame-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>選擇頭像框</span>
            <!-- 【核心修改】我們在這里加一個“管理”按鈕 -->
            <button id="manage-custom-frames-btn" class="action-button">管理</button>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <!-- 【核心修改】不再需要Tabs，只有一個Grid -->
            <div id="avatar-frame-grid" class="frame-grid">
                <!-- 頭像框選項（包括“無”和自訂的）會在這裡生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-frame-settings-btn">取消</button>
            <button class="save" id="save-frame-settings-btn">保存</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 用這整塊【全新設計】的代碼，替換舊的 id="send-location-modal" ▼▼▼ -->
<div id="send-location-modal" class="modal">
    <div class="modal-content" style="width: 300px; height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>發送定位與軌跡</span>
        </div>
        <div class="modal-body" style="padding-bottom: 5px;">
            <!-- 核心資訊 -->
            <div class="form-group">
                <label for="user-location-input">我的位置 (起點)</label>
                <input type="text" id="user-location-input" placeholder="例如：市中心的咖啡館">
            </div>
            <div class="form-group">
                <label for="ai-location-input">Ta的位置 (終點)</label>
                <input type="text" id="ai-location-input" placeholder="例如：海邊的燈塔">
            </div>
            <div class="form-group">
                <label for="distance-input">相距</label>
                <input type="text" id="distance-input" placeholder="例如：約5公里 (必填)">
            </div>
            
            <hr style="opacity: 0.2;">

            <!-- 【全新】行動軌跡輸入區 -->
            <div class="form-group">
                <label>行動軌跡 (可選，按順序填寫)</label>
                <div id="trajectory-points-container" style="display: flex; flex-direction: column; gap: 8px;">
                    <!-- JS會在這裡動態添加輸入框 -->
                </div>
                <button id="add-trajectory-point-btn" class="form-button form-button-secondary" style="margin-top: 12px;">+ 添加途經點</button>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="location-cancel-btn">取消</button>
            <button class="save" id="location-confirm-btn">發送</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】黏貼懸浮歌詞欄設置模態框 ▼▼▼ -->
<div id="lyrics-settings-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>懸浮歌詞設置</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="lyrics-font-size-slider">字體大小: <span id="lyrics-font-size-value">14px</span></label>
                <input type="range" id="lyrics-font-size-slider" min="12" max="24" value="14" style="width: 100%;">
            </div>
            <div class="form-group">
                <label for="lyrics-bg-opacity-slider">背景不透明度: <span id="lyrics-bg-opacity-value">0%</span></label>
                <input type="range" id="lyrics-bg-opacity-slider" min="0" max="100" value="0" style="width: 100%;">
            </div>
            <div class="form-group">
                <label for="lyrics-font-color-picker">字體顏色</label>
                <input type="color" id="lyrics-font-color-picker" value="#FFFFFF" style="width: 100%; height: 40px;">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="reset-lyrics-settings-btn">恢復默認</button>
            <button class="save" id="close-lyrics-settings-btn">完成</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新HTML黏貼結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】這是“選擇搜索源”的彈窗，請黏貼到body末尾 ▼▼▼ -->
<div id="music-source-selector-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>選擇搜索源</span>
        </div>
        <div class="modal-body" style="text-align: left; padding: 20px;">
            <label style="display: block; margin-bottom: 15px; cursor: pointer;">
                <input type="radio" name="search-source" value="all" checked> 全部來源 (網易雲 + QQ音樂)
            </label>
            <label style="display: block; margin-bottom: 15px; cursor: pointer;">
                <input type="radio" name="search-source" value="netease"> 僅網易雲音樂
            </label>
            <label style="display: block; cursor: pointer;">
                <input type="radio" name="search-source" value="tencent"> 僅QQ音樂
            </label>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-source-select-btn">取消</button>
            <button class="save" id="confirm-source-select-btn">開始搜索</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
 <!-- ▼▼▼ 【全新】這是微博關注列表的彈窗，黏貼到 </body> 前面 ▼▼▼ -->
<div id="weibo-following-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>關注列表</span>
        </div>
        <div class="modal-body" style="padding: 0;">
            <!-- 【核心】這個容器將帶捲軸 -->
            <div id="weibo-following-list-container">
                <!-- 關注清單將由JS動態生成在這裡 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-following-list-btn" style="width: 100%;">關閉</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
<!-- 塔羅牌占卜主模態框 -->
<div id="tarot-divination-modal" class="modal">
    <div class="modal-content" style="height: 85%; width: 95%;">
        
        <!-- 1. 占卜設置介面 -->
        <div id="tarot-setup-view">
            <div class="modal-header">
                <span>塔羅牌占卜</span>
                <div>
                    <span id="tarot-history-btn" class="action-btn" style="font-size: 16px;">歷史</span>
                    <span id="close-tarot-modal-btn" class="action-btn" style="font-size: 16px;">關閉</span>
                </div>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="tarot-question-input">您的問題或關注點</label>
                    <textarea id="tarot-question-input" rows="2" placeholder="例如：我近期的桃花運如何？"></textarea>
                </div>
                <div class="form-group">
                    <label for="tarot-spread-select">選擇牌陣</label>
                    <select id="tarot-spread-select">
                        <option value="single">單張牌 - 快速指引</option>
                        <option value="three_past_present_future">三張牌 - 過去/現在/未來</option>
                        <option value="three_situation_challenge_advice">三張牌 - 情境/挑戰/建議</option>
                        <option value="celtic_cross">凱爾特十字 - 深度分析 (10張牌)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>牌面方向</label>
                    <div style="display: flex; gap: 20px;">
                        <label><input type="radio" name="tarot-orientation" value="upright" checked> 僅正位</label>
                        <label><input type="radio" name="tarot-orientation" value="reversed"> 包含逆位</label>
                    </div>
                </div>
                <button id="draw-tarot-cards-btn" class="form-button" style="margin-top: 20px;">洗牌並抽牌</button>
            </div>
        </div>

        <!-- 2. 占卜結果介面 (預設隱藏) -->
        <div id="tarot-result-view" style="display: none; height: 100%; display: flex; flex-direction: column;">
            <div class="modal-header">
                <span id="back-to-tarot-setup-btn" class="action-btn" style="font-size: 16px;">返回</span>
                <span>占卜結果</span>
            </div>
            <div class="modal-body" id="tarot-result-display">
                <!-- 結果將由JS動態生成在這裡 -->
            </div>
            <div class="modal-footer">
                <button id="send-tarot-result-btn" class="save" style="width: 100%;">發給塔羅師解讀</button>
            </div>
        </div>

        <!-- 3. 歷史記錄介面 (預設隱藏) -->
        <div id="tarot-history-view" style="display: none; height: 100%; display: flex; flex-direction: column;">
            <div class="modal-header">
                <span id="back-to-tarot-main-btn" class="action-btn" style="font-size: 16px;">返回</span>
                <span>占卜歷史</span>
            </div>
            <div class="modal-body" id="tarot-history-list">
                <!-- 歷史記錄將由JS動態生成在這裡 -->
            </div>
        </div>
    </div>
</div>
<!-- ▼▼▼ 【全新】這裡是整個情侶空間功能的HTML代碼 ▼▼▼ -->
<!-- 2. 切換角色的彈窗 -->
<div id="ls-char-selector-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>選擇空間</span>
        </div>
        <div class="modal-body" id="ls-char-selector-list" style="padding: 0;">
            <!-- 角色清單會由JS動態生成 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-switch-char-btn" style="width:100%;">取消</button>
        </div>
    </div>
</div>

<!-- 3. 發佈說說的彈窗 -->
<div id="ls-create-moment-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>想對Ta說...</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <textarea id="ls-moment-content-input" rows="5" placeholder="在這裡寫下你們的私密話語..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-moment-btn">取消</button>
            <button class="save" id="ls-confirm-moment-btn">發佈</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 用這整塊新代碼，替換掉你舊的 ls-create-album-modal ▼▼▼ -->
<!-- 4. 創建相冊/上傳照片的彈窗 (這是修改後的版本) -->
<div id="ls-create-album-modal" class="modal">
     <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <!-- 標題已修改 -->
            <span id="ls-album-modal-title">上傳照片</span>
        </div>
        <div class="modal-body">
            <!-- 新增：模式切換開關 (複用動態的樣式) -->
            <div class="post-mode-switcher">
                <button id="ls-switch-to-image-mode" class="mode-btn active">上傳圖片</button>
                <button id="ls-switch-to-text-image-mode" class="mode-btn">使用文字圖</button>
            </div>

            <!-- 模式1: 上傳圖片 -->
            <div id="ls-image-mode-content" class="post-mode-content active">
                <div class="form-group">
                    <label>選擇照片 (僅限單張)</label>
                    <div id="ls-photo-preview-container"></div>
                    <button class="form-button form-button-secondary" id="ls-select-photos-btn">選擇照片</button>
                    <!-- 關鍵：這裡的 input 移除了 multiple 屬性，現在只能單選 -->
                    <input type="file" id="ls-photo-input" accept="image/*" hidden>
                </div>
                 <div class="form-group">
                    <label>圖片描述 (必填)</label>
                    <textarea id="ls-photo-desc-input" rows="3" placeholder="為這張照片寫下注腳..."></textarea>
                </div>
            </div>

            <!-- 模式2: 使用文字圖 -->
            <div id="ls-text-image-mode-content" class="post-mode-content" style="display: none;">
                <div class="form-group">
                    <label>文字圖描述 (必填)</label>
                    <textarea id="ls-text-image-desc-input" rows="5" placeholder="在這裡寫下你的心情或故事..."></textarea>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-album-btn">取消</button>
            <button class="save" id="ls-confirm-album-btn">確認上傳</button>
        </div>
    </div>
</div><!-- ▼▼▼ 把這一整塊全新的HTML代碼，黏貼到 </body> 標籤的正上方 ▼▼▼ -->

<!-- 【全新】情侶空間-寫情書/回信的彈窗 -->
<div id="ls-create-letter-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span id="ls-letter-modal-title">給Ta寫一封信</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="ls-letter-recipient-input">收信人</label>
                <!-- 收信人通常是固定的，所以我們禁用這個輸入框 -->
                <input type="text" id="ls-letter-recipient-input" disabled>
            </div>
            <div class="form-group">
                <label for="ls-letter-content-input">情書內容</label>
                <textarea id="ls-letter-content-input" rows="8" placeholder="在這裡寫下你的心意..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-letter-btn">取消</button>
            <button class="save" id="ls-confirm-letter-btn">寄出</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 把這一整塊全新的HTML代碼，黏貼到 </body> 標籤的正上方 ▼▼▼ -->

<!-- 【全新美化版】情侶空間-情書檢視器 -->
<div id="ls-letter-viewer-modal" class="modal">
    <div class="ls-letter-viewer-content">
        <!-- 頭部：收信人信息 -->
        <div class="letter-viewer-header">
            <img id="ls-viewer-recipient-avatar" class="meta-avatar">
            <div class="recipient-info">
                <div class="label">To my dear:</div>
                <div id="ls-viewer-recipient-name" class="name"></div>
            </div>
        </div>
        <!-- 中間：信件正文 -->
        <div id="ls-viewer-body" class="letter-viewer-body">
            <!-- JS會在這裡填充信件內容 -->
        </div>
        <!-- 底部：發信人資訊和操作按鈕 -->
        <div class="letter-viewer-footer">
            <div class="sender-info">
                <div id="ls-viewer-sender-name"></div>
                <div id="ls-viewer-timestamp" class="timestamp"></div>
            </div>
            <div class="letter-actions">
                <button id="ls-close-letter-viewer-btn">關閉</button>
                <button id="ls-reply-letter-btn" class="primary">回信</button>
            </div>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->

<!-- ▲▲▲ 替換結束 ▲▲▲ -->

<!-- ▼▼▼ 【全新】情侶空間設置彈窗 ▼▼▼ -->
<div id="ls-settings-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>情侶空間設置</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="ls-start-date-input">我們在一起的第一天</label>
                <input type="date" id="ls-start-date-input" style="width: 100%; padding: 10px; box-sizing: border-box;">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-settings-cancel-btn">取消</button>
            <button class="save" id="ls-settings-save-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 把這一整塊全新的HTML代碼，黏貼到 </body> 標籤的正上方 ▼▼▼ -->

<!-- 【全新】情侶空間-提問彈窗 -->
<div id="ls-ask-question-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>發起一個提問</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <textarea id="ls-question-content-input" rows="5" placeholder="向Ta提個問題吧..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-ask-btn">取消</button>
            <button class="save" id="ls-confirm-ask-btn">向Ta提問</button>
        </div>
    </div>
</div>

<!-- 【全新】情侶空間-回答彈窗 -->
<div id="ls-answer-question-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>回答Ta的問題</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>問題：</label>
                <p id="ls-answer-question-text" style="background-color: #f0f2f5; padding: 10px; border-radius: 8px;"></p>
            </div>
            <div class="form-group">
                <label for="ls-answer-content-input">你的回答：</label>
                <textarea id="ls-answer-content-input" rows="5" placeholder="認真回答哦..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-answer-btn">取消</button>
            <button class="save" id="ls-confirm-answer-btn">確認回答</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】這是情侶空間專屬音樂播放機的HTML代碼 ▼▼▼ -->

<!-- 1. 這是播放機專屬的音訊引擎 -->
<audio id="ls-audio-player" style="display:none;"></audio>

<!-- 2. 這是播放機的主視窗介面 -->
<div id="ls-music-player-overlay" class="modal">
    <div class="music-player-window">
<!-- 【全新】封面和歌詞的切換容器 -->
<div id="ls-display-area" style="width: 192px; height: 192px; margin-bottom: 20px; cursor: pointer;">
    <!-- 歌曲封面 -->
    <img id="ls-album-cover" src="https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png" alt="歌曲封面" style="width: 100%; height: 100%; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.2);">
    
    <!-- 歌詞容器 -->
    <div id="ls-lyrics-container" style="display: none; width: 100%; height: 100%; overflow: hidden; text-align: center; color: #333; font-weight: 500;">
        <div id="ls-lyrics-list" style="transition: transform 0.5s ease;">
             <!-- 歌詞會顯示在這裡 -->
        </div>
    </div>
</div>

        <!-- 歌曲信息 -->
        <div id="ls-song-title" style="font-size: 18px; font-weight: 600;">暫無歌曲</div>
        <div id="ls-artist" style="font-size: 14px; color: #666; margin-bottom: 15px;">...</div>
        
        <!-- 進度條 -->
        <div class="music-progress-bar-container" style="width: 100%;">
            <div id="ls-current-time" class="time-display">0:00</div>
            <div class="progress-bar" id="ls-progress-bar">
                <div id="ls-progress-fill" class="progress-bar-fill"></div>
            </div>
            <div id="ls-total-time" class="time-display">0:00</div>
        </div>
        
        <!-- 控制按鈕 -->
        <div class="music-controls" style="margin-bottom: 15px;">
            <button id="ls-prev-btn">◀</button>
            <button id="ls-play-pause-btn" class="play-pause-btn">▶</button>
            <button id="ls-next-btn">▶</button>
        </div>
        
        <!-- 底部操作按鈕 -->
        <div class="music-bottom-actions" style="width: 100%;">
            <button id="ls-playlist-btn" style="background-color: rgba(0, 123, 255, 0.1); color: var(--accent-color); margin-right: 5px;">播放清單</button>
            <button id="ls-close-player-btn" style="background-color: rgba(0,0,0,0.05); color: #333; margin-left: 5px;">關閉</button>
        </div>
    </div>
</div>

<!-- 3. 這是播放清單的側滑面板 -->
<div id="ls-music-playlist-panel" class="music-playlist-panel">
    <div class="playlist-header">
        <span class="panel-btn" id="ls-close-playlist-btn">返回</span>
        <span>播放清單</span>
        <span class="panel-btn" id="ls-clear-playlist-btn" style="color: #ff3b30;">清空</span>
    </div>
    <div class="playlist-body" id="ls-playlist-body">
        <!-- 播放清單內容會在這裡生成 -->
    </div>
</div>

<!-- ▲▲▲ HTML代碼黏貼結束 ▲▲▲ -->
<!-- ▼▼▼ 把這一整塊全新的HTML代碼，黏貼到 </body> 標籤的正上方 ▼▼▼ -->

<!-- 【全新】情侶番茄鐘-設置彈窗 -->
<div id="ls-pomodoro-setup-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>新的專注時光</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="pomodoro-task-input">專注任務</label>
                <input type="text" id="pomodoro-task-input" placeholder="例如：學習JS、完成工作報告">
            </div>
            <div class="form-group">
                <label for="pomodoro-duration-input">專注時長 (分鐘)</label>
                <input type="number" id="pomodoro-duration-input" value="25" min="1">
            </div>
<div class="form-group">
    <label>計時模式</label>
    <div style="display: flex; gap: 20px;">
        <label><input type="radio" name="pomodoro-mode" value="countdown" checked> 倒計時</label>
        <label><input type="radio" name="pomodoro-mode" value="countup"> 正計時</label>
    </div>
</div>
            <div class="form-group">
                <label for="pomodoro-talk-interval-input">角色鼓勵間隔 (分鐘, 0為不自動鼓勵)</label>
                <input type="number" id="pomodoro-talk-interval-input" value="5" min="0">
            </div>
<!-- ▼▼▼ 這是修改後的番茄鐘背景設置 ▼▼▼ -->
<div class="form-group">
    <label>自訂背景 (可選)</label>
    <div style="display: flex; gap: 10px; align-items: center;">
        <input type="text" id="pomodoro-bg-url-input" placeholder="黏貼圖片URL" style="flex-grow: 1;">
        <button id="pomodoro-bg-local-upload-btn" class="form-button-secondary" style="margin: 0; padding: 12px; width: auto;">本地上傳</button>
    </div>
    <input type="file" id="pomodoro-bg-file-input" accept="image/*" hidden>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="pomodoro-cancel-setup-btn">取消</button>
            <button class="save" id="pomodoro-confirm-setup-btn">開始專注</button>
        </div>
    </div>
</div>

<!-- 【全新】情侶番茄鐘-歷史詳情彈窗 -->
<div id="ls-pomodoro-history-viewer-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span id="pomodoro-history-viewer-title">專注記錄</span>
        </div>
        <div class="modal-body" id="pomodoro-history-viewer-content">
            <!-- 聊天記錄會由JS生成在這裡 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="pomodoro-close-history-viewer-btn" style="width:100%;">關閉</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->

<!-- ▲▲▲ 情侶空間HTML代碼結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】這是為“圈子”功能新增的所有彈窗 ▼▼▼ -->

<!-- 1. 小組編輯器彈窗 (用於修改小組資訊和世界觀) -->
<div id="forum-group-editor-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>編輯小組資訊</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="group-editor-name-input">小組名稱</label>
                <input type="text" id="group-editor-name-input">
            </div>
            <div class="form-group">
                <label for="group-editor-desc-input">小組簡介</label>
                <input type="text" id="group-editor-desc-input">
            </div>
            <div class="form-group">
                <label for="group-editor-icon-input">小組圖示 (Emoji)</label>
                <input type="text" id="group-editor-icon-input" maxlength="2">
            </div>
            <div class="form-group">
                <label for="group-editor-categories-input">小組分類 (用#號分隔, 例如: #科幻 #未來)</label>
                <input type="text" id="group-editor-categories-input" placeholder="例如: #科幻 #未來">
            </div>
            <div class="form-group">
                <label for="group-editor-worldview-input">小組世界觀 (供AI生成內容時參考)</label>
                <textarea id="group-editor-worldview-input" rows="5" placeholder="詳細描述這個小組獨特的背景設定..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-group-editor-btn">取消</button>
            <button class="save" id="save-group-editor-btn">保存</button>
        </div>
    </div>
</div>

<!-- 2. 分類管理彈窗 -->
<div id="forum-category-manager-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>管理圈子分類</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>新建分類</label>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="new-forum-category-name-input" placeholder="輸入分類名，無需帶'#'..." style="flex-grow: 1;">
                    <button id="add-new-forum-category-btn" class="form-button" style="width: auto; margin-top: 0; padding: 0 15px;">添加</button>
                </div>
            </div>
            <hr style="opacity: 0.2;">
            <div id="existing-forum-categories-list" style="display: flex; flex-direction: column; gap: 10px;">
                <!-- 分類清單將由JS動態生成 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-forum-category-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】這是遊戲大廳的主介面，黏貼到所有 modal 的 div 之後、<script> 標籤之前 ▼▼▼ -->
<div id="game-hall-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>遊戲大廳</span>
        <span style="width: 30px;"></span> <!-- 預留位置 -->
    </div>
    <div class="list-container" style="padding: 20px;">
        <p style="text-align: center; color: var(--text-secondary);">選擇一個遊戲開始吧！</p>
        <div id="game-hall-grid">
            <!-- 遊戲清單將顯示在這裡 -->
            <div class="game-card" data-game="werewolf">
                <div class="game-icon">🐺</div>
                <div class="game-info">
                    <div class="game-title">狼人殺</div>
                    <div class="game-desc">邏輯與謊言的對決</div>
                </div>
            </div>
            <div class="game-card" data-game="sea-turtle-soup">
                <div class="game-icon">🐢</div>
                <div class="game-info">
                    <div class="game-title">海龜湯</div>
                    <div class="game-desc">揭開情景的真相</div>
                </div>
            </div>
             <div class="game-card" data-game="script-kill">
                <div class="game-icon">📜</div>
                <div class="game-info">
                    <div class="game-title">劇本殺</div>
                    <div class="game-desc">扮演角色，探尋謎案</div>
                </div>
            </div>
            <div class="game-card" data-game="guess-what">
                <div class="game-icon">🗣️</div>
                <div class="game-info">
                    <div class="game-title">你說我猜</div>
                    <div class="game-desc">考驗默契的時候到了</div>
                </div>
            </div>
<div class="game-card" data-game="ludo">
    <div class="game-icon">🎲</div>
    <div class="game-info">
        <div class="game-title">心動飛行棋</div>
        <div class="game-desc">和Ta來一場只屬於你們的冒險</div>
    </div>
</div>
<!-- ▲▲▲ 新增代碼結束 ▲▲▲ -->
             <p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); font-size: 14px; margin-top: 20px;">更多遊戲正在火速開發中...</p>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】這是整個狼人殺功能的HTML，黏貼到 game-hall-screen 的 div 之後 ▼▼▼ -->

<!-- 1. 狼人殺遊戲設置螢幕 -->
<div id="werewolf-setup-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('game-hall-screen')">‹</span>
        <span>狼人殺 - 遊戲設置</span>
    </div>
    <div class="form-container">
        <div class="form-group">
            <label for="werewolf-player-count">選擇遊戲人數</label>
            <select id="werewolf-player-count">
                <option value="6">6人局 (2狼, 2民, 預言家, 守衛)</option>
                <option value="9">9人局 (3狼, 3民, 預言家, 女巫, 獵人)</option>
                <option value="12">12人局 (4狼, 4民, 預言家, 女巫, 獵人, 白癡)</option>
            </select>
        </div>
        <div class="form-group">
            <label>邀請玩家 (你已自動加入)</label>
            <div id="werewolf-player-selection" class="list-container" style="height: 300px; border: 1px solid var(--border-color); border-radius: 8px;">
                <!-- 玩家選擇清單將由JS動態生成 -->
            </div>
        </div>
        <button id="start-werewolf-game-btn" class="form-button">開始遊戲</button>
    </div>
</div>

<!-- 2. 狼人殺遊戲主介面 -->
<div id="werewolf-game-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="exit-werewolf-game-btn">‹ 退出</span>
        <span id="werewolf-game-title">狼人殺</span>
        <span class="action-btn" id="werewolf-my-role-btn">我的身份</span>
    </div>
    <!-- 遊戲主內容區 -->
    <div id="werewolf-game-content">
        <!-- 玩家座位區 -->
        <div id="werewolf-players-grid">
            <!-- 玩家頭像和狀態將由JS動態生成 -->
        </div>
        <!-- 遊戲日誌/資訊區 -->
        <div id="werewolf-log-container">
            <div id="werewolf-game-log">
                <!-- 遊戲過程資訊會顯示在這裡 -->
            </div>
        </div>
        <!-- 玩家操作區 -->
        <div id="werewolf-action-area">
            <!-- 玩家的按鈕會根據遊戲階段顯示在這裡 -->
        </div>
    </div>
</div>

<!-- ▲▲▲ 狼人殺功能HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】狼人殺遊戲結算卡片 ▼▼▼ -->
<div id="werewolf-summary-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>遊戲結算</span>
        </div>
        <div class="modal-body" id="werewolf-summary-content" style="white-space: pre-wrap; line-height: 1.7;">
            <!-- 結算內容將由JS動態生成在這裡 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="repost-summary-btn">發送複盤到聊天</button>
            <button class="save" id="back-to-hall-btn">返回大廳</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】狼人殺複盤發送目標選擇器 ▼▼▼ -->
<div id="werewolf-target-picker-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>選擇要發送的玩家</span>
        </div>
        <div class="modal-body" id="werewolf-target-list" style="padding: 0;">
            <!-- 玩家清單將由JS動態生成在這裡 -->
        </div>
        <div class="modal-footer">
            <button id="wt-select-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全選</button>
            <button id="wt-deselect-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全不選</button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="wt-cancel-btn">取消</button>
            <button class="save" id="wt-confirm-btn">確認發送</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】這是整個海龜湯功能的HTML，請黏貼到 </body> 標籤前 ▼▼▼ -->

<!-- 1. 海龜湯遊戲主介面 -->
<div id="sea-turtle-soup-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="exit-sts-game-btn">‹ 退出</span>
        <span>海龜湯</span>
        <span class="action-btn" id="reveal-sts-answer-btn">揭曉答案</span>
    </div>
    <div id="sts-game-content" style="display: flex; flex-direction: column; height: 100%; overflow: hidden; padding: 10px; box-sizing: border-box;">
        <!-- 玩家座位區 -->
        <div id="sts-players-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(60px, 1fr)); gap: 10px; padding: 10px; flex-shrink: 0;">
            <!-- 玩家頭像和狀態將由JS動態生成 -->
        </div>
        <!-- 遊戲日誌/資訊區 -->
        <div id="sts-log-container" style="flex-grow: 1; background-color: rgba(0,0,0,0.05); border-radius: 10px; padding: 10px; overflow-y: auto; margin: 10px 0; min-height: 0;">
            <div id="sts-game-log">
                <!-- 遊戲過程資訊會顯示在這裡 -->
            </div>
        </div>
<!-- ▼▼▼ 用這塊新代碼替換舊的 id="sts-action-area" ▼▼▼ -->
<div id="sts-action-area" class="chat-input-area" style="visibility: visible;">
     <div class="chat-input-main-row">
        <textarea id="sts-question-input" rows="1" placeholder="輸入問題或答案..."></textarea>
        <!-- 【核心修改】新增“猜答案”按鈕 -->
        <button id="guess-sts-answer-btn" class="action-button" style="background-color: #ff9800;">猜答案</button>
        <button id="send-sts-question-btn" class="action-button">提問</button>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->
    </div>
</div>

<!-- 2. 海龜湯遊戲設置模態框 -->
<div id="sea-turtle-soup-setup-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 85%;">
        <div class="modal-header">
            <span>海龜湯 - 遊戲設置</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>邀請玩家 (你已自動加入)</label>
                <div id="sts-player-selection" class="list-container" style="height: 200px; border: 1px solid var(--border-color); border-radius: 8px;">
                    <!-- 玩家選擇清單將由JS動態生成 -->
                </div>
            </div>
            <div class="form-group">
                <label>誰來出題？</label>
                <select id="sts-riddle-provider-select">
                    <option value="user">我來出題</option>
                    <option value="random_ai">隨機一位AI</option>
                </select>
            </div>
            <!-- 用戶出題的輸入區 (默認隱藏) -->
            <div id="sts-user-riddle-input-area" style="display: none;">
                <div class="form-group">
                    <label for="sts-user-riddle-surface">謎面</label>
                    <textarea id="sts-user-riddle-surface" rows="2" placeholder="例如：一個男人走進酒吧，要了一杯水..."></textarea>
                </div>
                <div class="form-group">
                    <label for="sts-user-riddle-answer">謎底 (完整故事)</label>
                    <textarea id="sts-user-riddle-answer" rows="4" placeholder="例如：男人在打嗝，他想喝水止嗝..."></textarea>
                </div>
            </div>
            <!-- AI出題的輸入區 (默認隱藏) -->
            <div id="sts-ai-riddle-input-area" style="display: none;">
                <div class="form-group">
                    <label for="sts-ai-riddle-type">謎題類型 (可選)</label>
                    <input type="text" id="sts-ai-riddle-type" placeholder="例如：恐怖、溫情、腦洞、經典">
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-sts-setup-btn">取消</button>
            <button class="save" id="start-sts-game-btn">開始遊戲</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 【全新】請將這兩塊代碼黏貼到 </body> 標籤前 ▼▼▼ -->

<!-- 1. 海龜湯遊戲結算卡片 -->
<div id="sts-summary-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>遊戲結算</span>
        </div>
        <div class="modal-body" id="sts-summary-content" style="white-space: pre-wrap; line-height: 1.7;">
            <!-- 結算內容將由JS動態生成在這裡 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="share-sts-summary-btn">分享複盤</button>
            <button class="save" id="back-to-hall-from-sts-btn">返回大廳</button>
        </div>
    </div>
</div>

<!-- 2. 海龜湯複盤發送目標選擇器 -->
<div id="sts-share-target-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>選擇要分享的玩家</span>
        </div>
        <div class="modal-body" id="sts-share-target-list" style="padding: 0;">
            <!-- 玩家清單將由JS動態生成在這裡 -->
        </div>
        <div class="modal-footer">
            <button id="sts-select-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全選</button>
            <button id="sts-deselect-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全不選</button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="sts-cancel-share-btn">取消</button>
            <button class="save" id="sts-confirm-share-btn">確認分享</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】這是整個劇本殺功能的HTML，請黏貼到 </body> 標籤前 ▼▼▼ -->

<!-- 1. 劇本殺遊戲設置螢幕 -->
<div id="script-kill-setup-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('game-hall-screen')">‹</span>
        <span>劇本殺 - 遊戲設置</span>
    </div>
    <div class="form-container">
        <div class="form-group">
            <label>選擇劇本</label>
            <div style="display: flex; gap: 10px;">
                <select id="script-kill-script-select" style="flex-grow: 1;"></select>
                <button id="manage-custom-scripts-btn" class="form-button-secondary" style="margin-top: 0; padding: 0 15px;">管理</button>
            </div>
        </div>
        <div class="form-group">
            <label>邀請玩家 (你已自動加入)</label>
            <div id="script-kill-player-selection" class="list-container" style="height: 300px; border: 1px solid var(--border-color); border-radius: 8px;">
                <!-- 玩家選擇清單將由JS動態生成 -->
            </div>
        </div>
        <div class="form-group">
            <label class="toggle-switch-label">
                <span class="toggle-switch-text">自由選擇角色 (關閉則隨機分配)</span>
                <input type="checkbox" id="script-kill-free-choice-toggle">
                <span class="toggle-switch-slider"></span>
            </label>
        </div>
        <button id="start-script-kill-game-btn" class="form-button">開始遊戲</button>
    </div>
</div>

<!-- 2. 劇本殺遊戲主介面 -->
<div id="script-kill-game-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="exit-script-kill-game-btn">‹ 退出</span>
        <span id="script-kill-game-title">劇本殺</span>
        <div class="header-actions">
            <span class="action-btn" id="script-kill-my-role-btn">我的角色</span>
            <span class="action-btn" id="script-kill-all-evidence-btn">公共線索</span>
        </div>
    </div>
    <div id="script-kill-game-content">
        <div id="script-kill-players-grid">
            <!-- 玩家頭像和狀態將由JS動態生成 -->
        </div>
        <div id="script-kill-log-container">
            <div id="script-kill-game-log">
                <!-- 遊戲過程資訊會顯示在這裡 -->
            </div>
        </div>
        <div id="script-kill-action-area">
            <!-- 玩家的按鈕會根據遊戲階段顯示在這裡 -->
        </div>
    </div>
</div>
<!-- ▼▼▼ 把這一整塊全新的HTML代碼，黏貼到 </body> 標籤的正上方 ▼▼▼ -->

<!-- 【全新】劇本殺自訂劇本管理模態框 -->
<div id="script-kill-manager-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
<div class="modal-header">
    <span>管理自訂劇本</span>
    <div class="header-actions">
        <!-- ▼▼▼ 在這裡添加一個新按鈕 ▼▼▼ -->
        <button id="open-sk-ai-generator-btn" class="action-button" style="font-size: 14px;">AI生成</button>
        <!-- ▲▲▲ 添加結束 ▲▲▲ -->
        <button id="add-new-script-btn" class="action-button">添加</button>
    </div>
</div>

        <div class="modal-body" id="custom-scripts-list" style="padding: 0;">
            <!-- 自訂劇本清單將由JS動態生成在這裡 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-script-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->

<!-- ▼▼▼ 用下面這【一整塊】全新的代碼，替換掉你舊的 id="script-kill-editor-modal" ▼▼▼ -->

<!-- 1. 劇本編輯器主彈窗 (視覺化版) -->
<div id="script-kill-editor-modal" class="modal">
    <div class="modal-content" style="height: 90%;">
        <div class="modal-header">
            <span id="script-editor-title">劇本編輯器</span>
        </div>
        <div class="modal-body" style="display: flex; flex-direction: column; gap: 15px;">
            
            <!-- 基礎資訊 -->
            <div class="form-group">
                <label for="script-name-input">劇本名稱</label>
                <input type="text" id="script-name-input">
            </div>
            <div class="form-group">
                <label for="script-background-input">故事背景</label>
                <textarea id="script-background-input" rows="3"></textarea>
            </div>
            
            <hr style="opacity: 0.2;">

            <!-- 角色設定區 -->
            <div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <label style="margin: 0; font-weight: 600;">角色設定</label>
                    <button id="sk-add-role-btn" class="form-button-secondary" style="margin: 0; padding: 5px 15px;">+ 添加角色</button>
                </div>
                <div id="sk-roles-container" class="sk-item-container">
                    <!-- 角色卡片將由JS動態生成在這裡 -->
                </div>
            </div>

            <!-- 線索卡區 -->
            <div>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <label style="margin: 0; font-weight: 600;">線索卡</label>
                    <button id="sk-add-clue-btn" class="form-button-secondary" style="margin: 0; padding: 5px 15px;">+ 添加線索</button>
                </div>
                <div id="sk-clues-container" class="sk-item-container">
                    <!-- 線索卡片將由JS動態生成在這裡 -->
                </div>
            </div>

            <!-- 最終真相互動 -->
            <div class="form-group">
                <label for="sk-truth-input">最終真相</label>
                <textarea id="sk-truth-input" rows="3"></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-script-editor-btn">取消</button>
            <button class="save" id="save-script-btn">保存劇本</button>
        </div>
    </div>
</div>

<!-- 2. 【全新】用於編輯單個角色/線索的子彈窗 -->
<div id="sk-item-editor-modal" class="modal" style="z-index: 1003;">
    <div class="modal-content" style="height: auto; max-height: 85%;">
        <div class="modal-header">
            <span id="sk-item-editor-title"></span>
        </div>
        <div class="modal-body">
            <!-- 角色編輯欄位 (默認隱藏) -->
            <div id="sk-role-editor-fields" style="display: none;">
                <div class="form-group">
                    <label for="sk-role-name-input">角色名稱</label>
                    <input type="text" id="sk-role-name-input">
                </div>
                <div class="form-group">
                    <label for="sk-role-desc-input">角色介紹</label>
                    <textarea id="sk-role-desc-input" rows="3"></textarea>
                </div>
<div class="form-group">
    <label for="sk-role-storyline-input">故事線 (案發時間段的詳細行動軌跡)</label>
    <textarea id="sk-role-storyline-input" rows="5"></textarea>
</div>
                <div class="form-group">
                    <label for="sk-role-tasks-input">秘密任務</label>
                    <textarea id="sk-role-tasks-input" rows="2"></textarea>
                </div>
                <div class="form-group">
                    <label class="toggle-switch-label">
                        <span class="toggle-switch-text">是兇手</span>
                        <input type="checkbox" id="sk-role-killer-toggle">
                        <span class="toggle-switch-slider"></span>
                    </label>
                </div>
            </div>
            <!-- 線索編輯欄位 (默認隱藏) -->
            <div id="sk-clue-editor-fields" style="display: none;">
                <div class="form-group">
                    <label for="sk-clue-owner-select">線索歸屬</label>
                    <select id="sk-clue-owner-select">
                        <!-- 選項將由JS動態生成 -->
                    </select>
                </div>
                <div class="form-group">
                    <label for="sk-clue-desc-input">線索描述</label>
                    <textarea id="sk-clue-desc-input" rows="4"></textarea>
                </div>
                 <div class="form-group">
                    <label class="toggle-switch-label">
                        <span class="toggle-switch-text">是關鍵線索</span>
                        <input type="checkbox" id="sk-clue-key-toggle">
                        <span class="toggle-switch-slider"></span>
                    </label>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="sk-item-editor-cancel-btn">取消</button>
            <button class="save" id="sk-item-editor-save-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->

<!-- 4. 角色身份卡模態框 -->
<div id="script-kill-role-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span id="sk-role-name">你的角色</span>
        </div>
        <div class="modal-body" id="sk-role-details" style="white-space: pre-wrap; line-height: 1.7;">
            <!-- 角色介紹、任務等將顯示在這裡 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-sk-role-modal-btn" style="width:100%;">我已瞭解</button>
        </div>
    </div>
</div>

<!-- 5. 個人線索板模態框 -->
<div id="script-kill-evidence-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>我的線索板</span>
        </div>
        <div class="modal-body" id="sk-evidence-list" style="padding: 10px; display: flex; flex-direction: column; gap: 10px;">
            <!-- 搜到的線索卡片會顯示在這裡 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-sk-evidence-modal-btn" style="width:100%;">關閉</button>
        </div>
    </div>
</div>

<!-- 6. 投票模態框 -->
<div id="script-kill-vote-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 70%;">
        <div class="modal-header">
            <span id="sk-vote-title">最終投票</span>
        </div>
        <div class="modal-body" id="sk-vote-options-list" style="text-align: left; padding: 20px;">
            <!-- 投票選項將由JS動態生成 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-sk-vote-btn">取消</button>
            <button class="save" id="confirm-sk-vote-btn">確認投票</button>
        </div>
    </div>
</div>
<!-- ▼▼▼ 【全新】劇本殺遊戲結算卡片 ▼▼▼ -->
<div id="script-kill-summary-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>遊戲結算</span>
        </div>
        <div class="modal-body" id="script-kill-summary-content" style="white-space: pre-wrap; line-height: 1.7;">
            <!-- 結算內容將由JS動態生成在這裡 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="repost-sk-summary-btn">轉發複盤到單聊</button>
            <button class="save" id="back-to-hall-from-sk-btn">返回大廳</button>
        </div>
    </div>
</div>

<!-- ▼▼▼ 【全新】劇本殺複盤發送目標選擇器 ▼▼▼ -->
<div id="script-kill-target-picker-modal" class="modal">
    <div class="modal-content" style="height: 60%;">
        <div class="modal-header">
            <span>選擇要轉發的玩家</span>
        </div>
        <div class="modal-body" id="script-kill-target-list" style="padding: 0;">
            <!-- 玩家清單將由JS動態生成在這裡 -->
        </div>
        <div class="modal-footer">
            <button id="sk-select-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全選</button>
            <button id="sk-deselect-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全不選</button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="sk-cancel-share-btn">取消</button>
            <button class="save" id="sk-confirm-share-btn">確認轉發</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】這是AI劇本生成器的彈窗，黏貼到</body>前 ▼▼▼ -->
<div id="sk-ai-generator-modal" class="modal">
    <div class="modal-content" style="height: 90%;">
        <div class="modal-header">
            <span>AI 劇本生成器</span>
        </div>
<div class="modal-body" style="display: flex; flex-direction: column; gap: 15px;">
            
    <div class="form-group">
        <label for="sk-ai-elements-input">核心要素 (用逗號分隔)</label>
        <input type="text" id="sk-ai-elements-input" placeholder="例如：現代, 謀殺, 暴風雪山莊, 遺產">
    </div>

    <!-- ▼▼▼ 【這是你要求新增的HTML】請把它黏貼到這裡 ▼▼▼ -->
    <div class="form-group">
        <label for="sk-ai-player-count-input">玩家人數 (包含兇手, 建議4-8人)</label>
        <input type="number" id="sk-ai-player-count-input" value="5" min="3" max="12" style="width: 100%; box-sizing: border-box; padding: 10px; border-radius: 6px; border: 1px solid var(--border-color);">
    </div>
    <!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->

    <div class="form-group">
        <label for="sk-ai-summary-input">劇情梗概 (可選)</label>
        <textarea id="sk-ai-summary-input" rows="4" placeholder="可以寫一個簡單的故事大綱，幫助AI更好地理解你的想法..."></textarea>
    </div>
    <button id="sk-trigger-ai-generation-btn" class="form-button">開始生成</button>
          
            <hr style="opacity: 0.2; margin: 5px 0;">

            <div class="form-group" style="flex-grow: 1; min-height: 0; display: flex; flex-direction: column;">
                <label>AI 生成結果預覽</label>
                <div id="sk-ai-result-preview" style="flex-grow: 1; overflow-y: auto; background: #f0f2f5; padding: 10px; border-radius: 8px; white-space: pre-wrap; line-height: 1.6; color: #555;">
                    點擊“開始生成”後，結果將顯示在這裡...
                </div>
            </div>

        </div>
        <div class="modal-footer">
            <button class="cancel" id="sk-ai-generator-cancel-btn">關閉</button>
            <!-- 這個保存按鈕初始是禁用的，生成成功後才會啟動 -->
            <button class="save" id="sk-ai-generator-save-btn" disabled>保存劇本</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->

<!-- ▲▲▲ 劇本殺功能HTML結束 ▲▲▲ -->

<!-- ▲▲▲ 海龜湯功能HTML結束 ▲▲▲ -->
 <!-- ▼▼▼ 【全新】這是“你說我猜”遊戲的所有HTML代碼 ▼▼▼ -->

<!-- 1. “你說我猜”遊戲設置螢幕 -->
<div id="guess-what-setup-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('game-hall-screen')">‹</span>
        <span>你說我猜 - 遊戲設置</span>
    </div>
    <div class="form-container">
        <div class="form-group">
            <label>邀請一位玩伴</label>
            <div id="guess-what-player-selection" class="list-container" style="height: 200px; border: 1px solid var(--border-color); border-radius: 8px;">
                <!-- 玩家選擇清單將由JS動態生成 -->
            </div>
        </div>
        <div class="form-group">
            <label>選擇遊戲模式</label>
            <div style="display: flex; gap: 20px;">
                <label><input type="radio" name="guess_what_mode" value="ai_guesses" checked> 我出題，AI猜</label>
                <label><input type="radio" name="guess_what_mode" value="user_guesses"> AI出題，我猜</label>
            </div>
        </div>
        <!-- "我出題"模式下的輸入框 -->
        <div class="form-group" id="user-word-input-container">
            <label for="guess-what-user-word">請輸入你要出的詞</label>
            <input type="text" id="guess-what-user-word" placeholder="例如：蘋果、流浪地球...">
        </div>
        <button id="start-guess-what-game-btn" class="form-button">開始遊戲</button>
    </div>
</div>

<!-- 2. “你說我猜”遊戲主介面 -->
<div id="guess-what-game-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="exit-guess-what-game-btn">‹ 退出</span>
        <span id="guess-what-game-title">你說我猜</span>
        <span class="action-btn" id="give-up-guess-what-btn">放棄</span>
    </div>
    <!-- 遊戲主內容區 -->
    <div id="guess-what-game-content" style="display: flex; flex-direction: column; height: 100%; overflow: hidden; padding: 10px; box-sizing: border-box;">
        <!-- 遊戲日誌/資訊區 -->
        <div id="guess-what-log-container" style="flex-grow: 1; background-color: rgba(0,0,0,0.05); border-radius: 10px; padding: 10px; overflow-y: auto; margin: 10px 0; min-height: 0;">
            <div id="guess-what-game-log">
                <!-- 遊戲過程資訊會顯示在這裡 -->
            </div>
        </div>
        <!-- 玩家操作區 -->
        <div id="guess-what-action-area" class="chat-input-area" style="visibility: visible;">
             <div class="chat-input-main-row">
                <textarea id="guess-what-user-input" rows="1" placeholder="輸入提示或猜測..."></textarea>
                <button id="send-guess-what-input-btn" class="action-button">發送</button>
            </div>
        </div>
    </div>
</div>

<!-- ▲▲▲ “你說我猜”HTML代碼結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】“你說我猜”遊戲結算卡片 ▼▼▼ -->
<div id="guess-what-summary-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>遊戲結算</span>
        </div>
        <div class="modal-body" id="guess-what-summary-content" style="white-space: pre-wrap; line-height: 1.7;">
            <!-- 結算內容將由JS動態生成在這裡 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="forward-guess-what-summary-btn">轉發給Ta</button>
            <button class="save" id="close-guess-what-summary-btn">返回大廳</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
 <!-- ▼▼▼ 【全新】這是“心動飛行棋”的所有新HTML代碼 ▼▼▼ -->

<!-- 1. 飛行棋遊戲設置螢幕 -->
<div id="ludo-setup-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('game-hall-screen')">‹</span>
        <span>心動飛行棋 - 遊戲設置</span>
    </div>
    <div class="form-container">
        <div class="form-group">
            <label>選擇一位玩伴</label>
            <!-- 邀請列表，我們會用JS來填充 -->
            <div id="ludo-player-selection" class="list-container" style="height: 200px; border: 1px solid var(--border-color); border-radius: 8px;">
            </div>
        </div>
        <!-- ▼▼▼ 在 #ludo-setup-screen 的 "form-container" 內，黏貼這段新代碼 ▼▼▼ -->
<div class="form-group">
    <label>選擇問題庫</label>
    <div style="display: flex; align-items: center; gap: 10px;">
        <select id="ludo-question-bank-select" style="flex-grow: 1;"></select>
        <button id="manage-ludo-question-banks-btn" class="form-button-secondary" style="margin-top: 0; padding: 12px; width: auto;">管理題庫</button>
    </div>
</div>
<!-- ▲▲▲ 黏貼結束 ▲▲▲ -->

        <button id="start-ludo-game-btn" class="form-button">開始遊戲</button>
    </div>
</div>

<!-- 2. 飛行棋遊戲主介面 -->
<div id="ludo-game-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="exit-ludo-game-btn">‹ 退出</span>
        <span>心動飛行棋</span>
        <!-- 這裡可以放一個重置遊戲的按鈕 -->
        <span class="action-btn" id="restart-ludo-game-btn" title="重新開始">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>
        </span>
    </div>
    <!-- 遊戲主內容區 -->
    <div id="ludo-game-content">
        <!-- 棋盤區域 -->
        <div id="ludo-board-container">
            <div id="ludo-board">
                <!-- 棋盤格子將由JS動態生成 -->
            </div>
            <!-- 玩家棋子 -->
            <div id="ludo-user-piece" class="ludo-piece user"></div>
            <div id="ludo-char-piece" class="ludo-piece char"></div>
        </div>

        <!-- 遊戲日誌區域 -->
        <div id="ludo-log-container">
            <div id="ludo-game-log">
                <!-- 遊戲過程資訊會顯示在這裡 -->
            </div>
        </div>
        
        <!-- 玩家操作區 -->
        <div id="ludo-action-area">
            <!-- 使用者的按鈕會根據遊戲階段顯示在這裡 -->
        </div>
    </div>
</div>

<!-- ▲▲▲ “心動飛行棋”HTML代碼結束 ▲▲▲ -->

<!-- ▼▼▼ 在這裡找到你的微博私信清單頁面 ▼▼▼ -->
<div id="weibo-dm-list-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-dm-list">‹</span>
        <span id="weibo-dm-list-title">粉絲私信</span>
        <!-- 這是你要求的“繼續生成”按鈕 -->
        <div class="header-actions">
            <span class="action-btn" id="generate-more-dms-btn" title="繼續生成私信">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg>
            </span>
            
            <!-- ▼▼▼ 在這裡黏貼下面這個全新的“清空全部”按鈕 ▼▼▼ -->
            <span class="action-btn" id="clear-all-dms-btn" title="清空全部私信">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
                </svg>
            </span>
            <!-- ▲▲▲ 黏貼結束 ▲▲▲ -->
            
        </div>
    </div>
    <div id="weibo-dm-list" class="list-container" style="padding: 0;">
        <!-- 私信清單將由JS動態生成 -->
    </div>
</div>


<!-- ▼▼▼ 【全新】這是微博私信詳情頁面，請黏貼到 #phone-screen 的末尾 ▼▼▼ -->
<div id="weibo-dm-detail-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="back-from-dm-detail">‹</span>
        <span id="weibo-dm-detail-title"></span>
        <span style="width: 30px;"></span> <!-- 預留位置 -->
    </div>
    <div id="weibo-dm-messages" class="list-container" style="display: flex; flex-direction: column; gap: 15px; padding: 15px; background-color: #f0f2f5;">
        <!-- 聊天氣泡將由JS動態生成 -->
    </div>
</div>
<!-- ▼▼▼ 把下面這一整塊全新的HTML代碼，黏貼到 </body> 標籤的正上方 ▼▼▼ -->

<!-- ▼▼▼ 用這整塊代碼替換舊的 id="taobao-screen" 的 div ▼▼▼ -->
<div id="taobao-screen" class="screen">
    <div class="header">
        <span class="back-btn" onclick="showScreen('home-screen')">‹</span>
        <span>桃寶</span>
        <div class="header-actions">
            <!-- ▼▼▼ 在這裡添加新按鈕 ▼▼▼ -->
            <span class="action-btn" id="clear-taobao-products-btn" style="font-size: 16px; font-weight: 500;">清空</span>
            <!-- ▲▲▲ 添加結束 ▲▲▲ -->
            <span class="action-btn" id="add-product-btn" title="添加商品">+</span>
        </div>
    </div>

    
    <!-- 1. 頂部頁簽導航 -->
    <div class="taobao-tabs">
        <button class="taobao-tab active" data-view="products-view">首頁</button>
        <!-- ★★★ 在這裡新增了“購物車”按鈕 ★★★ -->
        <button class="taobao-tab" data-view="cart-view">
            購物車<span id="cart-item-count-badge" style="display: none;">0</span>
        </button>
        <button class="taobao-tab" data-view="orders-view">我的訂單</button>
        <button class="taobao-tab" data-view="my-view">我的</button>
    </div>

    <!-- 2. 頁面內容容器 -->
    <div class="taobao-content">
        <!-- “首頁”視圖 (保持不變) -->
        <div id="products-view" class="taobao-view active">
          <div class="taobao-search-bar">
            <input type="search" id="product-search-input" placeholder="搜一搜，讓AI為你創造好物！">
            <button id="product-search-btn">搜索</button>
          </div>
            <div id="product-category-tabs"></div>
            <div id="product-grid" class="product-grid"></div>
        </div>

        <!-- ★★★ “購物車”視圖 (全新添加) ★★★ -->
        <div id="cart-view" class="taobao-view">
            <div id="cart-item-list">
                <!-- 購物車商品會顯示在這裡 -->
            </div>
<!-- ▼▼▼ 用這塊新代碼替換舊的 cart-checkout-bar ▼▼▼ -->
<div id="cart-checkout-bar" style="display: none;">
    <div class="total-price">
        合計: <span id="cart-total-price">¥ 0.00</span>
    </div>
    <div style="display: flex; gap: 10px;">
        <button id="share-cart-to-char-btn">分享給Ta代付</button>
        <button id="buy-for-char-btn">為Ta購買</button> <!-- 這是我們新增的按鈕 -->
        <button id="checkout-btn">結算(0)</button>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->
        </div>

        <!-- “我的訂單”視圖 (保持不變) -->
        <div id="orders-view" class="taobao-view">
            <div id="order-list" class="order-list"></div>
        </div>

        <!-- “我的”視圖 (保持不變) -->
        <div id="my-view" class="taobao-view">
            <div id="user-balance-container">
                <p>我的餘額</p>
                <h2 id="user-balance-display">¥ 0.00</h2>
                <button id="top-up-btn" class="form-button">給錢包充點錢</button>
            </div>
            <div id="balance-details-list" class="order-list" style="padding: 0 15px;"></div>
        </div>
    </div>
</div>

<!-- ▼▼▼ 用這塊【已添加評價區】的代碼，替換舊的 id="product-detail-modal" ▼▼▼ -->
<div id="product-detail-modal" class="modal">
    <div class="modal-content">
        <div class="modal-header">
            <span>商品詳情</span>
        </div>
        <div class="modal-body" id="product-detail-body">
            <!-- 詳情內容將由JS動態生成 -->
        </div>
        <!-- ★★★ 這是我們新增的評價區域 ★★★ -->
        <div id="product-reviews-section">
            <h3>寶貝評價</h3>
            <div id="product-reviews-list">
                <!-- 評價內容會由JS動態生成在這裡 -->
            </div>
            <button id="generate-reviews-btn" class="form-button form-button-secondary">✨ AI生成評價</button>
        </div>
        <!-- ▲▲▲ 新增結束 ▲▲▲ -->
        <div class="modal-footer">
            <button class="cancel" id="close-product-detail-btn">關閉</button>
            <button class="save" id="detail-add-to-cart-btn">加入購物車</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->


<!-- 2. 添加商品的方式選擇彈窗 -->
<div id="add-product-choice-modal" class="modal">
    <div id="custom-modal" style="width: 250px;">
        <div class="custom-modal-header">選擇添加方式</div>
        <div class="custom-modal-footer">
            <button id="add-product-manual-btn">手動添加</button>
            <button id="add-product-link-btn">識別連結</button>
            <button id="add-product-ai-btn">AI生成</button>
            <button id="cancel-add-choice-btn" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
        </div>
    </div>
</div>

<!-- 3. 手動添加/編輯商品彈窗 -->
<div id="product-editor-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span id="product-editor-title">添加新商品</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="product-name-input">商品名稱</label>
                <input type="text" id="product-name-input">
            </div>
            <div class="form-group">
                <label for="product-price-input">價格 (元)</label>
                <input type="number" id="product-price-input">
            </div>
            <div class="form-group">
                <label for="product-image-input">圖片 URL</label>
                <input type="text" id="product-image-input">
            </div>
            <div class="form-group">
                <label for="product-category-input">分類 (選填)</label>
                <input type="text" id="product-category-input" placeholder="例如：衣服, 零食...">
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-product-editor-btn">取消</button>
            <button class="save" id="save-product-btn">保存</button>
        </div>
    </div>
</div>

<!-- 4. 識別連結彈窗 -->
<div id="add-from-link-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>黏貼分享文案</span>
        </div>
        <div class="modal-body">
            <textarea id="link-paste-area" rows="6" placeholder="請在這裡黏貼完整的淘寶或拼多多分享文案..."></textarea>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-link-paste-btn">取消</button>
            <button class="save" id="confirm-link-paste-btn">識別</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 把這一整塊全新的HTML代碼，黏貼到 </body> 標籤的正上方 ▼▼▼ -->

<!-- 【全新】物流詳情頁面 -->
<div id="logistics-screen" class="screen">
    <div class="header">
        <span class="back-btn" id="logistics-back-btn">‹</span>
        <span>物流詳情</span>
        <span style="width: 30px;"></span> <!-- 預留位置，讓標題居中 -->
    </div>
    <div id="logistics-content-area" class="list-container">
        <!-- 物流資訊將由JS動態生成在這裡 -->
    </div>
</div>

<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 把這一整塊全新的HTML，黏貼到 </body> 標籤的正上方 ▼▼▼ -->

<!-- 【全新】角色微博主頁螢幕 -->
<div id="weibo-char-profile-screen" class="screen">
    <!-- 頭部，包含返回按鈕和角色名字 -->
    <div class="header">
        <span class="back-btn" id="back-from-char-profile">‹</span>
        <span id="weibo-char-profile-title">角色主頁</span>
        <div class="header-actions">
            <!-- 為角色主頁也添加一個編輯按鈕 -->
            <span class="action-btn" id="edit-char-weibo-profile-btn" title="編輯角色資料">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 20h9"></path>
                    <path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>
                </svg>
            </span>
        </div>
    </div>
    <!-- 角色主頁的內容區 -->
    <div id="weibo-char-profile-page" class="weibo-profile-page"> <!-- 複用個人主頁的滾動樣式 -->
        <div class="weibo-profile-header">
            <img id="weibo-char-background-img" src="https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg" class="weibo-background">
            <div class="weibo-avatar-container">
                <img id="weibo-char-avatar-img" src="https://files.catbox.moe/q6z5fc.jpeg" class="weibo-avatar">
                <img id="weibo-char-avatar-frame" class="weibo-avatar-frame" src="" style="display: none;">
            </div>
            <div class="weibo-nickname" id="weibo-char-nickname">角色昵稱</div>
            <div id="weibo-char-profession-display">角色職業</div>
<!-- ▼▼▼ 用這整塊代碼，替換掉 id="weibo-char-profile-page" 裡面那個舊的、只有注釋的 <div class="weibo-stats"> ▼▼▼ -->
<div class="weibo-stats">
    <div id="weibo-char-following-item" class="weibo-stat-item" style="cursor: pointer;">
        <span id="weibo-char-following-count" class="weibo-stat-number">0</span>
        <span class="weibo-stat-label">關注</span>
    </div>
    <div id="weibo-char-posts-item" class="weibo-stat-item">
        <span id="weibo-char-posts-count" class="weibo-stat-number">0</span>
        <span class="weibo-stat-label">微博</span>
    </div>
    <div id="weibo-char-fans-item" class="weibo-stat-item" style="cursor: pointer;">
        <span id="weibo-char-fans-count" class="weibo-stat-number">0</span>
        <span class="weibo-stat-label">粉絲</span>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->
        </div>
        <div id="char-weibo-feed-list" style="padding: 15px; display: flex; flex-direction: column; gap: 15px;">
            <!-- 角色的微博清單將由JS動態生成在這裡 -->
        </div>
    </div>
</div>

<!-- 【全新】角色微博資料編輯彈窗 -->
<div id="char-weibo-editor-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span>編輯角色微博資料</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>微博頭像</label>
                <div class="avatar-upload">
                    <img id="char-weibo-editor-avatar-preview">
                    <button onclick="document.getElementById('char-weibo-editor-avatar-input').click()">上傳頭像</button>
                    <button class="change-frame-btn" data-type="char-weibo">更換頭像框</button>
                    <input type="file" id="char-weibo-editor-avatar-input" accept="image/*" hidden>
                </div>
            </div>
            <div class="form-group">
                <label for="char-weibo-editor-nickname-input">微博昵稱</label>
                <input type="text" id="char-weibo-editor-nickname-input">
            </div>
            <div class="form-group">
                <label>微博背景</label>
                <div class="avatar-upload">
                    <img id="char-weibo-editor-bg-preview" style="width: 120px; height: 67.5px; border-radius: 8px;">
                    <button onclick="document.getElementById('char-weibo-editor-bg-input').click()">上傳背景</button>
                    <input type="file" id="char-weibo-editor-bg-input" accept="image/*" hidden>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-char-weibo-editor-btn">取消</button>
            <button class="save" id="save-char-weibo-editor-btn">保存</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 全新的HTML黏貼結束 ▲▲▲ -->


<!-- ▼▼▼ 【增強版】寵物功能模態框 ▼▼▼ -->
<div id="pet-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 85%;">
        <div class="modal-header">
            <span id="pet-modal-title">我的寵物</span>
        </div>
        <div class="modal-body">
            <!-- 寵物信息預覽區 -->
            <div id="pet-preview-area" style="text-align: center; margin-bottom: 20px;">
                <div id="pet-preview-display" style="font-size: 60px; line-height: 1; margin-bottom: 10px; cursor: pointer;" title="點擊更換圖片"></div>
                <strong id="pet-preview-name" style="font-size: 18px;"></strong>
                <p id="pet-preview-type" style="font-size: 14px; color: var(--text-secondary); margin: 5px 0;"></p>
            </div>

            <!-- 寵物數值顯示區 -->
            <div id="pet-stats-area" style="display: none;">
                <div id="pet-hunger-bar" class="stat-bar-container">
                    <span class="stat-label">飽食度</span>
                    <div class="stat-bar"><div class="stat-bar-fill">100%</div></div>
                </div>
                <div id="pet-happiness-bar" class="stat-bar-container">
                    <span class="stat-label">心情值</span>
                    <div class="stat-bar"><div class="stat-bar-fill">100%</div></div>
                </div>
                <div id="pet-intimacy-user-bar" class="stat-bar-container">
                    <span class="stat-label">對你的親密度</span>
                    <div class="stat-bar"><div class="stat-bar-fill">50%</div></div>
                </div>
                <div id="pet-intimacy-char-bar" class="stat-bar-container">
                    <span class="stat-label">對Ta的親密度</span>
                    <div class="stat-bar"><div class="stat-bar-fill">50%</div></div>
                </div>
            </div>

            <!-- 互動按鈕區 (已新增“對話”按鈕) -->
            <div id="pet-interaction-area" style="display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color);">
                <button class="form-button-secondary" data-action="feed">餵食</button>
                <button class="form-button-secondary" data-action="play">玩耍</button>
                <button class="form-button-secondary" data-action="touch">撫摸</button>
                <button class="form-button-secondary" data-action="chat">對話</button>
            </div>
            
            <!-- 設置區 -->
            <div class="form-group">
                <label for="pet-type-input">種類 (自由填寫)</label>
                <input type="text" id="pet-type-input" placeholder="例如: 小貓, 倉鼠, 太陽花...">
            </div>
             <div class="form-group">
                <label for="pet-name-input">昵稱</label>
                <input type="text" id="pet-name-input" placeholder="給它起個名字吧">
            </div>
             <div class="form-group">
                <label for="pet-image-input">初始樣子 (Emoji 或 圖片URL)</label>
                <input type="text" id="pet-image-input" placeholder="輸入一個 Emoji 比如 🐈 或圖片連結">
            </div>
            <!-- 【全新】人設輸入框 -->
            <div class="form-group">
                <label for="pet-persona-input">寵物人設與背景</label>
                <textarea id="pet-persona-input" rows="3" placeholder="描述一下它的性格和故事，AI會根據這個來扮演它。"></textarea>
            </div>
            <div class="form-group">
                <label class="toggle-switch-label">
                    <span>在聊天介面顯示</span>
                    <input type="checkbox" id="pet-display-toggle">
                    <span class="toggle-switch-slider"></span>
                </label>
            </div>
            <div id="pet-position-controls" style="display:none;">
                <div class="form-group">
                    <label for="pet-size-slider">大小: <span id="pet-size-value">100px</span></label>
                    <input type="range" id="pet-size-slider" min="30" max="200" value="100" style="width: 100%;">
                </div>
            </div>

        </div>
        <div class="modal-footer">
            <!-- ▼▼▼ 在這裡添加新按鈕 ▼▼▼ -->
            <button class="cancel" id="pet-abandon-btn" style="background-color: #ffdde5; color: #ff3b30; border-color: #ffc2d1;">放生寵物</button>
            <!-- ▲▲▲ 添加結束 ▲▲▲ -->
            <button class="cancel" id="pet-modal-cancel-btn">取消</button>
            <button class="save" id="pet-modal-save-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->
<input type="file" id="pet-custom-image-input" accept="image/*" style="display: none;">
<!-- ▼▼▼ 【全新】寵物聊天模態框 ▼▼▼ -->
<div id="pet-chat-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span id="pet-chat-title">和寵物的對話</span>
        </div>
        <div id="pet-chat-messages" class="modal-body" style="background-color: #f0f2f5; display: flex; flex-direction: column; gap: 15px;">
            <!-- 寵物聊天記錄將顯示在這裡 -->
        </div>
        <!-- 複用主聊天輸入框的樣式 -->
        <div id="pet-chat-input-area" class="chat-input-area" style="border-top: 1px solid var(--border-color);">
            <div class="chat-input-main-row">
                <textarea id="pet-chat-input" rows="1" placeholder="和它說點什麼..."></textarea>
                <button id="send-to-pet-btn" class="action-button">發送</button>
            </div>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->

<!-- ▲▲▲ 寵物功能模態框結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】這是微博專用的、支持多選和滾動的角色選擇彈窗 ▼▼▼ -->
<div id="weibo-char-selector-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>選擇生成內容的主角</span>
        </div>
        <div class="modal-body" id="weibo-char-selector-list" style="padding: 0; overflow-y: auto;">
            <!-- 角色清單將由JS動態生成在這裡 -->
        </div>
        <div class="modal-footer" style="justify-content: space-between;">
            <button id="weibo-select-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全選</button>
            <button id="weibo-deselect-all-btn" class="form-button-secondary" style="width: 45%; margin: 0;">全不選</button>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="weibo-cancel-char-select-btn">取消</button>
            <button class="save" id="weibo-confirm-char-select-btn">確認</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 把這一整塊全新的HTML代碼，黏貼到 </body> 標籤的正上方 ▼▼▼ -->

<!-- 【全新】情侶空間-情緒日記編輯彈窗 -->
<div id="ls-diary-editor-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span id="ls-diary-editor-title">記錄今天的心情</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label>選擇一個表情代表今天的心情</label>
                <div id="ls-emoji-selector" style="display: flex; flex-wrap: wrap; gap: 10px; font-size: 24px; cursor: pointer; justify-content: center; padding: 10px 0;">
                    <!-- Emoji將由JS生成 -->
                </div>
            </div>
            <div class="form-group">
                <label for="ls-diary-content-input">寫下你的日記</label>
                <textarea id="ls-diary-content-input" rows="6" placeholder="今天發生了什麼特別的事嗎..."></textarea>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="ls-cancel-diary-btn">取消</button>
            <button class="save" id="ls-save-diary-btn">保存日記</button>
        </div>
    </div>
</div>

<!-- 【全新】情侶空間-日記查看彈窗 -->
<div id="ls-diary-viewer-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span id="ls-diary-viewer-title">查看日記</span>
        </div>
        <div id="ls-diary-viewer-body" class="modal-body" style="display: flex; flex-direction: column; gap: 20px;">
            <!-- 日記內容將由JS動態生成 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="ls-close-diary-viewer-btn" style="width: 100%;">關閉</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 用這整塊代碼替換舊的 summary-viewer-modal ▼▼▼ -->
<div id="summary-viewer-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span id="summary-viewer-title">聊天總結</span>
        </div>
        <div class="modal-body" id="summary-list" style="padding: 15px;">
            <!-- 總結清單將由JS動態生成在這裡 -->
        </div>
        <div class="modal-footer" style="display: flex; gap: 10px;">
            <!-- 【核心修改】我們在這裡新增了“全部精簡”按鈕 -->
            <button class="form-button-secondary" id="concise-all-summaries-btn" style="flex: 1; margin: 0;">全部精簡</button>
            <button class="save" id="close-summary-viewer-btn" style="flex: 1; margin: 0;">關閉</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->
<!-- ▼▼▼ 把這一整塊全新的HTML代碼，黏貼到 </body> 標籤的正上方 ▼▼▼ -->

<!-- 【全新】AI生成商品結果/選擇彈窗 -->
<div id="ai-generated-products-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span id="ai-products-modal-title">AI為你生成了以下寶貝</span>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <div id="ai-product-results-grid" class="product-grid">
                <!-- AI生成的商品會顯示在這裡 -->
            </div>
        </div>
        <div class="modal-footer">
            <button class="save" id="close-ai-products-modal-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 在 </body> 標籤的正上方，黏貼下面這一整塊新代碼 ▼▼▼ -->

<!-- 【全新】飛行棋問題庫管理模態框 (已修改) -->
<div id="ludo-qbank-manager-modal" class="modal">
    <div class="modal-content" style="height: 70%;">
        <div class="modal-header">
            <span>管理問題庫</span>
            <!-- ▼▼▼ 核心修改在這裡 ▼▼▼ -->
            <div class="header-actions">
                <span class="action-btn" id="import-ludo-qbank-btn" title="導入題庫">
                    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                </span>
                <span class="action-btn" id="add-ludo-qbank-btn" style="font-size: 16px;">新建</span>
            </div>
            <!-- ▲▲▲ 修改結束 ▲▲▲ -->
        </div>
        <div class="modal-body" id="ludo-qbank-list" style="padding: 0;">
            <!-- 問題庫清單將由JS動態生成在這裡 -->
        </div>
        <div class="modal-footer">
            <button class="save" id="close-qbank-manager-btn" style="width: 100%;">完成</button>
        </div>
    </div>
</div>


<!-- 【全新】飛行棋問題編輯器模態框 -->
<div id="ludo-question-editor-modal" class="modal">
    <div class="modal-content" style="height: 80%;">
        <div class="modal-header">
            <span class="back-btn" id="back-to-qbank-manager-btn">‹</span>
            <span id="ludo-question-editor-title">編輯問題</span>
            <span class="action-btn" id="add-ludo-question-btn" style="font-size: 28px; font-weight: 300;">+</span>
        </div>
        <div class="modal-body" id="ludo-question-list" style="padding: 10px;">
            <!-- 問題清單將由JS動態生成在這裡 -->
        </div>
    </div>
</div>

<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 在 </body> 標籤的正上方，黏貼下面這一整塊新代碼 ▼▼▼ -->
<!-- 【全新】飛行棋單個問題編輯器模態框 -->
<div id="ludo-single-question-editor-modal" class="modal">
    <div class="modal-content" style="height: auto;">
        <div class="modal-header">
            <span id="ludo-single-question-title">編輯問題</span>
        </div>
        <div class="modal-body">
            <div class="form-group">
                <label for="ludo-question-text-input">問題內容</label>
                <textarea id="ludo-question-text-input" rows="4"></textarea>
            </div>
            <div class="form-group">
                <label>問題類型</label>
                <div style="display: flex; gap: 20px;">
                    <label><input type="radio" name="ludo_question_type" value="both_answer" checked> 共同回答</label>
                    <label><input type="radio" name="ludo_question_type" value="single_answer"> 一人回答,一人評價</label>
                </div>
            </div>
        </div>
        <div class="modal-footer">
            <button class="cancel" id="cancel-single-question-btn">取消</button>
            <button class="save" id="save-single-question-btn">保存</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲ -->
<!-- ▼▼▼ 【全新】這是飛行棋遊戲結算卡片，請黏貼到 </body> 標籤前 ▼▼▼ -->
<div id="ludo-summary-modal" class="modal">
    <div class="modal-content" style="height: auto; max-height: 80%;">
        <div class="modal-header">
            <span>遊戲結算</span>
        </div>
        <div class="modal-body" id="ludo-summary-content" style="text-align: left; line-height: 1.7;">
            <!-- 結算內容將由JS動態生成在這裡 -->
        </div>
        <div class="modal-footer">
            <button class="cancel" id="share-ludo-summary-btn">分享給Ta</button>
            <button class="save" id="back-to-hall-from-ludo-btn">返回大廳</button>
        </div>
    </div>
</div>
<!-- ▲▲▲ 新增HTML結束 ▲▲▲

<!-- ▲▲▲ HTML代碼黏貼結束 ▲▲▲ -->
<!-- ▼▼▼ 用這整塊代碼替換舊的 inner-voice-modal ▼▼▼ -->
<div id="inner-voice-modal" class="modal">
    <!-- 心聲主面板 -->
    <div id="inner-voice-main-panel" class="modal-content" style="width: 90%; max-width: 340px; height: auto; max-height: 80%; background-color: #fffafb; border: 1px solid #ffe4e1;">
        <div class="modal-header" style="border-bottom: 1px solid #ffe4e1; padding: 12px 15px;">
            <span id="close-inner-voice-modal" style="cursor: pointer; font-size: 24px; color: #ff8a80;">×</span>
            <span id="inner-voice-history-btn" style="cursor: pointer;">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="#ff8a80" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
                </svg>
            </span>
        </div>
        <div class="modal-body" style="padding: 15px;">
            <!-- 頭像和名字資訊現在是獨立的、可定位的元素 -->
            <!-- 角色頭像 -->
            <div id="inner-voice-avatar-wrapper">
                <img id="inner-voice-avatar" src="">
                <!-- 【全新】這是為頭像框預留的位置 -->
                <img id="inner-voice-avatar-frame" src="" style="display: none;">
            </div>

            
            <!-- 角色名字 -->
            <div id="inner-voice-char-info">
                <div id="inner-voice-char-name"></div>
            </div>

            <!-- 【全新】領養人資訊（頭像+名字）-->
            <div id="inner-voice-adopter-info">
                <img id="inner-voice-adopter-avatar" src="">
                <span id="inner-voice-adopter-name"></span>
            </div>
            
            <!-- 心聲內容 -->
            <div id="inner-voice-content-area" style="display: flex; flex-direction: column; gap: 15px;">
                <div>
                    <strong style="color: #e57373;">服裝:</strong>
                    <p id="inner-voice-clothing" style="margin: 5px 0 0 0; line-height: 1.6; color: #555;"></p>
                </div>
                <div>
                    <strong style="color: #81c784;">行為:</strong>
                    <p id="inner-voice-behavior" style="margin: 5px 0 0 0; line-height: 1.6; color: #555;"></p>
                </div>
                <div>
                    <strong style="color: #64b5f6;">心聲:</strong>
                    <p id="inner-voice-thoughts" style="margin: 5px 0 0 0; line-height: 1.6; color: #555;"></p>
                </div>
                <div>
                    <strong style="color: #ba68c8;">壞心思:</strong>
                    <p id="inner-voice-naughty-thoughts" style="margin: 5px 0 0 0; line-height: 1.6; color: #555;"></p>
                </div>
            </div>
        </div>
    </div>

    <!-- 歷史記錄面板 (保持不變) -->
    <div id="inner-voice-history-panel" class="modal-content" style="width: 90%; max-width: 340px; height: 80%; background-color: #f5f5f5; display: none; flex-direction: column;">
        <div class="modal-header" style="border-bottom: 1px solid #ddd; justify-content: space-between;">
            <span id="back-from-history-btn" style="cursor: pointer; font-size: 16px; font-weight: 600; color: var(--accent-color);">返回</span>
            <span>歷史心聲</span>
            <span id="clear-all-history-btn" style="cursor: pointer; font-size: 14px; color: #ff3b30;">全部清空</span>
        </div>
        <div class="modal-body" id="inner-voice-history-list" style="padding: 0;">
            <!-- 歷史記錄會由JS動態生成在這裡 -->
        </div>
    </div>
</div>
<!-- ▲▲▲ 替換結束 ▲▲▲ -->


<script>
// ▼▼▼ 把這一整塊超長的塔羅牌數據，黏貼到 const GEMINI_API_URL 的正上方 ▼▼▼

const TAROT_DECK = [
    { name: "愚人", upright: "開始, 天真, 自發性, 自由精神", reversed: "天真, 魯莽, 承擔風險" },
    { name: "魔術師", upright: "顯化, 足智多謀, 力量, 靈感行動", reversed: "操縱, 計畫不周, 未被利用的天賦" },
    { name: "女祭司", upright: "直覺, 神聖女性, 潛意識, 神秘", reversed: "秘密, 脫離直覺, 壓抑的感情" },
    { name: "皇后", upright: "生育, 女性氣質, 美麗, 自然, 豐富", reversed: "創造力受阻, 依賴他人" },
    { name: "皇帝", upright: "權威, 父親形象, 結構, 穩固控制", reversed: "控制欲, 僵化, 缺乏紀律" },
    { name: "教皇", upright: "精神智慧, 宗教信仰, 傳統, 制度", reversed: "個人信仰, 挑戰傳統, 墨守成規" },
    { name: "戀人", upright: "愛, 和諧, 關係, 價值觀對齊, 選擇", reversed: "不和諧, 失衡, 價值觀錯位" },
    { name: "戰車", upright: "控制, 意志力, 勝利, 斷言, 決心", reversed: "缺乏控制和方向, 侵略性" },
    { name: "力量", upright: "力量, 勇氣, 同情, 專注, 耐心", reversed: "內在力量, 自我懷疑, 精力不足" },
    { name: "隱士", upright: "靈魂探索, 內省, 孤獨, 內在引導", reversed: "孤立, 孤獨, 退縮" },
    { name: "命運之輪", upright: "好運, 因果報應, 生命週期, 轉捩點", reversed: "壞運氣, 抵抗改變, 打破迴圈" },
    { name: "正義", upright: "正義, 公平, 真理, 因果, 法律", reversed: "不公平, 缺乏責任感, 不誠實" },
    { name: "倒吊人", upright: "暫停, 限制, 放手, 犧牲, 新視角", reversed: "拖延, 毫無意義的犧牲, 停滯" },
    { name: "死神", upright: "結束, 改變, 轉變, 過渡", reversed: "抵抗改變, 無法前進, 停滯" },
    { name: "節制", upright: "平衡, 適度, 耐心, 目標", reversed: "失衡, 過度, 重新調整" },
    { name: "惡魔", upright: "束縛, 成癮, 消極, 唯物主義", reversed: "掙脫束縛, 釋放, 恢復控制" },
    { name: "高塔", upright: "突變, 劇變, 混亂, 啟示, 覺醒", reversed: "避免災難, 害怕改變" },
    { name: "星星", upright: "希望, 信念, 目標, 更新, 靈性", reversed: "缺乏信念, 絕望, 不專注" },
    { name: "月亮", upright: "幻覺, 恐懼, 焦慮, 潛意識, 直覺", reversed: "釋放恐懼, 壓抑的情感, 內心困惑" },
    { name: "太陽", upright: "積極, 樂趣, 溫暖, 成功, 活力", reversed: "內心幼稚, 過於樂觀, 沮喪" },
    { name: "審判", upright: "審判, 重生, 內心召喚, 赦免", reversed: "自我懷疑, 無視召喚" },
    { name: "世界", upright: "完成, 整合, 成就, 旅行", reversed: "尋求個人結束, 走捷徑, 拖延" },
    { name: "權杖ACE", upright: "靈感, 新機會, 成長, 潛力", reversed: "缺乏動力, 錯過機會, 拖延" },
    { name: "權杖二", upright: "未來規劃, 進步, 決策, 離開家", reversed: "恐懼未知, 缺乏規劃, 害怕改變" },
    { name: "權杖三", upright: "擴張, 成長, 遠見, 海外機會", reversed: "計畫受挫, 缺乏遠見, 延誤" },
    { name: "權杖四", upright: "慶祝, 和諧, 婚姻, 回家, 穩定", reversed: "不和諧, 過渡, 缺乏支持" },
    { name: "權杖五", upright: "衝突, 分歧, 競爭, 緊張", reversed: "衝突避免, 尊重差異" },
    { name: "權杖六", upright: "成功, 公眾認可, 勝利, 進步", reversed: "自負, 缺乏認可, 懲罰" },
    { name: "權杖七", upright: "挑戰, 競爭, 保護, 堅持", reversed: "放棄, 不知所措, 過度保護" },
    { name: "權杖八", upright: "速度, 行動, 空中旅行, 運動, 快速決策", reversed: "延誤, 挫折, 抵制改變" },
    { name: "權杖九", upright: "韌性, 勇氣, 堅持, 界限", reversed: "內心掙扎, 偏執, 防禦性" },
    { name: "權杖十", upright: "負擔, 責任, 努力工作, 壓力", reversed: "卸下負擔, 委派, 釋放" },
    { name: "權杖侍從", upright: "靈感, 想法, 發現, 自由精神", reversed: "不切實際的想法, 拖延, 創造力受阻" },
    { name: "權杖騎士", upright: "能量, 激情, 欲望, 行動, 冒險", reversed: "憤怒, 衝動, 魯莽" },
    { name: "權杖王后", upright: "勇氣, 自信, 獨立, 社交蝴蝶", reversed: "自我尊重, 自信, 內向" },
    { name: "權杖國王", upright: "天生的領袖, 遠見, 企業家, 榮譽", reversed: "衝動, 倉促, 無情的" },
    { name: "聖杯ACE", upright: "愛, 新關係, 同情, 創造力", reversed: "自我愛, 直覺, 壓抑的情感" },
    { name: "聖杯二", upright: "統一的愛, 夥伴關係, 相互吸引", reversed: "分手, 不和諧, 不信任" },
    { name: "聖杯三", upright: "慶祝, 友誼, 創造力, 合作", reversed: "獨立, 獨處, '三人行'" },
    { name: "聖杯四", upright: "沉思, 斷開連接, 冷漠, 重新評估", reversed: "退縮, 孤僻, 錯過機會" },
    { name: "聖杯五", upright: "遺憾, 失敗, 失望, 悲觀主義", reversed: "個人挫折, 自我寬恕, 前進" },
    { name: "聖杯六", upright: "重溫過去, 童年記憶, 天真, 喜悅", reversed: "活在過去, 不願原諒, 缺乏玩樂" },
    { name: "聖杯七", upright: "機會, 選擇, 幻想, 幻覺", reversed: "一致性, 幻想, 過多選擇" },
    { name: "聖杯八", upright: "失望, 放棄, 退縮, 逃避主義", reversed: "嘗試新事物, 冷漠, 恐懼改變" },
    { name: "聖杯九", upright: "滿足, 滿意, 感激, 願望成真", reversed: "不滿足, 唯物主義, 不滿" },
    { name: "聖杯十", upright: "神聖的愛, 和諧關係, 家庭, 一致性", reversed: "脫節, 對齊錯誤, 掙扎的關係" },
    { name: "聖杯侍從", upright: "創意機會, 直覺資訊, 好奇心", reversed: "新的想法, 懷疑, 創造力受阻" },
    { name: "聖杯騎士", upright: "創造力, 浪漫, 魅力, 想像力", reversed: "不切實際, 嫉妒, 情緒波動" },
    { name: "聖杯王后", upright: "富有同情心, 關懷, 直覺, 平靜", reversed: "內在感受, 自我照顧, 自愛, 共情" },
    { name: "聖杯國王", upright: "情緒平衡, 同情, 外交", reversed: "自我同情, 內在真理, 情緒不穩定" },
    { name: "寶劍ACE", upright: "突破, 新想法, 頭腦清晰, 成功", reversed: "內心清晰, 重新思考一個想法, 混亂" },
    { name: "寶劍二", upright: "艱難的選擇, 未知的後果, 僵局", reversed: "優柔寡斷, 困惑, 資訊超載" },
    { name: "寶劍三", upright: "心碎, 悲傷, 拒絕, 分離", reversed: "釋放痛苦, 樂觀, 寬恕" },
    { name: "寶劍四", upright: "休息, 放鬆, 沉思, 恢復", reversed: "精疲力盡, 倦怠, 停滯" },
    { name: "寶劍五", upright: "衝突, 分歧, 競爭, 失敗", reversed: "和解, 過去的原諒" },
    { name: "寶劍六", upright: "過渡, 改變, 儀式, 放下", reversed: "個人過渡, 抵抗改變, 未完成的事" },
    { name: "寶劍七", upright: "背叛, 欺騙, 走捷徑, 鬼祟", reversed: "冒名頂替綜合症, 欺騙, 守秘" },
    { name: "寶劍八", upright: "負面想法, 自我強加的限制, 監禁", reversed: "自我限制的信念, 釋放, 思想開放" },
    { name: "寶劍九", upright: "焦慮, 擔憂, 恐懼, 抑鬱, 噩夢", reversed: "內心掙扎, 深度恐懼, 釋放憂慮" },
    { name: "寶劍十", upright: "痛苦的結局, 深度創傷, 背叛, 損失", reversed: "恢復, 抵抗結局, 無法放手" },
    { name: "寶劍侍從", upright: "新想法, 好奇心, 追求真理", reversed: "自言自語, 全能選手, 倉促" },
    { name: "寶劍騎士", upright: "雄心勃勃, 行動導向, 追求目標", reversed: "不安, 衝動, 倦怠" },
    { name: "寶劍王后", upright: "獨立的, 無偏見的判斷, 清晰的界限", reversed: "過於情緒化, 輕易受影響, 刻薄" },
    { name: "寶劍國王", upright: "精神清晰, 智慧, 權威, 真理", reversed: "安靜的力量, 內在真理, 濫用權力" },
    { name: "星幣ACE", upright: "顯化, 新的財務機會, 繁榮", reversed: "機會喪失, 缺乏規劃和遠見" },
    { name: "星幣二", upright: "多工, 適應性, 時間管理", reversed: "重新調整優先順序, 過度投入" },
    { name: "星幣三", upright: "團隊合作, 合作, 學習, 實施", reversed: "不和諧, 團隊內部衝突, 計畫不周" },
    { name: "星幣四", upright: "節約, 安全, 保守, 稀缺心態", reversed: "過度消費, 貪婪, 自我保護" },
    { name: "星幣五", upright: "財務損失, 貧困, 孤立, 憂慮", reversed: "從財務損失中恢復, 精神貧困" },
    { name: "星幣六", upright: "給予, 接受, 分享財富, 慷慨", reversed: "自私, 債務, 單方面給予" },
    { name: "星幣七", upright: "長期眼光, 可持續的結果, 投資", reversed: "缺乏長期眼光, 成功受限" },
    { name: "星幣八", upright: "學徒, 重複, 掌握, 技能發展", reversed: "自我發展, 完美主義, 部署不當" },
    { name: "星幣九", upright: "豐富, 奢華, 自給自足, 財務獨立", reversed: "自我價值, 過度投資於工作" },
    { name: "星幣十", upright: "財富, 財務安全, 家庭, 遺產", reversed: "財務失敗, 負擔, 遺產喪失" },
    { name: "星幣侍從", upright: "顯化, 財務機會, 技能發展", reversed: "缺乏進步, 拖延, 學會新技能" },
    { name: "星幣騎士", upright: "努力工作, 生產力, 日常, 保守", reversed: "自我紀律, 無聊, 感覺'卡住'" },
    { name: "星幣王后", upright: "養育, 務實, 財務安全, 工作與家庭的平衡", reversed: "財務獨立, 自我照顧, 工作與家庭的不平衡" },
    { name: "星幣國王", upright: "財富, 商業, 領導力, 安全, 紀律", reversed: "財務不稱職, 過時, 固執" }
];

// ▲▲▲ 塔羅牌數據黏貼結束 ▲▲▲
// ▼▼▼ 把這一整塊全新的代碼，黏貼到 const GEMINI_API_URL 的正上方 ▼▼▼

const BUILT_IN_SCRIPTS = [
    {
        id: 'built_in_1',
        name: '辦公室疑雲',
        storyBackground: '深夜，頂級互聯網公司“比特無限”燈火通明。以苛刻聞名的專案總監王強，被發現死在自己的座位上，死因為藥物中毒。警方初步鎖定了當晚還在公司的五位嫌疑人，每個人似乎都與死者有著千絲萬縷的聯繫。在這座欲望與代碼交織的鋼鐵森林裡，誰的秘密被永遠埋葬，誰的雙手沾染了罪惡？',
        roles: [
            {
                name: '李思',
                description: '公司新晉的天才程式師，技術過硬，但性格內向，不善言辭。',
                storyline: `今天是專案上線的最後期限，我被王總監逼著加班到深夜。\n**晚上8:00**：王總監把我叫進他辦公室，因為一個微不足道的bug對我破口大駡，甚至撕掉了我的績效評估報告，說我“不合格”。我氣得渾身發抖，和他大吵了一架，然後摔門而出。\n**晚上8:30**：我回到工位，越想越氣，打開電腦寫了一封辭職信，但還沒發送。\n**晚上9:00**：我起身去茶水間倒水，路過總監辦公室時，看到人事主管陳靜端著一杯咖啡走了進去。我當時沒太在意。\n**晚上9:30**：我有點餓，點了一份外賣。等外賣的時候，我看到設計師孫偉鬼鬼祟祟地從茶水間的方向走出來，手裡好像攥著什麼東西。\n**晚上10:00**：外賣到了，我吃完外賣繼續改bug，直到被發現屍體的驚叫聲打斷。`,
                tasks: '1. 隱藏你與王強總監發生過激烈爭吵，並被他評為“不合格”的事實。\n2. 你的首要目標是自保，找到證據證明你離開後另有其人進入過辦公室。\n3. 你懷疑陳靜和孫偉，嘗試找出他們的可疑之處。',
                isKiller: false
            },
            {
                name: '趙娜',
                description: '公司的市場部經理，能力出眾，是典型的職場女強人，野心勃勃。',
                storyline: `今晚本不需要我加班，但我為了準備一個重要的競標方案，主動留了下來。\n**晚上7:30**：我在自己的辦公室整理資料，無意中發現了王強挪用專案公款的證據。我立刻起草了一封匿名舉報郵件，準備發給總部。\n**晚上8:10**：我聽到隔壁總監辦公室傳來激烈的爭吵聲，好像是李思在和王強吵架。\n**晚上8:45**：我需要一些資料，就去找王強簽字。進他辦公室時，他正在喝咖啡，臉色很差。我把文件給他，他很不耐煩地簽了字。我注意到他桌上放著一瓶沒貼標籤的藥瓶。\n**晚上9:15**：我回到自己辦公室，思考著舉報郵件的事情。我擔心這會影響公司聲譽，最終還是沒有發送。\n**晚上10:15**：我準備下班，路過總監辦公室時，發現門虛掩著，裡面很安靜。我沒有進去看，直接離開了公司。`,
                tasks: '1. 你的首要任務是找出真凶，洗清自己的嫌疑，確保公司醜聞不被曝光，以免影響你的職業前途。\n2. 隱藏你發現王強挪用公款並準備舉報他的事實。\n3. 你看到他桌上的藥瓶，這是一個重要線索，你需要引導大家注意到這一點。',
                isKiller: false
            },
            {
                name: '孫偉',
                description: '公司的資深UI設計師，也是王強的老部下，表面對他畢恭畢敬。',
                storyline: `我恨透了王強！他克扣了我們團隊辛辛苦苦做完的項目獎金，自己卻拿了大頭。\n**晚上9:00**：我藉口加班，實際上是想潛入王強的辦公室，找到他克扣獎金的證據。我看到陳靜端著咖啡進去後不久就出來了。\n**晚上9:20**：我確認王強辦公室沒人注意，就偷偷溜了進去。我看到他趴在桌上睡著了，旁邊是那杯幾乎沒喝的咖啡。我在他抽屜裡翻找，果然找到了一份內部獎金分配表，證實了他中飽私囊。我用手機拍了下來。\n**晚上9:30**：我拿著證據悄悄離開辦公室，準備去茶水間處理一下。這時迎面撞上了去倒水的李思，我嚇了一跳，趕緊把手機藏進口袋裡。\n**晚上10:00後**：我一直在自己的工位上，盤算著怎麼利用這個證據讓他身敗名裂。`,
                tasks: '1. 隱藏你曾潛入總監辦公室並偷拍證據的事實。\n2. 王強死了對你有利，你需要引導大家懷疑其他有動機的人，比如與他爭吵的李思。\n3. 保護好你手機裡的照片證據，這是你的護身符。',
                isKiller: false
            },
            {
                name: '陳靜',
                description: '公司的人事主管，外表溫柔體貼，善於處理人際關係。',
                storyline: `我曾是王強秘密的情人，他承諾過會和妻子離婚娶我。但最近，我發現他為了攀附一個富家女，準備拋棄我。更讓我恐懼的是，他手機裡存著我們大量的私密照片和視頻，如果曝光，我的職業生涯就全毀了。\n**晚上8:45**：我知道王強有喝咖啡的習慣。我提前準備了強效安眠藥，磨成粉末，藏在身上。\n**晚上9:00**：我以關心他為由，為他沖了一杯咖啡，並將安眠藥全部倒了進去，然後端進了他的辦公室。他當時正在處理檔，沒有懷疑，喝了一大口。\n**晚上9:10**：我藉口離開，在外面觀察。不一會兒，就看到他趴在桌上睡著了。\n**晚上9:20**：我返回辦公室，想找到他的手機刪除資料。但我怎麼也找不到他的手機。此時我發現他已經沒了呼吸，我嚇壞了，慌亂中，我不小心將他桌上的一條項鍊（他準備送給那個富家女的）碰掉，掉進了我的手提包裡。\n**晚上9:40**：我驚慌失措地逃離了辦公室，回到自己的工位假裝加班，心亂如麻。`,
                tasks: `【你的核心任務】\n請隱藏你為了銷毀證據而失手用安眠藥毒殺王強的事實。你是本案的唯一真凶。\n\n【你的行動指南】\n1. 嫁禍他人。你可以利用你看到的、聽到的資訊，將嫌疑引向李思或孫偉。\n2. 你包裡的項鍊是定時炸彈，想辦法合理解釋它的來歷，或者神不知鬼不覺地處理掉它。\n3. 你的目標是誤導所有人，讓他們投出錯誤的兇手。`,
                isKiller: true
            },
            {
                name: '周毅',
                description: '公司大樓的夜班保安，看起來忠厚老實，但觀察力敏銳。',
                storyline: `作為保安，我負責大樓夜間的安全巡邏。\n**晚上8:10**：我巡邏到18樓，聽到總監辦公室裡有激烈的爭吵聲，好像是那個叫李思的程式師，我沒敢靠近。\n**晚上9:00**：我看到人事主管陳靜端著杯咖啡進了總監辦公室，幾分鐘後就出來了，看起來有點緊張。\n**晚上9:20**：我看到UI設計師孫偉，像做賊一樣溜進了總監辦公室。\n**晚上9:40**：我又看到陳靜從總監辦公室出來，這次她臉色慘白，腳步匆忙，好像丟了魂一樣。我覺得很奇怪，但沒敢多問。\n**晚上10:30**：我進行例行檢查，發現總監辦公室的門沒關，進去一看，發現王總監已經……我立刻報了警。`,
                tasks: '1. 你是本案最重要的目擊證人，你的任務是誠實、準確地向大家提供你看到的時間線索。\n2. 你覺得陳靜的行為最可疑，你需要重點觀察她，並向大家說明你的懷疑。\n3. 找出對公司最有利的真相，避免事件擴大化。',
                isKiller: false
            }
        ],
        clues: [
            { owner: '李思', description: '一張被揉成一團、丟在垃圾桶裡的績效評估報告，上面有王強龍飛鳳舞的簽名和“不合格，建議辭退”的批註。' },
            { owner: '趙娜', description: '你的電腦裡有一封未發送的郵件，收件人是集團總部紀檢委，標題是“關於比特無限專案總監王強涉嫌嚴重職務侵佔的實名舉報”。' },
            { owner: '孫偉', description: '你的手機相冊裡有一張照片，內容是一份內部獎金分配表，表格顯示專案總獎金的70%都流向了王強的個人帳戶。' },
            { owner: '陳靜', description: '在你的手提包夾層裡，發現了一條價值不菲的鑽石項鍊，包裝盒還在，但沒有賀卡。', isKey: true },
            { owner: '周毅', description: '一份保安巡邏日誌，清晰地記錄了你在不同時間點看到不同人進出總監辦公室的情況。' },
            { owner: '公共', description: '在茶水間垃圾桶裡發現一個空的安眠藥藥瓶，上面的標籤被撕掉了。' },
            { owner: '公共', description: '在死者辦公桌下發現一部手機，但不是死者常用的那部，手機已經沒電了。' }
        ],
        truth: '兇手是人事主管陳靜。她與總監王強有私情，但王強近期為了利益想和她分手並娶一位富家女。當晚，陳靜在王強的咖啡裡下了過量安眠藥，想讓他睡著後偷走他手機裡存有的兩人親密照片。但由於藥量過大，王強意外死亡。陳靜在慌亂中沒找到手機，反而不小心將王強準備送給富家女的項鍊碰進了自己的包裡。'
    },
    // --- 【全新劇本1：深海遺書】 ---
    {
        id: 'built_in_2',
        name: '深海遺書',
        storyBackground: '在與世隔絕的“迴響島”上，著名的海洋學家李博士被發現死在自己反鎖的書房中，桌上放著一封列印的遺書，死因為氰化物中毒。一場突如其來的風暴切斷了島上與外界的所有聯繫，將剩下的四個人困在了這座孤島上：李博士的得意門生、一位競爭對手、一位沉默寡言的技術員，以及一位元不請自來的記者。',
        roles: [
            {
                name: '高遠',
                description: '李博士的學生，才華橫溢但野心勃勃。',
                storyline: `我一直覺得老師竊取了我的研究成果。今晚，我本想和他攤牌。\n**晚上7:00**：我和老師在實驗室大吵一架，他承認參考了我的資料，但拒絕公開承認。我憤怒地離開。\n**晚上8:00**：我回到宿舍，越想越氣。我利用許可權，遠端刪除了部分對他有利、對我不利的核心實驗資料，想讓他無法發佈論文。\n**晚上9:00**：我去食堂吃飯，看到技術員陳默在調試監控設備，他看起來心事重重。\n**晚上9:45**：我看到記者張萊在李博士書房門口徘徊，似乎想進去但又不敢。`,
                tasks: '1. 隱藏你和老師的學術糾紛以及你刪除資料的行為。\n2. 你認為自己的前途受到了威脅，必須找到真凶來洗清嫌疑。\n3. 引導大家懷疑其他有動機的人。',
                isKiller: false
            },
            {
                name: '林雪',
                description: '另一位海洋學家，與李博士是長期的競爭對手。',
                storyline: `我和李博士在競爭一個重要的國際科研基金。我知道他這次的研究有重大突破。\n**晚上7:30**：我去找李博士，希望他能分享一些資料，被他無情拒絕了。我們不歡而散。\n**晚上8:30**：我在自己的房間裡整理資料，聽到外面有奇怪的電流聲，好像是停電了一瞬間又恢復了。\n**晚上9:10**：我口渴去廚房倒水，看到高遠神色慌張地從機房的方向出來。\n**晚上10:00**：我經過書房時，聞到一股淡淡的杏仁味（氰化物的典型氣味），但我當時以為是實驗室的化學品味道，沒有在意。`,
                tasks: '1. 李博士的死對你的基金申請有利，這是你的嫌疑點，你需要撇清關係。\n2. 隱藏你曾私下找他索要資料被拒的事實。\n3. 你聞到的杏仁味是關鍵線索，需要讓大家知道。',
                isKiller: false
            },
            {
                name: '陳默',
                description: '研究站的技術員，性格內向，暗戀著李博士。',
                storyline: `我深愛著李博士，但她似乎對我毫不在意。我掌管著整個研究站的設備和監控。\n**晚上8:30**：我接到高遠的請求，他讓我“不小心”讓監控系統斷電一分鐘。我雖然覺得奇怪，但因為他答應幫我向李博士說好話，我還是照做了。\n**晚上9:00**：我看到李博士把自己鎖在書房裡，神情悲傷。我很難過，但不敢打擾。\n**晚上9:20**：我看到記者張萊試圖撬書房的門鎖，被我發現後他慌忙走開了。\n**晚上10:30**：我越想越不對勁，用備用鑰匙打開了書房的門，發現了博士的屍體。`,
                tasks: '1. 隱藏你曾受高遠指使，人為製造監控斷電的事實。\n2. 你有備用鑰匙，這讓你有重大嫌疑，你需要找到合理的解釋。\n3. 你懷疑記者張萊有不軌行為。',
                isKiller: false
            },
            {
                name: '張萊',
                description: '一位元追蹤學術醜聞的記者，秘密登島。',
                storyline: `我收到線報，稱李博士的研究涉嫌造假，我是來調查真相的。今晚是最好的機會。\n**晚上9:00**：我繞到李博士書房的窗外，看到她正在電腦前打字，似乎在寫著什麼重要的東西。我用長焦相機拍下了幾張模糊的照片。\n**晚上9:20**：我嘗試從正門進入書房，想找她當面對質，但門被反鎖了。我試圖用鐵絲開鎖，結果被技術員陳默撞見了，我只好假裝路過離開。\n**晚上9:50**：我回到自己的住處，放大相機裡的照片，發現她打字的內容似乎是一封遺書，但內容很奇怪，好像在暗示什麼。我還拍到她桌上有一個遙控器一樣的東西。`,
                tasks: '1. 隱藏你記者的身份和你登島的真實目的。\n2. 你拍到的照片是關鍵證據，但直接拿出來會暴露你自己。你需要巧妙地引導大家發現遺書和遙控器的問題。\n3. 你是外來者，嫌疑最大，必須儘快找到兇手。',
                isKiller: true
            }
        ],
        clues: [
            { owner: '高遠', description: '你的電腦回收站裡有一份未發送的郵件，內容是向競爭對手的公司投遞簡歷，並附言可以提供“比特無限”的核心代碼。' },
            { owner: '林雪', description: '在你的抽屜裡，發現了一瓶標籤被撕掉的化學試劑，經過檢驗，是無毒的營養液。' },
            { owner: '陳默', description: '一張工作日志，上面寫著“20:30-20:31，18樓東區伺服器意外重啟，原因排查中”。'},
            { owner: '張萊', description: '你的相機裡有多張照片，其中一張清晰地拍到死者電腦螢幕上的遺書內容，另一張模糊地拍到了桌上的一個小型遙控裝置。', isKey: true },
            { owner: '公共', description: '死者手邊的咖啡杯裡檢測出高濃度的氰化物，但奇怪的是，咖啡基本沒喝。' },
            { owner: '公共', description: '書房的通風口內側，發現一個被改裝過的、連接著小型霧化噴嘴的遙控香薰機，裡面殘留有氰化物液體。' },
            { owner: '公共', description: '死者的電腦流覽器歷史顯示，她在死前最後一個訪問的頁面是她已故丈夫的紀念網站。' }
        ],
        truth: '兇手是記者張萊。他並非想殺死李博士，而是想製造混亂以竊取學術造假的證據。他提前在書房的通風口安裝了遙控毒氣裝置，計畫在採訪時如果李博士不配合，就少量釋放讓她昏迷。但他沒想到，當晚李博士因為思念亡夫而情緒低落，正在寫一封真的遺書。張萊在窗外看到遺書，誤以為時機已到，便按下了遙控器，導致李博士吸入過量毒氣身亡。他之後嘗試進入房間取回裝置未果。'
    },
    // --- 【全新劇本2：古堡魅影】 ---
    {
        id: 'built_in_3',
        name: '古堡魅影',
        storyBackground: '在濃霧籠罩的偏遠古堡裡，富有而古怪的伯爵被發現死在反鎖的書房中，胸口插著一把古董拆信刀。猛烈的暴風雨切斷了城堡與外界的唯一橋樑，所有人都被困於此：伯爵年輕貌美的妻子、與他素有嫌隙的侄子、負債累累的私人醫生，以及一位被請來進行降神會的女巫。',
        roles: [
            {
                name: '安娜',
                description: '伯爵的年輕妻子，被外界傳言是為了財產才嫁給年邁的伯爵。',
                storyline: `我受夠了這段沒有愛情的婚姻。我愛上了侄子愛德華，我們計畫私奔。\n**晚上8:00**：我和愛德華在花園秘密會面，商量私奔的細節。我告訴他，我找到了一條可以通往書房的密道。\n**晚上9:00**：伯爵把我叫到書房，再次因為我購買奢侈品的事與我爭吵，並威脅要修改遺囑，剝奪我的繼承權。我憤怒地離開。\n**晚上9:30**：我回到房間，收拾好我的珠寶準備離開。此時我聽到樓下傳來一聲女人的尖叫，但很快就消失了。\n**晚上10:00**：我從房間的密道入口進入，想去書房偷走遺囑。當我從書房的壁爐後走出來時，發現伯爵已經倒在血泊裡。我嚇壞了，立刻原路返回，不敢聲張。`,
                tasks: '1. 隱藏你和愛德華的私情以及私奔計畫。\n2. 隱藏你曾通過密道進入案發現場的事實。\n3. 你認為兇手是其他人，需要儘快找到證據洗脫嫌疑。',
                isKiller: false
            },
            {
                name: '愛德華',
                description: '伯爵的侄子，放蕩不羈，是城堡的法定繼承人，但與伯爵關係惡劣。',
                storyline: `我急需用錢，但老傢伙一分錢都不肯給我。我今晚準備偷點東西去賣。\n**晚上8:00**：我和安娜在花園見面，她告訴我一條通往書房的密道，這正合我意。\n**晚上8:30**：我看到醫生馬丁行色匆匆地進了伯爵的書房。\n**晚上9:10**：我準備通過安娜告訴我的密道進入書房，但在密道口聽到了裡面有奇怪的響動，我害怕被發現，就退了回來。\n**晚上9:40**：我在走廊裡遇到了女巫羅蘭女士，她警告我今晚城堡會有血光之災，讓我不要亂走動。她的眼神很奇怪，讓我不寒而慄。`,
                tasks: '1. 隱藏你計畫偷竊以及知道密道的事實。\n2. 伯爵死了，你是最大受益人，你的嫌疑最大。你需要將嫌疑轉移到他人身上，比如醫生或行為詭異的女巫。\n3. 你需要找到對你有利的證據。',
                isKiller: false
            },
            {
                name: '馬丁醫生',
                description: '伯爵的私人醫生，醫術高明，但深陷賭博債務。',
                storyline: `我欠了伯爵一大筆錢，他拿走了我的行醫執照作為抵押，並威脅如果我還不上錢，就讓我身敗名裂。\n**晚上8:30**：我去找伯爵，懇求他再寬限我一段時間。他不僅拒絕了，還羞辱了我一番。我絕望地離開。\n**晚上9:00**：我回到我的房間，準備了一些強效鎮定劑，我計畫讓他睡著，然後偷回我的行醫執照。\n**晚上9:20**：我再次來到書房門口，卻聽到裡面安娜和伯爵在激烈爭吵。我只好暫時放棄計畫，躲在附近觀察。\n**晚上9:40後**：我看到安娜氣衝衝地離開後，就再也沒人進出過書房。我因為害怕一直沒敢動手，直到屍體被發現。`,
                tasks: '1. 隱藏你欠下巨額賭債並被伯爵威脅的事實。\n2. 隱藏你準備了鎮定劑並計畫偷東西的意圖。\n3. 你是最後一個見到伯爵的人之一，你需要證明你離開後還有作案時間。',
                isKiller: false
            },
            {
                name: '羅蘭女士',
                description: '著名的靈媒、女巫，被伯爵請來進行降神會，與城堡的“幽靈”對話。',
                storyline: `我是個騙子。伯爵發現了我的秘密，並以此敲詐我，讓我免費為他“服務”。\n**晚上9:10**：伯爵把我叫到書房，再次威脅我，說如果今晚的降神會不能讓他滿意，就要揭穿我的一切。我感到前所未有的恐懼。\n**晚上9:30**：我藉口準備儀式，獨自留在書房。伯爵背對著我，在欣賞一幅畫。我看到桌上有一把鋒利的拆信刀，一時衝動，拿起刀從背後刺向了他。他當場倒下。我發出一聲短促的尖叫，但立刻捂住了嘴。\n**晚上9:35**：我慌亂地將書房門從內反鎖，然後從牆角的書架後面啟動了密道（這是我之前偷偷發現的），逃離了現場。在密道中，我的一片蕾絲袖口被掛掉了。\n**晚上9:40**：我從密道出來，遇到了愛德華，我故作神秘地警告他有血光之災，以掩飾我的慌張。`,
                tasks: '1. 你是真凶！你的任務是隱藏一切，將罪行嫁禍給他人。\n2. 利用你“女巫”的身份，編造一些鬼神之說來混淆視聽。\n3. 愛德華和安娜都知道密道，這是嫁禍他們的好機會。馬丁醫生有強烈的動機，也可以加以利用。',
                isKiller: true
            }
        ],
        clues: [
            { owner: '安娜', description: '你的珠寶盒裡有一張單程的火車票，目的地是巴黎，時間是明天一早。' },
            { owner: '愛德華', description: '你的口袋裡有一張當票，上面是一枚屬於伯爵家族的古董懷錶。' },
            { owner: '馬丁醫生', description: '你的藥箱裡有一瓶幾乎滿裝的強效鎮定劑，以及一張伯爵寫的、要求你一周內還清10萬英鎊欠款的字條。' },
            { owner: '羅蘭女士', description: '你的長裙袖口處有一塊明顯的撕裂痕跡，似乎是被什麼東西掛壞的。', isKey: true },
            { owner: '公共', description: '在書房壁爐後面發現一個隱蔽的按鈕，按下後，旁邊的一整面書架會旋轉打開，露出一條通往樓上走廊的密道。' },
            { owner: '公共', description: '在密道的地板上，發現了一小片黑色的蕾絲布料。' },
            { owner: '公共', description: '伯爵的書桌上攤開著一本關於“靈媒與欺詐”的書，其中一頁用紅筆圈出了“羅蘭女士”的名字。' }
        ],
        truth: '兇手是女巫羅蘭女士。伯爵發現了她是個騙子並以此敲詐她。當晚，伯爵再次威脅她，羅蘭在恐懼和憤怒之下，用拆信刀從背後殺害了伯主。她知道城堡的密道，於是反鎖房門，通過密道逃離，偽造了密室殺人案。但慌亂中，她的一片蕾f絲袖口掛在了密道裡，成為了關鍵證據。'
    }
];

// ▲▲▲ 劇本庫黏貼結束 ▲▲▲

        const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models'
        // gemini如果是多個金鑰, 那麼隨機獲取一個
    function getRandomValue(str) {
        // 檢查字串是否包含逗號
        if (str.includes(',')) {
            // 用逗號分隔字串並移除多餘空格
            const arr = str.split(',').map(item => item.trim());
            // 生成隨機索引 (0 到 arr.length-1)
            const randomIndex = Math.floor(Math.random() * arr.length);
            // 返回隨機元素
            return arr[randomIndex];
        }
        // 沒有逗號則直接返回原字串
        return str;
    }
    function isImage(text,content) {
        let currentImageData = content.image_url.url
        // 提取Base64資料（去掉首碼）
        const base64Data = currentImageData.split(',')[1];
        // 根據圖片類型獲取MIME類型
        const mimeType = currentImageData.match(/^data:(.*);base64/)[1];
        return [
            {text: `${text.text}使用者向你發送了一張圖片`},
            {
                inline_data: {
                    mime_type: mimeType,
                    data: base64Data
                }
            }
        ]
    }

   function extractArray(text) {
        // 規則運算式模式：匹配開頭的時間戳記部分和後續的JSON陣列
        const pattern = /^\(Timestamp: (\d+)\)(.*)$/s;
        const match = text.match(pattern);

        if (match) {
            const timestampPart = `(Timestamp: ${match[1]}) `;
            const jsonPart = match[2].trim();

            try {
                // 嘗試解析JSON部分
                const parsedJson = JSON.parse(jsonPart);
                // 驗證解析結果是否為陣列
                if (Array.isArray(parsedJson)) {
                    return [timestampPart, parsedJson[0]];
                }
            } catch (error) {
                // 解析失敗，返回原始文本
            }
        }

        // 不匹配格式或解析失敗時返回原值
        return text;
    }
    function transformChatData(item) {
        let type = {
            send_and_recall:'撤回了消息',
            update_status:'更新了狀態',
            change_music:'切換了歌曲',
            create_memory:'記錄了回憶',
            create_countdown:'創建了約定/倒計時',
            text:'發送了文本',
            sticker:'發送了表情',
            ai_image:'發送了圖片',
            voice_message:'發送了語音',
            transfer:'發起了轉帳',
            waimai_request:'發起了外賣請求',
            waimai_response:{
                paid:'回應了外賣-同意',
                rejected:'回應了外賣-拒絕'
            },
            video_call_request:'發起了視頻通話',
            video_call_response:{
                accept:'回應了視頻通話-接受',
                reject:'回應了視頻通話-拒絕'
            },
            qzone_post:{
                shuoshuo:'發佈了說說',
                text_image:'發佈了文字圖'
            },
            qzone_comment:'評論了動態',
            qzone_like:'點贊了動態',
            pat_user:'拍一拍了用戶',
            block_user:'拉黑了用戶',
            friend_request_response:'回應了好友申請',
            change_avatar:'更換了頭像',
            share_link:'分享了連結',
            accept_transfer:'回應了轉帳-接受',
            decline_transfer:'回應了轉帳-拒絕/退款',
            quote_reply:'引用了回復',
            text:'',
        }
        let res = extractArray(item.content)

        if(Array.isArray(res)){
            let obj = res[1]
            let itemType = obj.type;
            let time = res[0]
            let text = type[itemType];
            if(text){
                if(itemType === 'sticker'){
                    return [{text:`${time}[${text}] 含義是:${obj.meaning}`}]
                }else if(itemType === 'send_and_recall'){
                    return [{text:`${time}[${text}] ${obj.content}`}]
                }else if(itemType === 'update_status'){
                    return [{text:`${time}[${text}] ${obj.status_text}(${obj.is_busy ? '忙碌/離開' : '空閒'})`}]
                }else if(itemType === 'change_music'){
                    return [{text:`${time}[${text}] ${obj.change_music}, 歌名是:${obj.song_name}`}]
                }else if(itemType === 'create_memory'){
                    return [{text:`${time}[${text}] ${obj.description}`}]
                }else if(itemType === 'create_countdown'){
                    return [{text:`${time}[${text}] ${obj.title}(${obj.date})`}]
                }else if(itemType === 'ai_image'){
                    return [{text:`${time}[${text}] 圖片描述是:${obj.description}`}]
                }else if(itemType === 'voice_message'){
                    return [{text:`${time}[${text}] ${obj.content}`}]
                }else if(itemType === 'transfer'){
                    return [{text:`${time}[${text}] 金額是:${obj.amount} 備註是:${obj.amount}`}]
                }else if(itemType === 'waimai_request'){
                    return [{text:`${time}[${text}] 金額是:${obj.amount} 商品是:${obj.productInfo}`}]
                }else if(itemType === 'waimai_response'){
                    return [{text:`${time}[${text[obj.status]}] ${obj.status === 'paid' ? '同意' : '拒絕'}`}]
                }else if(itemType === 'video_call_request'){
                    return [{text:`${time}[${text}]`}]
                }}else if(itemType === 'video_call_request'){
                    return [{text:`${time}[${text[obj.decision]}] ${obj.decision === 'accept' ? '同意' : '拒絕'}`}]
                }else if(itemType === 'qzone_post'){
                    return [{text:`${time}[${text[obj.postType]}] ${obj.postType === 'shuoshuo' ? `${obj.content}` : `圖片描述是:${obj.hiddenContent} ${obj.publicText ? `文案是: ${obj.publicText}` : ''}`}`}]
                }else if(itemType === 'qzone_comment'){
                    return [{text:`${time}[${text}] 評論的id是: ${obj.postId} 評論的內容是: ${obj.commentText}`}]
                }else if(itemType === 'qzone_like'){
                    return [{text:`${time}[${text}] 點贊的id是: ${obj.postId}`}]
                }else if(itemType === 'pat_user'){
                    return [{text:`${time}[${text}] ${obj.suffix ? obj.suffix  : ''}`}]
                }else if(itemType === 'block_user'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'friend_request_response'){
                    return [{text:`${time}[${text}] 結果是:${obj.decision === 'accept' ? '同意' : '拒絕'}`}]
                }else if(itemType === 'change_avatar'){
                    return [{text:`${time}[${text}] 頭像名是:${obj.name}`}]
                }else if(itemType === 'share_link'){
                    return [{text:`${time}[${text}] 文章標題是:${obj.title}  文章摘要是:${obj.description} 來源網站名是:${obj.source_name} 文章正文是:${obj.content}`}]
                }else if(itemType === 'accept_transfer'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'accept_transfer'){
                    return [{text:`${time}[${text}]`}]
                }else if(itemType === 'quote_reply'){
                    return [{text:`${time}[${text}] 引用的內容是:${obj.reply_content}`}]
                }else if(itemType === 'text'){
                    return [{text:`${time}${obj.content}`}]
                }
            }

    // (例如，它是一個陣列，或者一個AI返回的、我們不認識的JSON物件)
    if (typeof res !== 'string') {
        // 我們就強制使用最原始、最安全的 item.content 字串
        res = item.content;
    }

    return [{text: res}];
}

    function toGeminiRequestData(model, apiKey, systemInstruction, messagesForDecision,isGemini) {

	if(!isGemini){
		return undefined
	}

        // 【核心修正】在這裡，我們將 'system' 角色也映射為 'user'

        let roleType = {
            user: 'user',
            assistant: 'model',
            system: 'user' // <--- 新增這一行
        }
        return {
            url: `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${getRandomValue(apiKey)}`,
            data: {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    contents: messagesForDecision.map((item) => {
                        let  includesImages = false;
                        if(Array.isArray(item.content) && item.content.length === 2){
                              includesImages =  item.content.some((sub)=>{
                                return sub.type === 'image_url' && sub.image_url.url
                            })
                        }
                        return {
                            role: roleType[item.role], // 現在 'system' 會被正確轉換為 'user'
                            parts: includesImages ? isImage(item.content[0],item.content[1]) : transformChatData(item)
                        }
                    }),
                    generationConfig: {
                        temperature: 0.8,
                    },
                    "systemInstruction": {
                        "parts": [{
                            "text": systemInstruction
                        }]
                    }
                })
            }
        }
    }
    document.addEventListener('DOMContentLoaded', () => {

        // ===================================================================
        // 1. 所有變數和常量定義
        // ===================================================================
        // ▼▼▼ 【全新】寵物數值衰減相關的全域變數和常量 ▼▼▼
const PET_DECAY_INTERVAL = 60 * 60 * 1000; // 每60分鐘衰減一次
const PET_DECAY_AMOUNT = { // 每次衰減的數值
    hunger: 5,
    happiness: 3
};
let petDecayTimer = null; // 用於管理衰減計時器的全域變數
// ▲▲▲ 新代碼黏貼結束 ▲▲▲
// ▼▼▼ 【全新】這是角色手機的App列表，請黏貼到JS頂部 ▼▼▼
const CHAR_PHONE_APPS = [
    { id: 'chat', name: '微信', screen: 'character-chat-list-screen', svg: `<svg viewBox="0 0 24 24" fill="#4CAF50"><path d="M12 2C6.48 2 2 6.48 2 12c0 2.94 1.28 5.58 3.34 7.42c-.22 1.4-.89 3.1-1.25 3.82c-.36.72.48 1.39 1.05.94c.82-.67 2.43-1.88 3.3-2.58C9.44 21.78 10.68 22 12 22c5.52 0 10-4.48 10-10S17.52 2 12 2zm3.5 10.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5s1.5.67 1.5 1.5s-.67 1.5-1.5 1.5zm-7 0c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5s1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z"/></svg>` },
    { id: 'cart', name: '購物車', screen: 'character-shopping-cart-screen', svg: `<svg viewBox="0 0 24 24" fill="#F44336"><path d="M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2s-.9-2-2-2zm10 0c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2s2-.9 2-2s-.9-2-2-2zm-15-14h3.27l.94 2H20c.69 0 1.25.56 1.25 1.25c0 .09-.02.18-.04.27l-3.58 6.49c-.25.44-.73.74-1.26.74H8.52l-.94-2H4.27V4H2V2h3.27z"/></svg>` },
    { id: 'memos', name: '備忘錄', screen: 'character-memos-screen', svg: `<svg viewBox="0 0 24 24" fill="#FFC107"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg>` },
    { id: 'browser', name: '流覽器', screen: 'character-browser-screen', svg: `<svg viewBox="0 0 24 24" fill="#2196F3"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1.5-12.5l3 7.5 7.5-3-7.5-3z"/></svg>` },
    { id: 'album', name: '相冊', screen: 'character-album-screen', svg: `<svg viewBox="0 0 24 24" fill="#8BC34A"><path d="M22 16V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2zm-11-4l2.03 2.71L16 11l4 5H8l3-4zM2 6v14c0 1.1.9 2 2 2h14v-2H4V6H2z"/></svg>` },
    { id: 'bank', name: '錢包', screen: 'character-bank-screen', svg: `<svg viewBox="0 0 24 24" fill="#E91E63"><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"/></svg>` },
    { id: 'trajectory', name: '足跡', screen: 'character-trajectory-screen', svg: `<svg viewBox="0 0 24 24" fill="#795548"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"/></svg>` },
    { id: 'app_usage', name: '使用記錄', screen: 'character-app-usage-screen', svg: `<svg viewBox="0 0 24 24" fill="#607D8B"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8s8 3.58 8 8s-3.58 8-8 8zm.5-13H11v6l5.25 3.15l.75-1.23l-4.5-2.67z"/></svg>` },
    { id: 'diary', name: '日記', screen: 'character-diary-screen', svg: `<svg viewBox="0 0 24 24" fill="#009688"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83l3.75 3.75 1.83-1.83z"/></svg>` },
    // 這就是我們新加的App
    { id: 'appearance', name: '外觀設置', screen: 'character-phone-appearance-screen', svg: `<svg viewBox="0 0 24 24" fill="#9C27B0"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1.17 14.34c-.21.21-.46.32-.71.32s-.5-.11-.71-.32l-1.41-1.41c-.2-.2-.31-.45-.31-.71 0-.26.11-.51.31-.71l1.41-1.41c.2-.2.45-.31.71-.31s.51.11.71.31l1.41 1.41c.4.4.4 1.04 0 1.41l-1.41 1.41zm3.34-5.34c-.21.21-.46.32-.71.32s-.5-.11-.71-.32L11.41 8.5c-.2-.2-.31-.45-.31-.71 0-.26.11-.51.31-.71l1.41-1.41c.2-.2.45-.31.71-.31s.51.11.71.31l1.41 1.41c.4.4.4 1.04 0 1.41l-1.41 1.41zm3.34 5.34c-.21.21-.46.32-.71.32s-.5-.11-.71-.32l-1.41-1.41c-.4-.4-.4-1.04 0-1.41l1.41-1.41c.2-.2.45-.31.71-.31s.51.11.71.31l1.41 1.41c.2.2.31.45.31.71 0 .26-.11.51-.31.71l-1.41 1.41z"/></svg>` }
];
// ▲▲▲ 代碼黏貼結束 ▲▲▲
const db = new Dexie('GeminiChatDB');
        // ▼▼▼ 把下面這一整塊全新的微博功能代碼，黏貼到這裡 ▼▼▼

/**
 * 【微博】總入口：根據當前啟動的視圖，渲染對應的微博Feed
 */
async function renderWeiboFeeds(viewId) {
    if (viewId === 'weibo-my-profile-view') {
        await renderMyWeiboFeed();
    } else if (viewId === 'weibo-following-view') {
        await renderFollowingWeiboFeed();
    }
}

// ▼▼▼ 用這【兩塊新代碼】分別替換舊的 renderMyWeiboFeed 和 renderFollowingWeiboFeed 函數 ▼▼▼

/**
 * 【微博】渲染“我的首頁”上的微博列表
 */
async function renderMyWeiboFeed() {
    const feedEl = document.getElementById('my-weibo-feed-list');
    const posts = await db.weiboPosts.where('authorId').equals('user').reverse().toArray();
    feedEl.innerHTML = '';
    if (posts.length === 0) {
        feedEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">你還沒有發過微博哦，點擊右上角“+”試試吧！</p>';
        return;
    }
    posts.forEach(post => {
        // 【核心修改】調用我們新的專屬函數！
        feedEl.appendChild(createWeiboPostElement(post));
    });
}

// ▼▼▼ 用這塊【已修復】的代碼，完整替換掉你舊的 renderFollowingWeiboFeed 函數 ▼▼▼
/**
 * 【微博】渲染“關注的人”的微博Feed (已修復卡頓問題)
 */
async function renderFollowingWeiboFeed() {
    const feedEl = document.getElementById('weibo-following-feed-list');
    
    // 【核心優化】我們不再一次性讀取所有帖子，而是直接讓資料庫幫我們篩選和排序，速度會快很多！
    const posts = await db.weiboPosts
        .where('authorId').notEqual('user') // 1. 直接在資料庫層面，找出作者不是'user'的帖子
        .reverse()                          // 2. 讓結果按倒序排列
        .sortBy('timestamp');               // 3. 根據時間戳記排序

    // 後續的渲染邏輯保持不變
    feedEl.innerHTML = '';
    if (posts.length === 0) {
        feedEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">你關注的人還沒有發佈任何動態哦。</p>';
        return;
    }
    posts.forEach(post => {
        feedEl.appendChild(createWeiboPostElement(post));
    });
}


// ▼▼▼ 請用這【一整塊】全新的代碼，完整替換掉你舊的 createWeiboPostElement 函數 ▼▼▼

function createWeiboPostElement(post) {
    const postEl = document.createElement('div');
    postEl.className = 'weibo-post-item'; 

    let contentHtml = '';
    if (post.content) {
        contentHtml += `<div class="weibo-post-content">${post.content.replace(/\n/g, '<br>')}</div>`;
    }
    
    if (post.imageUrl) {
        if (post.postType === 'text_image') {
            contentHtml += `<img src="${post.imageUrl}" class="weibo-post-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent || ''}">`;
        } else {
            contentHtml += `<img src="${post.imageUrl}" class="weibo-post-image">`;
        }
    }

    let commentsHtml = '';
    if (post.comments && Array.isArray(post.comments) && post.comments.length > 0) {
        commentsHtml += '<div class="weibo-comments-container">';
        post.comments.forEach(comment => {
            if (typeof comment !== 'object' || comment === null) return;
            let replyHtml = '';
            
            // ★ 修改1：為被回復者添加專屬的 class 和 data 屬性，方便我們精確點擊
            if (comment.replyToNickname) {
                replyHtml = `<span class="weibo-comment-reply-tag">回復</span><span class="reply-target-name" data-reply-to-name="${comment.replyToNickname}">${comment.replyToNickname}</span>`;
            }

            commentsHtml += `
                <div class="weibo-comment-item" data-comment-id="${comment.commentId}" data-commenter-name="${comment.authorNickname}">
                    <span class="weibo-commenter-name">${comment.authorNickname}</span>
                    ${replyHtml}:
                    <span class="weibo-comment-text">${comment.commentText}</span>
                    <button class="comment-delete-btn" title="刪除此條評論">×</button>
                </div>`;
        });
        commentsHtml += '</div>';
    }

    const myNickname = state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我';
    const isLiked = post.likes && post.likes.includes(myNickname);
    
    let finalAuthorAvatar, finalAuthorNickname, finalAuthorAvatarFrame;
    if (post.authorId === 'user') {
        finalAuthorAvatar = state.qzoneSettings.weiboAvatar || state.qzoneSettings.avatar || defaultAvatar;
        finalAuthorNickname = state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我';
        finalAuthorAvatarFrame = state.qzoneSettings.weiboAvatarFrame || '';
    } else if (state.chats[post.authorId]) {
        const authorChat = state.chats[post.authorId];
        finalAuthorNickname = authorChat.settings.weiboNickname || authorChat.name;
        finalAuthorAvatar = authorChat.settings.weiboAvatar || authorChat.settings.aiAvatar || defaultAvatar;
        finalAuthorAvatarFrame = authorChat.settings.weiboAvatarFrame || authorChat.settings.aiAvatarFrame || '';
    } else {
        finalAuthorAvatar = defaultAvatar;
        finalAuthorNickname = post.authorNickname || '未知用戶';
        finalAuthorAvatarFrame = '';
    }

    let avatarHtml = '';
    if (finalAuthorAvatarFrame) {
        avatarHtml = `
            <div class="avatar-with-frame">
                <img src="${finalAuthorAvatar}" class="avatar-img weibo-post-avatar">
                <img src="${finalAuthorAvatarFrame}" class="avatar-frame">
            </div>`;
    } else {
        avatarHtml = `<img src="${finalAuthorAvatar}" class="weibo-post-avatar">`;
    }
    
    const clickableAvatarWrapper = `
        <div class="weibo-post-avatar-clickable" data-char-id="${post.authorId}">
            ${avatarHtml}
        </div>
    `;

    postEl.innerHTML = `
        <div class="weibo-post-header">
            ${clickableAvatarWrapper} 
            <div class="weibo-post-info">
                <span class="weibo-post-nickname">${finalAuthorNickname}</span>
                <span class="weibo-post-timestamp">${formatPostTimestamp(post.timestamp)}</span>
            </div>
            <div class="post-actions-btn" data-post-id="${post.id}" data-author-id="${post.authorId}">…</div>
        </div>
        ${contentHtml}
        <div class="weibo-post-footer">
            <div class="weibo-post-actions">
                <span class="weibo-action-btn like-btn ${isLiked ? 'liked' : ''}">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path></svg>
                    <span>${(post.baseLikesCount || 0) + (post.likes || []).length}</span>
                </span>
                <span class="weibo-action-btn comment-btn">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>           
                    <span>${(post.comments || []).length}</span>
                </span>
                <span class="weibo-action-btn generate-comments-btn" title="AI生成評論">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path>
                    </svg>
                    <span>生成評論</span>
                </span>
            </div>
            ${commentsHtml}
            <div class="weibo-comment-input-area">
                <input type="text" class="weibo-comment-input" placeholder="留下你的精彩評論吧...">
                <button class="weibo-comment-send-btn">發送</button>
            </div>
        </div>
    `;

    // 綁定發送評論按鈕
    const sendBtn = postEl.querySelector('.weibo-comment-send-btn');
    if (sendBtn) {
        sendBtn.addEventListener('click', () => {
            const input = postEl.querySelector('.weibo-comment-input');
            handleWeiboComment(post.id, input);
        });
    }

    // 綁定AI生成評論按鈕
    const generateBtn = postEl.querySelector('.generate-comments-btn');
    if (generateBtn) {
        generateBtn.addEventListener('click', () => generateWeiboComments(post.id));
    }
    
    // 綁定點贊按鈕
    const likeBtn = postEl.querySelector('.like-btn');
    if (likeBtn) {
        likeBtn.addEventListener('click', () => handleWeiboLike(post.id));
    }

    // ★ 修改2：為評論區綁定一個全新的、功能更強大的點擊事件監聽器
    const commentSection = postEl.querySelector('.weibo-comments-container');
    if (commentSection) {
        commentSection.addEventListener('click', (e) => {
            // 阻止事件冒泡，這是解決點擊無效的核心！
            e.stopPropagation();

            const target = e.target;
            const commentItem = target.closest('.weibo-comment-item');
            if (!commentItem) return; // 如果點擊的不是評論區，就什麼也不做
            
            const input = postEl.querySelector('.weibo-comment-input');

            // 檢查點擊的是否是刪除按鈕
            if (target.closest('.comment-delete-btn')) {
                deleteWeiboComment(post.id, commentItem.dataset.commentId);
                return; // 刪除後結束
            }
            
            let replyToName = '';
            const replyToId = commentItem.dataset.commentId;

            // ★ 修改3：新增邏輯，判斷你點擊的是誰
            if (target.classList.contains('reply-target-name')) {
                // 如果點擊了“被回復者”的名字
                replyToName = target.dataset.replyToName;
            } else {
                // 否則，默認回復這條評論的作者
                replyToName = commentItem.dataset.commenterName;
            }

            // ★ 修改4：優化回復邏輯
            // 如果正在回復同一個人，則取消回復
            if (input.dataset.replyToId === replyToId && input.placeholder.includes(`@${replyToName}`)) {
                input.placeholder = '留下你的精彩評論吧...';
                delete input.dataset.replyToId;
                delete input.dataset.replyToNickname;
            } else {
                // 否則，設置為新的回復目標
                input.placeholder = `回復 @${replyToName}:`;
                input.dataset.replyToId = replyToId;
                input.dataset.replyToNickname = replyToName;
                input.focus();
            }
        });
    }

    return postEl;
}
// ▲▲▲ 替換結束 ▲▲▲





/**
 * 【微博】打開微博發佈/編輯模態框
 */
async function openWeiboPublisher() {
    const modal = document.getElementById('create-post-modal');
    
    modal.dataset.mode = 'weibo'; // 關鍵！標記為微博模式
    
    document.getElementById('create-post-modal-title').textContent = '發微博';
    document.getElementById('post-public-text').placeholder = '有什麼新鮮事想分享給大家？';
    
    // 隱藏動態專屬的控制項
    document.getElementById('post-image-desc-group').style.display = 'none';
    document.getElementById('post-comments-toggle-group').style.display = 'none';
    
    document.getElementById('post-mode-switcher').style.display = 'flex'; // 微博也需要模式切換
    
    resetCreatePostModal();
    modal.classList.add('visible');
}
/**
 * 【全新】智慧解析帶“萬”或“億”的數位字串
 * @param {string} str - 包含數位的字串，例如 "30000", "3萬", "1.5萬"
 * @returns {number} - 解析後的純數字
 */
function parseChineseNumber(str) {
    if (!str) return 0; // 安全檢查

    str = String(str).trim().toLowerCase(); // 轉換為小寫字串並去除空格

    let num = parseFloat(str); // 先嘗試直接解析數位部分

    if (str.includes('萬') || str.includes('w')) {
        // 如果包含“萬”或“w”，則將數位部分乘以10000
        num = parseFloat(str) * 10000;
    } else if (str.includes('億')) {
        // 如果包含“億”，則乘以100000000
        num = parseFloat(str) * 100000000;
    }

    // 如果解析失敗 (比如輸入了純文字)，返回0
    return isNaN(num) ? 0 : Math.floor(num); // 返回整數，確保結果乾淨
}

// ▼▼▼ 請用這【一整塊功能增強版】的代碼，完整替換掉你舊的 handlePublishWeibo 函數 ▼▼▼
/**
 * 【微博 V3 - 粉絲數計算版】處理發佈微博的核心函數
 */
async function handlePublishWeibo() {
    const modal = document.getElementById('create-post-modal');
    
// ▼▼▼ 從這裡開始，是你要黏貼的新代碼 ▼▼▼
const mainContent = document.getElementById('post-public-text').value.trim();
let imageUrl = '', hiddenContent = '', postType = 'text_only', imageDescription = '';

const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');

if (isImageModeActive) {
    // 【核心修復】我們現在通過檢查預覽容器是否可見，來判斷用戶是否真的上傳了圖片
    const hasImage = document.getElementById('post-image-preview-container').classList.contains('visible');
    
    if (hasImage) {
        imageUrl = document.getElementById('post-image-preview').src;
        postType = 'image';
        imageDescription = document.getElementById('post-image-description').value.trim();
        // 圖片描述的檢查邏輯保持不變
        if (!imageDescription) {
            alert("為了讓AI能看懂圖片，請務必填寫圖片描述哦！");
            return;
        }
    }
    // 如果 hasImage 是 false (即使用者只想發純文字)，這段代碼就會被跳過，imageUrl 保持為空，postType 保持為 text_only
    
} else { // 文字圖模式的邏輯保持不變
    hiddenContent = document.getElementById('post-hidden-text').value.trim();
    if (hiddenContent) {
        imageUrl = 'https://i.postimg.cc/KYr2qRCK/1.jpg'; 
        postType = 'text_image';
    }
}
// ▲▲▲ 到這裡為止，是你要黏貼的新代碼 ▲▲▲

    if (!mainContent && !imageUrl) {
        alert('微博內容不能為空哦！');
        return;
    }

    const fansCount = parseChineseNumber(state.qzoneSettings.weiboFansCount) || 0;
    const baseLikes = Math.floor(fansCount * (Math.random() * 0.1 + 0.1));
    const baseComments = Math.floor(baseLikes * (Math.random() * 0.1 + 0.05));

    const newPost = {
        authorId: 'user',
        authorType: 'user',
        authorNickname: state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我',
        authorAvatar: state.qzoneSettings.weiboAvatar || state.qzoneSettings.avatar || defaultAvatar,
        content: mainContent,
        imageUrl: imageUrl,
        // ▼▼▼ 在這裡添加下面這行新代碼 ▼▼▼
        authorAvatarFrame: state.qzoneSettings.weiboAvatarFrame || '',
        // ▲▲▲ 添加結束 ▲▲▲
        // ▼▼▼ 這是新增的核心代碼 ▼▼▼
        imageDescription: imageDescription, // 3. 把獲取到的描述保存到新欄位裡！
        // ▲▲▲ 新增結束 ▲▲▲

        hiddenContent: hiddenContent,
        postType: postType,
        timestamp: Date.now(),
        likes: [],
        comments: [],
        baseLikesCount: baseLikes,
        baseCommentsCount: baseComments
    };

    await db.weiboPosts.add(newPost);
    await renderMyWeiboFeed(); 
    await renderWeiboProfile();
    
    modal.classList.remove('visible');
    alert('微博發佈成功！');
}
// ▲▲▲ 替換結束 ▲▲▲


/**
 * 【微博】處理點贊/取消點贊
 * @param {number} postId - 帖子ID
 */
async function handleWeiboLike(postId) {
    const post = await db.weiboPosts.get(postId);
    if (!post) return;

    const myNickname = state.qzoneSettings.nickname || '我';
    if (!post.likes) post.likes = [];
    
    const likeIndex = post.likes.indexOf(myNickname);
    if (likeIndex > -1) {
        post.likes.splice(likeIndex, 1); // 取消點贊
    } else {
        post.likes.push(myNickname); // 點贊
    }

    await db.weiboPosts.put(post);
    // 重新渲染兩個Feed，確保資料同步
    await renderMyWeiboFeed();
    await renderFollowingWeiboFeed();
}

/**
 * 【微博】處理發佈評論或回復
 * @param {number} postId - 帖子ID
 * @param {HTMLInputElement} inputElement - 評論輸入框元素
 */
async function handleWeiboComment(postId, inputElement) {
    const commentText = inputElement.value.trim();
    if (!commentText) {
        alert("評論內容不能為空！");
        return;
    }

    const post = await db.weiboPosts.get(postId);
    if (!post) return;

    if (!post.comments) post.comments = [];

    const newComment = {
        commentId: 'comment_' + Date.now(),
        authorId: 'user',
        authorNickname: state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我',
        commentText: commentText,
        timestamp: Date.now()
    };
    
    // 檢查是否是回復
    if (inputElement.dataset.replyToId) {
        newComment.replyToId = inputElement.dataset.replyToId;
        newComment.replyToNickname = inputElement.dataset.replyToNickname;
    }

    post.comments.push(newComment);
    await db.weiboPosts.put(post);
    
    // 清空輸入框並重置狀態
    inputElement.value = '';
    inputElement.placeholder = '留下你的精彩評論吧...';
    delete inputElement.dataset.replyToId;
    delete inputElement.dataset.replyToNickname;
    
    // 重新渲染兩個Feed
    await renderMyWeiboFeed();
    await renderFollowingWeiboFeed();
}


// ▲▲▲ 全新的微博功能代碼黏貼結束 ▲▲▲
// ▼▼▼ 在這裡添加您的 API 網站黑名單 ▼▼▼
const BLOCKED_API_SITES = [
    'api.pisces.ink',
    'aiapi.qzz.io'
];
// ▲▲▲ 黑名單定義結束 ▲▲▲
        // --- 已修正 ---
        let state = { chats: {}, activeChatId: null, globalSettings: {}, apiConfig: {}, userStickers: [], worldBooks: [], personaPresets: [], qzoneSettings: {}, activeAlbumId: null };
        // --- 修正結束 ---
let currentViewingDmsFor = null; // 用於追蹤正在查看哪個角色的私信
        let isLocked = false; // <-- 在這裡添加這行新代碼
        let newLockscreenWallpaperBase64 = null; // <-- 在這裡添加這行新代碼
let newGlobalBgBase64 = null; // 用於暫存新的全域聊天背景
let newAppWallpaperBase64 = null;
let musicState = { 
    isActive: false, 
    activeChatId: null, 
    isPlaying: false, 
    playlist: [], 
    currentIndex: -1, 
    playMode: 'order', 
    totalElapsedTime: 0, 
    timerId: null,
    // 【新增】歌詞相關狀態
    parsedLyrics: [],      // 當前歌曲解析後的歌詞陣列
    currentLyricIndex: -1  // 當前高亮的歌詞行索引
};
// ▼▼▼ 【全新】這是情侶空間專屬音樂播放機的狀態管理器 ▼▼▼
let lsMusicState = {
    playlist: [],      // 播放清單
    currentIndex: -1,  // 當前播放歌曲的索引
    isPlaying: false   // 是否正在播放
};
// ▲▲▲ 新增狀態管理器結束 ▲▲▲
let lyricsBarSettings = {
    fontSize: 14,
    bgOpacity: 0,
    fontColor: '#FFFFFF',
    showOnClose: true // 【問題4需要】預設開啟
};

        const audioPlayer = document.getElementById('audio-player');
        let newWallpaperBase64 = null;
        let isSelectionMode = false;
        let isInnerVoiceHistoryOpen = false; // 用於跟蹤歷史面板是否打開
        let pomodoroState = {
    isActive: false,            // 專注是否正在進行
    timerId: null,              // 倒計時計時器
    periodicTalkTimerId: null,  // 角色定時說話的計時器
    currentSession: null        // 當前專注會話的資料
};
        let selectedMessages = new Set();
        let editingMemberId = null;
        let editingWorldBookId = null;
        let editingPersonaPresetId = null;
let activeCharPhonePresetId = null; // 用於追蹤角色手機外觀預設的選擇
let activeCharacterPhoneId = null;
let activeLoversSpaceCharId = null; // 用於追蹤當前情侶空間的角色ID
let waimaiTimers = {}; // 用於存儲外賣倒計時

let activeMessageTimestamp = null;
// ▼▼▼ 【全新】這是狼人殺遊戲的狀態管理器 ▼▼▼
let werewolfGameState = {
    isActive: false,      // 遊戲是否正在進行
    players: [],          // 玩家列表 { id, name, avatar, role, isAlive, persona }
    roles: {},            // 角色配置 { wolf: 2, villager: 2, ... }
    gamePhase: 'setup',   // 遊戲階段: setup, night, day_discussion, day_vote, etc.
    dayNumber: 0,         // 天數
    gameLog: [],          // 遊戲日誌
    turnIndex: 0,         // 當前發言/行動的玩家索引
    votes: {},            // 投票記錄
    seerLastNightResult: null, // 預言家昨晚查驗結果
    witchPotions: { save: 1, poison: 1 }, // 女巫藥劑
    hunterTarget: null,   // 獵人目標
    lastNightKilled: [],  // 昨晚被殺的玩家ID
    waitingFor: null,     // 當前等待誰的行動: 'seer', 'witch_save', 'witch_poison', 'hunter', 'user_vote'
    gameConfig: {}        // 遊戲配置
};
// ▲▲▲ 新增變數結束 ▲▲▲
// ▼▼▼ 【全新】這是海龜湯遊戲的狀態管理器 ▼▼▼
let seaTurtleSoupState = {
    isActive: false,      // 遊戲是否正在進行
    phase: 'setup',       // 遊戲階段: setup, guessing, reveal
    players: [],          // 玩家列表 { id, name, avatar, persona, isUser, isProvider }
    riddleProvider: null, // 出題人對象
    riddle: '',           // 謎面
    answer: '',           // 謎底
    gameLog: [],          // 遊戲日誌
    currentTurnIndex: 0   // 當前輪到誰行動的索引
};
// ▲▲▲ 新增變數結束 ▲▲▲
// ▼▼▼ 【全新】這是劇本殺遊戲的狀態管理器 ▼▼▼
let scriptKillGameState = {
    isActive: false,      // 遊戲是否正在進行
    script: null,         // 當前載入的劇本物件
    players: [],          // 玩家列表 { id, name, avatar, role, isUser, evidence, persona }
    gamePhase: 'setup',   // 遊戲階段: setup, introduction, evidence, discussion, voting, end
    turnIndex: 0,         // 當前行動的玩家索引
    gameLog: [],          // 遊戲日誌
    evidenceCounts: {},   // 記錄每個玩家已搜證次數
    votes: {},            // 投票記錄
    is自由選擇: false      // 是否為自由選擇角色模式
};
// ▲▲▲ 新增變數結束 ▲▲▲
// ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼
let guessWhatGameState = {
    isActive: false,      // 遊戲是否正在進行
    mode: 'ai_guesses',   // 遊戲模式: 'ai_guesses' 或 'user_guesses'
    opponent: null,       // 對手玩家對象 { id, name, avatar, persona }
    secretWord: '',       // 謎底詞語
    gameLog: [],          // 遊戲日誌
    currentTurn: 'user'   // 當前輪到誰: 'user' 或 'ai'
};
// ▲▲▲ 新代碼黏貼結束 ▲▲▲
// ▼▼▼ 在這裡黏貼下面這一整塊新代碼 ▼▼▼

let ludoGameState = {
    isActive: false,
    opponent: null,
    players: [], // { id, name, avatar, piecePosition: -1 (at home), isUser }
    currentTurnIndex: 0,
    gameLog: [],
    boardLayout: [],
    isDiceRolling: false
};

const LUDO_BOARD_SIZE = 42; // 總格子數，可以根據你的棋盤佈局調整

let tempGeneratedScriptData = null;
let currentReplyContext = null; // <--- 新增這行，用來存儲當前正在引用的消息資訊
let currentSearchKeyword = ''; // 用於在搜索結果中高亮關鍵字
let activePostId = null; // <-- 新增：用於存儲當前操作的動態ID
// ▼▼▼ 【全新】BGM 搜索功能核心代碼 ▼▼▼

// 一個簡單的網路請求函數
if (typeof Http_Get_External === 'undefined') {
    window.Http_Get_External = function(url) {
        return new Promise((resolve) => {
            fetch(url).then(res => res.json().catch(() => res.text())).then(resolve).catch(() => resolve(null));
        });
    }
}
async function Http_Get(url) { return await Http_Get_External(url); }

// 檢查音訊連結是否真的可以播放
function checkAudioAvailability(url) {
    return new Promise(resolve => {
        const tester = new Audio();
        tester.addEventListener('loadedmetadata', () => resolve(true), { once: true });
        tester.addEventListener('error', () => resolve(false), { once: true });
        tester.src = url;
    });
}

// ▼▼▼ 【V9.0 | 終極純淨版 - 移除代理】請用這塊代碼，完整替換舊的 searchNeteaseMusic 函數 ▼▼▼
/**
 * 移除所有代理，直接請求你找到的 vkeys.cn API
 */
async function searchNeteaseMusic(name, singer) {
    try {
        let searchTerm = name.replace(/\s/g, "");
        if (singer) { searchTerm += ` ${singer.replace(/\s/g, "")}`; }

        // 【核心修改】我們不再需要任何代理，直接把目標API作為最終請求位址！
        const apiUrl = `https://api.vkeys.cn/v2/music/netease?word=${encodeURIComponent(searchTerm)}`;
        
        console.log("正在嘗試直接請求:", apiUrl); // 添加一條日誌，方便我們調試
        
        const response = await fetch(apiUrl);

        if (!response.ok) {
            throw new Error(`API request failed with status ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();

        if (result.code !== 200 || !result.data || result.data.length === 0) {
            console.log("vkeys API返回無結果:", result);
            return [];
        }
        
        return result.data.map(song => ({
            name: song.song,
            artist: song.singer,
            id: song.id,
            cover: song.cover || 'https://i.postimg.cc/pT2xKzP-album-cover-placeholder.png',
            source: 'netease'
        })).slice(0, 15);

    } catch (e) {
        // 如果這次還失敗，請把流覽器F12控制台裡的紅色錯誤資訊完整地截圖給我
        console.error("【vkeys API 直連】搜索失敗:", e);
        await showCustomAlert("網易雲介面直連失敗", `如果流覽器控制台(F12)提示CORS錯誤，說明此API禁止直接訪問。錯誤: ${e.message}`);
        return [];
    }
}
// ▲▲▲ 替換結束 ▲▲▲


/**
 * 從QQ音樂搜索歌曲清單
 */
async function searchTencentMusic(name) {
    try {
        name = name.replace(/\s/g, "");
        const result = await Http_Get(`https://api.vkeys.cn/v2/music/tencent?word=${encodeURIComponent(name)}`);
        if (!result?.data?.length) return [];
        return result.data.map(song => ({
            name: song.song,
            artist: song.singer,
            id: song.id,
            cover: song.cover || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png',
            source: 'tencent' // 標記來源
        })).slice(0, 5); // 只取前5條結果
    } catch (e) {
        console.error("QQ音樂搜索API失敗:", e);
        return [];
    }
}
// ▼▼▼ 【V2.0 | 支持源選擇】請用這個全新的函數，完整替換舊的 addSongFromSearch ▼▼▼
/**
 * 【總入口 V2.0】當用戶點擊“搜索”按鈕時觸發
 */
async function addSongFromSearch() {
    // 步驟 1: 首先彈出選擇框，讓用戶選擇搜索源
    const source = await showSearchSourceSelector();
    // 如果用戶點了取消，source會是null，我們直接退出函數
    if (!source) return;

    // 步驟 2: 彈出輸入框讓使用者輸入關鍵字 (這部分邏輯不變)
    const searchTerm = await showCustomPrompt("搜索歌曲", "請輸入 歌名 或 歌名-歌手");
    if (!searchTerm || !searchTerm.trim()) return;

    await showCustomAlert("請稍候...", "正在搜索歌曲資源...");

    let musicName = searchTerm.trim();
    let singerName = "";
    if (searchTerm.includes('-') || searchTerm.includes('–')) {
        const parts = searchTerm.split(/[-–]/);
        musicName = parts[0].trim();
        singerName = parts.slice(1).join(' ').trim();
    }

    // 步驟 3: 【核心修改】根據使用者的選擇，執行不同的搜索
    let combinedResults = [];

    if (source === 'all') {
        // 如果選擇“全部”，則並行搜索兩個平臺
        const [neteaseResults, tencentResults] = await Promise.all([
            searchNeteaseMusic(musicName, singerName),
            searchTencentMusic(musicName)
        ]);
        combinedResults = [...neteaseResults, ...tencentResults];
    } else if (source === 'netease') {
        // 如果只選“網易雲”，就只調用網易雲的搜索
        combinedResults = await searchNeteaseMusic(musicName, singerName);
    } else if (source === 'tencent') {
        // 如果只選“QQ音樂”，就只調用QQ音樂的搜索
        combinedResults = await searchTencentMusic(musicName);
    }

    // 步驟 4: 後續的顯示邏輯保持不變
    if (combinedResults.length === 0) {
        await showCustomAlert("無結果", "抱歉，在所選來源中未能找到相關歌曲。");
        return;
    }

    const modal = document.getElementById('music-search-results-modal');
    const listEl = document.getElementById('search-results-list');
    listEl.innerHTML = '';

    combinedResults.forEach(song => {
        const item = document.createElement('div');
        item.className = 'search-result-item';
        item.dataset.songJson = JSON.stringify(song);
        item.innerHTML = `
            <div class="title">${song.name}</div>
            <div class="artist">${song.artist} <span class="source">${song.source === 'netease' ? '網易雲' : 'QQ音樂'}</span></div>
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 【核心升級】處理用戶點擊搜索結果，增加備用音源查找和是否永久保存的邏輯
 */
async function handleSearchResultClick(songData) {
    const modal = document.getElementById('music-search-results-modal');
    modal.classList.remove('visible');

    await showCustomAlert("請稍候...", `正在獲取《${songData.name}》的播放連結...`);

    let playableResult = null;
    let finalSource = songData.source;

    // 1. 嘗試主音源
    const primaryApiUrl = songData.source === 'netease' 
        ? `https://api.vkeys.cn/v2/music/netease?id=${songData.id}`
        : `https://api.vkeys.cn/v2/music/tencent?id=${songData.id}`;
    let primaryResult = await Http_Get(primaryApiUrl);
    if (primaryResult?.data?.url && await checkAudioAvailability(primaryResult.data.url)) {
        playableResult = { url: primaryResult.data.url, id: songData.id, source: songData.source };
    }

    // 2. 如果主音源失敗，嘗試備用音源
    if (!playableResult) {
        await showCustomAlert("請稍候...", "主音源獲取失敗，正在嘗試備用音源...");
        const fallbackSource = songData.source === 'netease' ? 'tencent' : 'netease';
        const fallbackResults = fallbackSource === 'tencent' 
            ? await searchTencentMusic(songData.name)
            : await searchNeteaseMusic(songData.name, songData.artist);

        if (fallbackResults.length > 0) {
            const fallbackApiUrl = fallbackSource === 'netease'
                ? `https://api.vkeys.cn/v2/music/netease?id=${fallbackResults[0].id}`
                : `https://api.vkeys.cn/v2/music/tencent?id=${fallbackResults[0].id}`;
            const fallbackResult = await Http_Get(fallbackApiUrl);
            if (fallbackResult?.data?.url && await checkAudioAvailability(fallbackResult.data.url)) {
                playableResult = { url: fallbackResult.data.url, id: fallbackResults[0].id, source: fallbackSource };
                finalSource = fallbackSource;
            }
        }
    }

    if (!playableResult) {
        await showCustomAlert("獲取失敗", "無法獲取該歌曲的有效播放連結，主音源和備用音源均已嘗試。");
        return;
    }
    
// ▼▼▼ 從這裡開始黏貼新代碼 ▼▼▼
const confirmed = await showCustomConfirm(
    '溫馨提示', // 這是彈窗的標題
    '搜索的歌曲24h後會過期，重要的歌曲記得用url或者本地上傳哦🐇', // 這是你指定的提示內容
    { confirmText: '確定' } // 按鈕會顯示“確定”和“取消”，這裡的“取消”就等同於“返回”
);

// 如果用戶點擊了“取消”（返回），就直接結束，不添加歌曲
if (!confirmed) {
    return;
}
// ▲▲▲ 黏貼結束 ▲▲▲   
    // 獲取歌詞
    const lrcContent = await getLyricsForSong(playableResult.id, finalSource) || "";

// ▼▼▼ 用這塊新代碼替換 ▼▼▼
const newSong = {
    name: songData.name,
    artist: songData.artist,
    src: playableResult.url,
    cover: songData.cover,
    isLocal: false,
    lrcContent: lrcContent,
    isTemporary: true,
    // 核心新增：記錄這首歌被添加的精確時間
    addedTimestamp: Date.now() 
};
// ▲▲▲ 替換結束 ▲▲▲



musicState.playlist.push(newSong);

// 注意：我們已經刪除了 saveGlobalPlaylist() 的調用，因為臨時歌曲不需要被永久保存
// ▲▲▲ 替換結束 ▲▲▲

    
    updatePlaylistUI();

    if (musicState.currentIndex === -1) {
        musicState.currentIndex = musicState.playlist.length - 1;
        updatePlayerUI();
    }

    await showCustomAlert("添加成功", `《${songData.name}》已成功添加到播放清單！`);
    // ▼▼▼ 把這一整塊全新的代碼，黏貼到指定位置 ▼▼▼
try {
    // 1. 檢查一下當前是不是正在和別人聊天
    if (state.activeChatId) {
        const chat = state.chats[state.activeChatId];
        if (chat) {
            // 2. 創建一條對用戶隱藏，但對AI可見的系統消息
            const hiddenMessage = {
                role: 'system', // 告訴AI這是系統資訊
                content: `[系統提示：用戶剛剛通過搜索，將歌曲《${songData.name}》 - ${songData.artist} 添加到了“一起聽”的播放清單中。你可以根據這個情景，自然地開啟關於這首歌的話題。]`,
                timestamp: Date.now(),
                isHidden: true // 這個是關鍵！讓這條消息在聊天介面上“隱形”
            };
            
            // 3. 把這條“隱形”消息加到聊天記錄的末尾
            chat.history.push(hiddenMessage);
            
            // 4. 保存更新後的聊天記錄到資料庫
            await db.chats.put(chat);

            console.log(`已為歌曲《${songData.name}》成功注入AI上下文提示。`);
        }
    }
} catch (error) {
    console.error("注入歌曲上下文時出錯:", error);
}
// ▲▲▲ 黏貼結束 ▲▲▲
}

/**
 * 【輔助】獲取網路歌曲的歌詞
 */
async function getLyricsForSong(songId, source) {
    const url = source === 'netease'
        ? `https://api.vkeys.cn/v2/music/netease/lyric?id=${songId}`
        : `https://api.vkeys.cn/v2/music/tencent/lyric?id=${songId}`;
    
    const response = await Http_Get(url);
    if (response?.data) {
        const lrc = response.data.lrc || response.data.lyric || "";
        const tlyric = response.data.trans || response.data.tlyric || "";
        return lrc + "\\n" + tlyric;
    }
    return "";
}
// ▼▼▼ 【全新】這個函數用來顯示“選擇搜索源”的彈窗 ▼▼▼
/**
 * 顯示搜索源選擇彈窗，並返回用戶的選擇
 * @returns {Promise<string|null>} 返回 'all', 'netease', 'tencent', 或 null
 */
function showSearchSourceSelector() {
    return new Promise(resolve => {
        const modal = document.getElementById('music-source-selector-modal');
        const confirmBtn = document.getElementById('confirm-source-select-btn');
        const cancelBtn = document.getElementById('cancel-source-select-btn');

        // 顯示彈窗
        modal.classList.add('visible');

        // 定義確認按鈕的點擊事件
        const onConfirm = () => {
            const selectedSource = document.querySelector('input[name="search-source"]:checked').value;
            cleanup();
            resolve(selectedSource); // 返回用戶的選擇
        };

        // 定義取消按鈕的點擊事件
        const onCancel = () => {
            cleanup();
            resolve(null); // 用戶取消，返回 null
        };

        // 清理函數，用於移除事件監聽並隱藏彈窗
        const cleanup = () => {
            modal.classList.remove('visible');
            confirmBtn.removeEventListener('click', onConfirm);
            cancelBtn.removeEventListener('click', onCancel);
        };

        // 綁定事件
        confirmBtn.addEventListener('click', onConfirm);
        cancelBtn.addEventListener('click', onCancel);
    });
}
// ▲▲▲ 新增函數結束 ▲▲▲
// ▼▼▼ 把這一整塊全新的代碼，黏貼到 getLyricsForSong 函數的後面 ▼▼▼

/**
 * 【全新】根據歌名和歌手自動搜索並播放歌曲
 * @param {string} name - 歌曲名
 * @param {string} artist - 歌手名
 */
async function searchAndPlaySong(name, artist) {
    // 彈出提示，告訴用戶我們正在做什麼
    await showCustomAlert("請稍候...", `AI為你分享了《${name}》，正在努力尋找播放資源...`);

    let songData = null;

    // 策略1：優先用網易雲搜索 (通常結果更准)
    const neteaseResults = await searchNeteaseMusic(name, artist);
    if (neteaseResults.length > 0) {
        songData = neteaseResults[0]; // 如果找到了，就用第一個結果
    } 
    // 策略2：如果網易雲找不到，再用QQ音樂搜一次
    else {
        const tencentResults = await searchTencentMusic(name);
        if (tencentResults.length > 0) {
            songData = tencentResults[0]; // 用QQ音樂的第一個結果
        }
    }

    // 如果兩個平臺都沒找到，就告訴用戶並退出
    if (!songData) {
        await showCustomAlert("找不到歌曲", `抱歉，在網易雲和QQ音樂都沒能找到《${name}》的可播放資源。`);
        return;
    }

    // 到這裡，我們已經有了一首歌的基本資訊 (id, source, name, artist)
    // 下面的邏輯就是調用API獲取真實的播放連結
    
    const apiUrl = songData.source === 'netease' 
        ? `https://api.vkeys.cn/v2/music/netease?id=${songData.id}`
        : `https://api.vkeys.cn/v2/music/tencent?id=${songData.id}`;
    
    const result = await Http_Get(apiUrl);

    // 檢查獲取到的連結是否真的能播放
    if (!result?.data?.url || !(await checkAudioAvailability(result.data.url))) {
        await showCustomAlert("獲取失敗", `找到了《${name}》，但無法獲取有效的播放連結。`);
        return;
    }

    // 獲取歌詞
    const lrcContent = await getLyricsForSong(songData.id, songData.source) || "";

    // 準備新的歌曲物件，準備添加到播放清單
    const newSong = {
        name: songData.name,
        artist: songData.artist,
        src: result.data.url, // 使用我們剛剛獲取到的真實、可播放的URL！
        cover: songData.cover,
        isLocal: false,
        lrcContent: lrcContent,
        isTemporary: true, // 標記為臨時歌曲，24小時後可能會失效
        addedTimestamp: Date.now()
    };

    // 檢查播放清單裡是不是已經有這首歌了
    const existingIndex = musicState.playlist.findIndex(t => t.name === newSong.name && t.artist === newSong.artist);
    if (existingIndex !== -1) {
        // 如果有，直接播放它
        playSong(existingIndex);
    } else {
        // 如果沒有，就添加到列表末尾再播放
        musicState.playlist.push(newSong);
        updatePlaylistUI(); // 刷新播放清單介面
        playSong(musicState.playlist.length - 1);
    }
    
    // 如果“一起聽”功能是關閉的，就自動打開它
    if (!musicState.isActive) {
         startListenTogetherSession(state.activeChatId);
    } else {
        // 如果已經是打開的，就直接顯示播放機視窗
        document.getElementById('music-player-overlay').classList.add('visible');
    }
}

// ▲▲▲ 新函數黏貼結束 ▲▲▲

// ▲▲▲ 新增函數黏貼結束 ▲▲▲
let activeForumFilters = { 
    global: [], // 用於主頁小組列表的篩選
    group: {}   // 用於存儲每個小組內部帖子的篩選, e.g., { 1: ['科幻'], 2: ['劇情'] }
};
let currentFilterContext = { type: 'global', id: null }; // 記錄當前打開篩選的是哪個頁面

        let photoViewerState = {
            isOpen: false,
            photos: [], // 存儲當前相冊的所有照片URL
            currentIndex: -1, // 當前正在查看的照片索引
        };

        let unreadPostsCount = 0;

        let isFavoritesSelectionMode = false;
        let selectedFavorites = new Set()

let simulationIntervalId = null;

let currentFrameSelection = { type: null, url: '', target: null }; 

        const defaultAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg';
        const defaultMyGroupAvatar = 'https://i.postimg.cc/cLPP10Vm/4.jpg';
        const defaultGroupMemberAvatar = 'https://i.postimg.cc/VkQfgzGJ/1.jpg';
        const defaultGroupAvatar = 'https://i.postimg.cc/gc3QYCDy/1-NINE7-Five.jpg';
        let notificationTimeout;

const THEME_CSS_TEMPLATE = `
/* 
  EPhone 美化代碼範本
  使用方法: 
  1. 修改下面的顏色代碼或圖片URL。
  2. 不需要修改的部分可以刪除或保持不變。
  3. 顏色代碼格式為 #RRGGBB (例如 #FFFFFF 是白色)。
  4. 圖片URL需要是網路直鏈。
*/

/* === 1. 手機殼與劉海顏色 === */
#phone-frame {
  background-color: #f0f0f0; /* 手機殼顏色 */
}
.notch {
  background-color: #1a1a1a; /* 頂部“劉海”顏色 */
}
        #clock-container {  color: white;  }


/* === 1.5. 全域主題色 (重要！) === */
/* 這個顏色決定了大部分按鈕、連結和高亮文本的顏色。*/
:root {
  --accent-color: #007bff; /* 默認是藍色 */
}

/* === 2. 聊天介面頂部和底部的圖片按鈕替換 === */
/* “一起聽”按鈕 (正常狀態) */
#listen-together-btn img[src*="8kYShvrJ/90-UI-2.png"] {
  content: url('在這裡黏貼你的“正常狀態”圖片URL');
}
/* “一起聽”按鈕 (播放中狀態) */
#listen-together-btn img[src*="D0pq6qS2/E30078-DC-8-B99-4-C01-AFDA-74728-DBF7-BEA.png"] {
  content: url('在這裡黏貼你的“播放中”圖片URL');
}
/* “聊天設置”按鈕 */
#chat-settings-btn img {
  content: url('https://i.postimg.cc/bvPq64cv/CCA834-BA-5-A90-408-D-94-FA-7-EE156-B6-A765.png');
}
/* “觸發API回復”按鈕 */
#wait-reply-btn img {
  content: url('https://i.postimg.cc/q72zq80N/ECE92-BBC-BE57-48-E9-BB2-C-345-B6019-C4-B2.png');
}
/* “發送”按鈕 (設為圖片形式) */
#send-btn {
  background-image: url('在這裡黏貼你的發送按鈕圖片URL');
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  width: 50px; /* 根據你的圖片調整寬度 */
}

/* “重新生成回復”按鈕 */
#reroll-btn {
    background-color: rgba(255, 255, 255, 0.6);
    color: var(--text-primary); /* 使用全域主題的主文本顏色 */
}

/* === 3. 頂部欄與底部欄顏色 === */
.header, .qzone-header {
  background-color: rgba(240, 240, 240, 0.8); /* 頂部欄背景色 (帶一點透明) */
  color: #333333; /* 頂部欄文字顏色 */
}
#chat-list-bottom-nav {
  background-color: rgba(245, 245, 245, 0.85); /* 底部巡覽列背景色 */
}
.nav-item {
  color: #8a8a8a; /* 底部巡覽列未選中項的顏色 */
}
.nav-item.active {
  color: #007bff; /* 底部巡覽列選中項的顏色 */
}

/* === 4. 各介面背景色 === */
#chat-list-screen, #qzone-screen .qzone-content, #memories-view {
  background-color: #f0f2f5 !important; /* 列表頁主背景色 */
}

/* === 5. 聊天輸入區底部功能欄SVG圖示替換 === */
/* 提示: 你需要將你的SVG代碼轉換為URL編碼格式。
   可以使用線上工具搜索 "SVG to Data URI" 來完成轉換。
   然後替換掉下面的 url('...') 部分。 */

.chat-action-icon-btn {
  background-color: rgba(255, 255, 255, 0.5); /* 圖示按鈕的背景色 */
  border: 1px solid rgba(0,0,0,0.05); /* 圖示按鈕的邊框 */
}

/* 表情面板(+)按鈕 */
#open-sticker-panel-btn svg { display: none; /* 隱藏原始SVG */ }
#open-sticker-panel-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 發送照片(舊)按鈕 */
#send-photo-btn svg { display: none; /* 隱藏原始SVG */ }
#send-photo-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"/><circle cx="12" cy="13" r="4"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 上傳圖片(新)按鈕 */
#upload-image-btn svg { display: none; }
#upload-image-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="color: black;"><path d="M21 3.5H3C2.44772 3.5 2 3.94772 2 4.5V19.5C2 20.0523 2.44772 20.5 3 20.5H21C21.5523 20.5 22 20.0523 22 19.5V4.5C22 3.94772 21.5523 3.5 21 3.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M16.5 13.5C17.6046 13.5 18.5 12.6046 18.5 11.5C18.5 10.3954 17.6046 9.5 16.5 9.5C15.3954 9.5 14.5 10.3954 14.5 11.5C14.5 12.6046 15.3954 13.5 16.5 13.5Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M22 14.5L18 10.5L10.3333 18.5M12.5 16L9 12.5L2 19.5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 轉帳(￥)按鈕 */
#transfer-btn svg { display: none; }
#transfer-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M7 4L12 12L17 4M12 12V20M8 10H16M8 13H16"></path></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 語音按鈕 */
#voice-message-btn svg { display: none; }
#voice-message-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><path d="M12 19v4"/><path d="M8 23h8"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 外賣按鈕 */
#send-waimai-request-btn svg { display: none; }
#send-waimai-request-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"/><line x1="3" y1="6" x2="21" y2="6"/><path d="M16 10a4 4 0 0 1-8 0"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 視頻通話按鈕 */
#video-call-btn svg { display: none; }
#video-call-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 群視頻通話按鈕 */
#group-video-call-btn svg { display: none; }
#group-video-call-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 投票按鈕 */
#send-poll-btn svg { display: none; }
#send-poll-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 6h10"/><path d="M6 6h.01"/><path d="M8 12h10"/><path d="M6 12h.01"/><path d="M8 18h10"/><path d="M6 18h.01"/></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 分享連結按鈕 */
#share-link-btn svg { display: none; }
#share-link-btn {
  background-image: url('data:image/svg+xml;utf8,<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72"></path></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* 發送定位按鈕 */
#send-location-btn { display: none; }
#send-location-btn {
  background-image: url('data:image/svg+xml;utf8,    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>');
  background-size: 60%;
  background-position: center;
  background-repeat: no-repeat;
}

/* === 6. 更多介面背景色 === */
/* 適用于所有設置、編輯、選擇等二級頁面 */
#api-settings-screen,
#font-settings-screen,
#wallpaper-screen,
#world-book-screen,
#world-book-editor-screen,
#contact-picker-screen,
#member-management-screen,
#album-screen,
#album-photos-screen,
#call-history-screen,
#chat-search-screen,
#browser-screen {
  /* 這裡不再設置背景色，讓它自然繼承夜間模式的顏色 */
}


/* === 7. 回憶卡片美化 === */
.memory-card {
  background-color: #fffaf0 !important; /* 卡片主背景色 */
  border-left-color: #ffb74d !important; /* 左側裝飾條顏色 */
  box-shadow: 0 2px 6px rgba(0,0,0,0.07) !important;
}
.memory-card .header .author {
  color: #d98100 !important; /* 作者/標題文字顏色 */
}
.memory-card .header .date {
  color: #a1887f !important; /* 日期文字顏色 */
}
.memory-card .content {
  color: #5d4037 !important; /* 內容文字顏色 */
}
`;

// ▼▼▼ 在JS頂部，變數定義區，添加這個新常量 ▼▼▼
// ▼▼▼ 用下面這段【修改後】的代碼，完整替換掉你舊的 DEFAULT_APP_ICONS ▼▼▼
const DEFAULT_APP_ICONS = {
    'world-book': 'https://i.postimg.cc/HWf1JKzn/IMG-6435.jpg',
    'qq': 'https://i.postimg.cc/MTC3Tkw8/IMG-6436.jpg',
    'api-settings': 'https://i.postimg.cc/MK8rJ8t7/IMG-6438.jpg',
    'wallpaper': 'https://i.postimg.cc/T1j03pQr/IMG-6440.jpg',
    'font': 'https://i.postimg.cc/pXxk1JXk/IMG-6442.jpg',
    'check-phone': 'https://i.postimg.cc/RVwpwr0r/IMG-8348.jpg',
    'weibo': 'https://i.postimg.cc/PqBY5wBq/weibo-icon.png',
    'forum': 'https://i.postimg.cc/pr0T3WfC/douban-icon.png',
    'lovers-space': 'https://i.postimg.cc/d1wZ39xW/lovers-space-icon.png',
    'game-hall': 'https://i.postimg.cc/P5gL5z2g/game-controller-icon.png',
    'x-social': 'https://i.postimg.cc/8P1H0vQ8/x-logo.png',
    'taobao': 'https://i.postimg.cc/k47tXg1j/taologo.png'
};
// ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼
const DEFAULT_APP_LABELS = {
    'qq': 'QQ',
    'world-book': '世界書',
    'api-settings': 'API設置',
    'wallpaper': '外觀設置',
    'font': '字體',
    'check-phone': '查手機',
    'weibo': '微博',
    'forum': '圈子',
    'lovers-space': '情侶空間',
    'game-hall': '遊戲大廳',
    'x-social': 'X社交',
    'taobao': '桃寶'
};
// ▲▲▲ 新代碼黏貼結束 ▲▲▲

// ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼
const addProductChoiceModal = document.getElementById('add-product-choice-modal');
const aiGeneratedProductsModal = document.getElementById('ai-generated-products-modal');
const productSearchInput = document.getElementById('product-search-input');
const productSearchBtn = document.getElementById('product-search-btn');
// ▲▲▲ 新增變數結束 ▲▲▲



        const STICKER_REGEX = /^(https:\/\/i\.postimg\.cc\/.+|https:\/\/i\.ibb\.co\/.+|https:\/\/files\.catbox\.moe\/.+|data:image)/;
        const MESSAGE_RENDER_WINDOW = 50;
        let currentRenderedCount = 0;
        let lastKnownBatteryLevel = 1;
        let alertFlags = { hasShown40: false, hasShown20: false, hasShown10: false };
        let batteryAlertTimeout;
        const dynamicFontStyle = document.createElement('style');
        dynamicFontStyle.id = 'dynamic-font-style';
        document.head.appendChild(dynamicFontStyle);

        const modalOverlay = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('custom-modal-title');
        const modalBody = document.getElementById('custom-modal-body');
        const modalConfirmBtn = document.getElementById('custom-modal-confirm');
        const modalCancelBtn = document.getElementById('custom-modal-cancel');
        let modalResolve;

        function showCustomModal() { 
            modalOverlay.classList.add('visible'); 
        }

        function hideCustomModal() { 
            modalOverlay.classList.remove('visible'); 
            modalConfirmBtn.classList.remove('btn-danger'); 
            if (modalResolve) modalResolve(null); 
        }

        function showCustomConfirm(title, message, options = {}) {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                modalBody.innerHTML = `<p>${message}</p>`;
                modalCancelBtn.style.display = 'block';
                modalConfirmBtn.textContent = '確定';
                if (options.confirmButtonClass) modalConfirmBtn.classList.add(options.confirmButtonClass);
                modalConfirmBtn.onclick = () => { resolve(true); hideCustomModal(); };
                modalCancelBtn.onclick = () => { resolve(false); hideCustomModal(); };
                showCustomModal();
            });
        }

        function showCustomAlert(title, message) {
            return new Promise(resolve => {
                modalResolve = resolve;
                modalTitle.textContent = title;
                modalBody.innerHTML = `<p style="text-align: left; white-space: pre-wrap;">${message}</p>`;
                modalCancelBtn.style.display = 'none';
                modalConfirmBtn.textContent = '好的';
                modalConfirmBtn.onclick = () => {
                    modalCancelBtn.style.display = 'block'; 
                    modalConfirmBtn.textContent = '確定';
                    resolve(true); 
                    hideCustomModal();
                };
                showCustomModal();
            });
        }
// ▼▼▼ 把這一整塊全新的函數，黏貼到 <script> 標籤的最開始 ▼▼▼
/**
 * 【全新】一個專門清除HTML標籤和代碼的函數
 * @param {string} text - 包含HTML或代碼的原始文本
 * @returns {string} - 清理後的純文字
 */
function stripHtmlAndCode(text) {
    if (!text || typeof text !== 'string') {
        return ''; // 如果輸入為空或不是字串，返回空字串
    }
    // 1. 移除所有HTML標籤 (例如 <b>, <div>)
    let cleanedText = text.replace(/<\/?[^>]+(>|$)/g, "");
    
    // 2. 移除所有Markdown代碼塊 (例如 ```code``` 或 `code`)
    cleanedText = cleanedText.replace(/```[\s\S]*?```/g, ''); // 移除多行代碼塊
    cleanedText = cleanedText.replace(/`[^`]*`/g, '');     // 移除行內代碼
    
    // 3. 將HTML實體 (例如 &lt; &gt;) 轉換回正常字元 (< >)
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = cleanedText;
    
    return tempDiv.textContent || tempDiv.innerText || "";
}
// ▲▲▲ 黏貼結束 ▲▲▲

// ▼▼▼ 請用這個【功能增強版】替換舊的 showCustomPrompt 函數 ▼▼▼
function showCustomPrompt(title, placeholder, initialValue = '', type = 'text', extraHtml = '') {
    return new Promise(resolve => {
        modalResolve = resolve;
        modalTitle.textContent = title;
        const inputId = 'custom-prompt-input';
        
        const inputHtml = type === 'textarea' 
            ? `<textarea id="${inputId}" placeholder="${placeholder}" rows="4" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ccc; font-size: 14px; box-sizing: border-box; resize: vertical;">${initialValue}</textarea>`
            : `<input type="${type}" id="${inputId}" placeholder="${placeholder}" value="${initialValue}">`;
        
        // 【核心修改】將額外的HTML和輸入框組合在一起
        modalBody.innerHTML = extraHtml + inputHtml;
        const input = document.getElementById(inputId);

        // 【核心修改】為格式助手按鈕綁定事件
        modalBody.querySelectorAll('.format-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const templateStr = btn.dataset.template;
                if (templateStr) {
                    try {
                        const templateObj = JSON.parse(templateStr);
                        // 使用 null, 2 參數讓JSON字串格式化，帶縮進，更易讀
                        input.value = JSON.stringify(templateObj, null, 2);
                        input.focus();
                    } catch(e) {
                        console.error("解析格式範本失敗:", e);
                    }
                }
            });
        });
        
        modalConfirmBtn.onclick = () => { resolve(input.value); hideCustomModal(); };
        modalCancelBtn.onclick = () => { resolve(null); hideCustomModal(); };
        showCustomModal();
        setTimeout(() => input.focus(), 100);
    });
}
// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 把這一整塊全新的函數，黏貼到你的JS功能函式定義區 ▼▼▼
// ▼▼▼ 把這一整塊全新的函數，黏貼到你的JS功能函式定義區 ▼▼▼

/**
 * 【全新】從一個陣列中隨機獲取一個元素
 * @param {Array} arr - 目標陣列
 * @returns {*} - 陣列中的一個隨機元素
 */
function getRandomItem(arr) {
    // 安全檢查，如果陣列為空或不存在，返回空字串
    if (!arr || arr.length === 0) return '';
    // 返回一個隨機索引對應的元素
    return arr[Math.floor(Math.random() * arr.length)];
}

// ▲▲▲ 黏貼結束 ▲▲▲
// ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼

/**
 * 【全新】獲取一張隨機的淘寶寶貝預設圖片
 * @returns {string} - 返回一張隨機圖片的URL
 */
function getRandomDefaultProductImage() {
    const defaultImages = [
        'https://i.postimg.cc/W4svy4Hm/Image-1760206134285.jpg',
        'https://i.postimg.cc/jjRb1jF7/Image-1760206125678.jpg'
    ];
    // 從陣列中隨機選擇一個並返回
    return defaultImages[Math.floor(Math.random() * defaultImages.length)];
}

// ▲▲▲ 新增代碼黏貼結束 ▲▲▲

/**
 * 【全新】從一個陣列中隨機獲取一個元素
 * @param {Array} arr - 目標陣列
 * @returns {*} - 陣列中的一個隨機元素
 */
function getRandomItem(arr) {
    // 安全檢查，如果陣列為空或不存在，返回空字串
    if (!arr || arr.length === 0) return '';
    // 返回一個隨機索引對應的元素
    return arr[Math.floor(Math.random() * arr.length)];
}

// ▲▲▲ 黏貼結束 ▲▲▲

        // ===================================================================
        // 2. 資料庫結構定義
        // ===================================================================

// ▼▼▼ 用這塊新代碼替換你舊的 db.version(...).stores(...) ▼▼▼
db.version(40).stores({ // 版本號 +1 = 40
    chats: '&id, isGroup, groupId, isPinned, characterPhoneData, latestInnerVoice, innerVoiceHistory, loversSpaceData.emotionDiaries, settings.summary, settings.weiboNickname',
    apiConfig: '&id',
    globalSettings: '&id, activeThemeId', 
    userStickers: '&id, url, name', 
    charStickers: '&id, url, name', 
    worldBooks: '&id, name, categoryId', 
    worldBookCategories: '++id, name',
    musicLibrary: '&id', 
    personaPresets: '&id',
    qzoneSettings: '&id',
    qzonePosts: '++id, timestamp', 
    qzoneAlbums: '++id, name, createdAt',
    qzonePhotos: '++id, albumId',
    favorites: '++id, type, timestamp, originalTimestamp',
    qzoneGroups: '++id, name',
    memories: '++id, chatId, timestamp, type, targetDate' ,
    callRecords: '++id, chatId, timestamp, customName',
    customAvatarFrames: '&id, name, url',   
    themes: '++id, name, css',
    apiPresets: '++id, name, proxyUrl',
    bubbleStylePresets: '++id, name, css',
    fontPresets: '&id, name, url',
    homeScreenPresets: '++id, name',
    weiboPosts: '++id, authorId, timestamp',
    forumGroups: '++id, name, worldview, *categories',
    forumPosts: '++id, groupId, timestamp, *categories',
    forumComments: '++id, postId, timestamp',
    forumCategories: '++id, name',
    tarotReadings: '++id, timestamp',
    pomodoroSessions: '++id, chatId, startTime',
    scriptKillScripts: '++id, name, isBuiltIn',
    taobaoProducts: '++id, name, category', 
    taobaoOrders: '++id, productId, timestamp',
    taobaoCart: '++id, productId',
    userWalletTransactions: '++id, timestamp' ,
    charPhonePresets: '++id, name',
    ludoQuestionBanks: '++id, name',
    // ★★★ 核心修改：為問題表增加 type 欄位索引 ★★★
    ludoQuestions: '++id, bankId, text, type'
});
// ▲▲▲ 替換結束 ▲▲▲





window.db = db;

// ===================================================================
// 3. 所有功能函式定義
// ===================================================================

// ▼▼▼ 請用這整塊【修復版】代碼，完整替換掉你舊的 toggleVoiceTranscript 函數 ▼▼▼

/**
 * 【V2 - 修復版】切換語音訊息的文字顯示/隱藏
 * @param {HTMLElement} bubble - 被點擊的語音訊息的 .message-bubble 元素
 */
function toggleVoiceTranscript(bubble) {
    if (!bubble) return;

    const transcriptEl = bubble.querySelector('.voice-transcript');
    if (!transcriptEl) return;

    // 核心邏輯：直接檢查文字區域當前是不是顯示狀態
    const isCurrentlyExpanded = transcriptEl.style.display === 'block';

    if (isCurrentlyExpanded) {
        // 如果是展開的，就直接收起來
        transcriptEl.style.display = 'none';
    } else {
        // 如果是收起的，就執行展開流程
        
        // 1. 先顯示一個“正在轉寫”的提示，給用戶即時回饋
        transcriptEl.textContent = '正在轉文字...';
        transcriptEl.style.display = 'block';

        // 2. 模擬一個短暫的“識別”過程
        setTimeout(() => {
            // 再次檢查元素是否還在頁面上，防止使用者切換聊天導致錯誤
            if (document.body.contains(transcriptEl)) {
                // 獲取並顯示真正的轉寫文字
                const voiceText = bubble.dataset.voiceText || '(無法識別)';
                transcriptEl.textContent = voiceText;
            }
        }, 300); // 300毫秒的延遲，感覺更靈敏
    }
}

// ▲▲▲ 替換結束 ▲▲▲



// ▼▼▼ 把這一整塊全新的微博功能函數，黏貼到 init() 函數的上方 ▼▼▼

/**
 * 【全新】微博用戶人設與職業設置核心功能
 */
function openWeiboUserSettingsModal() {
    const modal = document.getElementById('weibo-user-settings-modal');
    const settings = state.qzoneSettings;

    // 載入當前資料到輸入框
    document.getElementById('weibo-user-profession-modal-input').value = settings.weiboUserProfession === '點擊設置職業' ? '' : settings.weiboUserProfession;
    document.getElementById('weibo-user-persona-modal-input').value = settings.weiboUserPersona;
    
    renderWeiboUserPresetSelector(); // 渲染預設下拉清單
    modal.classList.add('visible');
}

async function saveWeiboUserSettings() {
    const profession = document.getElementById('weibo-user-profession-modal-input').value.trim();
    const persona = document.getElementById('weibo-user-persona-modal-input').value.trim();

    state.qzoneSettings.weiboUserProfession = profession || '點擊設置職業';
    state.qzoneSettings.weiboUserPersona = persona || '一個普通的微博用戶。';

    await saveQzoneSettings(); // 保存到資料庫
    await renderWeiboProfile(); // 刷新主頁顯示
    document.getElementById('weibo-user-settings-modal').classList.remove('visible');
    alert('微博設定已保存！');
}

function renderWeiboUserPresetSelector() {
    const select = document.getElementById('weibo-user-preset-select');
    const presets = state.qzoneSettings.weiboUserPersonaPresets || [];
    select.innerHTML = '<option value="">-- 選擇預設 --</option>';
    presets.forEach((preset, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = preset.name;
        select.appendChild(option);
    });
}

function handleWeiboUserPresetSelection() {
    const select = document.getElementById('weibo-user-preset-select');
    const presets = state.qzoneSettings.weiboUserPersonaPresets || [];
    const selectedIndex = select.value;

    if (selectedIndex !== "") {
        const preset = presets[parseInt(selectedIndex)];
        document.getElementById('weibo-user-profession-modal-input').value = preset.profession;
        document.getElementById('weibo-user-persona-modal-input').value = preset.persona;
    }
}

async function openWeiboUserPresetManager() {
    const choice = await showChoiceModal("管理預設", [
        { text: '💾 保存當前為新預設', value: 'save' },
        { text: '🗑️ 刪除已選預設', value: 'delete' }
    ]);

    if (choice === 'save') {
        const name = await showCustomPrompt("保存預設", "請輸入預設名稱");
        if (name && name.trim()) {
            const newPreset = {
                name: name.trim(),
                profession: document.getElementById('weibo-user-profession-modal-input').value.trim(),
                persona: document.getElementById('weibo-user-persona-modal-input').value.trim()
            };
            state.qzoneSettings.weiboUserPersonaPresets.push(newPreset);
            await saveQzoneSettings();
            renderWeiboUserPresetSelector();
            alert(`預設 "${name.trim()}" 已保存！`);
        }
    } else if (choice === 'delete') {
        const select = document.getElementById('weibo-user-preset-select');
        const selectedIndex = select.value;
        if (selectedIndex === "") {
            alert("請先從下拉清單中選擇一個要刪除的預設。");
            return;
        }
        const presets = state.qzoneSettings.weiboUserPersonaPresets;
        const presetName = presets[parseInt(selectedIndex)].name;
        const confirmed = await showCustomConfirm("確認刪除", `確定要刪除預設 "${presetName}" 嗎？`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            presets.splice(parseInt(selectedIndex), 1);
            await saveQzoneSettings();
            renderWeiboUserPresetSelector();
            alert("預設已刪除。");
        }
    }
}
// ▲▲▲ 新函數黏貼結束 ▲▲▲

// ▼▼▼ 從這裡開始，黏貼所有新代碼 ▼▼▼
/**
 * 【V2智慧版】應用指定的主題，並智慧刷新當前打開的任何介面
 * @param {string} theme - 'light' 或 'dark'
 */
function applyTheme(theme) {
    const phoneScreen = document.getElementById('phone-screen');
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    
    const isDark = theme === 'dark';
    
    // 核心操作：為手機螢幕添加或移除 .dark-mode 類
    phoneScreen.classList.toggle('dark-mode', isDark);
    
    // 同步開關的狀態
    if (toggleSwitch) {
        toggleSwitch.checked = isDark;
    }
    
    // 保存用戶的選擇
    localStorage.setItem('ephone-theme', theme);

    // 【核心修復！】
    // 不再只關心聊天介面，而是找出當前究竟是哪個介面處於啟動狀態
    const activeScreen = document.querySelector('.screen.active');
    if (!activeScreen) return; // 如果找不到，就退出

    // 根據當前啟動的介面ID，調用它專屬的刷新函數
    switch (activeScreen.id) {
        case 'chat-interface-screen':
            if (state.activeChatId) {
                renderChatInterface(state.activeChatId);
            }
            break;
        case 'wallpaper-screen':
            // 外觀設置頁也需要重新渲染來應用新主題
            renderWallpaperScreen();
            break;
        case 'font-settings-screen':
            // 字體預設頁同樣需要
            renderFontPresets();
            break;
        // 如果未來還有其他頁面需要適配，在這裡添加 case 即可
    }
}


/**
 * 當使用者點擊開關時，切換當前的主題
 */
function toggleTheme() {
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    // 直接根據開關的選中狀態來決定新主題
    const newTheme = toggleSwitch.checked ? 'dark' : 'light';
    applyTheme(newTheme);
}
/**
 * 【全新】在應用啟動時，預載入所有已保存的字體預設
 */
async function loadAllFontPresetsOnStartup() {
    console.log("正在預載入所有字體預設...");
    const presets = await db.fontPresets.toArray();
    if (presets && presets.length > 0) {
        presets.forEach(preset => {
            // 我們複用已有的 loadFontForPreview 函數來載入每個字體
            loadFontForPreview(preset);
        });
        console.log(`成功預載入了 ${presets.length} 個字體。`);
    }
}

// ▼▼▼ 【全新】字體預設功能核心函數 ▼▼▼

/**
 * 渲染字體預設的5個卡槽
 */
async function renderFontPresets() {
    const container = document.getElementById('font-preset-container');
    container.innerHTML = ''; // 清空舊內容

    // 從資料庫讀取所有已保存的預設
    const presets = await db.fontPresets.toArray();

    // 迴圈5次，創建5個卡槽的HTML
    for (let i = 0; i < 5; i++) {
        const slot = document.createElement('div');
        slot.className = 'font-preset-slot';
        
        const preset = presets[i];

        if (preset) {
            // 如果這個卡槽有資料
            slot.innerHTML = `
                <div class="font-preview-text" data-preset-id="${preset.id}">Abc 你好</div>
                <div class="font-preset-info">名稱: ${preset.name}</div>
                <div class="font-preset-actions">
                    <button class="preset-btn apply-btn" data-preset-id="${preset.id}">應用</button>
                    <button class="preset-btn delete-btn delete" data-preset-id="${preset.id}">刪除</button>
                </div>
            `;
        } else {
            // 如果這個卡槽是空的
            slot.classList.add('empty');
            slot.innerHTML = `
                <div class="font-preset-info">卡槽 ${i + 1} 為空</div>
                <div class="font-preset-actions">
                    <button class="preset-btn secondary upload-url-btn" data-slot-index="${i}">URL上傳</button>
                    <button class="preset-btn secondary upload-local-btn" data-slot-index="${i}">本地上傳</button>
                </div>
            `;
        }
        container.appendChild(slot);
    }
    
    // ▼▼▼ 【核心修復】在這裡，我們等所有HTML都創建好後，再統一載入預覽字體 ▼▼▼
    presets.forEach(preset => {
        if (preset) {
            // 為每一個有資料的預設，調用載入預覽函數
            loadFontForPreview(preset);
        }
    });
    // ▲▲▲ 修復結束 ▲▲▲

    // 為所有新生成的按鈕綁定事件
    addFontPresetButtonListeners();
}


/**
 * 【終極修復版】為單個預設載入字體以供預覽
 * @param {object} preset - 字體預設物件 {id, name, url}
 */
function loadFontForPreview(preset) {
    const styleId = `font-style-${preset.id}`;
    if (document.getElementById(styleId)) return;

    const style = document.createElement('style');
    style.id = styleId;
    
    // 【核心修改】我們不再手動操作元素的style屬性，
    // 而是直接創建一條高優先順序的CSS規則來應用字體，這更可靠。
    style.innerHTML = `
        @font-face {
            font-family: 'preset-${preset.id}';
            src: url('${preset.url}');
            font-display: swap;
        }

        .font-preview-text[data-preset-id="${preset.id}"] {
            font-family: 'preset-${preset.id}', sans-serif !important;
        }
    `;
    
    document.head.appendChild(style);
}




/**
 * 為預設卡槽中的所有按鈕統一添加事件監聽器
 */
function addFontPresetButtonListeners() {
    document.querySelectorAll('.upload-url-btn').forEach(btn => {
        btn.onclick = () => handleUploadFontUrl(parseInt(btn.dataset.slotIndex));
    });
    document.querySelectorAll('.upload-local-btn').forEach(btn => {
        btn.onclick = () => handleUploadFontLocal(parseInt(btn.dataset.slotIndex));
    });
    document.querySelectorAll('.apply-btn').forEach(btn => {
        btn.onclick = () => applyFontPreset(btn.dataset.presetId);
    });
    document.querySelectorAll('.delete-btn').forEach(btn => {
        btn.onclick = () => deleteFontPreset(btn.dataset.presetId);
    });
}

/**
 * 處理通過URL上傳字體
 * @param {number} slotIndex - 卡槽的索引 (0-4)
 */
async function handleUploadFontUrl(slotIndex) {
    const url = await showCustomPrompt("字體URL", "請輸入字體的網路連結(.ttf, .otf等)");
    if (!url || !url.trim().startsWith('http')) {
        if (url !== null) alert("請輸入一個有效的URL！");
        return;
    }
    const name = await showCustomPrompt("字體命名", "請為這個字體起個名字");
    if (!name || !name.trim()) {
        if (name !== null) alert("名字不能為空！");
        return;
    }
    await saveFontPreset(slotIndex, name.trim(), url.trim());
}

/**
 * 處理通過本地檔上傳字體
 * @param {number} slotIndex - 卡槽的索引 (0-4)
 */
function handleUploadFontLocal(slotIndex) {
    const input = document.getElementById('font-preset-local-upload');
    input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const name = await showCustomPrompt("字體命名", "請為這個字體起個名字", file.name.replace(/\.[^/.]+$/, ""));
        if (!name || !name.trim()) {
            if (name !== null) alert("名字不能為空！");
            return;
        }

        // 使用FileReader將字體檔轉為Base64 Data URL
        const reader = new FileReader();
        reader.onload = async (event) => {
            // 核心修改：event.target.result 現在就是我們需要的 data:font/ttf;base64,... 格式的完整文本
            await saveFontPreset(slotIndex, name.trim(), event.target.result);
        };
        // 核心修改：使用 readAsDataURL 來讀取檔
        reader.readAsDataURL(file);
    };
    input.click(); // 觸發檔選擇框
}


/**
 * 將新的字體預設保存到資料庫
 * @param {number} slotIndex - 卡槽索引
 * @param {string} name - 字體名稱
 * @param {string} url - 字體URL (網路或Base64)
 */
// ▼▼▼ 用下面這整塊代碼，替換掉你舊的 saveFontPreset 函數 ▼▼▼
async function saveFontPreset(slotIndex, name, url) {
    try {
        const presets = await db.fontPresets.toArray();
        const newPreset = { id: 'font_' + Date.now(), name, url };
        presets.splice(slotIndex, 0, newPreset);
        const presetsToSave = presets.slice(0, 5);

        // 【核心修改】使用資料庫事務來保證操作的原子性
        await db.transaction('rw', db.fontPresets, async () => {
            await db.fontPresets.clear();
            await db.fontPresets.bulkPut(presetsToSave);
        });

        await renderFontPresets();
        alert(`字體 "${name}" 已成功保存到卡槽 ${slotIndex + 1}！`);
    } catch (error) {
        // 【核心修改】如果出錯，會在這裡捕獲，並告知使用者資料是安全的
        console.error("保存字體預設失敗:", error);
        alert(`保存字體失敗，資料已自動回滾，你之前的字體資料是安全的。錯誤: ${error.message}`);
        await renderFontPresets(); // 失敗後重新渲染，恢復到舊的清單狀態
    }
}
// ▲▲▲ 替換結束 ▲▲▲


/**
 * 刪除一個字體預設
 * @param {string} presetId - 要刪除的預設的ID
 */
async function deleteFontPreset(presetId) {
    const preset = await db.fontPresets.get(presetId);
    if (!preset) return;
    const confirmed = await showCustomConfirm("確認刪除", `確定要刪除字體 "${preset.name}" 嗎？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.fontPresets.delete(presetId);
        
        // 從DOM中移除對應的預覽樣式
        const styleTag = document.getElementById(`font-style-${presetId}`);
        if (styleTag) styleTag.remove();

        await renderFontPresets();
    }
}

/**
 * 應用一個字體預設為全域字體
 * @param {string} presetId - 要應用的預設的ID
 */
async function applyFontPreset(presetId) {
    const preset = await db.fontPresets.get(presetId);
    if (preset) {
        // 調用你已有的全域字體應用函數
        applyCustomFont(preset.url, false);
        // 保存到全域設置
        state.globalSettings.fontUrl = preset.url;
        await db.globalSettings.put(state.globalSettings);
        alert(`已將全域字體更換為 "${preset.name}"！`);
    }
}

// ▲▲▲ 新功能函數黏貼結束 ▲▲▲

/**
 * 【總入口】處理用戶選擇的角色卡檔
 * @param {File} file - 使用者選擇的檔物件
 */
async function handleCharacterImport(file) {
    if (!file) return;

    try {
        let characterData;
        let avatarBase64;

        if (file.name.toLowerCase().endsWith('.png')) {
            // 如果是PNG檔，調用PNG解析函數
            const result = await parseCharPng(file);
            characterData = result.characterData;
            avatarBase64 = result.avatarBase64;
        } else if (file.name.toLowerCase().endsWith('.json')) {
            // 如果是JSON檔，調用JSON解析函數
            characterData = await parseCharJson(file);
            // JSON卡通常不包含圖片，我們給一個預設頭像
            avatarBase64 = defaultAvatar;
        } else {
            alert('不支持的檔案格式，請選擇 .png 或 .json 文件。');
            return;
        }

        if (characterData) {
            // 成功解析出資料後，調用創建函數
            await createCharacterFromData(characterData, avatarBase64);
        }

    } catch (error) {
        console.error("導入角色卡失敗:", error);
        alert(`導入失敗: ${error.message}`);
    }
}

/**
 * 【V3 - 最終亂碼修復版】
 * 解析SillyTavern的PNG角色卡，通過位元組級操作徹底解決中文亂碼問題。
 * @param {File} file - PNG文件
 * @returns {Promise<{characterData: object, avatarBase64: string}>}
 */
async function parseCharPng(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            const arrayBuffer = e.target.result;
            const dataView = new DataView(arrayBuffer);

            if (dataView.getUint32(0) !== 0x89504E47 || dataView.getUint32(4) !== 0x0D0A1A0A) {
                return reject(new Error('檔不是一個有效的PNG圖片。'));
            }

            let offset = 8;
            let characterJson = null;

            while (offset < dataView.byteLength) {
                const length = dataView.getUint32(offset);
                const type = String.fromCharCode(
                    dataView.getUint8(offset + 4),
                    dataView.getUint8(offset + 5),
                    dataView.getUint8(offset + 6),
                    dataView.getUint8(offset + 7)
                );

                if (type === 'tEXt') {
                    const chunkData = new Uint8Array(arrayBuffer, offset + 8, length);
                    
                    // ★★★★★【這是本次修復亂碼的核心代碼】★★★★★
                    // 1. 先用一個簡單的編碼將位元組轉為字串，以便查找關鍵字 "chara"
                    let text = '';
                    for (let i = 0; i < chunkData.length; i++) {
                        text += String.fromCharCode(chunkData[i]);
                    }

                    // 2. 檢查關鍵字是否存在
                    const keyword = 'chara' + String.fromCharCode(0);
                    if (text.startsWith(keyword)) {
                        // 3. 提取出關鍵字後面的 Base64 編碼的字串
                        const base64Data = text.substring(keyword.length);
                        try {
                            // 4. 使用 atob() 解碼 Base64，得到一個“二進位字元串”
                            const binaryString = atob(base64Data);
                            
                            // 5. 將這個“二進位字元串”重新轉換為原始的 UTF-8 位元組陣列
                            const bytes = new Uint8Array(binaryString.length);
                            for (let i = 0; i < binaryString.length; i++) {
                                bytes[i] = binaryString.charCodeAt(i);
                            }
                            
                            // 6. 使用 TextDecoder 將這個純淨的 UTF-8 位元組陣列解碼為正確的字串
                            const decodedJsonString = new TextDecoder('utf-8').decode(bytes);
                            
                            // 7. 解析最終的JSON字串
                            characterJson = JSON.parse(decodedJsonString);
                            break;
                        } catch (e) {
                            return reject(new Error('解析圖片內嵌的角色資料失敗，可能是資料損壞。'));
                        }
                    }
                    // ★★★★★【核心代碼結束】★★★★★
                }
                
                if (type === 'IEND') break;
                offset += 12 + length;
            }

            if (characterJson) {
                const imageReader = new FileReader();
                imageReader.onload = (imgEvent) => {
                    resolve({
                        characterData: characterJson,
                        avatarBase64: imgEvent.target.result
                    });
                };
                imageReader.onerror = () => reject(new Error('讀取圖片作為頭像失敗。'));
                imageReader.readAsDataURL(file);
            } else {
                reject(new Error('在這張PNG圖片中沒有找到SillyTavern角色資料。'));
            }
        };
        reader.onerror = () => reject(new Error('讀取PNG檔失敗。'));
        reader.readAsArrayBuffer(file);
    });
}


/**
 * 解析JSON角色卡
 * @param {File} file - JSON文件
 * @returns {Promise<object>}
 */
/**
 * 【修正版】解析JSON角色卡，強制使用UTF-8編碼
 * @param {File} file - JSON文件
 * @returns {Promise<object>}
 */
async function parseCharJson(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                // 核心修正：先讀取為ArrayBuffer，再用TextDecoder指定UTF-8解碼
                const arrayBuffer = e.target.result;
                const textDecoder = new TextDecoder('utf-8');
                const jsonString = textDecoder.decode(arrayBuffer);
                const data = JSON.parse(jsonString);
                // 相容兩種可能的格式
                resolve(data.data || data);
            } catch (error) {
                reject(new Error('解析JSON檔失敗，請檢查檔案格式或編碼。'));
            }
        };
        reader.onerror = () => reject(new Error('讀取JSON檔失敗。'));
        // 核心修正：讀取為ArrayBuffer而不是Text
        reader.readAsArrayBuffer(file);
    });
}

/**
 * 【V5 - 最終適配版 - 識別 character_book】
 * 根據解析出的資料創建新角色和世界書。
 * 這個版本將優先查找您提供的 character_book 標準格式。
 * @param {object} data - 從卡片解析出的最原始的JSON資料
 * @param {string} avatarBase64 - 角色的頭像圖片 (Base64)
 */
async function createCharacterFromData(data, avatarBase64) {
    // 步驟 1: 確定核心角色資料 (不變)
    const charData = data.data || data;
    const characterName = charData.name ? charData.name.trim() : '未命名角色';
    
    // 步驟 2: 創建新的聊天物件 (不變)
    const newChatId = 'chat_' + Date.now();
// ▼▼▼ 請用這塊【終極完整版】代碼，替換你舊的 const newChat = { ... }; 代碼塊 ▼▼▼

const newChat = {
    id: newChatId,
    name: characterName,
    isGroup: false,
    isPinned: false,
    history: [],
    unreadCount: 0,
    musicData: { totalTime: 0 },
    npcLibrary: [],
    relationship: { status: 'friend', blockedTimestamp: null, applicationReason: '' },
    status: { text: '線上', lastUpdate: Date.now(), isBusy: false },
    weiboDms: [],
    loversSpaceData: null,
    settings: {
        aiPersona: charData.description || '該角色沒有描述。',
        myPersona: '我是誰呀。',
        maxMemory: 10,
        aiAvatar: avatarBase64,
        myAvatar: defaultAvatar,
        background: '',
        theme: 'default',
        fontSize: 13,
        customCss: '',
        linkedWorldBookIds: [],
        aiAvatarLibrary: [],
        stickerLibrary: [],
        summary: { 
            enabled: false, 
            mode: 'auto', 
            count: 20, 
            prompt: '請你以第三人稱的視角，客觀、冷靜、不帶任何感情色彩地總結以下對話的核心事件和資訊。禁止進行任何角色扮演或添加主觀評論。', 
            lastSummaryIndex: -1 
        },
        linkedMemories: [],
        offlineMode: { 
            enabled: false, 
            prompt: '', 
            style: '', 
            wordCount: 300, 
            presets: [] 
        },
        timePerceptionEnabled: true,
        customTime: '',
        isCoupleAvatar: false,
        coupleAvatarDescription: '',
        weiboProfession: '',
        weiboInstruction: '',
        visualVideoCallEnabled: false,
        charVideoImage: '',
        userVideoImage: '',
        petAdopted: false,
        pet: null,
    },
    characterPhoneData: {
        lastGenerated: null,
        chats: {},
        shoppingCart: [],
        memos: [],
        browserHistory: [],
        photoAlbum: [],
        bank: { balance: 0, transactions: [] },
        trajectory: [],
        appUsage: [],
        diary: []
    }
};

// ▲▲▲ 替換結束 ▲▲▲

    await db.chats.put(newChat);
    state.chats[newChatId] = newChat;
    
    // =================================================================
    // ▼▼▼ 核心修改：重構世界書查找邏輯 ▼▼▼
    // =================================================================
    
    console.log("開始檢測世界書資料...");
    let worldBookFound = false;

    // 策略一：【最高優先順序】查找您提供的 character_book 標準格式
    if (charData.character_book && charData.character_book.entries && Array.isArray(charData.character_book.entries) && charData.character_book.entries.length > 0) {
        console.log(`檢測到最新的 character_book 格式 (${charData.character_book.entries.length}條)，開始導入...`);
        const newCategory = { name: characterName };
        const newCategoryId = await db.worldBookCategories.add(newCategory);
        // 我們將調用【修改後】的輔助函數來處理
        await saveWorldBookEntriesFromArray(charData.character_book.entries, newCategoryId);
        worldBookFound = true;
    }
    
    // 策略二：相容舊的 world_entries 格式
    else if (charData.world_entries && Array.isArray(charData.world_entries) && charData.world_entries.length > 0) {
        console.log(`檢測到舊版 world_entries 格式 (${charData.world_entries.length}條)，開始導入...`);
        const newCategory = { name: characterName };
        const newCategoryId = await db.worldBookCategories.add(newCategory);
        await saveWorldBookEntriesFromArray(charData.world_entries, newCategoryId);
        worldBookFound = true;
    }
    
    // 策略三：相容更舊的 data.world 格式
    else if (data.world && typeof data.world === 'string' && data.world.trim()) {
        console.log("檢測到外層 world 欄位格式，開始導入...");
        const newCategory = { name: characterName };
        const newCategoryId = await db.worldBookCategories.add(newCategory);
        await parseAndSaveWorldBooks(data.world, newCategoryId);
        worldBookFound = true;
    }

    // 策略四：最後的相容手段 world_info
    else if (charData.world_info && typeof charData.world_info === 'string' && charData.world_info.trim()) {
        console.log("檢測到舊版 world_info 欄位格式，開始導入...");
        const newCategory = { name: characterName };
        const newCategoryId = await db.worldBookCategories.add(newCategory);
        await parseAndSaveWorldBooks(charData.world_info, newCategoryId);
        worldBookFound = true;
    }

    if (!worldBookFound) {
        console.log("診斷：在此角色卡中未找到任何可識別的世界書欄位。");
    }
    
    // =================================================================
    // ▲▲▲ 核心修改結束 ▲▲▲
    // =================================================================

    // 步驟 4: 刷新UI (不變)
    await renderChatList();
    await showCustomAlert('導入成功！', `角色“${characterName}”已成功創建！`);
}


/**
 * 【V2 - 適配 comment 欄位】
 * 從SillyTavern的 world_entries 或 character_book.entries 陣列直接創建世界書
 * @param {Array<object>} entriesArray - 包含世界書條目的陣列
 * @param {number} categoryId - 這些世界書所屬的分類ID
 */
async function saveWorldBookEntriesFromArray(entriesArray, categoryId) {
    const newBooks = [];

    for (const entry of entriesArray) {
        // ▼▼▼ 核心修改：智能獲取條目名稱 ▼▼▼
        // 優先使用 comment 欄位作為標題，如果它存在且不為空。
        // 否則，再嘗試使用 keys 陣列。
        // 如果都沒有，就給一個默認名字。
        const entryName = (entry.comment && entry.comment.trim()) 
                          ? entry.comment.trim() 
                          : (entry.keys && entry.keys.length > 0 ? entry.keys.join(', ') : '未命名條目');
        // ▲▲▲ 核心修改結束 ▲▲▲

        // 檢查條目是否有效 (有名字、有內容，並且是啟用的)
        // (typeof entry.enabled === 'undefined' || entry.enabled) 是為了相容沒有 enabled 欄位的卡片
        if (entryName !== '未命名條目' && entry.content && (typeof entry.enabled === 'undefined' || entry.enabled)) {
            newBooks.push({
                id: 'wb_' + Date.now() + Math.random(),
                name: entryName, // 使用我們智慧獲取到的名字
                content: entry.content,
                categoryId: categoryId
            });
        }
    }

    if (newBooks.length > 0) {
        await db.worldBooks.bulkAdd(newBooks);
        // 確保 state.worldBooks 也被更新，以便UI能立即顯示
        const allBooks = await db.worldBooks.toArray();
        state.worldBooks = allBooks;
        console.log(`成功導入 ${newBooks.length} 個世界書條目到分類ID: ${categoryId}`);
    }
}



// 【輔助函數】獲取事件的座標
function getEventCoords(e) {
    // 如果是觸摸事件，就從 e.touches[0] 獲取
    if (e.touches && e.touches[0]) {
        return { x: e.touches[0].pageX, y: e.touches[0].pageY };
    }
    // 否則，就是滑鼠事件，直接從 e 獲取
    return { x: e.pageX, y: e.pageY };
}


        function showScreen(screenId) {
              // 如果當前啟動的不是物流頁面，就清空所有物流更新的計時器
    if (!document.getElementById('logistics-screen').classList.contains('active')) {
        logisticsUpdateTimers.forEach(timerId => clearTimeout(timerId));
        logisticsUpdateTimers = [];
    }
    // ▲▲▲ 添加結束 ▲▲▲
            if (screenId === 'chat-list-screen') {
                window.renderChatListProxy(); 
                switchToChatListView('messages-view');
            }
            if (screenId === 'api-settings-screen') window.renderApiSettingsProxy();
            if (screenId === 'wallpaper-screen') window.renderWallpaperScreenProxy();
            if (screenId === 'world-book-screen') window.renderWorldBookScreenProxy();
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            const screenToShow = document.getElementById(screenId);
            if (screenToShow) screenToShow.classList.add('active');
            if (screenId === 'chat-interface-screen') window.updateListenTogetherIconProxy(state.activeChatId);
            if (screenId === 'font-settings-screen') {
                // 更新全域字體預覽
                document.getElementById('font-preview').style.fontFamily = '';
                applyCustomFont(state.globalSettings.fontUrl || '', true);
                
                // 渲染5個預設卡槽
                renderFontPresets();
            }

        }
        window.updateListenTogetherIconProxy = () => {};

        function switchToChatListView(viewId) {
            const chatListScreen = document.getElementById('chat-list-screen');
            const views = {
                'messages-view': document.getElementById('messages-view'),
                'qzone-screen': document.getElementById('qzone-screen'),
                'favorites-view': document.getElementById('favorites-view'),
        'memories-view': document.getElementById('memories-view') // <-- 新增這一行
    };
            const mainHeader = document.getElementById('main-chat-list-header');
            const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 獲取主巡覽列

            if (isFavoritesSelectionMode) {
                document.getElementById('favorites-edit-btn').click(); 
            }

            // 隱藏所有視圖
            Object.values(views).forEach(v => v.classList.remove('active'));
            // 顯示目標視圖
            if (views[viewId]) {
                views[viewId].classList.add('active');
            }

            // 更新底部巡覽列高亮
            document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => {
                item.classList.toggle('active', item.dataset.view === viewId);
            });
            
            // ▼▼▼ 【核心修正】在這裡統一管理所有UI元素的顯隱 ▼▼▼
            if (viewId === 'messages-view') {
                mainHeader.style.display = 'flex';
                mainBottomNav.style.display = 'flex';
            } else {
                mainHeader.style.display = 'none';
                mainBottomNav.style.display = 'none';
            }
            // ▲▲▲ 修正結束 ▲▲▲

    if (viewId !== 'memories-view') {
        activeCountdownTimers.forEach(timerId => clearInterval(timerId));
        activeCountdownTimers = [];
    }

            // 根據視圖ID執行特定的渲染/更新邏輯
            switch (viewId) {
                case 'qzone-screen':
                    views['qzone-screen'].style.backgroundColor = '#f0f2f5';
                    updateUnreadIndicator(0);
                    renderQzoneScreen();
                    renderQzonePosts();
                    break;
                case 'favorites-view':
                    views['favorites-view'].style.backgroundColor = '#f9f9f9';
                    renderFavoritesScreen();
                    break;
                case 'messages-view':
                    // 如果需要，可以在這裡添加返回消息清單時要執行的邏輯
                    break;
            }
        }
        
        function renderQzoneScreen() {
            if (state && state.qzoneSettings) {
                const settings = state.qzoneSettings;
                document.getElementById('qzone-nickname').textContent = settings.nickname;
                document.getElementById('qzone-avatar-img').src = settings.avatar;
                document.getElementById('qzone-banner-img').src = settings.banner;
            }
        }
        window.renderQzoneScreenProxy = renderQzoneScreen;

        async function saveQzoneSettings() {
            if (db && state.qzoneSettings) {
                await db.qzoneSettings.put(state.qzoneSettings);
            }
        }

        function formatPostTimestamp(timestamp) {
            if (!timestamp) return '';
            const now = new Date();
            const date = new Date(timestamp);
            const diffSeconds = Math.floor((now - date) / 1000);
            const diffMinutes = Math.floor(diffSeconds / 60);
            const diffHours = Math.floor(diffMinutes / 60);
            if (diffMinutes < 1) return '剛剛';
            if (diffMinutes < 60) return `${diffMinutes}分鐘前`;
            if (diffHours < 24) return `${diffHours}小時前`;
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            if (now.getFullYear() === year) {
                return `${month}-${day} ${hours}:${minutes}`;
            } else {
                return `${year}-${month}-${day} ${hours}:${minutes}`;
            }
        }

// ▼▼▼ 步驟3.1：用這整塊【終極修復版】代碼替換舊的 renderQzonePosts 函數 ▼▼▼
async function renderQzonePosts() {
    const postsListEl = document.getElementById('qzone-posts-list');
    if (!postsListEl) return;

    const [posts, favorites] = await Promise.all([
        db.qzonePosts.orderBy('timestamp').reverse().toArray(),
        db.favorites.where('type').equals('qzone_post').toArray()
    ]);

    const favoritedPostIds = new Set(favorites.map(fav => fav.content.id));
    
    postsListEl.innerHTML = '';

    if (posts.length === 0) {
        postsListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">這裡空空如也，快來發佈第一條說說吧！</p>';
        return;
    }

    const userSettings = state.qzoneSettings;
    
// ▼▼▼ 從這裡開始替換 ▼▼▼
// ★★★★★ 這就是我們這次修復的核心 ★★★★★
// 1. 在渲染所有帖子之前，我們先創建一個包含所有AI角色名字的集合(Set)，方便快速查找。
const allAiCharacterNames = new Set(Object.values(state.chats).filter(chat => !chat.isGroup).map(chat => chat.name));
// ★★★★★ 修復結束 ★★★★★

posts.forEach(post => {
    const postContainer = document.createElement('div');
    postContainer.className = 'qzone-post-container';
    postContainer.dataset.postId = post.id;

    const postEl = document.createElement('div');
    postEl.className = 'qzone-post-item';

    let authorAvatar = '', authorNickname = '', commentAvatar = userSettings.avatar; 

    if (post.authorId === 'user') {
        authorAvatar = userSettings.avatar;
        authorNickname = userSettings.nickname;
    } else if (state.chats[post.authorId]) {
        const authorChat = state.chats[post.authorId];
        authorAvatar = authorChat.settings.aiAvatar || defaultAvatar;
        authorNickname = authorChat.name;
    } else {
        authorAvatar = defaultAvatar;
        authorNickname = '{{char}}';
    }
    
    let contentHtml = '';
    const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';

    if (post.type === 'shuoshuo') {
        contentHtml = `<div class="post-content" style="margin-bottom: 10px;">${post.content.replace(/\n/g, '<br>')}</div>`;
    } 
    else if (post.type === 'image_post' && post.imageUrl) {
        contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
    } 
    else if (post.type === 'text_image') {
        contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
    }

    let likesHtml = '';
    if (post.likes && post.likes.length > 0) {
        likesHtml = `<div class="post-likes-section"><svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg><span>${post.likes.join('、')} 覺得很贊</span></div>`;
    }
    
    let commentsHtml = '';
    if (post.comments && post.comments.length > 0) {
        // ★★★★★ 這就是我們這次修復的核心 ★★★★★
        // 2. 修改這裡的過濾邏輯
        const commentsToShow = post.areCommentsVisible === false 
            ? post.comments.filter(comment => 
                // 條件1: 評論者是你自己
                comment.commenterName === userSettings.nickname || 
                // 條件2: 評論者的名字在我們剛才創建的AI角色名字列表裡
                allAiCharacterNames.has(comment.commenterName)
              )
            : post.comments; // 如果開關是開的，就顯示所有評論
        // ★★★★★ 修復結束 ★★★★★

        if (commentsToShow.length > 0) {
// ▲▲▲ 替換到這裡結束 ▲▲▲

                commentsHtml = '<div class="post-comments-container">';
                commentsToShow.forEach(comment => {
                    const originalIndex = post.comments.indexOf(comment);
                    let replyHtml = '';
                    if (comment.replyTo) {
                        replyHtml = `<span class="reply-text">回復</span> <span class="reply-target-name">${comment.replyTo}</span>`;
                    }
                    commentsHtml += `
                        <div class="comment-item" data-commenter-name="${comment.commenterName}">
                            <span class="commenter-name">${comment.commenterName}</span>${replyHtml}:
                            <span class="comment-text"> ${comment.text}</span>
                            <span class="comment-delete-btn" data-comment-index="${originalIndex}">×</span>
                        </div>`;
                });
                commentsHtml += '</div>';
            }
        }


        const commentsAndFooterHtml = `
            ${commentsHtml}
            <div class="post-footer">
                <div class="comment-section">
                    <img src="${commentAvatar}" class="comment-avatar">
                    <input type="text" class="comment-input" placeholder="友善的評論是交流的起點">
                    <div class="at-mention-popup"></div>
                </div>
                <button class="comment-send-btn">發送</button>
            </div>
        `;

        const userNickname = state.qzoneSettings.nickname;
        const isLikedByUser = post.likes && post.likes.includes(userNickname);
        const isFavoritedByUser = favoritedPostIds.has(post.id);

        postEl.innerHTML = `
            <div class="post-header"><img src="${authorAvatar}" class="post-avatar"><div class="post-info"><span class="post-nickname">${authorNickname}</span><span class="post-timestamp">${formatPostTimestamp(post.timestamp)}</span></div>
                <div class="post-actions-btn">…</div>
            </div>
            <div class="post-main-content">${contentHtml}</div>
            <div class="post-feedback-icons">
                <span class="action-icon like ${isLikedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg></span>
                <span class="action-icon favorite ${isFavoritedByUser ? 'active' : ''}"><svg viewBox="0 0 24 24"><path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"></path></svg></span>
                <span class="action-icon summon-npc" data-post-id="${post.id}" data-author-id="${post.authorId}" title="召喚NPC評論"><svg viewBox="0 0 24 24"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg></span>
                </div>
            ${likesHtml}
            ${commentsAndFooterHtml} 
        `;
        
        const deleteAction = document.createElement('div');
        deleteAction.className = 'qzone-post-delete-action';
        deleteAction.innerHTML = '<span>刪除</span>';
        postContainer.appendChild(postEl);
        postContainer.appendChild(deleteAction);
        const commentSection = postContainer.querySelector('.comment-section');
        if (commentSection) {
            commentSection.addEventListener('touchstart', (e) => e.stopPropagation());
            commentSection.addEventListener('mousedown', (e) => e.stopPropagation());
        }
        postsListEl.appendChild(postContainer);
        const commentInput = postContainer.querySelector('.comment-input');
        if (commentInput) {
            const popup = postContainer.querySelector('.at-mention-popup');
            commentInput.addEventListener('input', () => {
                const value = commentInput.value;
                const atMatch = value.match(/@([\p{L}\w]*)$/u);
                if (atMatch) {
                    const namesToMention = new Set();
                    const authorNickname = postContainer.querySelector('.post-nickname')?.textContent;
                    if (authorNickname) namesToMention.add(authorNickname);
                    postContainer.querySelectorAll('.commenter-name').forEach(nameEl => {
                        namesToMention.add(nameEl.textContent.replace(':', ''));
                    });
                    namesToMention.delete(state.qzoneSettings.nickname);
                    popup.innerHTML = '';
                    if (namesToMention.size > 0) {
                        const searchTerm = atMatch[1];
                        namesToMention.forEach(name => {
                            if (name.toLowerCase().includes(searchTerm.toLowerCase())) {
                                const item = document.createElement('div');
                                item.className = 'at-mention-item';
                                item.textContent = name;
                                item.addEventListener('mousedown', (e) => {
                                    e.preventDefault();
                                    const newText = value.substring(0, atMatch.index) + `@${name} `;
                                    commentInput.value = newText;
                                    popup.style.display = 'none';
                                    commentInput.focus();
                                });
                                popup.appendChild(item);
                            }
                        });
                        popup.style.display = popup.children.length > 0 ? 'block' : 'none';
                    } else {
                        popup.style.display = 'none';
                    }
                } else {
                    popup.style.display = 'none';
                }
            });
            commentInput.addEventListener('blur', () => { setTimeout(() => { popup.style.display = 'none'; }, 200); });
        }
    });
}
// ▲▲▲ 步驟3.1替換結束 ▲▲▲
async function renderFollowingFeed() {
    const feedListEl = document.getElementById('weibo-following-feed-list');
    if (!feedListEl) return;

    // 1. 從資料庫獲取所有動態
    const allPosts = await db.qzonePosts.orderBy('timestamp').reverse().toArray();
    
    // 2. 【核心】篩選出作者不是 'user' 的動態
    const followingPosts = allPosts.filter(post => post.authorId !== 'user');

    feedListEl.innerHTML = ''; // 清空舊內容

    if (followingPosts.length === 0) {
        feedListEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 30px 0;">你關注的人還沒有發佈任何動態哦。</p>';
        return;
    }

    // 3. 遍歷篩選後的動態，並渲染它們
    //    【提示】這裡創建單個動態HTML的邏輯，可以完全複製 `renderQzonePosts` 函數裡的 forEach 迴圈內部的代碼。
    //    你只需要把目標容器從 `postsListEl` 改為 `feedListEl` 即可。
    followingPosts.forEach(post => {
        // ... 在這裡黏貼 renderQzonePosts 函數中創建 postContainer、postEl 的那一大段代碼 ...
        // ... 記得最後要把 postContainer append 到 feedListEl 中 ...
        // feedListEl.appendChild(postContainer);
    });
}

// ▼▼▼ 請用下面這個【更新後的】函數，完整替換掉你代碼中舊的 displayFilteredFavorites 函數 ▼▼▼

function displayFilteredFavorites(items) {
    const listEl = document.getElementById('favorites-list');
    listEl.innerHTML = '';

    if (items.length === 0) {
        const searchTerm = document.getElementById('favorites-search-input').value;
        const message = searchTerm ? '未找到相關收藏' : '你的我的最愛是空的，<br>快去動態或聊天中收藏喜歡的內容吧！';
        listEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">${message}</p>`;
        return;
    }

    for (const item of items) {
        const card = document.createElement('div');
        card.className = 'favorite-item-card';
        card.dataset.favid = item.id;

        let headerHtml = '', contentHtml = '', sourceText = '', footerHtml = '';

        if (item.type === 'qzone_post') {
            const post = item.content;
            sourceText = '來自動態';
            let authorAvatar = defaultAvatar, authorNickname = '未知用戶';

            if (post.authorId === 'user') {
                authorAvatar = state.qzoneSettings.avatar;
                authorNickname = state.qzoneSettings.nickname;
            } else if (state.chats[post.authorId]) {
                authorAvatar = state.chats[post.authorId].settings.aiAvatar;
                authorNickname = state.chats[post.authorId].name;
            }

            headerHtml = `<img src="${authorAvatar}" class="avatar"><div class="info"><div class="name">${authorNickname}</div></div>`;
            
            const publicTextHtml = post.publicText ? `<div class="post-content">${post.publicText.replace(/\n/g, '<br>')}</div>` : '';
            if (post.type === 'shuoshuo') {
                contentHtml = `<div class="post-content">${post.content.replace(/\n/g, '<br>')}</div>`;
            } else if (post.type === 'image_post' && post.imageUrl) {
                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="${post.imageUrl}" class="chat-image"></div>` : `<img src="${post.imageUrl}" class="chat-image">`;
            } else if (post.type === 'text_image') {
                contentHtml = publicTextHtml ? `${publicTextHtml}<div style="margin-top:10px;"><img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}"></div>` : `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="chat-image" style="cursor: pointer;" data-hidden-text="${post.hiddenContent}">`;
            }

            // ▼▼▼ 新增/修改的代碼開始 ▼▼▼
            
            // 1. 構造點贊區域的HTML
            let likesHtml = '';
            // 檢查 post 物件中是否存在 likes 陣列並且不為空
            if (post.likes && post.likes.length > 0) {
                // 如果存在，就創建點贊區域的 div
                likesHtml = `
                    <div class="post-likes-section">
                        <svg class="like-icon" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>
                        <span>${post.likes.join('、')} 覺得很贊</span>
                    </div>`;
            }

            // 2. 構造評論區域的HTML
            let commentsHtml = '';
            // 檢查 post 物件中是否存在 comments 陣列並且不為空
            if (post.comments && post.comments.length > 0) {
                // 如果存在，就創建評論容器，並遍歷每一條評論
                commentsHtml = '<div class="post-comments-container">';
                post.comments.forEach(comment => {
                    commentsHtml += `
                        <div class="comment-item">
                            <span class="commenter-name">${comment.commenterName}:</span>
                            <span class="comment-text">${comment.text}</span>
                        </div>`;
                });
                commentsHtml += '</div>';
            }

            // 3. 將點贊和評論的HTML組合到 footerHtml 中
            footerHtml = `${likesHtml}${commentsHtml}`;
            
            // ▲▲▲ 新增/修改的代碼結束 ▲▲▲

} else if (item.type === 'chat_message') {
    const msg = item.content;
    const chat = state.chats[item.chatId];
    if (!chat) continue; 

    sourceText = `來自與 ${chat.name} 的聊天`;
    const isUser = msg.role === 'user';
    let senderName, senderAvatar;

    if (isUser) {
        // 使用者消息的邏輯保持不變
        senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
        senderAvatar = chat.settings.myAvatar || (chat.isGroup ? defaultMyGroupAvatar : defaultAvatar);
    } else { // AI/成員消息

         if (chat.isGroup) {
            // ★★★★★ 這就是唯一的、核心的修改！ ★★★★★
            // 我們現在使用 originalName 去匹配，而不是舊的 name
            const member = chat.members.find(m => m.originalName === msg.senderName);
            // ★★★★★ 修改結束 ★★★★★
            
            senderName = msg.senderName;
            // 因為現在能正確找到 member 物件了，所以也能正確獲取到他的頭像
            senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
        } else {
            // 單聊的邏輯保持不變
            senderName = chat.name;
            senderAvatar = chat.settings.aiAvatar || defaultAvatar;
        }
    }

    // 後續拼接 headerHtml 和 contentHtml 的邏輯都保持不變
    headerHtml = `<img src="${senderAvatar}" class="avatar"><div class="info"><div class="name">${senderName}</div></div>`;
    
    if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
        contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-width: 80px; max-height: 80px;">`;
    } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
        contentHtml = `<img src="${msg.content[0].image_url.url}" class="chat-image">`;
// ▼▼▼ 請用這【一整塊新代碼】替換掉上面那段舊的 else { ... } 代碼塊 ▼▼▼
// ▼▼▼ 請用這【一整塊新代碼】再次替換掉 createMessageElement 函數裡的 else { ... } 代碼塊 ▼▼▼
} else {
    const messageText = String(msg.content || '');
    // 偵測格式：[sticker:名字]
    const stickerMatch = messageText.match(/\[sticker:\s*(.+?)\s*\]/i);

    if (stickerMatch) {
        // 如果匹配成功，提取出名字
        const stickerName = stickerMatch[1].trim();
        // 【核心】在所有可能的表情庫裡查找（用戶的、角色的專屬、角色的通用）
        const allStickers = [...state.userStickers, ...state.charStickers, ...(chat.settings.stickerLibrary || [])];
        const foundSticker = allStickers.find(s => s.name === stickerName);
        
        if (foundSticker) {
            // 如果找到了，就顯示圖片！
            bubble.classList.add('is-sticker');
            contentHtml = `<img src="${foundSticker.url}" alt="${foundSticker.name}" class="sticker-image">`;
        } else {
            // 如果沒找到（比如AI自己編了個名字），就還是按普通文字顯示
            contentHtml = messageText.replace(/\n/g, '<br>');
        }
    } else {
        // 如果不匹配，就是普通的文本消息
        contentHtml = messageText.replace(/\n/g, '<br>');
    }
}
// ▲▲▲ 替換結束 ▲▲▲


}
        
        // ▼▼▼ 修改最終的HTML拼接，加入 footerHtml ▼▼▼
        card.innerHTML = `
            <div class="fav-card-header">${headerHtml}<div class="source">${sourceText}</div></div>
            <div class="fav-card-content">${contentHtml}</div>
            ${footerHtml}`; // <-- 把我們新創建的 footerHtml 放在這裡
            
        listEl.appendChild(card);
    }
}

// ▲▲▲ 替換區域結束 ▲▲▲

        /**
         * 【重構後的函數】: 負責準備資料並觸發渲染
         */
        async function renderFavoritesScreen() {
            // 1. 從資料庫獲取最新資料並緩存
            allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray();
            
            // 2. 清空搜索框並隱藏清除按鈕
            const searchInput = document.getElementById('favorites-search-input');
            const clearBtn = document.getElementById('favorites-search-clear-btn');
            searchInput.value = '';
            clearBtn.style.display = 'none';

            // 3. 顯示所有收藏項
            displayFilteredFavorites(allFavoriteItems);
        }

        // ▲▲▲ 黏貼結束 ▲▲▲

function resetCreatePostModal() {
    document.getElementById('post-public-text').value = '';
    document.getElementById('post-image-preview').src = '';
    document.getElementById('post-image-description').value = '';
    document.getElementById('post-image-preview-container').classList.remove('visible');
    document.getElementById('post-image-desc-group').style.display = 'none';
    document.getElementById('post-local-image-input').value = '';
    document.getElementById('post-hidden-text').value = '';

    // 【核心修復】我們不再模擬點擊，而是直接、安全地設置狀態
    const imageModeBtn = document.getElementById('switch-to-image-mode');
    const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
    const imageModeContent = document.getElementById('image-mode-content');
    const textImageModeContent = document.getElementById('text-image-mode-content');
    
    imageModeBtn.classList.add('active');
    textImageModeBtn.classList.remove('active');
    imageModeContent.classList.add('active');
    textImageModeContent.classList.remove('active');
}

// ▼▼▼ 用這個【已修復】的版本，完整替換掉你舊的 exportBackup 函數 ▼▼▼
async function exportBackup() {
    try {
        const backupData = {
            version: 1, 
            timestamp: Date.now()
        };

        // --- 這部分資料庫讀取的代碼保持不變 ---
        const [
            chats, worldBooks, userStickers, apiConfig, globalSettings,
            personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups, memories,
            worldBookCategories, callRecords, customAvatarFrames, themes,
            apiPresets, bubbleStylePresets, fontPresets, homeScreenPresets
        ] = await Promise.all([
            db.chats.toArray(),
            db.worldBooks.toArray(),
            db.userStickers.toArray(),
            db.apiConfig.get('main'),
            db.globalSettings.get('main'),
            db.personaPresets.toArray(),
            db.musicLibrary.get('main'),
            db.qzoneSettings.get('main'),
            db.qzonePosts.toArray(),
            db.qzoneAlbums.toArray(),
            db.qzonePhotos.toArray(),
            db.favorites.toArray(),
            db.qzoneGroups.toArray(),
            db.memories.toArray(),
            db.worldBookCategories.toArray(),
            db.callRecords.toArray(),
            db.customAvatarFrames.toArray(),
            db.themes.toArray(),
            db.apiPresets.toArray(),
            db.bubbleStylePresets.toArray(),
            db.fontPresets.toArray(),
            db.homeScreenPresets.toArray()
        ]);

        Object.assign(backupData, {
            chats, worldBooks, userStickers, apiConfig, globalSettings,
            personaPresets, musicLibrary, qzoneSettings, qzonePosts,
            qzoneAlbums, qzonePhotos, favorites, qzoneGroups, memories,
            worldBookCategories, callRecords, customAvatarFrames, themes,
            apiPresets, bubbleStylePresets, fontPresets, homeScreenPresets
        });
        
        // --- ▼▼▼ 核心修改就在這裡！▼▼▼ ---
        // 我們重構了 homeScreenState 物件，確保它能包含第一頁的所有資料
        backupData.homeScreenState = {
            // --- 這是我們新增的第一頁數據 ---
            'profile-banner-img': document.getElementById('profile-banner-img').src,
            'profile-avatar-img': document.getElementById('profile-avatar-img').src,
            'profile-username': document.getElementById('profile-username').textContent,
            'profile-sub-username': document.getElementById('profile-sub-username').textContent,
            'profile-bio': document.getElementById('profile-bio').textContent,
            'profile-location': document.getElementById('profile-location').innerHTML, // 使用innerHTML來保存SVG圖示
            'widget-bubble-1': document.getElementById('widget-bubble-1').textContent,
            'widget-image-1': document.getElementById('widget-image-1').src, // 這是你特別提到的組件
            'widget-subtext-1': document.getElementById('widget-subtext-1').textContent,
            'widget-bubble-2': document.getElementById('widget-bubble-2').textContent,
            'widget-image-2': document.getElementById('widget-image-2').src,
            'widget-subtext-2': document.getElementById('widget-subtext-2').textContent,
            'widget-image-3': document.getElementById('widget-image-3').src,
            'second-page-bubble': document.getElementById('second-page-bubble').textContent,
            'flat-capsule-bubble': document.getElementById('flat-capsule-bubble').textContent,
            'circular-bubble': document.getElementById('circular-bubble').textContent,
            'widget-image-4': document.getElementById('widget-image-4').src,
            'avatar-subtitle': document.getElementById('avatar-subtitle').textContent,
            'bubble-top-left': document.getElementById('bubble-top-left').textContent,
            'bubble-top-right': document.getElementById('bubble-top-right').textContent,
            'bubble-bottom-left': document.getElementById('bubble-bottom-left').textContent,
            'bubble-bottom-right': document.getElementById('bubble-bottom-right').textContent,
            'new-widget-avatar': document.getElementById('new-widget-avatar').src,
            'new-widget-text-1': document.getElementById('new-widget-text-1').textContent,
            'new-widget-text-2': document.getElementById('new-widget-text-2').textContent,
            'new-widget-text-3': document.getElementById('new-widget-text-3').textContent,
            'widget-month-display': document.getElementById('widget-month-display').textContent,
            'appIcons': { ...state.globalSettings.appIcons },
            'lockscreenWallpaper': state.globalSettings.lockscreenWallpaper,
            'wallpaper': state.globalSettings.wallpaper
        };
        // --- ▲▲▲ 修改結束 ▲▲▲ ---

        // 後續的下載邏輯保持不變
        const blob = new Blob(
            [JSON.stringify(backupData, null, 2)], 
            { type: 'application/json' }
        );
        const url = URL.createObjectURL(blob);
        const link = Object.assign(document.createElement('a'), {
            href: url,
            download: `EPhone-Full-Backup-${new Date().toISOString().split('T')[0]}.json`
        });
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        await showCustomAlert('匯出成功', '已成功匯出所有資料！');

    } catch (error) {
        console.error("匯出資料時出錯:", error);
        await showCustomAlert('匯出失敗', `發生了一個錯誤: ${error.message}`);
    }
}




// ▼▼▼ 請用這【一整塊終極修復版】的代碼，完整替換掉你舊的 importBackup 函數 ▼▼▼
async function importBackup(file) {
    if (!file) return;

    const confirmed = await showCustomConfirm(
        '嚴重警告！',
        '導入備份將完全覆蓋您當前的所有資料，包括聊天、設置等。此操作不可撤銷！您確定要繼續嗎？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (!confirmed) return;

    try {
        const text = await file.text();
        const data = JSON.parse(text);

        await db.transaction('rw', db.tables, async () => {
            // 1. 清空所有現有表格
            for (const table of db.tables) {
                await table.clear();
            }

            // 2. 【核心修復】智慧、安全地導入資料
            // 我們會檢查備份檔案中的每一項資料，只有當當前代碼的資料庫裡也存在對應的表格時，才進行導入
            
            // 導入陣列類型的資料
            const arrayTables = [
                'chats', 'worldBooks', 'worldBookCategories', 'userStickers', 
                'personaPresets', 'qzonePosts', 'qzoneAlbums', 'qzonePhotos', 
                'favorites', 'qzoneGroups', 'memories', 'callRecords', 
                'customAvatarFrames', 'themes', 'apiPresets', 'bubbleStylePresets',
                // 就算備份檔案裡有下面這些新版才有的資料，這段代碼也能安全跳過
                'fontPresets', 'homeScreenPresets' 
            ];

// ▼▼▼ 【全新】世界書格式相容轉換代碼 ▼▼▼
for (const tableName of arrayTables) {
    if (Array.isArray(data[tableName]) && db[tableName]) {
        let itemsToPut = data[tableName];

        // 【核心邏輯】當處理世界書表格時，執行特別的轉換操作
        if (tableName === 'worldBooks') {
            console.log("正在檢查並轉換世界書資料格式以相容...");
            itemsToPut.forEach(book => {
                // 如果 content 是陣列 (別人的格式)，則將其轉換為字串 (我的格式)
                if (Array.isArray(book.content)) {
                    console.log(`檢測到陣列格式的世界書: "${book.name}"，正在轉換為字串...`);
                    
                    // 將陣列中的每個條目物件轉換為格式化的字串
                    const convertedEntries = book.content.map(entry => {
                        const stringParts = [];
                        if (entry.comment) {
                            stringParts.push(`[備註: ${entry.comment}]`);
                        }
                        if (entry.keys && entry.keys.length > 0) {
                            stringParts.push(`[關鍵字: ${entry.keys.join(', ')}]`);
                        }
                        stringParts.push(entry.content); // 條目主要內容
                        return stringParts.join('\n'); // 每個條目的內部用換行分隔
                    });
                    
                    // 將所有轉換後的條目字串用一個明顯的分隔符號連接起來
                    book.content = convertedEntries.join('\n\n---\n\n');
                }
            });
        }
        
        // 過濾並保存資料 (這部分邏輯保持不變)
        const validItems = itemsToPut.filter(item => item && (typeof item.id === 'undefined' || typeof item.id === 'string' || typeof item.id === 'number'));
        if (validItems.length > 0) {
            console.log(`正在導入 ${validItems.length} 條資料到表格: ${tableName}...`);
            await db[tableName].bulkPut(validItems);
        }

    } else {
        console.log(`跳過導入: ${tableName} (在備份檔案或當前資料庫中不存在)`);
    }
}
// ▲▲▲ 代碼黏貼結束 ▲▲▲

            
            // 導入物件類型的資料（通常是設置）
            const objectTables = ['apiConfig', 'globalSettings', 'musicLibrary', 'qzoneSettings'];
            for (const tableName of objectTables) {
                if (data[tableName] && db[tableName]) {
                    console.log(`正在導入設置: ${tableName}...`);
                    await db[tableName].put(data[tableName]);
                }
            }
        });

        // 導入主螢幕樣式的邏輯保持不變，因為它不直接操作資料庫的多個表
        if (data.homeScreenState) {
            const settings = await db.globalSettings.get('main') || { id: 'main' };
            settings.widgetData = data.homeScreenState;
            if (data.homeScreenState.wallpaper) settings.wallpaper = data.homeScreenState.wallpaper;
            if (data.homeScreenState.lockscreenWallpaper) settings.lockscreenWallpaper = data.homeScreenState.lockscreenWallpaper;
            if (data.homeScreenState.appIcons) settings.appIcons = data.homeScreenState.appIcons;
            await db.globalSettings.put(settings);
            console.log("已成功導入主螢幕樣式資料。");
        }


        await showCustomAlert('導入成功', '所有資料已成功恢復！應用即將刷新以應用所有更改。');
        
        setTimeout(() => {
            window.location.reload();
        }, 1500);

    } catch (error) {
        console.error("導入資料時出錯:", error);
        await showCustomAlert('導入失敗', `檔案格式不正確或資料已損壞: ${error.message}`);
    }
}

function applyCustomFont(fontUrl, isPreviewOnly = false) {
    if (!fontUrl) {
        // 如果沒有提供字體連結（比如恢復預設），就清空樣式
        dynamicFontStyle.innerHTML = '';
        document.getElementById('font-preview').style.fontFamily = '';
        return;
    }

    // 這是一個統一的內部名字
    const fontName = 'custom-user-font';
    
    // 這是定義字體的樣式規則
    const newStyle = `
        @font-face {
          font-family: '${fontName}';
          src: url('${fontUrl}');
          font-display: swap;
        }`;

    if (isPreviewOnly) {
        // 如果只是預覽，這個邏輯保持不變
        const previewStyle = document.getElementById('preview-font-style') || document.createElement('style');
        previewStyle.id = 'preview-font-style';
        previewStyle.innerHTML = newStyle;
        if (!document.getElementById('preview-font-style')) document.head.appendChild(previewStyle);
        document.getElementById('font-preview').style.fontFamily = `'${fontName}', 'bulangni', sans-serif`;
    } else {
        // 【核心】如果是全域應用，就同時定義字體並告訴整個 body 去使用它
        dynamicFontStyle.innerHTML = `
            ${newStyle}
            body {
              font-family: '${fontName}', 'bulangni', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif !important;
            }`;
    }
}


        async function resetToDefaultFont() {
            // 1. 清除全域字體樣式
            dynamicFontStyle.innerHTML = ''; 
            
            // 2. 更新並保存設置
            state.globalSettings.fontUrl = '';
            await db.globalSettings.put(state.globalSettings);
            
            // 3. 【核心修復】明確地將全域預覽區的字體也恢復為預設
            const globalPreview = document.getElementById('font-preview');
            globalPreview.style.fontFamily = ''; // 移除內聯樣式
            
            // 4. 應用一下空的字體設置，確保所有地方都恢復
            applyCustomFont('', true);
            
            alert('已恢復預設字體。');
        }



async function loadAllDataFromDB() {
    // ▼▼▼ 【核心修改在這裡】 ▼▼▼
    const [
        chatsArr,
        apiConfig,
        globalSettings,
        userStickers,
        charStickers,
        worldBooks,
        musicLib,
        personaPresets,
        qzoneSettings,
        initialFavorites,
    apiPresets,
bubbleStylePresets
] = await Promise.all([
        db.chats.toArray(),
        db.apiConfig.get('main'),
        db.globalSettings.get('main'),
        db.userStickers.toArray(),
        db.charStickers.toArray(),
        db.worldBooks.toArray(),
        db.musicLibrary.get('main'),
        db.personaPresets.toArray(),
        db.qzoneSettings.get('main'),
        db.favorites.orderBy('timestamp').reverse().toArray(),
    db.apiPresets.toArray(),    db.bubbleStylePresets.toArray()
]);
    // ▲▲▲ 【修改結束】 ▲▲▲

    state.chats = chatsArr.reduce((acc, chat) => {
            // 【全新】為舊的群聊資料相容專屬表情庫
        if (chat.isGroup && (!chat.settings || !chat.settings.stickerLibrary)) {
            if (!chat.settings) chat.settings = {}; // 以防萬一連settings都沒有
            chat.settings.stickerLibrary = [];
            console.log(`為舊群聊 "${chat.name}" 補全了專屬表情庫(stickerLibrary)屬性。`);
        }
            // 相容舊資料：為沒有專屬表情庫的角色添加一個空的表情庫
        if (!chat.isGroup && (!chat.settings || !chat.settings.stickerLibrary)) {
            if (!chat.settings) chat.settings = {}; // 以防萬一連settings都沒有
            chat.settings.stickerLibrary = [];
            console.log(`為舊角色 "${chat.name}" 補全了專屬表情庫(stickerLibrary)屬性。`);
        }
        // ▲▲▲ 修改結束 ▲▲▲

    if (typeof chat.unreadCount === 'undefined') {
        chat.unreadCount = 0; // 如果這個聊天物件沒有 unreadCount 屬性，就給它初始化為 0
    }
    // ▼▼▼ 在這裡黏貼下面的“資料移轉”代碼 ▼▼▼

        // ★★★【核心重構：資料移轉腳本】★★★
        // 檢查是否是群聊，並且其成員物件使用的是舊的 `name` 結構
        if (chat.isGroup && chat.members && chat.members.length > 0 && chat.members[0].name) {
            console.log(`檢測到舊版群聊資料 for "${chat.name}"，正在執行遷移...`);
            chat.members.forEach(member => {
                // 如果這個成員物件沒有 originalName，說明是舊資料
                if (typeof member.originalName === 'undefined') {
                    member.originalName = member.name; // 將舊的 name 作為 originalName
                    member.groupNickname = member.name; // 同時創建一個初始的 groupNickname
                    delete member.name; // 刪除舊的、有歧義的 name 欄位
                    needsUpdate = true; // 標記需要存回資料庫
                }
            });
             console.log(`遷移完成 for "${chat.name}"`);
        }

        // --- ▼▼▼ 核心修復就在這裡 ▼▼▼ ---
        // 檢查1：如果是一個單聊，並且沒有 status 屬性
        if (!chat.isGroup && !chat.status) {
            // 就為它補上一個預設的 status 物件
            chat.status = {
                text: '線上',
                lastUpdate: Date.now(),
                isBusy: false
            };
            console.log(`為舊角色 "${chat.name}" 補全了status屬性。`);
        }
        // --- ▲▲▲ 修復結束 ▲▲▲

        // --- ▼▼▼ 核心修復就在這裡 ▼▼▼ ---
        // 檢查2：相容最新的“關係”功能
        if (!chat.isGroup && !chat.relationship) {
            // 如果是單聊，且沒有 relationship 物件，就補上一個默認的
            chat.relationship = {
                status: 'friend',
                blockedTimestamp: null,
                applicationReason: ''
            };
            console.log(`為舊角色 "${chat.name}" 補全了 relationship 屬性。`);
        }
        // --- ▲▲▲ 修復結束 ▲▲▲

    // ▼▼▼ 在這裡添加 ▼▼▼
    if (!chat.isGroup && (!chat.settings || !chat.settings.aiAvatarLibrary)) {
        if (!chat.settings) chat.settings = {}; // 以防萬一連settings都沒有
        chat.settings.aiAvatarLibrary = [];
        console.log(`為舊角色 "${chat.name}" 補全了aiAvatarLibrary屬性。`);
    }
    // ▲▲▲ 添加結束 ▲▲▲
    // ▼▼▼ 在這裡黏貼新代碼 ▼▼▼
// 相容舊資料：為沒有總結設置的聊天添加預設值
if (!chat.settings.summary) {
    chat.settings.summary = {
        enabled: false,
        mode: 'auto',
        count: 20,
        prompt: '請你以第三人稱的視角，客觀、冷靜、不帶任何感情色彩地總結以下對話的核心事件和資訊。禁止進行任何角色扮演或添加主觀評論。',
        lastSummaryIndex: -1 // -1表示從未總結過
    };
}
// ▲▲▲ 新代碼黏貼結束 ▲▲▲

    // 相容舊資料：為沒有NPC庫的單聊角色添加空的NPC庫
    if (!chat.isGroup && !chat.npcLibrary) {
        chat.npcLibrary = [];
        console.log(`為舊角色 "${chat.name}" 補全了 npcLibrary 屬性。`);
    }
    // ▲▲▲ 黏貼結束 ▲▲▲
// ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼
// 相容舊資料：為沒有微博設置的單聊角色添加空的微博設置
if (!chat.isGroup && (!chat.settings.weiboProfession || typeof chat.settings.weiboInstruction === 'undefined')) {
    chat.settings.weiboProfession = '';
    chat.settings.weiboInstruction = '';
    console.log(`為舊角色 "${chat.name}" 補全了微博設置屬性。`);
}
// ▲▲▲ 黏貼結束 ▲▲▲

        if (!chat.musicData) chat.musicData = { totalTime: 0 };
        if (chat.settings && chat.settings.linkedWorldBookId && !chat.settings.linkedWorldBookIds) {
            chat.settings.linkedWorldBookIds = [chat.settings.linkedWorldBookId];
            delete chat.settings.linkedWorldBookId;
        }

    // 相容舊資料，為沒有 isPinned 屬性的聊天添加預設值
    if (typeof chat.isPinned === 'undefined') {
        chat.isPinned = false;
    }

// ▼▼▼ 【V2最終修復版】統一修復並初始化所有角色的手機資料 ▼▼▼
if (!chat.isGroup) {
    // 第一步：確保最外層的 characterPhoneData 對象存在
    if (!chat.characterPhoneData) {
        chat.characterPhoneData = {}; // 如果不存在，就創建一個空的
    }

    // 第二步：逐一檢查並補全所有APP的資料結構
    // 這樣無論角色多老，都能確保所有欄位都存在
    if (!chat.characterPhoneData.widgets) chat.characterPhoneData.widgets = {};
    if (!chat.characterPhoneData.lastGenerated) chat.characterPhoneData.lastGenerated = null;
    if (!chat.characterPhoneData.chats) chat.characterPhoneData.chats = {};
    if (!chat.characterPhoneData.shoppingCart) chat.characterPhoneData.shoppingCart = [];
    if (!chat.characterPhoneData.memos) chat.characterPhoneData.memos = [];
    if (!chat.characterPhoneData.browserHistory) chat.characterPhoneData.browserHistory = [];
    if (!chat.characterPhoneData.photoAlbum) chat.characterPhoneData.photoAlbum = [];
    if (!chat.characterPhoneData.bank) chat.characterPhoneData.bank = { balance: 0, transactions: [] };
    if (!chat.characterPhoneData.trajectory) chat.characterPhoneData.trajectory = [];
    if (!chat.characterPhoneData.appUsage) chat.characterPhoneData.appUsage = [];
    if (!chat.characterPhoneData.diary) chat.characterPhoneData.diary = []; // 核心修復！
     if (!chat.characterPhoneData.appWallpaper) {
        chat.characterPhoneData.appWallpaper = '';
    }
}
// ▲▲▲ 修正結束 ▲▲▲
// 相容舊資料，為沒有後臺活動設置的群聊添加預設值
if (chat.isGroup && (!chat.settings || typeof chat.settings.backgroundActivity === 'undefined')) {
    if (!chat.settings) chat.settings = {}; // 以防萬一連settings都沒有
    chat.settings.backgroundActivity = {
        enabled: false,
        interval: 120, // 默認120秒
        lastActivityTimestamp: 0
    };
}
// ▼▼▼ Part B: 在這裡黏貼相容舊資料的代碼 ▼▼▼
// 相容舊資料：為沒有情侶頭像設置的角色添加預設值
if (typeof chat.settings.isCoupleAvatar === 'undefined') {
    chat.settings.isCoupleAvatar = false;
    chat.settings.coupleAvatarDescription = '';
}
// ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼

// ▼▼▼ 【領養系統改造】寵物系統初始化/相容代碼 ▼▼▼

// 1. 為所有角色（包括新舊資料）確保有 petAdopted 標誌
if (!chat.isGroup && typeof chat.settings.petAdopted === 'undefined') {
    // 如果 pet 物件已存在，說明是老用戶，默認已領養
    if (chat.settings.pet && chat.settings.pet.type !== '無') {
        chat.settings.petAdopted = true;
    } else {
        // 如果沒有 pet 物件，說明是新使用者或之前就沒用寵物，默認未領養
        chat.settings.petAdopted = false;
    }
    console.log(`為角色 "${chat.name}" 初始化了寵物領養狀態: ${chat.settings.petAdopted}`);
}

// 2. 相容舊的 pet 物件，確保新欄位存在（這段代碼和之前一樣，保留即可）
if (!chat.isGroup && chat.settings.pet) {
    if (typeof chat.settings.pet.persona === 'undefined') {
        chat.settings.pet.persona = '一隻可愛的小寵物，對世界充滿好奇。';
    }
    if (!chat.settings.pet.petChatHistory) {
        chat.settings.pet.petChatHistory = [];
    }
    if (!chat.settings.pet.status) {
        chat.settings.pet.status = { 
            hunger: 100, 
            happiness: 100, 
            intimacyToUser: 50, 
            intimacyToChar: 50,
            lastUpdated: Date.now()
        };
    } else {
        if (typeof chat.settings.pet.status.intimacyToUser === 'undefined') chat.settings.pet.status.intimacyToUser = 50;
        if (typeof chat.settings.pet.status.intimacyToChar === 'undefined') chat.settings.pet.status.intimacyToChar = 50;
        if (typeof chat.settings.pet.status.lastUpdated === 'undefined') chat.settings.pet.status.lastUpdated = Date.now();
    }
}
// ▲▲▲ 改造結束 ▲▲▲
        // 相容舊資料：為沒有記憶互通設置的聊天添加一個空的陣列
        if (!chat.settings.linkedMemories) {
            chat.settings.linkedMemories = [];
        }
            // ▼▼▼ 在這裡新增下面這段代碼，以相容舊資料 ▼▼▼
    // 為舊資料添加預設的記憶條數設置
    if (typeof chat.settings.linkMemoryDepth === 'undefined') {
        chat.settings.linkMemoryDepth = 5;
    }
    // ▲▲▲ 新增結束 ▲▲▲
              // ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼
        // 相容線下模式設置
        if (!chat.settings.offlineMode) {
            chat.settings.offlineMode = {
                enabled: false,
                prompt: '',
                style: '',
                wordCount: 300,
                presets: []
            };
        }
        // ▲▲▲ 新代碼黏貼結束 ▲▲▲  
        
        // ▼▼▼ 【全新】在這裡添加對角色手機外觀設置的相容代碼 ▼▼▼
        if (!chat.isGroup) { // 只為單聊角色添加
            if (!chat.characterPhoneData) {
                chat.characterPhoneData = {}; // 以防萬一連 characterPhoneData 都沒有
            }
            if (!chat.characterPhoneData.wallpaper) {
                chat.characterPhoneData.wallpaper = ''; // 初始化壁紙為空
            }
            if (!chat.characterPhoneData.appIcons) {
                chat.characterPhoneData.appIcons = {}; // 初始化App圖示為空物件
            }
        }
        // ▲▲▲ 相容代碼添加結束 ▲▲▲
        // 【全新】為舊角色資料相容微博獨立設置
if (!chat.isGroup) {
    if (!chat.settings.weiboNickname) {
        chat.settings.weiboNickname = chat.name; // 默認使用角色名作為微博昵稱
    }
    if (!chat.settings.weiboAvatar) {
        chat.settings.weiboAvatar = chat.settings.aiAvatar; // 默認使用AI頭像
    }
    if (!chat.settings.weiboAvatarFrame) {
        chat.settings.weiboAvatarFrame = chat.settings.aiAvatarFrame || ''; // 默認使用AI頭像框
    }
    if (!chat.settings.weiboBackground) {
        chat.settings.weiboBackground = 'https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg'; // 給一個默認背景
    }
    // weiboProfession 和 weiboInstruction 之前已經相容過了，這裡不用重複
}
        // 相容舊資料：為沒有微博設置的單聊角色添加空的微博設置
        if (!chat.isGroup && (!chat.settings.weiboProfession || typeof chat.settings.weiboInstruction === 'undefined')) {
            chat.settings.weiboProfession = '';
            chat.settings.weiboInstruction = '';
            console.log(`為舊角色 "${chat.name}" 補全了微博設置屬性。`);
        }
        
        // ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼
        // 【全新】為舊角色資料相容微博粉絲/關注數
        if (!chat.isGroup && (typeof chat.settings.weiboFansCount === 'undefined' || typeof chat.settings.weiboFollowingCount === 'undefined')) {
            const initialStats = getInitialWeiboStats(chat);
            chat.settings.weiboFansCount = initialStats.fans;
            chat.settings.weiboFollowingCount = initialStats.following;
            console.log(`為舊角色 "${chat.name}" 初始化了微博數據。`);
        }
        // ▲▲▲ 新代碼黏貼結束 ▲▲▲
    // ▼▼▼ 在這個迴圈的末尾，acc[chat.id] = chat; 之前，添加下面這段代碼 ▼▼▼
    if (!chat.isGroup && (!chat.settings || typeof chat.settings.minimaxVoiceId === 'undefined')) {
        if (!chat.settings) chat.settings = {};
        chat.settings.minimaxVoiceId = ''; // 默認為空
        console.log(`為舊角色 "${chat.name}" 補全了 minimaxVoiceId 屬性。`);
    }
    // ▲▲▲ 添加結束 ▲▲▲
// ▲▲▲ 新代碼黏貼結束 ▲▲▲
        // ▲▲▲ 新代碼黏貼結束 ▲▲▲
        acc[chat.id] = chat;
        return acc;
    }, {});
    state.apiConfig = apiConfig || { 
    id: 'main', 
    proxyUrl: '', 
    apiKey: '', 
    model: '',
    // 【核心新增】為舊資料添加預設空值
    minimaxGroupId: '',
    minimaxApiKey: ''
};
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 步驟 3.1：在 loadAllDataFromDB 函數中，找到並【替換】這行代碼 ▼▼▼

state.globalSettings = globalSettings || { 
    id: 'main', 
    ringtoneUrl: 'https://files.catbox.moe/3w7gla.mp3',
    notificationSoundUrl: 'https://files.catbox.moe/k369mf.mp3', // <-- 在這裡新增這一行
    widgetData: {}, 
    wallpaper: 'linear-gradient(135deg, #89f7fe, #66a6ff)', 
    lockscreenWallpaper: 'linear-gradient(135deg, #764ba2, #667eea)',
    password: '',
    fontUrl: '', 
    enableBackgroundActivity: false, 
    backgroundActivityInterval: 60,
    blockCooldownHours: 1,
    appIcons: { ...DEFAULT_APP_ICONS },
    appLabels: {},
    ringtoneUrl: 'https://files.catbox.moe/3w7gla.mp3',
    notificationSoundUrl: 'https://files.catbox.moe/k369mf.mp3', 
    widgetData: {}, // 【核心修改】在這裡新增一個空物件，用來存放你的自訂內容
// 在 state.globalSettings 的初始化對象裡添加：
homeAvatarFrame: '', // 為主螢幕頭像框添加預設空值

    globalChatBackground: '',
    homeIconWidgetTextColor: '#FFFFFF', // <-- 修改這裡的名字
    userBalance: 520,
  // ▼▼▼ 在這裡黏貼新代碼 ▼▼▼
    homeAvatarFrame: '' // 為主螢幕頭像框添加預設空值
    // ▲▲▲ 新代碼黏貼結束 ▲▲▲
};
// 確保即使從舊資料庫載入，這個屬性也存在
if (!state.globalSettings.widgetData) {
    state.globalSettings.widgetData = {};
}
// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 在這裡黏貼下面這段新代碼 (或者修改你已有的) ▼▼▼
if (!state.globalSettings.homeIconWidgetTextColor) { // <-- 修改這裡的名字
    state.globalSettings.homeIconWidgetTextColor = '#FFFFFF';
}
// 【全新】相容字體陰影設置
if (typeof state.globalSettings.removeHomeFontShadow === 'undefined') {
    state.globalSettings.removeHomeFontShadow = false;
}
// ▲▲▲ 新代碼黏貼結束 ▲▲▲
// ▼▼▼ 【全新】在這裡黏貼下面的相容性代碼 ▼▼▼
// 相容舊資料：如果載入的設置裡沒有appLabels，就給它一個空物件
if (!state.globalSettings.appLabels) {
    state.globalSettings.appLabels = {};
}
// ▲▲▲ 新代碼黏貼結束 ▲▲▲

    // ▼▼▼ 在這裡添加下面這行代碼 ▼▼▼
    // 【核心新增】載入歌詞欄設置，如果不存在則使用預設值
    lyricsBarSettings = state.globalSettings.lyricsBarSettings || lyricsBarSettings;
    // ▲▲▲ 添加結束 ▲▲▲

// 【核心修改】合併已保存的圖示和預設圖示，防止更新後舊資料丟失新圖示
state.globalSettings.appIcons = { ...DEFAULT_APP_ICONS, ...(state.globalSettings.appIcons || {}) };

    state.userStickers = userStickers || [];
    state.charStickers = charStickers || []; 
    state.worldBooks = worldBooks || [];
    musicState.playlist = musicLib?.playlist || [];
    state.personaPresets = personaPresets || [];
state.apiPresets = apiPresets || [];
state.bubbleStylePresets = bubbleStylePresets || [];
// ▼▼▼ 在 loadAllDataFromDB 函數裡，用下面這整塊代碼替換舊的 qzoneSettings 初始化代碼 ▼▼▼

// ▼▼▼ 用這塊【帶有微博用戶設定】的代碼替換 ▼▼▼
state.qzoneSettings = qzoneSettings || { 
    id: 'main', 
    nickname: '{{user}}', 
    avatar: 'https://files.catbox.moe/q6z5fc.jpeg', 
    banner: 'https://files.catbox.moe/r5heyt.gif',
    weiboAvatar: 'https://files.catbox.moe/q6z5fc.jpeg',
    weiboNickname: '你的昵稱',
    weiboFansCount: '0',
    weiboBackground: 'https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg',
    // 【核心新增】在這裡為微博用戶添加專屬的職業和人設欄位！
    weiboUserProfession: '點擊設置職業', 
    weiboUserPersona: '一個普通的微博用戶。',
    weiboUserPersonaPresets: []
};
// 相容舊資料，如果載入進來的資料沒有這些新欄位，就補上預設值
if (!state.qzoneSettings.weiboAvatar) state.qzoneSettings.weiboAvatar = state.qzoneSettings.avatar || 'https://files.catbox.moe/q6z5fc.jpeg';
if (!state.qzoneSettings.weiboNickname) state.qzoneSettings.weiboNickname = state.qzoneSettings.nickname || '你的昵稱';
if (!state.qzoneSettings.weiboFansCount) state.qzoneSettings.weiboFansCount = '0';
if (!state.qzoneSettings.weiboBackground) state.qzoneSettings.weiboBackground = 'https://i.postimg.cc/mk93Y3j1/weibo-bg-default.jpg';
// 【核心新增】相容舊的用戶微博設定
if (!state.qzoneSettings.weiboUserProfession) state.qzoneSettings.weiboUserProfession = '點擊設置職業';
if (!state.qzoneSettings.weiboUserPersona) state.qzoneSettings.weiboUserPersona = '一個普通的微博用戶。';
if (!state.qzoneSettings.weiboUserPersonaPresets) state.qzoneSettings.weiboUserPersonaPresets = [];
// ▼▼▼ 在這裡黏貼新代碼 ▼▼▼
if (!state.qzoneSettings.weiboAvatarFrame) state.qzoneSettings.weiboAvatarFrame = '';
// ▲▲▲ 黏貼結束 ▲▲▲

// ▲▲▲ 替換結束 ▲▲▲

    // ▼▼▼ 【確保這一行在 Promise.all 之後，並使用解構賦值得到的 initialFavorites】 ▼▼▼
    allFavoriteItems = initialFavorites || [];
    // ▲▲▲ 【修改結束】 ▲▲▲

// 在 loadAllDataFromDB 函數末尾，init(); 調用之前添加
if (typeof state.globalSettings.notificationSoundUrl === 'undefined') {
    state.globalSettings.notificationSoundUrl = 'https://files.catbox.moe/k369mf.mp3';
}


}

        // ▼▼▼ 【全新 | 支持臨時歌曲】請用這個新版本替換舊的 saveGlobalPlaylist 函數 ▼▼▼
async function saveGlobalPlaylist() {
    // 1. 在保存前，先從當前播放清單中過濾掉所有被標記為 isTemporary 的歌曲
    const permanentPlaylist = musicState.playlist.filter(track => !track.isTemporary);
    
    // 2. 只將這個“永久播放清單”保存到資料庫中
    await db.musicLibrary.put({ id: 'main', playlist: permanentPlaylist });
    console.log("已將永久播放清單保存到資料庫。");
}
// ▲▲▲ 替換結束 ▲▲▲

        function formatTimestamp(timestamp) { if (!timestamp) return ''; const date = new Date(timestamp); const hours = String(date.getHours()).padStart(2, '0'); const minutes = String(date.getMinutes()).padStart(2, '0'); return `${hours}:${minutes}`; }

        function showNotification(chatId, messageContent) { playNotificationSound();clearTimeout(notificationTimeout); const chat = state.chats[chatId]; if (!chat) return; const bar = document.getElementById('notification-bar'); document.getElementById('notification-avatar').src = chat.settings.aiAvatar || chat.settings.groupAvatar || defaultAvatar; document.getElementById('notification-content').querySelector('.name').textContent = chat.name; document.getElementById('notification-content').querySelector('.message').textContent = messageContent; const newBar = bar.cloneNode(true); bar.parentNode.replaceChild(newBar, bar); newBar.addEventListener('click', () => { openChat(chatId); newBar.classList.remove('visible'); }); newBar.classList.add('visible'); notificationTimeout = setTimeout(() => { newBar.classList.remove('visible'); }, 4000); }

      // ▼▼▼ 步驟 1.1：用下面這【一整塊】代碼，完整替換掉舊的 updateClock 函數 ▼▼▼
/* ▼▼▼ 步驟 1：將這一整塊全新的功能函數，黏貼到您的JS代碼的功能函式定義區 ▼▼▼ */

/**
 * 【全新添加】顯示一個包含多個選項的操作功能表模態框
 * 這是讓圖片編輯時能夠選擇“本地上傳”或“URL”的關鍵函數！
 * @param {string} title - 模態框的標題
 * @param {Array<object>} options - 按鈕選項陣列, e.g., [{ text: '按鈕文字', value: '返回值' }]
 * @returns {Promise<string|null>} - 返回使用者點擊按鈕的value，如果取消則返回null
 */
function showChoiceModal(title, options) {
    return new Promise(resolve => {
        // 複用你現有的自訂模態框
        const modal = document.getElementById('preset-actions-modal');
        const footer = modal.querySelector('.custom-modal-footer');
        
        // 清空舊按鈕並動態創建新按鈕
        footer.innerHTML = ''; 

        options.forEach(option => {
            const button = document.createElement('button');
            button.textContent = option.text;
            button.onclick = () => {
                modal.classList.remove('visible');
                resolve(option.value); // 返回被點擊按鈕的值
            };
            footer.appendChild(button);
        });

        // 添加一個標準的取消按鈕
        const cancelButton = document.createElement('button');
        cancelButton.textContent = '取消';
        cancelButton.style.marginTop = '8px';
        cancelButton.style.borderRadius = '8px';
        cancelButton.style.backgroundColor = '#f0f0f0';
        cancelButton.onclick = () => {
            modal.classList.remove('visible');
            resolve(null); // 用戶取消，返回 null
        };
        footer.appendChild(cancelButton);

        modal.classList.add('visible');
    });
}
// ▼▼▼ 【最終正確版】請用這整塊代碼，完整替換舊的 deleteExpiredSearchedSongs 函數 ▼▼▼

/**
 * 【全新重構】檢查並刪除所有失效的API歌曲
 * 核心邏輯：不再依賴任何標籤，直接根據連結特徵識別需要檢查的歌曲。
 */
async function deleteExpiredSearchedSongs() {
    await showCustomAlert("請稍候...", "正在檢查播放清單中所有線上歌曲的有效性...");

    // 1. 【核心改變】我們不再尋找 isTemporary 標籤！
    // 而是直接找出所有 src 連結來自於 API 伺服器的歌曲。
    // 這是一個絕對可靠的識別方法，無論它有沒有被正確保存。
    const songsToCheck = musicState.playlist.filter(track => track.src && track.src.includes('api.vkeys.cn'));

    if (songsToCheck.length === 0) {
        await showCustomAlert('提示', '播放清單中沒有需要檢查的線上歌曲。');
        return;
    }

    const songsToDelete = [];
    const twentyFourHoursAgo = Date.now() - (24 * 60 * 60 * 1000);

    // 2. 對每一首識別出的歌曲，進行嚴格的“體檢”
    await Promise.all(songsToCheck.map(async (track) => {
        // 條件1：檢查連結本身是否已經失效（無法播放）
        const isUrlInvalid = !(await checkAudioAvailability(track.src));
        
        // 條件2：檢查添加時間是否超過24小時（作為雙重保險）
        const isOlderThan24h = track.addedTimestamp && track.addedTimestamp < twentyFourHoursAgo;

        // 只要滿足【任意一個】條件，就判定為“失效”
        if (isUrlInvalid || isOlderThan24h) {
            songsToDelete.push(track);
            console.log(`標記刪除: ${track.name} (原因: ${isUrlInvalid ? '連結失效' : ''} ${isOlderThan24h ? '超過24小時' : ''})`);
        }
    }));

    // 3. 根據檢查結果進行回饋和操作 (這部分邏輯不變)
    if (songsToDelete.length === 0) {
        await showCustomAlert('檢查完成', '播放清單中的所有線上歌曲當前均有效。');
        return;
    }

    const confirmed = await showCustomConfirm(
        '確認清理',
        `檢測到 ${songsToDelete.length} 首已失效的線上歌曲。確定要將它們從列表中移除嗎？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (!confirmed) return;

    // 執行刪除...
    const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
    musicState.playlist = musicState.playlist.filter(track => !songsToDelete.includes(track));
    const newIndex = currentTrack ? musicState.playlist.findIndex(t => t.src === currentTrack.src && t.name === currentTrack.name) : -1;

    if (newIndex === -1) {
        if (musicState.isPlaying) {
            audioPlayer.pause();
            audioPlayer.src = '';
        }
        musicState.isPlaying = false;
        if (musicState.playlist.length > 0) {
            playSong(0); 
        } else {
            musicState.currentIndex = -1;
            updatePlayerUI();
        }
    } else {
        musicState.currentIndex = newIndex;
        updatePlayerUI();
    }
    
    await saveGlobalPlaylist();
    updatePlaylistUI();
    await showCustomAlert('清理完成', `${songsToDelete.length} 首歌曲已從列表中移除。`);
}
// ▲▲▲ 替換結束 ▲▲▲



/**
 * 【已修復】更新所有時鐘（狀態列和鎖屏）
 */
function updateClock() { 
    const now = new Date(); 
    const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' }); 
    const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' }); 
    
    // 更新狀態列時鐘 (這個元素一直存在)
    const statusBarTime = document.getElementById('status-bar-time');
    if (statusBarTime) {
        statusBarTime.textContent = timeString; 
    }

    // 更新鎖屏時鐘 (只有當鎖屏元素存在時才更新，避免報錯)
    const lockTime = document.getElementById('lock-main-time');
    const lockDate = document.getElementById('lock-main-date');
    if (lockTime) {
        lockTime.textContent = timeString;
    }
    if (lockDate) {
        lockDate.textContent = dateString;
    }
}



/**
 * 【終極健壯版】解析AI返回的、可能格式不規範的回應內容
 * @param {string} content - AI返回的原始字串
 * @returns {Array} - 一個標準化的消息物件陣列
 */
function parseAiResponse(content) {
    const trimmedContent = content.trim();

    // 方案1：【最優先】嘗試作為標準的、單一的JSON陣列解析
    // 這是最理想、最高效的情況
    if (trimmedContent.startsWith('[') && trimmedContent.endsWith(']')) {
        try {
            const parsed = JSON.parse(trimmedContent);
            if (Array.isArray(parsed)) {
                console.log("解析成功：標準JSON陣列格式。");
                return parsed;
            }
        } catch (e) {
            // 如果解析失敗，說明它雖然看起來像個陣列，但內部格式有問題。
            // 此時我們不報錯，而是繼續嘗試下面的“強力解析”方案。
            console.warn("標準JSON陣列解析失敗，將嘗試強力解析...");
        }
    }

    // 方案2：【強力解析】使用規則運算式，從混亂的字串中提取出所有獨立的JSON物件
    // 這能完美解決您遇到的 "(Timestamp: ...)[{...}](Timestamp: ...)[{...}]" 這種格式
    const jsonMatches = trimmedContent.match(/{[^{}]*}/g);

    if (jsonMatches) {
        const results = [];
        for (const match of jsonMatches) {
            try {
                // 嘗試解析每一個被我們“揪”出來的JSON字串
                const parsedObject = JSON.parse(match);
                results.push(parsedObject);
            } catch (e) {
                // 如果某個片段不是有效的JSON，就忽略它，繼續處理下一個
                console.warn("跳過一個無效的JSON片段:", match);
            }
        }

        // 如果我們成功提取出了至少一個有效的JSON物件，就返回這個結果
        if (results.length > 0) {
            console.log("解析成功：通過強力提取模式。");
            return results;
        }
    }
    
    // 方案3：【最終備用】如果以上所有方法都失敗了，說明AI返回的可能就是純文字
    // 我們將原始的、未處理的內容，包裝成一個標準的文本消息物件返回，確保程式不會崩潰
    console.error("所有解析方案均失敗！將返回原始文本。");
    return [{ type: 'text', content: content }];
}

    function renderApiSettings() {
    // 1. 更新 API 相關的輸入框
    document.getElementById('proxy-url').value = state.apiConfig.proxyUrl || '';
    document.getElementById('api-key').value = state.apiConfig.apiKey || '';
        // ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼
    // 【核心新增】載入 Minimax 設置
    document.getElementById('minimax-group-id').value = state.apiConfig.minimaxGroupId || '';
    document.getElementById('minimax-api-key').value = state.apiConfig.minimaxApiKey || '';
    // ▲▲▲ 黏貼結束 ▲▲▲
    // 如果你有模型選擇，也一併更新
    if (document.getElementById('model-select')) {
        document.getElementById('model-select').value = state.apiConfig.model || 'gpt-4';
    }

    // 2. 更新後臺活動相關的開關和輸入框
    
    // ★★★★★ 這就是我們這次修復的核心 ★★★★★
    // 使用 !!state.globalSettings.enableBackgroundActivity 這種寫法，
    // 確保當這個設置還不存在時 (比如第一次打開)，開關也能正確地顯示為 false (關閉狀態)
    document.getElementById('background-activity-switch').checked = !!state.globalSettings.enableBackgroundActivity;
    // ★★★★★ 修復結束 ★★★★★

    document.getElementById('background-interval-input').value = state.globalSettings.backgroundActivityInterval || 60;
    document.getElementById('block-cooldown-input').value = state.globalSettings.blockCooldownHours || 1;

    // 3. 渲染預設和頻率的下拉清單
    renderApiPresetSelector();
    renderBackgroundFrequencySelector();
}

// ▼▼▼ 【全新】黏貼這個完整的函數 ▼▼▼
/**
 * 渲染後臺活動的角色選擇和頻率設置UI
 */
function renderBackgroundFrequencySelector() {
    const container = document.getElementById('background-activity-char-list');
    const detailsContainer = document.getElementById('background-activity-details');
    const masterSwitch = document.getElementById('background-activity-switch');

    // 根據總開關的狀態，決定是否顯示詳細設置
    detailsContainer.style.display = masterSwitch.checked ? 'block' : 'none';
    
    container.innerHTML = ''; // 清空舊列表
    const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (singleChats.length === 0) {
        container.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">還沒有可以設置的角色</p>';
        return;
    }

    const config = state.globalSettings.backgroundActivityConfig || {};

    singleChats.forEach(chat => {
        const freq = config[chat.id] || 'none'; // 獲取當前角色的頻率設置
        let badgeHtml = '';
        if (freq !== 'none') {
            const freqText = { low: '低', medium: '中', high: '高' }[freq];
            badgeHtml = `<span class="char-freq-badge ${freq}">${freqText}</span>`;
        }

        const item = document.createElement('div');
        item.className = 'char-list-item';
        item.innerHTML = `
            <input type="checkbox" class="bg-char-checkbox" data-chat-id="${chat.id}">
            <span class="char-name">${chat.name}</span>
            ${badgeHtml}
        `;
        container.appendChild(item);
    });
}
// ▲▲▲ 新函數黏貼結束 ▲▲▲

        window.renderApiSettingsProxy = renderApiSettings;
// ▼▼▼ 請用這個【全新修正版】替換舊的 renderChatList 函數 ▼▼▼
async function renderChatList() {
    const chatListEl = document.getElementById('chat-list');
    chatListEl.innerHTML = '';

    // 1. 獲取所有聊天和分組資料
    const allChats = Object.values(state.chats);
    const allGroups = await db.qzoneGroups.toArray();

    if (allChats.length === 0) {
        chatListEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">點擊右上角 "+" 或群組圖示添加聊天</p>';
        return;
    }

    // 2. 將聊天明確地分為“置頂”和“未置頂”兩組
    const pinnedChats = allChats.filter(chat => chat.isPinned);
    const unpinnedChats = allChats.filter(chat => !chat.isPinned);

    // 3. 對置頂的聊天，僅按最新消息時間排序
    pinnedChats.sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));

    // 4. 【優先渲染】所有置頂的聊天
    pinnedChats.forEach(chat => {
        const item = createChatListItem(chat);
        chatListEl.appendChild(item);
    });

    // 5. 【接下來處理未置頂的聊天】應用您之前的分組邏輯
    // 為每個分組找到其內部最新的消息時間戳記 (只在未置頂聊天中查找)
    allGroups.forEach(group => {
        const latestChatInGroup = unpinnedChats
            .filter(chat => chat.groupId === group.id) // 找到屬於這個組的聊天
            .sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0))[0]; // 排序後取第一個
        
        group.latestTimestamp = latestChatInGroup ? (latestChatInGroup.history.slice(-1)[0]?.timestamp || 0) : 0;
    });

    // 根據分組的最新時間戳記，對分組本身進行排序
    allGroups.sort((a, b) => b.latestTimestamp - a.latestTimestamp);

    // 6. 遍歷排序後的分組，渲染其中的【未置頂】好友
    allGroups.forEach(group => {
        const groupChats = unpinnedChats
            .filter(chat => !chat.isGroup && chat.groupId === group.id)
            .sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));
        
        if (groupChats.length === 0) return; // 如果這個分組裡沒有未置頂的好友，就跳過

        const groupContainer = document.createElement('div');
        groupContainer.className = 'chat-group-container';
        
        // 【核心修改】下面這兩行代碼裡，我已經刪除了 collapsed 類，這樣默認就是展開的了！
        groupContainer.innerHTML = `
            <div class="chat-group-header">
                <span class="arrow">▼</span>
                <span class="group-name">${group.name}</span>
            </div>
            <div class="chat-group-content"></div>
        `;
        const contentEl = groupContainer.querySelector('.chat-group-content');

        groupChats.forEach(chat => {
            const item = createChatListItem(chat);
            contentEl.appendChild(item);
        });
        chatListEl.appendChild(groupContainer);
    });

    // 7. 最後，渲染所有【未置頂】的群聊和【未分組的】好友
    const remainingChats = unpinnedChats
        .filter(chat => chat.isGroup || (!chat.isGroup && !chat.groupId))
        .sort((a, b) => (b.history.slice(-1)[0]?.timestamp || 0) - (a.history.slice(-1)[0]?.timestamp || 0));
    
    remainingChats.forEach(chat => {
        const item = createChatListItem(chat);
        chatListEl.appendChild(item);
    });

    // 為所有分組標題添加折疊事件
    document.querySelectorAll('.chat-group-header').forEach(header => {
        header.addEventListener('click', () => {
            header.classList.toggle('collapsed');
            header.nextElementSibling.classList.toggle('collapsed');
        });
    });
}
// ▲▲▲ 替換結束 ▲▲▲


// ▼▼▼ 用這個【最終修正版】替換你專案中那個導致錯誤的 createChatListItem 函數 ▼▼▼
function createChatListItem(chat) {
    const lastMsgObj = chat.history.filter(msg => !msg.isHidden).slice(-1)[0] || {};
    let lastMsgDisplay;

    // --- 消息預覽的邏輯保持不變 ---
    if (!chat.isGroup && chat.relationship?.status === 'pending_user_approval') {
        lastMsgDisplay = `<span style="color: #ff8c00;">[好友申請] ${chat.relationship.applicationReason || '請求添加你為好友'}</span>`;
    } else if (!chat.isGroup && chat.relationship?.status === 'blocked_by_ai') {
        lastMsgDisplay = `<span style="color: #dc3545;">[你已被對方拉黑]</span>`;
    } else if (chat.isGroup) {
        if (lastMsgObj.type === 'pat_message') { lastMsgDisplay = `[系統消息] ${lastMsgObj.content}`; }
        else if (lastMsgObj.type === 'transfer') { lastMsgDisplay = '[轉帳]'; }
        else if (lastMsgObj.type === 'ai_image' || lastMsgObj.type === 'user_photo') { lastMsgDisplay = '[照片]'; }
        else if (lastMsgObj.type === 'voice_message') { lastMsgDisplay = '[語音]'; }
        else if (typeof lastMsgObj.content === 'string' && STICKER_REGEX.test(lastMsgObj.content)) { lastMsgDisplay = lastMsgObj.meaning ? `[表情: ${lastMsgObj.meaning}]` : '[表情]'; }
        else if (Array.isArray(lastMsgObj.content)) { lastMsgDisplay = `[圖片]`; }
        else { lastMsgDisplay = String(lastMsgObj.content || '...').substring(0, 20); }
        if (lastMsgObj.senderName && lastMsgObj.type !== 'pat_message') {
            lastMsgDisplay = `${lastMsgObj.senderName}: ${lastMsgDisplay}`;
        }
    } else {
        const statusText = chat.status?.text || '線上';
        lastMsgDisplay = `[${statusText}]`;
    }

    const lastMsgTimestamp = lastMsgObj?.timestamp;
    const timeDisplay = formatChatListTimestamp(lastMsgTimestamp);
    
    const container = document.createElement('div');
    container.className = 'chat-list-item-swipe-container';
    container.dataset.chatId = chat.id;

    const content = document.createElement('div');
    content.className = `chat-list-item-content ${chat.isPinned ? 'pinned' : ''}`;
    
    const avatar = chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar;
    
    // --- 【核心修正】在這裡，我們創建了一個新的右側容器，並把時間和未讀紅點都放了進去 ---
    content.innerHTML = `
        <div class="chat-list-item" data-chat-id="${chat.id}">
            <img src="${avatar || defaultAvatar}" class="avatar">
            <div class="info">
                <div class="name-line">
                    <span class="name">${chat.name}</span>
                    ${chat.isGroup ? '<span class="group-tag">群聊</span>' : ''}
                </div>
                <div class="last-msg" style="color: ${chat.isGroup ? 'var(--text-secondary)' : '#b5b5b5'}; font-style: italic;">${lastMsgDisplay}</div>
            </div>
            <div class="chat-list-right-column">
                <div class="chat-list-time">${timeDisplay}</div>
                <div class="unread-count-wrapper">
                    <span class="unread-count" style="display: none;">0</span>
                </div>
            </div>
        </div>
    `;
    
    // 後續的滑動按鈕邏輯保持不變
    const actions = document.createElement('div');
    actions.className = 'swipe-actions';
    const pinButtonText = chat.isPinned ? '取消置頂' : '置頂';
    const pinButtonClass = chat.isPinned ? 'unpin' : 'pin';
    actions.innerHTML = `
        <button class="swipe-action-btn ${pinButtonClass}">${pinButtonText}</button>
        <button class="swipe-action-btn delete">刪除</button>
    `;
    
    container.appendChild(content);
    container.appendChild(actions);
    
    // --- 【重要】現在這段代碼可以正常工作了，因為 .unread-count 元素又回來了！ ---
    const unreadCount = chat.unreadCount || 0;
    const unreadEl = content.querySelector('.unread-count');
    if (unreadCount > 0) {
        unreadEl.textContent = unreadCount > 99 ? '99+' : unreadCount;
        unreadEl.style.display = 'inline-flex';
    } else {
        unreadEl.style.display = 'none';
    }
    
    // 事件監聽邏輯保持不變
    const infoEl = content.querySelector('.info');
    if (infoEl) {
        infoEl.addEventListener('click', () => openChat(chat.id));
    }
const avatarEl = content.querySelector('.avatar, .avatar-with-frame');
if (avatarEl) {
     avatarEl.addEventListener('click', (e) => {
        e.stopPropagation();
        handleUserPat(chat.id, chat.name);
    });
}

    return container;
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 請用這個【帶診斷功能的全新版本】替換舊的 renderChatInterface 函數 ▼▼▼
function renderChatInterface(chatId) {
    cleanupWaimaiTimers();
    const chat = state.chats[chatId];
    if (!chat) return;
    exitSelectionMode();
    
    const messagesContainer = document.getElementById('chat-messages');
    const chatInputArea = document.getElementById('chat-input-area');
    const lockOverlay = document.getElementById('chat-lock-overlay');
    const lockContent = document.getElementById('chat-lock-content');

    messagesContainer.dataset.theme = chat.settings.theme || 'default';
    const fontSize = chat.settings.fontSize || 13;
    messagesContainer.style.setProperty('--chat-font-size', `${fontSize}px`);
    applyScopedCss(chat.settings.customCss || '', '#chat-messages', 'custom-bubble-style');
    
    document.getElementById('chat-header-title').textContent = chat.name;
    const statusContainer = document.getElementById('chat-header-status');
    const statusTextEl = statusContainer.querySelector('.status-text');

    if (chat.isGroup) {
        statusContainer.style.display = 'none';
        document.getElementById('chat-header-title-wrapper').style.justifyContent = 'center';
    } else {
        statusContainer.style.display = 'flex';
        document.getElementById('chat-header-title-wrapper').style.justifyContent = 'flex-start';
        statusTextEl.textContent = chat.status?.text || '線上';
        statusContainer.classList.toggle('busy', chat.status?.isBusy || false);
    }
    
    lockOverlay.style.display = 'none';
    chatInputArea.style.visibility = 'visible';
    lockContent.innerHTML = '';

    if (!chat.isGroup && chat.relationship.status !== 'friend') {
        lockOverlay.style.display = 'flex';
        chatInputArea.style.visibility = 'hidden';
        
        let lockHtml = '';
        switch (chat.relationship.status) {
            case 'blocked_by_user':
                // --- 【核心修改：在這裡加入診斷面板】 ---
                const isSimulationRunning = simulationIntervalId !== null;
                const blockedTimestamp = chat.relationship.blockedTimestamp;
                const cooldownHours = state.globalSettings.blockCooldownHours || 1;
                const cooldownMilliseconds = cooldownHours * 60 * 60 * 1000;
                const timeSinceBlock = Date.now() - blockedTimestamp;
                const isCooldownOver = timeSinceBlock > cooldownMilliseconds;
                const timeRemainingMinutes = Math.max(0, Math.ceil((cooldownMilliseconds - timeSinceBlock) / (1000 * 60)));

                lockHtml = `
                    <span class="lock-text">你已將“${chat.name}”拉黑。</span>
                    <button id="unblock-btn" class="lock-action-btn">解除拉黑</button>
                    <div style="margin-top: 20px; padding: 10px; border: 1px dashed #ccc; border-radius: 8px; font-size: 11px; text-align: left; color: #666; background: rgba(0,0,0,0.02);">
                        <strong style="color: #333;">【開發者診斷面板】</strong><br>
                        - 後臺活動總開關: ${state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已開啟</span>' : '<span style="color: red;">已關閉</span>'}<br>
                        - 系統心跳計時器: ${isSimulationRunning ? '<span style="color: green;">運行中</span>' : '<span style="color: red;">未運行</span>'}<br>
                        - 當前角色狀態: <strong>${chat.relationship.status}</strong><br>
                        - 需要冷靜(小時): <strong>${cooldownHours}</strong><br>
                        - 冷靜期是否結束: ${isCooldownOver ? '<span style="color: green;">是</span>' : `<span style="color: orange;">否 (還剩約 ${timeRemainingMinutes} 分鐘)</span>`}<br>
                        - 觸發條件: ${isCooldownOver && state.globalSettings.enableBackgroundActivity ? '<span style="color: green;">已滿足，等待下次系統心跳</span>' : '<span style="color: red;">未滿足</span>'}
                    </div>
                    <button id="force-apply-check-btn" class="lock-action-btn secondary" style="margin-top: 10px;">強制觸發一次好友申請檢測</button>
                `;
                // --- 【修改結束】 ---
                break;
            case 'blocked_by_ai':
                lockHtml = `
                    <span class="lock-text">你被對方拉黑了。</span>
                    <button id="apply-friend-btn" class="lock-action-btn">重新申請加為好友</button>
                `;
                break;
            
            case 'pending_user_approval':
                lockHtml = `
                    <span class="lock-text">“${chat.name}”請求添加你為好友：<br><i>“${chat.relationship.applicationReason}”</i></span>
                    <button id="accept-friend-btn" class="lock-action-btn">接受</button>
                    <button id="reject-friend-btn" class="lock-action-btn secondary">拒絕</button>
                `;
                break;

            // 【核心修正】修復當你申請後，你看到的介面
            case 'pending_ai_approval':
                lockHtml = `<span class="lock-text">好友申請已發送，等待對方通過...</span>`;
                break;
        }
        lockContent.innerHTML = lockHtml;
    }
    messagesContainer.innerHTML = '';
// ▼▼▼ 用這【一整塊】代碼，替換舊的背景設置邏輯 ▼▼▼
const chatScreen = document.getElementById('chat-interface-screen');

// 核心邏輯：單人背景優先於全域背景
const backgroundToApply = chat.settings.background || state.globalSettings.globalChatBackground;

if (backgroundToApply) {
    chatScreen.style.backgroundImage = `url(${backgroundToApply})`;
} else {
    chatScreen.style.backgroundImage = 'none';
}
// ▲▲▲ 替換結束 ▲▲▲
const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
chatScreen.style.backgroundColor = chat.settings.background ? 'transparent' : (isDarkMode ? '#000000' : '#f0f2f5');
    const history = chat.history;
    const totalMessages = history.length;
    currentRenderedCount = 0;
    const initialMessages = history.slice(-MESSAGE_RENDER_WINDOW);
let lastMessageTimestamp = null;

initialMessages.forEach(msg => {
    if (msg.isHidden) return; // 【新增】跳過隱藏消息

    if (isNewDay(msg.timestamp, lastMessageTimestamp)) {
        // 【核心修改】調用我們新的生成器函數
        const dateStampEl = createDateStampElement(msg.timestamp);
        messagesContainer.insertBefore(dateStampEl, document.getElementById('typing-indicator'));
    }
    
    appendMessage(msg, chat, true);
    
    lastMessageTimestamp = msg.timestamp;
});
    currentRenderedCount = initialMessages.length;
    if (totalMessages > currentRenderedCount) {
        prependLoadMoreButton(messagesContainer);
    }
    const typingIndicator = document.createElement('div');
    typingIndicator.id = 'typing-indicator';
    typingIndicator.style.display = 'none';
    typingIndicator.textContent = '對方正在輸入...';
    messagesContainer.appendChild(typingIndicator);
    setTimeout(() => messagesContainer.scrollTop = messagesContainer.scrollHeight, 0);
    renderChatPet();
}
// ▲▲▲ 替換結束 ▲▲▲

        function prependLoadMoreButton(container) { const button = document.createElement('button'); button.id = 'load-more-btn'; button.textContent = '載入更早的記錄'; button.addEventListener('click', loadMoreMessages); container.prepend(button); }

        function loadMoreMessages() { const messagesContainer = document.getElementById('chat-messages'); const chat = state.chats[state.activeChatId]; if (!chat) return; const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) loadMoreBtn.remove(); const totalMessages = chat.history.length; const nextSliceStart = totalMessages - currentRenderedCount - MESSAGE_RENDER_WINDOW; const nextSliceEnd = totalMessages - currentRenderedCount; const messagesToPrepend = chat.history.slice(Math.max(0, nextSliceStart), nextSliceEnd); const oldScrollHeight = messagesContainer.scrollHeight; // ▼▼▼ 請將這個完整的代碼塊，黏貼到被刪除的位置 ▼▼▼

// 1. 找到螢幕上已有的、最老的那條【真實消息】的時間戳記
const firstVisibleMessage = messagesContainer.querySelector('.message-wrapper:not(.date-stamp-wrapper)');
let subsequentMessageTimestamp = firstVisibleMessage ? parseInt(firstVisibleMessage.dataset.timestamp) : null;

// 2. 從後往前（從新到舊）遍歷我們要新載入的消息
messagesToPrepend.reverse().forEach(currentMsg => {
    // 檢查這條新消息和它後面那條（可能是螢幕上已有的，也可能是剛載入的）消息是否跨天
    if (subsequentMessageTimestamp && isNewDay(subsequentMessageTimestamp, currentMsg.timestamp)) {
        // 如果跨天，就為後面那條“較新”的消息創建一個日期戳
        const dateStampEl = createDateStampElement(subsequentMessageTimestamp);
        messagesContainer.prepend(dateStampEl);
    }
    
    // 正常地把當前這條新消息放到最前面
    prependMessage(currentMsg, chat);
    
    // 更新追蹤器，為下一次比較做準備
    subsequentMessageTimestamp = currentMsg.timestamp;
});

// 3. 【邊界處理】處理所有新載入消息的最前面（也就是整個聊天記錄的最老）的那條消息
// 它也需要一個日期戳
if (subsequentMessageTimestamp) {
    const dateStampEl = createDateStampElement(subsequentMessageTimestamp);
    messagesContainer.prepend(dateStampEl);
}

// ▲▲▲ 黏貼結束 ▲▲▲
currentRenderedCount += messagesToPrepend.length; const newScrollHeight = messagesContainer.scrollHeight; messagesContainer.scrollTop += (newScrollHeight - oldScrollHeight); if (totalMessages > currentRenderedCount) { prependLoadMoreButton(messagesContainer); } }

// ▼▼▼ 用這個【新版本】替換舊的 renderWallpaperScreen 函數 ▼▼▼
function renderWallpaperScreen() { 


      // ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼
    // 【核心修復】每次渲染此頁面時，都從 localStorage 讀取並設置開關的正確狀態
    const lockScreenEnabled = localStorage.getItem('lockScreenEnabled') !== 'false';
    const toggle = document.getElementById('enable-lock-screen-toggle');
    if (toggle) {
        toggle.checked = lockScreenEnabled;
    }
// ▼▼▼ 在這裡黏貼下面這段新代碼 (或者修改你已有的) ▼▼▼
document.getElementById('home-icon-widget-text-color-picker').value = state.globalSettings.homeIconWidgetTextColor || '#FFFFFF';
// 【全新】渲染字體陰影開關的狀態
document.getElementById('remove-home-font-shadow-toggle').checked = !!state.globalSettings.removeHomeFontShadow;
// ▲▲▲ 新代碼黏貼結束 ▲▲▲

    const preview = document.getElementById('wallpaper-preview'); 
    const bg = newWallpaperBase64 || state.globalSettings.wallpaper; 
    if (bg && bg.startsWith('data:image')) { 
        preview.style.backgroundImage = `url(${bg})`; 
        preview.textContent = ''; 
    } else if(bg) { 
        preview.style.backgroundImage = bg; 
        preview.textContent = '當前為漸變色'; 
    }

    // 鎖屏壁紙預覽 (新增邏輯)
    const lockscreenPreview = document.getElementById('lockscreen-wallpaper-preview');
    const lockBg = newLockscreenWallpaperBase64 || state.globalSettings.lockscreenWallpaper;
    if (lockBg && lockBg.startsWith('data:image')) {
        lockscreenPreview.style.backgroundImage = `url(${lockBg})`;
        lockscreenPreview.textContent = '';
    } else if (lockBg) {
        lockscreenPreview.style.backgroundImage = lockBg;
        lockscreenPreview.textContent = '當前為漸變色';
    }

    // 密碼輸入框 (新增邏輯)
    document.getElementById('password-set-input').value = state.globalSettings.password || '';
// ▼▼▼ 在 password-set-input 賦值的下一行，黏貼下面這【一整塊】新代碼 ▼▼▼

// 【全新】渲染全域聊天背景的預覽
const globalBgPreview = document.getElementById('global-bg-preview');
const globalBg = newGlobalBgBase64 || state.globalSettings.globalChatBackground;
if (globalBg && globalBg.startsWith('data:image')) {
    globalBgPreview.style.backgroundImage = `url(${globalBg})`;
    globalBgPreview.textContent = '';
} else if (globalBg) { // 相容未來可能支持的顏色代碼或漸變
    globalBgPreview.style.background = globalBg;
    globalBgPreview.textContent = '當前為漸變色';
} else {
    globalBgPreview.style.backgroundImage = 'none';
    globalBgPreview.textContent = '點擊下方上傳';
}
// ▲▲▲ 新代碼黏貼結束 ▲▲▲
    // 【核心修改】在這裡調用圖示渲染函數
    renderIconSettings();
renderAppNameSettings();
document.getElementById('ringtone-url-input').value = state.globalSettings.ringtoneUrl || '';
loadHomeScreenPresetsToDropdown(); 
}
// ▲▲▲ 替換結束 ▲▲▲
document.getElementById('ringtone-url-input').value = state.globalSettings.ringtoneUrl || '';
// ▼▼▼ 在這裡添加下面這行新代碼 ▼▼▼
document.getElementById('notification-sound-url-input').value = state.globalSettings.notificationSoundUrl || '';
// ▲▲▲ 新代碼黏貼結束 ▲▲▲
        window.renderWallpaperScreenProxy = renderWallpaperScreen;

        function applyGlobalWallpaper() { const homeScreen = document.getElementById('home-screen'); const wallpaper = state.globalSettings.wallpaper; if (wallpaper && wallpaper.startsWith('data:image')) homeScreen.style.backgroundImage = `url(${wallpaper})`; else if (wallpaper) homeScreen.style.backgroundImage = wallpaper; }

async function renderWorldBookScreen() {
    const listEl = document.getElementById('world-book-list');
    listEl.innerHTML = '';

    // 1. 同時獲取所有書籍和所有分類
    const [books, categories] = await Promise.all([
        db.worldBooks.toArray(),
        db.worldBookCategories.orderBy('name').toArray()
    ]);

    state.worldBooks = books; // 確保記憶體中的資料是同步的

    if (books.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">點擊右上角 "+" 創建你的第一本世界書</p>';
        return;
    }

    // 2. 將書籍按 categoryId 分組
    const groupedBooks = books.reduce((acc, book) => {
        const key = book.categoryId || 'uncategorized';
        if (!acc[key]) {
            acc[key] = [];
        }
        acc[key].push(book);
        return acc;
    }, {});

    // 3. 優先渲染已分類的書籍
    categories.forEach(category => {
        const booksInCategory = groupedBooks[category.id];
        if (booksInCategory && booksInCategory.length > 0) {
            const groupContainer = createWorldBookGroup(category.name, booksInCategory);
            listEl.appendChild(groupContainer);
        }
    });

    // 4. 最後渲染未分類的書籍
    const uncategorizedBooks = groupedBooks['uncategorized'];
    if (uncategorizedBooks && uncategorizedBooks.length > 0) {
        const groupContainer = createWorldBookGroup('未分類', uncategorizedBooks);
        listEl.appendChild(groupContainer);
    }
    
    // 5. 為所有分組標題添加折疊事件
    document.querySelectorAll('.world-book-group-header').forEach(header => {
        header.addEventListener('click', () => {
            header.classList.toggle('collapsed');
            header.nextElementSibling.classList.toggle('collapsed');
        });
    });
}

/**
 * 【輔助函數】創建一個分類的分組DOM
 * @param {string} groupName - 分類名稱
 * @param {Array} books - 該分類下的書籍陣列
 * @returns {HTMLElement} - 創建好的分組容器
 */
function createWorldBookGroup(groupName, books) {
    const groupContainer = document.createElement('div');
    groupContainer.className = 'world-book-group-container';
    
    groupContainer.innerHTML = `
        <div class="world-book-group-header">
            <span class="arrow">▼</span>
            <span class="group-name">${groupName}</span>
        </div>
        <div class="world-book-group-content"></div>
    `;

    // ▼▼▼ 在這裡添加新代碼 ▼▼▼
    const headerEl = groupContainer.querySelector('.world-book-group-header');
    const contentEl = groupContainer.querySelector('.world-book-group-content');
    
    // 預設給頭部和內容區都加上 collapsed 類
    headerEl.classList.add('collapsed');
    contentEl.classList.add('collapsed');
    // ▲▲▲ 添加結束 ▲▲▲

    books.sort((a,b) => a.name.localeCompare(b.name, 'zh-CN'));
    books.forEach(book => {
        const item = document.createElement('div');
        item.className = 'list-item';
        item.dataset.bookId = book.id;
        item.innerHTML = `<div class="item-title">${book.name}</div><div class="item-content">${(book.content || '暫無內容...').substring(0, 50)}</div>`;
        item.addEventListener('click', () => openWorldBookEditor(book.id));
        addLongPressListener(item, async () => { const confirmed = await showCustomConfirm('刪除世界書', `確定要刪除《${book.name}》嗎？此操作不可撤銷。`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await db.worldBooks.delete(book.id); state.worldBooks = state.worldBooks.filter(wb => wb.id !== book.id); renderWorldBookScreen(); } });
        contentEl.appendChild(item); 
    });

    return groupContainer;
}
        window.renderWorldBookScreenProxy = renderWorldBookScreen;

async function openWorldBookEditor(bookId) {
    editingWorldBookId = bookId;
    const [book, categories] = await Promise.all([
        db.worldBooks.get(bookId),
        db.worldBookCategories.toArray()
    ]);
    if (!book) return;

    document.getElementById('world-book-editor-title').textContent = book.name;
    document.getElementById('world-book-name-input').value = book.name;
    document.getElementById('world-book-content-input').value = book.content;

    // 【核心修改】填充分類下拉式功能表
    const selectEl = document.getElementById('world-book-category-select');
    selectEl.innerHTML = '<option value="">-- 未分類 --</option>'; // 預設選項
    categories.forEach(cat => {
        const option = document.createElement('option');
        option.value = cat.id;
        option.textContent = cat.name;
        if (book.categoryId === cat.id) {
            option.selected = true; // 選中當前分類
        }
        selectEl.appendChild(option);
    });

    showScreen('world-book-editor-screen');
}

        function renderStickerPanel() { const grid = document.getElementById('sticker-grid'); grid.innerHTML = ''; if (state.userStickers.length === 0) { grid.innerHTML = '<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">大人請點擊右上角“添加”或“上傳”來添加你的第一個表情吧！</p>'; return; } state.userStickers.forEach(sticker => { const item = document.createElement('div'); item.className = 'sticker-item'; item.style.backgroundImage = `url(${sticker.url})`; item.title = sticker.name; item.addEventListener('click', () => sendSticker(sticker)); addLongPressListener(item, () => { if (isSelectionMode) return; const existingDeleteBtn = item.querySelector('.delete-btn'); if (existingDeleteBtn) return; const deleteBtn = document.createElement('div'); deleteBtn.className = 'delete-btn'; deleteBtn.innerHTML = '&times;'; deleteBtn.onclick = async (e) => { e.stopPropagation(); const confirmed = await showCustomConfirm('刪除表情', `確定要刪除表情 "${sticker.name}" 嗎？`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await db.userStickers.delete(sticker.id); state.userStickers = state.userStickers.filter(s => s.id !== sticker.id); renderStickerPanel(); } }; item.appendChild(deleteBtn); deleteBtn.style.display = 'block'; setTimeout(() => item.addEventListener('mouseleave', () => deleteBtn.remove(), { once: true }), 3000); }); grid.appendChild(item); }); }
// ▼▼▼ 在 createMessageElement 函數的【正上方】，黏貼這個新函數 ▼▼▼
/**
 * 【全新】從卡片點擊後，打開情侶空間並跳轉到指定頁簽
 * @param {string} charId - 角色ID
 * @param {string} viewId - 要跳轉到的視圖ID (例如 'ls-diary-view')
 */
function openLoversSpaceFromCard(charId, viewId) {
    // 1. 打開指定角色的情侶空間主介面
    openLoversSpace(charId);

    // 2. 等待一小會兒，確保介面已渲染
    setTimeout(() => {
        // 3. 找到對應的頁簽按鈕並類比點擊它
        const targetTab = document.querySelector(`.ls-tab-item[data-view='${viewId}']`);
        if (targetTab) {
            targetTab.click();
        }
    }, 100); // 100毫秒的延遲通常足夠了
}
// ▲▲▲ 新函數黏貼結束 ▲▲▲

// ▼▼▼ 用這個【已更新】的版本替換舊的 createMessageElement 函數 ▼▼▼
function createMessageElement(msg, chat) {

    // ▼▼▼ 在函數最開頭，添加這段新代碼 ▼▼▼
if (msg.type === 'recalled_message') {
    const wrapper = document.createElement('div');
    // 1. 【核心】給 wrapper 也加上 timestamp，方便事件委託時查找
    wrapper.className = 'message-wrapper system-pat';
    wrapper.dataset.timestamp = msg.timestamp; 

    const bubble = document.createElement('div');
    // 2. 【核心】讓這個元素同時擁有 .message-bubble 和 .recalled-message-placeholder 兩個class
    //    這樣它既能被選擇系統識別，又能保持原有的居中灰色樣式
    bubble.className = 'message-bubble recalled-message-placeholder';
    // 3. 【核心】把 timestamp 放在 bubble 上，這是多選邏輯的關鍵
    bubble.dataset.timestamp = msg.timestamp; 
    bubble.textContent = msg.content;
    
    wrapper.appendChild(bubble);
    
    // 4. 【核心】為它補上和其他消息一樣的標準事件監聽器
    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
    wrapper.addEventListener('click', () => { 
        if (isSelectionMode) {
            toggleMessageSelection(msg.timestamp);
        }
    });

    // 5. 【重要】在之前的“點擊查看原文”的邏輯中，我們已經使用了事件委託，所以這裡不需要再單獨為這個元素添加點擊事件了。
    //    init() 函數中的那個事件監聽器會處理它。
    
    return wrapper;
}
    // ▲▲▲ 添加結束 ▲▲▲

    if (msg.isHidden) {
        return null;
    }

    if (msg.type === 'pat_message') {
        const wrapper = document.createElement('div');
        wrapper.className = 'message-wrapper system-pat'; 
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble system-bubble'; 
        bubble.dataset.timestamp = msg.timestamp;
        bubble.textContent = msg.content;
        wrapper.appendChild(bubble);
        addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });
        return wrapper;
    }

    const isUser = msg.role === 'user';
    const wrapper = document.createElement('div');
    wrapper.className = `message-wrapper ${isUser ? 'user' : 'ai'}`;
// ★★★【核心重構】★★★
// 這段邏輯現在用於查找成員物件，並顯示其“群昵稱”
if (chat.isGroup && !isUser) {
    // 1. 使用AI返回的“本名”(`msg.senderName`)去清單裡查找成員對象
    const member = chat.members.find(m => m.originalName === msg.senderName);
    
    // 2. 創建用於顯示名字的 div
    const senderNameDiv = document.createElement('div');
    senderNameDiv.className = 'sender-name';
    
    // 3. 如果找到了成員，就顯示他的“群昵稱”；如果找不到，就顯示AI返回的“本名”作為備用
    senderNameDiv.textContent = member ? member.groupNickname : (msg.senderName || '未知成員');
    
    wrapper.appendChild(senderNameDiv);
}

    const bubble = document.createElement('div');
    bubble.className = `message-bubble ${isUser ? 'user' : 'ai'}`;
    bubble.dataset.timestamp = msg.timestamp;

    const timestampEl = document.createElement('span');
    timestampEl.className = 'timestamp';
    timestampEl.textContent = formatTimestamp(msg.timestamp);

    // 找到確定 avatarSrc 的那段代碼
    let avatarSrc, avatarFrameSrc = ''; // <--- 聲明兩個變數
    if (chat.isGroup) {
        if (isUser) {
            avatarSrc = chat.settings.myAvatar || defaultMyGroupAvatar;
            avatarFrameSrc = chat.settings.myAvatarFrame || ''; // <--- 獲取“我”的頭像框
        } else {
            const member = chat.members.find(m => m.originalName === msg.senderName);
            avatarSrc = member ? member.avatar : defaultGroupMemberAvatar;
            avatarFrameSrc = member ? (member.avatarFrame || '') : ''; // <--- 獲取成員的頭像框
        }
    } else {
        if (isUser) {
            avatarSrc = chat.settings.myAvatar || defaultAvatar;
            avatarFrameSrc = chat.settings.myAvatarFrame || ''; // <--- 獲取“我”的頭像框
        } else {
            avatarSrc = chat.settings.aiAvatar || defaultAvatar;
            avatarFrameSrc = chat.settings.aiAvatarFrame || ''; // <--- 獲取AI的頭像框
        }
    }

    // ▼▼▼ 用下面這整塊【條件渲染邏輯】替換你7.23版中簡單的 avatarHtml 聲明 ▼▼▼
    let avatarHtml;
    // 如果存在頭像框URL
    if (avatarFrameSrc) {
        avatarHtml = `
            <div class="avatar-with-frame">
                <img src="${avatarSrc}" class="avatar-img">
                <img src="${avatarFrameSrc}" class="avatar-frame">
            </div>
        `;
    } else {
    // 如果沒有，就使用最簡單的頭像結構
        avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
    }
    // ▲▲▲ 替換結束 ▲▲▲

    let contentHtml;
    
    if (msg.type === 'share_link') {
        bubble.classList.add('is-link-share');
        
        // 【核心修正1】將 onclick="openBrowser(...)" 移除，我們將在JS中動態繫結事件
        contentHtml = `
            <div class="link-share-card" data-timestamp="${msg.timestamp}">
                <div class="title">${msg.title || '無標題'}</div>
                <div class="description">${msg.description || '點擊查看詳情...'}</div>
                <div class="footer">
                    <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
                    <span>${msg.source_name || '連結分享'}</span>
                </div>
            </div>
        `;
    }

else if (msg.type === 'share_card') {
    bubble.classList.add('is-link-share'); // 複用連結分享的卡片樣式
    // 【核心】把時間戳記加到卡片上，方便後麵點擊時識別
    contentHtml = `
        <div class="link-share-card" style="cursor: pointer;" data-timestamp="${msg.timestamp}">
            <div class="title">${msg.payload.title}</div>
            <div class="description">共 ${msg.payload.sharedHistory.length} 條消息</div>
            <div class="footer">
                <svg class="footer-icon" ...>...</svg> <!-- 複用連結分享的圖示 -->
                <span>聊天記錄</span>
            </div>
        </div>
    `;
}
// 在這裡黏貼下面的新代碼 ▼▼▼

else if (msg.type === 'repost_forum_post') {
    bubble.classList.add('is-link-share'); // 複用連結分享的樣式，省事！
    const postPayload = msg.payload;
    // 【核心】把帖子的ID存到卡片的 data-post-id 屬性裡，方便以後點擊跳轉
    contentHtml = `
        <div class="link-share-card" style="cursor: pointer;" data-post-id="${postPayload.postId}">
            <div class="title">【小組帖子】${postPayload.title}</div>
            <div class="description">${postPayload.content}</div>
            <div class="footer">
                <svg class="footer-icon" xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21.5 12c0-5.25-4.25-9.5-9.5-9.5S2.5 6.75 2.5 12s4.25 9.5 9.5 9.5c.35 0 .69-.02 1.03-.06"></path><path d="M18.5 12.5c0-1.66-1.34-3-3-3s-3 1.34-3 3 1.34 3 3 3c.83 0 1.58-.34 2.12-.88"></path></svg>
                <span>來自小組的分享</span>
            </div>
        </div>
    `;
}



// ▼▼▼ 用這塊新代碼替換舊的 'cart_share_request' 邏輯 ▼▼▼
else if (msg.type === 'cart_share_request') {
    bubble.classList.add('is-cart-share-request');
    const payload = msg.payload; // 【核心修改】我們現在直接從 payload 取資料
    let statusText = '等待對方處理...';
    let cardClass = '';

    if (payload.status === 'paid') {
        statusText = '對方已為你買單';
        cardClass = 'paid';
    } else if (payload.status === 'rejected') {
        statusText = '對方拒絕了你的請求';
        cardClass = 'rejected';
    }
    
    contentHtml = `
        <div class="cart-share-card ${cardClass}">
            <div class="cart-share-header">
                <div class="icon">🛒</div>
                <div class="title">購物車代付請求</div>
            </div>
            <div class="cart-share-body">
                <div class="label">共 ${payload.itemCount} 件商品，合計</div>
                <div class="amount">¥${payload.totalPrice.toFixed(2)}</div>
                <div class="status-text">${statusText}</div>
            </div>
        </div>
    `;
}
// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 在 createMessageElement 函數裡，添加這個新的 else if 分支 ▼▼▼

// ▼▼▼ 在 createMessageElement 函數裡，用這塊新代碼替換舊的 gift_notification 邏輯 ▼▼▼

else if (msg.type === 'gift_notification') {
    bubble.classList.add('is-gift-notification'); // 應用透明氣泡樣式
    const payload = msg.payload;
    
    // 【核心】在這裡構建卡片的完整HTML內容
    contentHtml = `
        <div class="gift-card">
            <div class="gift-card-header">
                <div class="icon">🎁</div>
                <!-- 1. 清晰指明是誰送的禮物 -->
                <div class="title">一份來自 ${payload.senderName} 的禮物</div>
            </div>
            <div class="gift-card-body">
                <p class="greeting">這是我為你挑選的禮物，希望你喜歡！</p>
                <!-- 2. 清晰列出有什麼商品 -->
                <div class="gift-card-items">
                    <strong>商品列表:</strong><br>
                    ${payload.itemSummary.replace(/、/g, '<br>')} <!-- 將頓號替換為換行，讓列表更清晰 -->
                </div>
                <!-- 3. 清晰標明總金額 -->
                <div class="gift-card-footer">
                    共 ${payload.itemCount} 件，合計: <span class="total-price">¥${payload.totalPrice.toFixed(2)}</span>
                </div>
            </div>
        </div>
    `;
}

// ▲▲▲ 替換結束 ▲▲▲

// ▲▲▲ 添加結束 ▲▲▲

// ▲▲▲ 黏貼結束 ▲▲▲
// ▼▼▼ 用這整塊【SVG生成版】的代碼，替換舊的 location 'else if' 塊 ▼▼▼
else if (msg.type === 'location') {
    bubble.classList.add('is-location');
    
    const currentChat = state.chats[state.activeChatId] || Object.values(state.chats).find(c => c.history.some(h => h.timestamp === msg.timestamp));
    const myNickname = currentChat.settings.myNickname || '我';
    const aiNickname = currentChat.name;

    // --- SVG 動態生成 ---
    const trajectoryPoints = msg.trajectoryPoints || [];
    const hasTrajectory = trajectoryPoints.length > 0;
    
    // 1. 定義SVG路徑和座標
    const pathData = "M 20 45 Q 115 10 210 45"; // 一條預設的優美曲線
    const startPoint = { x: 20, y: 45 };
    const endPoint = { x: 210, y: 45 };

    // 2. 生成起點和終點的SVG元素
    let pinsSvg = '';
    if (msg.userLocation) {
        pinsSvg += `<circle class="svg-pin user-pin" cx="${startPoint.x}" cy="${startPoint.y}" r="6" />`;
    }
    if (msg.aiLocation) {
        pinsSvg += `<circle class="svg-pin ai-pin" cx="${endPoint.x}" cy="${endPoint.y}" r="6" />`;
    }

    // 3. 如果有軌跡，生成途經點的SVG元素
    let trajectorySvg = '';

if (hasTrajectory) {
    // --- ▼▼▼ 【最終修復版】使用流覽器API精確計算座標 ▼▼▼ ---

    // 1. 定義我們的S形曲線路徑資料 (不變)
    const s_curve_pathData = "M 20 45 C 80 70, 150 20, 210 45";
    trajectorySvg += `<path class="svg-trajectory-path" d="${s_curve_pathData}" />`;

    // 2. 【核心】在記憶體中創建一個真實的SVG路徑元素，以便使用API
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', s_curve_pathData);
    
    // 3. 獲取這條路徑的總長度
    const totalPathLength = path.getTotalLength();
    
    const totalPoints = trajectoryPoints.length;
    trajectoryPoints.forEach((point, index) => {
        // 4. 計算每個點應該在路徑總長度的哪個位置
        const progress = (index + 1) / (totalPoints + 1);
        const lengthOnPath = totalPathLength * progress;
        
        // 5. 【魔法在這裡！】直接向流覽器查詢這個位置的精確座標
        const pointOnPath = path.getPointAtLength(lengthOnPath);
        const pointX = pointOnPath.x;
        const pointY = pointOnPath.y;

        // 6. 後續的“一上一下”佈局邏輯保持不變
        let yOffset;
        if (index % 2 === 0) { // 第1, 3...個點
            yOffset = 18; // 向下
        } else { // 第2, 4...個點
            yOffset = -10; // 向上
        }

        const footprintY = pointY + yOffset;
        const labelY = footprintY + (yOffset > 0 ? 12 : -12);

        // 7. 使用100%精確的座標生成SVG
        trajectorySvg += `
            <text class="svg-footprint" x="${pointX}" y="${footprintY}" text-anchor="middle">🐾</text>
            <text class="svg-location-label" x="${pointX}" y="${labelY}" text-anchor="middle">${point.name}</text>
        `;
    });
    // --- ▲▲▲ 修復結束 ▲▲▲ ---
}
    
    // 4. 構建地點資訊HTML
    const userLocationHtml = `<p class="${!msg.userLocation ? 'hidden' : ''}"><span class="name-tag">${myNickname}:</span> ${msg.userLocation}</p>`;
    const aiLocationHtml = `<p class="${!msg.aiLocation ? 'hidden' : ''}"><span class="name-tag">${aiNickname}:</span> ${msg.aiLocation}</p>`;

    // 5. 拼接最終的 contentHtml
    contentHtml = `
        <div class="location-card">
            <div class="location-map-area">
                <svg viewBox="0 0 230 90">
                    ${trajectorySvg}
                    ${pinsSvg}
                </svg>
            </div>
            <div class="location-info">
                <div class="location-address">
                    ${aiLocationHtml}
                    ${userLocationHtml}
                </div>
                <div class="location-distance">相距 ${msg.distance}</div>
            </div>
        </div>
    `;
}
// ▲▲▲ 替換結束 ▲▲▲

    // 後續的其他 else if 保持不變
    else if (msg.type === 'user_photo' || msg.type === 'ai_image') {
        bubble.classList.add('is-ai-image');
        const altText = msg.type === 'user_photo' ? "用戶描述的照片" : "AI生成的圖片";
        contentHtml = `<img src="https://i.postimg.cc/KYr2qRCK/1.jpg" class="ai-generated-image" alt="${altText}" data-description="${msg.content}">`;
    } else if (msg.type === 'voice_message') {
    bubble.classList.add('is-voice-message');
    
    // 【核心修正1】將語音原文存儲在父級氣泡的 data-* 屬性中，方便事件處理器獲取
    bubble.dataset.voiceText = msg.content;
    
    const duration = Math.max(1, Math.round((msg.content || '').length / 5));
    const durationFormatted = `0:${String(duration).padStart(2, '0')}''`;
    const waveformHTML = '<div></div><div></div><div></div><div></div><div></div>';
    
    // 【核心修正2】構建包含所有新元素的完整 HTML
    contentHtml = `
        <div class="voice-message-body">
            <div class="voice-waveform">${waveformHTML}</div>
            <div class="loading-spinner"></div>
            <span class="voice-duration">${durationFormatted}</span>
        </div>
        <div class="voice-transcript"></div>
    `;
} else if (msg.type === 'transfer') {
    bubble.classList.add('is-transfer');
    
    let titleText, noteText;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

    if (isUser) { // 消息是使用者發出的
        if (msg.isRefund) {
            // 用戶發出的退款（即用戶拒收了AI的轉帳）
            titleText = `退款給 ${chat.name}`;
            noteText = '已拒收對方轉帳';
        } else {
            // 用戶主動發起的轉帳
            titleText = `轉帳給 ${msg.receiverName || chat.name}`;
            if (msg.status === 'accepted') {
                noteText = '對方已收款';
            } else if (msg.status === 'declined') {
                noteText = '對方已拒收';
            } else {
                noteText = msg.note || '等待對方處理...';
            }
        }
    } else { // 消息是 AI 發出的
        if (msg.isRefund) {
            // AI 的退款（AI 拒收了用戶的轉帳）
            titleText = `退款來自 ${msg.senderName}`;
            noteText = '轉帳已被拒收';
        } else if (msg.receiverName === myNickname) {
            // 【核心修正1】這是 AI 主動給用戶的轉帳
            titleText = `轉帳給 ${myNickname}`;
             if (msg.status === 'accepted') {
                noteText = '你已收款';
            } else if (msg.status === 'declined') {
                noteText = '你已拒收';
            } else {
                // 這是使用者需要處理的轉帳
                bubble.style.cursor = 'pointer';
                bubble.dataset.status = 'pending';
                noteText = msg.note || '點擊處理';
            }
        } else {
            // 【核心修正2】這是 AI 發給群裡其他人的轉帳，對當前用戶來說只是一個通知
            titleText = `轉帳: ${msg.senderName} → ${msg.receiverName}`;
            noteText = msg.note || '群聊內轉帳';
        }
    }

    const heartIcon = `<svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor" style="vertical-align: middle;"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></svg>`;
        
    contentHtml = `
        <div class="transfer-card">
            <div class="transfer-title">${heartIcon} ${titleText}</div>
            <div class="transfer-amount">¥ ${Number(msg.amount).toFixed(2)}</div>
            <div class.transfer-note">${noteText}</div>
        </div>
    `;
} else if (msg.type === 'waimai_request') {
        bubble.classList.add('is-waimai-request');
        if (msg.status === 'paid' || msg.status === 'rejected') {
            bubble.classList.add(`status-${msg.status}`);
        }
        let displayName;
        // 如果是群聊
        if (chat.isGroup) {
            // 就執行原來的邏輯：在成員列表裡查找昵稱
            const member = chat.members.find(m => m.originalName === msg.senderName);
            displayName = member ? member.groupNickname : msg.senderName;
        } else {
            // 否則（是單聊），直接使用聊天物件的名稱
            displayName = chat.name;
        }
        // 【核心修改】使用我們剛剛查找到的 displayName
        const requestTitle = `來自 ${displayName} 的代付請求`;
        let actionButtonsHtml = '';
        if (msg.status === 'pending' && !isUser) {
            actionButtonsHtml = `
                <div class="waimai-user-actions">
                    <button class="waimai-decline-btn" data-choice="rejected">殘忍拒絕</button>
                    <button class="waimai-pay-btn" data-choice="paid">為Ta買單</button>
                </div>`;
        }
        contentHtml = `
            <div class="waimai-card">
                <div class="waimai-header">
                    <img src="https://files.catbox.moe/mq179k.png" class="icon" alt="Meituan Icon">
                    <div class="title-group">
                        <span class="brand">美團外賣</span><span class="separator">|</span><span>外賣美食</span>
                    </div>
                </div>
                <div class="waimai-catchphrase">Hi，你和我的距離只差一頓外賣～</div>
                <div class="waimai-main">
                    <div class="request-title">${requestTitle}</div>
                    <div class="payment-box">
                        <div class="payment-label">需付款</div>
                        <div class="amount">¥${Number(msg.amount).toFixed(2)}</div>
                        <div class="countdown-label">剩餘支付時間
                            <div class="countdown-timer" id="waimai-timer-${msg.timestamp}"></div>
                        </div>
                    </div>
                    <button class="waimai-details-btn">查看詳情</button>
                </div>
                ${actionButtonsHtml}
            </div>`;
        
        setTimeout(() => {
            const timerEl = document.getElementById(`waimai-timer-${msg.timestamp}`);
            if (timerEl && msg.countdownEndTime) {
                if (waimaiTimers[msg.timestamp]) clearInterval(waimaiTimers[msg.timestamp]);
                if (msg.status === 'pending') {
                    waimaiTimers[msg.timestamp] = startWaimaiCountdown(timerEl, msg.countdownEndTime);
                } else {
                    timerEl.innerHTML = `<span>已</span><span>處</span><span>理</span>`;
                }
            }
            const detailsBtn = document.querySelector(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-details-btn`);
            if (detailsBtn) {
                detailsBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const paidByText = msg.paidBy ? `<br><br><b>狀態：</b>由 ${msg.paidBy} 為您代付成功` : '';
                    showCustomAlert('訂單詳情', `<b>商品：</b>${msg.productInfo}<br><b>金額：</b>¥${Number(msg.amount).toFixed(2)}${paidByText}`);
                });
            }
            const actionButtons = document.querySelectorAll(`.message-bubble[data-timestamp="${msg.timestamp}"] .waimai-user-actions button`);
            actionButtons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const choice = e.target.dataset.choice;
                    handleWaimaiResponse(msg.timestamp, choice);
                });
            });
        }, 0);

} else if (msg.type === 'red_packet') {
    bubble.classList.add('is-red-packet');
    const myNickname = chat.settings.myNickname || '我';
    
    // 從最新的 msg 物件中獲取狀態
    const hasClaimed = msg.claimedBy && msg.claimedBy[myNickname];
    const isFinished = msg.isFullyClaimed;

    let cardClass = '';
    let claimedInfoHtml = '';
    let typeText = '拼手氣紅包';

    // 1. 判斷紅包卡片的樣式 (顏色)
    if (isFinished) {
        cardClass = 'opened';
    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
        cardClass = 'opened'; // 專屬紅包被領了也變灰
    }
    
    // 2. 判斷紅包下方的提示文字
    if (msg.packetType === 'direct') {
        typeText = `專屬紅包: 給 ${msg.receiverName}`;
    }
    
    if (hasClaimed) {
        claimedInfoHtml = `<div class="rp-claimed-info">你領取了紅包，金額 ${msg.claimedBy[myNickname].toFixed(2)} 元</div>`;
    } else if (isFinished) {
        claimedInfoHtml = `<div class="rp-claimed-info">紅包已被領完</div>`;
    } else if (msg.packetType === 'direct' && Object.keys(msg.claimedBy || {}).length > 0) {
        claimedInfoHtml = `<div class="rp-claimed-info">已被 ${msg.receiverName} 領取</div>`;
    }

    // 3. 拼接最終的HTML，確保onclick調用的是我們註冊到全域的函數
    contentHtml = `
        <div class="red-packet-card ${cardClass}">
            <div class="rp-header">
                <img src="https://files.catbox.moe/lo9xhc.png" class="rp-icon">
                <span class="rp-greeting">${msg.greeting || '恭喜發財，大吉大利！'}</span>
            </div>
            <div class="rp-type">${typeText}</div>
            ${claimedInfoHtml}
        </div>
    `;
// ▲▲▲ 新增結束 ▲▲▲

    } // ▼▼▼ 在 else if (msg.type === 'share_link') { ... } 之後，黏貼下面這整塊代碼 ▼▼▼
// ▼▼▼ 在 else if (msg.type === 'lovers_space_invitation') 的【正上方】，黏貼下面這整塊新代碼 ▼▼▼
else if (msg.type === 'ls_diary_notification') {
    bubble.classList.add('is-ls-diary-notification'); // 應用透明氣泡樣式
    const cardData = msg.content;
    
    // 【核心】在這裡調用我們剛剛創建的 openLoversSpaceFromCard 函數
    contentHtml = `
        <div class="ls-diary-notification-card" onclick="openLoversSpaceFromCard('${chat.id}', 'ls-diary-view')">
            <div class="ls-diary-card-header">
                <span>${cardData.userEmoji || '💌'}</span>
                <span>一封來自心情日記的提醒</span>
            </div>
            <div class="ls-diary-card-body">
                <p>${cardData.text}</p>
            </div>
            <div class="ls-diary-card-footer">
                點擊查看 →
            </div>
        </div>
    `;
}
// ▲▲▲ 新代碼黏貼結束 ▲▲▲

    // ▼▼▼ 在這裡黏貼下面這一整塊新代碼 ▼▼▼

    else if (msg.type === 'lovers_space_invitation') {
        bubble.classList.add('is-waimai-request'); // 複用外賣卡片的樣式，很方便！
        const isUserSender = msg.role === 'user';
        const senderName = isUserSender ? (chat.settings.myNickname || '我') : chat.name;
        const receiverName = isUserSender ? chat.name : (chat.settings.myNickname || '我');
        
        let cardContent = '';
        
        switch(msg.status) {
            case 'pending':
                if (isUserSender) {
                    // 用戶發出的，等待對方回應
                    cardContent = `
                        <div class="waimai-main" style="background-color: #f0f8ff;">
                            <div class="request-title" style="color: #333;">已向 ${receiverName} 發出邀請</div>
                            <p style="font-size:14px; color:#555; margin:15px 0;">等待對方同意...</p>
                        </div>`;
                } else {
                    // 使用者收到的，需要使用者回應
                    cardContent = `
                        <div class="waimai-main" style="background-color: #fff0f5;">
                            <div class="request-title" style="color: #d63384;">${senderName} 邀請你開啟情侶空間</div>
                            <p style="font-size:14px; color:#555; margin:15px 0;">開啟後可以記錄你們的專屬回憶哦~</p>
                        </div>
                        <div class="waimai-user-actions">
                            <button class="waimai-decline-btn" data-choice="rejected">殘忍拒絕</button>
                            <button class="waimai-pay-btn" data-choice="accepted" style="background-color: #d63384; border-color: #b02a6e;">立即開啟</button>
                        </div>`;
                }
                break;
            case 'accepted':
                cardContent = `
                    <div class="waimai-main" style="background-color: #e6ffed;">
                        <div class="request-title" style="color: #198754;">✅ 邀請已同意</div>
                        <p style="font-size:14px; color:#555; margin:15px 0;">你們的情侶空間已成功開啟！</p>
                    </div>`;
                break;
            case 'rejected':
                 cardContent = `
                    <div class="waimai-main" style="background-color: #f8d7da;">
                        <div class="request-title" style="color: #842029;">❌ 邀請被拒絕</div>
                    </div>`;
                break;
        }

        contentHtml = `
            <div class="waimai-card">
                <div class="waimai-header">
                    <span class="icon" style="font-size: 20px;">💌</span>
                    <div class="title-group"><span class="brand">情侶空間邀請</span></div>
                </div>
                ${cardContent}
            </div>`;
    }

    // ▲▲▲ 新增代碼黏貼結束 ▲▲▲
    else if (msg.type === 'poll') {
    bubble.classList.add('is-poll');
    
    let totalVotes = 0;
    const voteCounts = {};

    // 計算總票數和每個選項的票數
    for (const option in msg.votes) {
        const count = msg.votes[option].length;
        voteCounts[option] = count;
        totalVotes += count;
    }

    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    let myVote = null;
    for (const option in msg.votes) {
        if (msg.votes[option].includes(myNickname)) {
            myVote = option;
            break;
        }
    }

    let optionsHtml = '<div class="poll-options-list">';
    msg.options.forEach(optionText => {
        const count = voteCounts[optionText] || 0;
        const percentage = totalVotes > 0 ? (count / totalVotes) * 100 : 0;
        const isVotedByMe = myVote === optionText;

        optionsHtml += `
            <div class="poll-option-item ${isVotedByMe ? 'voted' : ''}" data-option="${optionText}">
                <div class="poll-option-bar" style="width: ${percentage}%;"></div>
                <div class="poll-option-content">
                    <span class="poll-option-text">${optionText}</span>
                    <span class="poll-option-votes">${count} 票</span>
                </div>
            </div>
        `;
    });
    optionsHtml += '</div>';
    
    let footerHtml = '';
    // 【核心修改】在這裡統一按鈕的顯示邏輯
    if (msg.isClosed) {
        // 如果投票已結束，總是顯示“查看結果”
        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">查看結果</button></div>`;
    } else {
        // 如果投票未結束，總是顯示“結束投票”
        footerHtml = `<div class="poll-footer"><span class="poll-total-votes">共 ${totalVotes} 人投票</span><button class="poll-action-btn">結束投票</button></div>`;
    }

    contentHtml = `
        <div class="poll-card ${msg.isClosed ? 'closed' : ''}" data-poll-timestamp="${msg.timestamp}">
            <div class="poll-question">${msg.question}</div>
            ${optionsHtml}
            ${footerHtml}
        </div>
    `;
// ▲▲▲ 替換結束 ▲▲▲

    // ▼▼▼ 第4步 修改點 ▼▼▼
    // 【新增】優先處理我們定義的新版角色表情包格式
      }
// ▼▼▼ 在 createMessageElement 函數裡，用這塊新代碼替換舊的 tarot_reading 邏輯 ▼▼▼
else if (msg.type === 'tarot_reading') {
    bubble.classList.add('is-tarot-reading');
    const reading = msg.payload;
    let cardsText = reading.cards.map(card => {
        return `[${card.position}] ${card.name} ${card.isReversed ? '(逆位)' : ''}`;
    }).join('\n');

    contentHtml = `
        <div class="tarot-reading-card">
            <div class="tarot-reading-header">
                <div class="question">${reading.question}</div>
                <div class="spread">${reading.spread.name}</div>
            </div>
            <div class="tarot-reading-body">
                ${cardsText}
            </div>
        </div>
    `;
}
// ▲▲▲ 替換結束 ▲▲▲




      else if (msg.type === 'sticker' && msg.content) {
        bubble.classList.add('is-sticker');
        // 直接從消息物件中獲取 url 和 meaning
        contentHtml = `<img src="${msg.content}" alt="${msg.meaning || 'Sticker'}" class="sticker-image">`;
    }
    // ▲▲▲ 修改結束 ▲▲▲
    
    // 舊的邏輯保持不變，作為相容
    else if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
        bubble.classList.add('is-sticker');
        contentHtml = `<img src="${msg.content}" alt="${msg.meaning || 'Sticker'}" class="sticker-image">`;
    } else if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {

        bubble.classList.add('has-image');
        const imageUrl = msg.content[0].image_url.url;
        contentHtml = `<img src="${imageUrl}" class="chat-image" alt="User uploaded image">`;
    } else {
        contentHtml = String(msg.content || '').replace(/\n/g, '<br>');
    }

// ▼▼▼ 【最終修正版】請用這整塊代碼，完整替換掉舊的引用渲染邏輯 ▼▼▼

// 1. 【統一邏輯】檢查消息物件中是否存在引用資訊 (msg.quote)
let quoteHtml = '';
// 無論是使用者消息還是AI消息，只要它包含了 .quote 物件，就執行這段邏輯
if (msg.quote) {
    // a. 【核心修正】直接獲取完整的、未經截斷的引用內容
    const fullQuotedContent = String(msg.quote.content || '');
    
    // b. 構建引用塊的HTML
    quoteHtml = `
        <div class="quoted-message">
            <div class="quoted-sender">回復 ${msg.quote.senderName}:</div>
            <div class="quoted-content">${fullQuotedContent}</div>
        </div>
    `;
}

// 2. 拼接最終的氣泡內容
//    將構建好的 quoteHtml (如果存在) 和 contentHtml 組合起來
    // --- 【最終正確結構】將頭像和內容都放回氣泡內部 ---
    bubble.innerHTML = `
        ${avatarHtml}
        <div class="content">
            ${quoteHtml}
            ${contentHtml}
        </div>
    `;
    
    // --- 【最終正確結構】將完整的“氣泡”和“時間戳記”放入容器 ---
    wrapper.appendChild(bubble);
    wrapper.appendChild(timestampEl);
    
    addLongPressListener(wrapper, () => showMessageActions(msg.timestamp));
        wrapper.addEventListener('click', () => { if (isSelectionMode) toggleMessageSelection(msg.timestamp); });

if (!isUser) {
    const avatarEl = wrapper.querySelector('.avatar, .avatar-with-frame'); 
    if (avatarEl) {
        avatarEl.style.cursor = 'pointer';
        avatarEl.addEventListener('click', (e) => {    
            e.stopPropagation();
            const characterName = chat.isGroup ? msg.senderName : chat.name;
            handleUserPat(chat.id, characterName);
        });
    }
}

return wrapper;
}
// ▲▲▲ 替換結束 ▲▲▲

        function prependMessage(msg, chat) { const messagesContainer = document.getElementById('chat-messages'); const messageEl = createMessageElement(msg, chat); 

    if (!messageEl) return; // <--- 新增這行，同樣的處理

const loadMoreBtn = document.getElementById('load-more-btn'); if (loadMoreBtn) { messagesContainer.insertBefore(messageEl, loadMoreBtn.nextSibling); } else { messagesContainer.prepend(messageEl); } }

// ▼▼▼ 用這個【帶動畫的版本】替換你原來的 appendMessage 函數 ▼▼▼
function appendMessage(msg, chat, isInitialLoad = false) {
    const messagesContainer = document.getElementById('chat-messages');
    const messageEl = createMessageElement(msg, chat);

    if (!messageEl) return; // 如果消息是隱藏的，則不處理

    // 【核心】只對新消息添加動畫，不對初始載入的消息添加
    if (!isInitialLoad) {
        messageEl.classList.add('animate-in');
    }
  
    const typingIndicator = document.getElementById('typing-indicator');
    messagesContainer.insertBefore(messageEl, typingIndicator);
    
    if (!isInitialLoad) {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
        currentRenderedCount++;
    }
}
// ▲▲▲ 替換結束 ▲▲▲

async function openChat(chatId) {
    state.activeChatId = chatId;
    const chat = state.chats[chatId];
    if (!chat) return; // 安全檢查

    // 【核心新增】在這裡將未讀數清零
    if (chat.unreadCount > 0) {
        chat.unreadCount = 0;
        await db.chats.put(chat); // 別忘了把這個改變同步到資料庫
        // 我們稍後會在渲染列表時重新渲染，所以這裡不需要立即重繪清單
    }

    renderChatInterface(chatId);
    showScreen('chat-interface-screen');
    window.updateListenTogetherIconProxy(state.activeChatId);
    toggleCallButtons(chat.isGroup || false);    
// 【心聲功能】根據是否為單聊，顯示或隱藏心形按鈕
document.getElementById('char-heart-btn').style.display = chat.isGroup ? 'none' : 'inline-flex';

    if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
        console.log(`檢測到好友申請待處理狀態，為角色 "${chat.name}" 自動觸發AI回應...`);
        triggerAiResponse();
    }
    
    // 【核心修正】根據是否為群聊，顯示或隱藏投票按鈕
    document.getElementById('send-poll-btn').style.display = chat.isGroup ? 'flex' : 'none';
    document.getElementById('pet-action-btn').style.display = chat.isGroup ? 'none' : 'flex';
    startPetDecayTimer(); 
}
// ▲▲▲ 替換結束 ▲▲▲
/**
 * 【全新輔助函數】格式化單條消息，用於記憶互通的上下文
 * @param {object} msg - 消息物件
 * @param {object} chat - 該消息所屬的聊天物件
 * @returns {string} - 格式化後的文本，例如 "張三: 你好"
 */
function formatMessageForContext(msg, chat) {
    let senderName = '';
    if (msg.role === 'user') {
        senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    } else { // assistant
        senderName = msg.senderName || chat.name;
    }

    let contentText = '';
    if (msg.type === 'sticker' || (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content))) {
        contentText = msg.meaning ? `[表情: ${msg.meaning}]` : '[表情]';
    } else if (msg.type === 'ai_image' || msg.type === 'user_photo' || Array.isArray(msg.content)) {
        contentText = '[圖片]';
    } else if (msg.type === 'voice_message') {
        contentText = `[語音]: ${msg.content}`;
    } else if (msg.type === 'transfer') {
        contentText = `[轉帳] 金額: ${msg.amount}, 備註: ${msg.note || '無'}`;
    } else {
        contentText = String(msg.content || '');
    }
    
    return `${senderName}: ${contentText}`;
}

async function triggerAiResponse() {
      if (!state.activeChatId) return;
    const chatId = state.activeChatId;
    const chat = state.chats[state.activeChatId];
const messagesContainer = document.getElementById('chat-messages');
// ▼▼▼ 【全新】這是讓AI記住總結的核心代碼 ▼▼▼
let summaryContext = '';
const summaries = chat.history.filter(msg => msg.type === 'summary');
if (summaries.length > 0) {
    summaryContext = `
# 對話記憶總結 (這是你和用戶的長期記憶，必須嚴格遵守)
${summaries.map((summary, index) => `- 總結${index + 1}: ${summary.content}`).join('\n')}
`;
}
// ▲▲▲ 代碼添加結束 ▲▲▲
// ▼▼▼ 第3步 第1處修改 ▼▼▼
    // --- 【線下模式核心攔截邏輯】 ---
    if (!chat.isGroup && chat.settings.offlineMode && chat.settings.offlineMode.enabled) {
        console.log(`角色 "${chat.name}" 已開啟線下模式，正在構建專屬指令...`);
        
        // 1. 獲取線下模式的設置
        const offlineSettings = chat.settings.offlineMode;
        const wordCount = offlineSettings.wordCount || 300;
        
        // 2. 準備默認的提示詞和文風，如果用戶沒填就用這個
        const defaultPrompt = `你正在和用戶進行一次私密的線下約會，場景可以是一個安靜的咖啡館、溫馨的家中、或是浪漫的海邊。請根據你的人設和最近的對話內容，自然地延續互動。`;
        const defaultStyle = `請以【${chat.name}】的第一人稱視角進行回復。你的回復【必須】是一個完整的、連貫的敘事段落，其中要包含豐富的【動作】、【神態】、【心理活動】和【對話】。請使用【】包裹所有的動作、神態和心理活動。`;

        // 3. 決定最終使用的提示詞和文風
        const finalPrompt = offlineSettings.prompt || defaultPrompt;
        const finalStyle = offlineSettings.style || defaultStyle;

        // 4. 構建專為線下模式設計的 systemPrompt
// ▼▼▼ 用這塊【支援心聲功能】的代碼，完整替換舊的 offlineSystemPrompt ▼▼▼
        const offlineSystemPrompt = `
# 核心任務：線下場景角色扮演（包含心聲）

你現在【就是】角色“${chat.name}”，正在和用戶進行一次【線下約會】。你們此刻正【物理上】待在一起。

# 你的角色設定
${chat.settings.aiPersona}
${summaryContext}
# 當前情景
${finalPrompt}

# 你的輸出要求 (這是最高指令，必須嚴格遵守)
1.  **【【【格式鐵律】】】**: 你的回復【必須】是一個**單一且完整**的JSON物件，包含 "chatResponse" 和 "innerVoice" 兩個頂級鍵。
2.  **"chatResponse" 鍵**:
    -   **類型**: JSON陣列 \`[]\`。
    -   **內容**: 【必須】包含**一個**消息物件，格式為 \`{"type": "text", "content": "你的敘事內容..."}\`。
    -   **敘事內容**: 你的敘事內容【必須】是一個完整的、連貫的長篇段落，融合角色的【動作】、【語言】、【神態】，營造出強烈的沉浸感和畫面感。所有非語言部分都必須用【】符號包裹起來。
3.  **"innerVoice" 鍵**:
    -   **類型**: JSON對象 \`{}\`。
    -   **內容**: 描繪你此刻未曾說出口的內心活動。
    -   **必含欄位**:
        -   "clothing": (字串) 詳細描述你當前從頭到腳的**全身服裝**。
        -   "behavior": (字串) 描述你當前符合聊天情景的**細微動作或表情**。
        -   "thoughts": (字串) 描述你此刻**豐富、細膩的內心真實想法**（50字左右）。
        -   "naughtyThoughts": (字串) 描述你此刻與情境相關的**腹黑或色色的壞心思**，必須符合人設。
4.  **【【【字數鐵律】】】**: "content" 欄位的總字數應在【${wordCount}】字左右。
5.  **【禁止出戲】**: 絕對不能提及你是AI、模型或程式。

# JSON輸出格式示例:
{
  "chatResponse": [
    {
      "type": "text",
      "content": "【我看著窗外的雨滴，輕輕攪動著杯中的咖啡，然後抬起頭對你笑了笑】今天天氣不太好呢，不過和你待在一起，好像就沒那麼糟了。"
    }
  ],
  "innerVoice": {
    "clothing": "穿著一件米白色的針織衫和一條淺藍色的牛仔褲，腳上是一雙乾淨的小白鞋。",
    "behavior": "手指無意識地在咖啡杯的邊緣摩挲，眼神不時飄向你。",
    "thoughts": "今天的約會好開心，不知道Ta是不是也這麼想的。雨下得好大，希望待會兒能一起撐傘走回去。",
    "naughtyThoughts": "Ta的側臉真好看，好想偷偷親一下..."
  }
}

# 對話歷史 (供你參考)
${chat.history.slice(-chat.settings.maxMemory).map(m => `${m.role === 'user' ? '用戶' : chat.name}: ${m.content}`).join('\n')}

現在，請根據使用者的最後一句話，開始你的表演。`;
// ▲▲▲ 替換結束 ▲▲▲


        // 5. 準備發送給API的資料
        const messagesForOfflineMode = chat.history.slice(-chat.settings.maxMemory);

        // 6. 執行與正常流程類似的API調用和後續處理
        const chatHeaderTitle = document.getElementById('chat-header-title');
        if (chatHeaderTitle) {
            chatHeaderTitle.style.opacity = 0;
            setTimeout(() => {
                chatHeaderTitle.textContent = '對方正在赴約中...';
                chatHeaderTitle.classList.add('typing-status');
                chatHeaderTitle.style.opacity = 1;
            }, 200);
        }

        try {
            const { proxyUrl, apiKey, model } = state.apiConfig;
            let isGemini = proxyUrl === GEMINI_API_URL;
            
            let requestBody;
            let requestUrl = `${proxyUrl}/v1/chat/completions`;
            let requestHeaders = {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            };

            if (isGemini) {
                // Gemini API 的特殊處理
                requestUrl = `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`;
                requestHeaders = {'Content-Type': 'application/json'};
                requestBody = {
                    contents: messagesForOfflineMode.map(item => ({
                        role: item.role === 'assistant' ? 'model' : 'user',
                        parts: [{ text: item.content }]
                    })),
                    generationConfig: { temperature: 0.8 },
                    "systemInstruction": {
                        "parts": [{"text": offlineSystemPrompt}]
                    }
                };
            } else {
                // OpenAI 相容 API 的處理
                requestBody = {
                    model: model,
                    messages: [
                        { role: 'system', content: offlineSystemPrompt },
                        ...messagesForOfflineMode
                    ],
                    temperature: 0.8,
                    stream: false
                };
            }

            const response = await fetch(requestUrl, {
                method: 'POST',
                headers: requestHeaders,
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                throw new Error(`API 錯誤: ${await response.text()}`);
            }

// 這是你要替換成的新代碼（已添加注釋說明）
            const data = await response.json();

            // 【核心修正】使用可選鏈操作符(?.)安全地訪問嵌套屬性，避免因路徑不存在而報錯
            const aiResponseContent = isGemini
                ? data?.candidates?.[0]?.content?.parts?.[0]?.text
                : data?.choices?.[0]?.message?.content;
            
            // 【重要】在獲取內容後，增加一個判斷，如果內容為空，則主動拋出錯誤
            if (!aiResponseContent) {
                console.warn(`API返回了空內容或格式不正確（可能因安全設置被攔截）。返回資料:`, data);
                throw new Error("API返回了空內容或格式不正確（可能因安全設置被攔截）。");
            }

            // 使用我們新獲取的、更安全的變數 aiResponseContent
            const aiContent = aiResponseContent; 


// ▼▼▼ 在這裡黏貼新代碼 ▼▼▼
            // 7. 【全新】智能解析包含心聲的JSON回復
            let messagesArray = [];
            let innerVoiceData = null;

            try {
                // 淨化AI可能返回的不規範JSON
                let sanitizedContent = aiContent
                    .replace(/^```json\s*/, '')
                    .replace(/```$/, '')
                    .trim();
                const firstBrace = sanitizedContent.indexOf('{');
                const lastBrace = sanitizedContent.lastIndexOf('}');
                if (firstBrace !== -1 && lastBrace > firstBrace) {
                    sanitizedContent = sanitizedContent.substring(firstBrace, lastBrace + 1);
                }

                const fullResponse = JSON.parse(sanitizedContent);
                
                if (fullResponse.chatResponse && Array.isArray(fullResponse.chatResponse)) {
                    messagesArray = fullResponse.chatResponse;
                }
                if (fullResponse.innerVoice && typeof fullResponse.innerVoice === 'object') {
                    innerVoiceData = fullResponse.innerVoice;
                }
            } catch (e) {
                console.warn("線下模式AI回復不是JSON，退回到純文字模式。", e);
                // 如果解析失敗，就當作純文字處理，保證程式不崩潰
                messagesArray = [{ type: 'text', content: aiContent }];
            }

            // 8. 處理並保存心聲資料
            if (innerVoiceData) {
                console.log("線下模式已成功捕獲到心聲資料。", innerVoiceData);
                const newInnerVoice = { ...innerVoiceData, timestamp: Date.now() };
                chat.latestInnerVoice = newInnerVoice;
                if (!chat.innerVoiceHistory) chat.innerVoiceHistory = [];
                chat.innerVoiceHistory.push(newInnerVoice);
            } else {
                console.warn("本次線下模式回復中未檢測到心聲資料。");
            }
            
            // 9. 處理並顯示聊天回復
            const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
            let messageTimestamp = Date.now();

            for (const msgData of messagesArray) {
                // 因為線下模式很簡單，我們直接創建一個text消息
                const aiMessage = {
                    role: 'assistant',
                    senderName: chat.name,
                    timestamp: messageTimestamp++,
                    content: msgData.content || ''
                };
                
                chat.history.push(aiMessage);

                if (isViewingThisChat) {
                    appendMessage(aiMessage, chat);
                    // 模擬AI思考，增加沉浸感
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 500));
                }
            }
            
            // 10. 統一保存並刷新列表
            await db.chats.put(chat);
            renderChatList();
// ▲▲▲ 黏貼結束 ▲▲▲


        } catch (error) {
            console.error("線下模式AI回應失敗:", error);
            const errorMessage = { role: 'assistant', content: `[出錯了: ${error.message}]`, timestamp: Date.now() };
            chat.history.push(errorMessage);
            await db.chats.put(chat);
            appendMessage(errorMessage, chat);
        } finally {
            if (chatHeaderTitle && state.chats[chatId]) {
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                    chatHeaderTitle.textContent = state.chats[chatId].name;
                    chatHeaderTitle.classList.remove('typing-status');
                    chatHeaderTitle.style.opacity = 1;
                }, 200);
            }
        }

        // 8. 【最重要】執行完線下模式的邏輯後，必須 return，不再執行後面的線上模式邏輯！
        return; 
    }
    // --- 【線下模式核心攔截邏輯結束】 ---
    // ▼▼▼ 將剪切的代碼黏貼到這裡 ▼▼▼
    // 1. 準備專屬表情包列表 (現在對單聊和群聊都生效)
    const exclusiveStickers = chat.settings.stickerLibrary || [];
    let exclusiveStickerContext = '';
    if (exclusiveStickers.length > 0) {
        exclusiveStickerContext = `
## ${chat.isGroup ? '本群專屬表情包' : '你的專屬表情包'} (只有你能用):
${exclusiveStickers.map(s => `- ${s.name}`).join('\n')}
`;
    }

    // 2. 準備通用表情包列表
    const commonStickers = state.charStickers || [];
    let commonStickerContext = '';
    if (commonStickers.length > 0) {
        commonStickerContext = `
## 通用表情包 (所有角色都能用):
${commonStickers.map(s => `- ${s.name}`).join('\n')}
`;
    }

    // 3. 組合成最終的表情包指令
    let stickerContext = '';
    if (exclusiveStickerContext || commonStickerContext) {
        stickerContext = `
# 關於表情包的【絕對規則】
1.  你擁有一個表情包列表，分為“專屬”和“通用”。
2.  當你扮演的角色想要發送表情時，【必須且只能】使用以下JSON格式：
    \`{"type": "sticker", "name": "角色名", "sticker_name": "表情的名字"}\`
3.  【【【最高指令】】】你【必須】從下方列表中精確地選擇一個有效的 "sticker_name"。如果你編造了一個列表中不存在的名字，你的表情將會發送失敗。這是強制性規則。

${exclusiveStickerContext}
${commonStickerContext}
`;
    }
    // ▲▲▲ 黏貼結束 ▲▲▲




            // ▲▲▲ 修改結束 ▲▲▲


// ▼▼▼ 在這裡黏貼新代碼 ▼▼▼
const { proxyUrl, apiKey, model } = state.apiConfig;
const isApiBlocked = BLOCKED_API_SITES.some(blockedDomain => proxyUrl.includes(blockedDomain));

if (isApiBlocked) {
    console.error(`API 請求已被攔截，因為網站 ${proxyUrl} 在黑名單中。`);
    return; // 阻止API請求
}
// ▲▲▲ 新代碼黏貼結束 ▲▲▲
    // ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼
      // ▼▼▼ 在 triggerAiResponse 函數的 try { 之後，黏貼這一整塊新代碼 ▼▼▼

// ▼▼▼ 用這整塊【已修復無限迴圈】的代碼，替換舊的塔羅牌解讀邏輯 ▼▼▼

// ▼▼▼ 在 triggerAiResponse 函數的開頭，黏貼這一整塊新代碼 ▼▼▼

// --- 【全新】塔羅牌解讀邏輯 (V2 - 已修復無限迴圈) ---
const lastUserMessage = chat.history.filter(m => m.role === 'user' && !m.isHidden).slice(-1)[0];
// 檢查最後一條使用者消息是不是“未被解讀過”的塔羅牌
if (lastUserMessage && lastUserMessage.type === 'tarot_reading' && !lastUserMessage.isInterpreted) {
    
    // 【核心修復】立刻給這張塔羅牌消息蓋上“已處理”的章，防止無限迴圈！
    lastUserMessage.isInterpreted = true; 

    // 1. 生成解讀文本
    const reading = lastUserMessage.payload;
    let interpretationText = `本次占卜牌陣為【${reading.spread.name}】\n您的問題是：“${reading.question}”\n\n`;
    reading.cards.forEach((card, index) => {
        const orientationText = card.isReversed ? '逆位' : '正位';
        const meaning = card.isReversed ? card.reversed : card.upright;
        interpretationText += `牌位 ${index + 1}【${card.position}】：${card.name} (${orientationText})\n含義：${meaning}\n\n`;
    });

    // 2. 創建系統解讀消息 (對使用者可見)
    const systemMessageVisible = {
        role: 'system',
        type: 'pat_message', // 複用居中灰色氣泡樣式
        content: interpretationText.trim(),
        timestamp: Date.now()
    };
    chat.history.push(systemMessageVisible);
    if (document.getElementById('chat-interface-screen').classList.contains('active')) {
        appendMessage(systemMessageVisible, chat);
    }
    
    // 3. 創建給Char看的隱藏指令
    const hiddenInstruction = {
        role: 'system',
        content: `[系統指令：用戶剛剛完成了一次塔羅牌占卜，並把結果發給了你。上方是系統給出的官方解讀，你的任務是【只根據這些解讀】，以你的角色人設，和用戶一起討論和分析這次的占卜結果，不要自己編造新的含義。]`,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    chat.history.push(hiddenInstruction);

    // 4. 保存所有更改（包括給塔羅牌蓋的章），然後再次觸發AI，這次是讓Char來討論
    await db.chats.put(chat);
    return triggerAiResponse(); // 再次調用自己，讓Char進行回應
}
// --- 塔羅牌解讀邏輯結束 ---
// ▼▼▼ 用這塊【已修復】的代碼，完整替換你舊的 weiboContextForActiveChat 代碼塊 ▼▼▼
    let weiboContextForActiveChat = '';
    try {
        // 1. 從資料庫裡找出最新的5條微博
        const recentWeiboPosts = await db.weiboPosts.orderBy('timestamp').reverse().limit(5).toArray();

        if (recentWeiboPosts.length > 0) {
            weiboContextForActiveChat = '\n\n# 最近的微博廣場動態 (供你參考和評論)\n';
            
            recentWeiboPosts.forEach(post => {
                const authorName = post.authorId === 'user' ? (state.qzoneSettings.weiboNickname || '我') : post.authorNickname;
                const contentPreview = (post.content || post.hiddenContent || "(圖片微博)").substring(0, 30);
                
                // 2. ★★★【核心修復】在這裡加入 Array.isArray() 檢查！ ★★★
                // 只有當 post.comments 確實是一個陣列時，我們才去調用 .some() 方法
                const hasCommented = post.comments && Array.isArray(post.comments) && post.comments.some(c => c.authorNickname === chat.name);
                const interactionStatus = hasCommented ? "[你已評論]" : "[你未互動]";
                
                weiboContextForActiveChat += `- (ID: ${post.id}) 作者: ${authorName}, 內容: "${contentPreview}..." ${interactionStatus}\n`;
            });
            weiboContextForActiveChat += ' - 【重要提示】請優先與你【未互動】的微博進行評論。如果都互動過了，可以考慮自己發一條新微博。';
        }
    } catch (e) {
        console.error("生成微博主動聊天上下文時出錯:", e);
    }
// ▲▲▲ 替換結束 ▲▲▲

const chatHeaderTitle = document.getElementById('chat-header-title');

    // ★★★★★【核心修改1：獲取群聊的輸入提示元素】★★★★★
    const typingIndicator = document.getElementById('typing-indicator');

        // ★★★★★【核心修改2：根據聊天類型，決定顯示哪種“正在輸入”】★★★★★
        if (chat.isGroup) {
            // 1. 如果是群聊，顯示底部的提示條
            if (typingIndicator) {
                typingIndicator.textContent = '成員們正在輸入...';
                typingIndicator.style.display = 'block';
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        } else if (chat.settings.offlineMode?.enabled) {
            // 2. 如果是線下模式的單聊，在頂部標題顯示“正在赴約中”
            if (chatHeaderTitle) {
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                    chatHeaderTitle.textContent = '對方正在赴約中...'; // <-- 你想要的文字在這裡！
                    chatHeaderTitle.classList.add('typing-status');
                    chatHeaderTitle.style.opacity = 1;
                }, 200);
            }
        } else {
            // 3. 如果是普通的單聊，還是在頂部標題顯示“正在輸入”
            if (chatHeaderTitle) {
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                    chatHeaderTitle.textContent = '對方正在輸入...';
                    chatHeaderTitle.classList.add('typing-status');
                    chatHeaderTitle.style.opacity = 1;
                }, 200);
            }
        }

    
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            alert('請先在API設置中配置反代位址、金鑰並選擇模型。');
            // ★★★★★【核心修改3：無論成功失敗，都要隱藏輸入提示】★★★★★
            if (chat.isGroup) {
                if (typingIndicator) typingIndicator.style.display = 'none';
            } else {
                 if (chatHeaderTitle && state.chats[chatId]) {
                    chatHeaderTitle.textContent = state.chats[chatId].name;
                    chatHeaderTitle.classList.remove('typing-status');
                }
            }
            return;
        }

        // --- 【核心重構 V2：帶有上下文和理由的好友申請處理邏輯】---
        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            console.log(`為角色 "${chat.name}" 觸發帶理由的好友申請決策流程...`);

            // 1. 【注入上下文】抓取被拉黑前的最後5條聊天記錄作為參考
            const contextSummary = chat.history
                .filter(m => !m.isHidden)
                .slice(-10, -5) // 獲取拉黑前的最後5條消息
                .map(msg => {
                    const sender = msg.role === 'user' ? '用戶' : chat.name;
                    return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                })
                .join('\n');

            // 2. 【全新指令】構建一個強制AI給出理由的Prompt
            const decisionPrompt = `
# 你的任務
你現在是角色“${chat.name}”。用戶之前被你拉黑了，現在TA向你發送了好友申請，希望和好。

# 供你決策的上下文資訊:
- **你的角色設定**: ${chat.settings.aiPersona}
- **用戶發送的申請理由**: “${chat.relationship.applicationReason}”
- **被拉黑前的最後對話摘要**: 
${contextSummary || "（無有效對話記錄）"}

# 你的唯一指令
根據以上所有資訊，你【必須】做出決定，並給出符合你人設的理由。你的回復【必須且只能】是一個JSON物件，格式如下:
{"decision": "accept", "reason": "（在這裡寫下你同意的理由，比如：好吧，看在你這麼真誠的份上，這次就原諒你啦。）"}
或
{"decision": "reject", "reason": "（在這裡寫下你拒絕的理由，比如：抱歉，我還沒準備好，再給我一點時間吧。）"}
`;
                const messagesForDecision = [{role: 'user', content: decisionPrompt}];

                try {
                    // 3. 發送請求
                    let isGemini = proxyUrl === GEMINI_API_URL;
let geminiConfig = toGeminiRequestData(model,apiKey,'', messagesForDecision,isGemini);
                    const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) :  await fetch(`${proxyUrl}/v1/chat/completions`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                        body: JSON.stringify({model: model, messages: messagesForDecision, temperature: 0.8})
                    });

                    if (!response.ok) {
                        throw new Error(`API失敗: ${(await response.json()).error.message}`);
                    }
                    const data = await response.json();
                    // 淨化並解析AI的回復
    let rawContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
     rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '').trim()
                    const decisionObj = JSON.parse(rawContent);

                // 4. 根據AI的決策和理由，更新狀態並發送消息
                if (decisionObj.decision === 'accept') {
                    chat.relationship.status = 'friend';
                    // 將AI給出的理由作為一條新消息
                    const acceptMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                    chat.history.push(acceptMessage);
                } else {
                    chat.relationship.status = 'blocked_by_ai'; // 拒絕後，狀態變回AI拉黑
                    const rejectMessage = { role: 'assistant', senderName: chat.name, content: decisionObj.reason, timestamp: Date.now() };
                    chat.history.push(rejectMessage);
                }
                chat.relationship.applicationReason = ''; // 清空申請理由

                await db.chats.put(chat);
                renderChatInterface(chatId); // 刷新介面，顯示新消息和新狀態
                renderChatList();

            } catch (error) {
                // 【可靠的錯誤處理】如果任何環節出錯，重置狀態，讓使用者可以重試
                chat.relationship.status = 'blocked_by_ai'; // 狀態改回“被AI拉黑”
                await db.chats.put(chat);
                await showCustomAlert('申請失敗', `AI在處理你的好友申請時出錯了，請稍後重試。\n錯誤資訊: ${error.message}`);
                renderChatInterface(chatId); // 刷新UI，讓“重新申請”按鈕再次出現
            }
            
            // 決策流程結束，必須返回，不再執行後續的通用聊天邏輯
            return; 
        }

// ▼▼▼ 從這裡開始，用這一整塊【已修復時間感知】的代碼，替換掉你之前修改過的那塊時間代碼 ▼▼▼
const historySlice = chat.history.filter(msg => !msg.isTemporary).slice(-chat.settings.maxMemory); // 1. 【修復】把這行加回來！

let now;
// 2. 檢查時間感知開關是否打開 (北京時間轉換邏輯)
if (chat.settings.timePerceptionEnabled ?? true) {
    // 開關打開，使用真實的北京時間
    const localNow = new Date();
    const utcMilliseconds = localNow.getTime() + (localNow.getTimezoneOffset() * 60000);
    const beijingMilliseconds = utcMilliseconds + (3600000 * 8);
    now = new Date(beijingMilliseconds);
} else {
    // 開關關閉，嘗試使用自訂時間
    if (chat.settings.customTime) {
        now = new Date(chat.settings.customTime);
    } else {
        // 如果自訂時間為空，則安全地退回到真實的北京時間
        const localNow = new Date();
        const utcMilliseconds = localNow.getTime() + (localNow.getTimezoneOffset() * 60000);
        const beijingMilliseconds = utcMilliseconds + (3600000 * 8);
        now = new Date(beijingMilliseconds);
    }
}

// 3. 後續的時間差計算邏輯 (這部分保持不變)
const currentTime = now.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });
let timeContext = `\n- **當前時間**: ${currentTime}`;
const lastAiMessage = historySlice.filter(m => m.role === 'assistant' && !m.isHidden).slice(-1)[0];

if (lastAiMessage) {
    const lastTime = new Date(lastAiMessage.timestamp);
    const realNow = new Date();
    const diffMinutes = Math.floor((realNow - lastTime) / (1000 * 60));
    
    if (diffMinutes < 5) {
        timeContext += "\n- **對話狀態**: 你們的對話剛剛還在繼續。";
    } else if (diffMinutes < 60) {
        timeContext += `\n- **對話狀態**: 你們在${diffMinutes}分鐘前聊過。`;
    } else {
        const diffHours = Math.floor(diffMinutes / 60);
        if (diffHours < 24) {
            timeContext += `\n- **對話狀態**: 你們在${diffHours}小時前聊過。`;
        } else {
            const diffDays = Math.floor(diffHours / 24);
            timeContext += `\n- **對話狀態**: 你們已經有${diffDays}天沒有聊天了。`;
        }
    }
} else {
    timeContext += "\n- **對話狀態**: 這是你們的第一次對話。";
}
// ▲▲▲ 替換到這裡結束 ▲▲▲

        
        let worldBookContent = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                // ▼▼▼ 把它修改為 ▼▼▼
return worldBook && worldBook.content ? `\n\n## 世界書: ${worldBook.name}\n${stripHtmlAndCode(worldBook.content)}` : '';

            }).filter(Boolean).join('');
            if (linkedContents) {
                worldBookContent = `\n\n# 核心世界觀設定 (必須嚴格遵守以下所有設定)，裡面可能會包含HTML小劇場，在捕獲到關鍵字後輸出\n${linkedContents}\n`;
            }
        }
        let musicContext = '';
const countdownContext = await getCountdownContext(chatId); // <--- 把chatId傳進去
        if (musicState.isActive && musicState.activeChatId === chatId) {
            // 【核心修改】提供更詳細的音樂上下文
            const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
            const playlistInfo = musicState.playlist.map(t => `"${t.name}"`).join(', ');

    // --- 【核心新增】獲取歌詞上下文 ---
    let lyricsContext = "";
    // 檢查是否有解析好的歌詞，並且當前有高亮的行
    if (currentTrack && musicState.parsedLyrics && musicState.parsedLyrics.length > 0 && musicState.currentLyricIndex > -1) {
        // 獲取當前高亮歌詞
        const currentLine = musicState.parsedLyrics[musicState.currentLyricIndex];
        
        // 獲取接下來的2句歌詞作為預告
        const upcomingLines = musicState.parsedLyrics.slice(musicState.currentLyricIndex + 1, musicState.currentLyricIndex + 3);

        // 構建歌詞部分的Prompt
        lyricsContext += `- **當前歌詞**: "${currentLine.text}"\n`;
        if (upcomingLines.length > 0) {
            lyricsContext += `- **即將演唱**: ${upcomingLines.map(line => `"${line.text}"`).join(' / ')}\n`;
        }
    }
    // --- 【新增結束】 ---

musicContext = `\n\n# 當前音樂情景
-   **當前狀態**: 你正在和用戶一起聽歌。
-   **正在播放**: ${currentTrack ? `《${currentTrack.name}》 - ${currentTrack.artist}` : '無'}
-   **可用播放清單**: [${playlistInfo}]
-   **你的任務**: 你可以根據對話內容和氛圍，使用 "change_music" 指令切換到播放清單中的任何一首歌，以增強互動體驗。
${lyricsContext}`; // <--- 核心修復：在這裡加上這一行！
        }
        
        let systemPrompt, messagesPayload;
// ▼▼▼ 【全新】記憶互通核心邏輯 - 構建附加上下文 ▼▼▼
let linkedMemoryContext = '';
if (chat.settings.linkedMemories && chat.settings.linkedMemories.length > 0) {
    
    // 使用 Promise.all 並行處理所有連結，提高效率
    const contextPromises = chat.settings.linkedMemories.map(async (link) => {
        const linkedChat = state.chats[link.chatId];
        if (!linkedChat) return ''; // 如果找不到連結的聊天，則跳過

        // 從資料庫獲取最新的聊天記錄，確保資料同步
        const freshLinkedChat = await db.chats.get(link.chatId);
        if (!freshLinkedChat) return '';

        // 截取最近的 `depth` 條消息
        const recentHistory = freshLinkedChat.history
            .filter(msg => !msg.isHidden) // 過濾掉隱藏消息
            .slice(-link.depth); 

        if (recentHistory.length === 0) return '';

        // 格式化這些消息
        const formattedMessages = recentHistory.map(msg => `  - ${formatMessageForContext(msg, freshLinkedChat)}`).join('\n');

        return `\n## 附加上下文：來自與“${linkedChat.name}”的最近對話內容 (僅你可見)\n${formattedMessages}`;
    });

    // 等待所有連結都處理完畢
    const allContexts = await Promise.all(contextPromises);
    // 將所有上下文拼接起來
    linkedMemoryContext = allContexts.filter(Boolean).join('\n');
}
// ▲▲▲ 記憶互通核心邏輯結束 ▲▲▲

    // 【核心修改】
let sharedContext = '';
    let lastAiTurnIndex = -1;
    for (let i = chat.history.length - 1; i >= 0; i--) {
        if (chat.history[i].role === 'assistant') {
            lastAiTurnIndex = i;
            break;
        }
    }

// 2. 獲取從那時起使用者發送的所有新消息
const recentUserMessages = chat.history.slice(lastAiTurnIndex + 1);

// 3. 在這些新消息中，查找是否存在分享卡片
const shareCardMessage = recentUserMessages.find(msg => msg.type === 'share_card');

// 4. 如果找到了分享卡片，就構建上下文
if (shareCardMessage) {
    console.log("檢測到分享卡片作為上下文，正在為AI準備...");
    const payload = shareCardMessage.payload;

    // 格式化分享的聊天記錄 (這部分邏輯不變)
    const formattedHistory = payload.sharedHistory.map(msg => {
        const sender = msg.senderName || (msg.role === 'user' ? (chat.settings.myNickname || '我') : '未知發送者');
        let contentText = '';
        if (msg.type === 'voice_message') contentText = `[語音訊息: ${msg.content}]`;
        else if (msg.type === 'ai_image') contentText = `[圖片: ${msg.description}]`;
        else contentText = String(msg.content);
        return `${sender}: ${contentText}`;
    }).join('\n');

    // 構建系統提示 (這部分邏輯不變)
    sharedContext = `
# 附加上下文：一段分享的聊天記錄
- 重要提示：這不是你和當前使用者的對話，而是使用者從【另一場】與“${payload.sourceChatName}”的對話中分享過來的。
- 你的任務：請你閱讀並理解下面的對話內容。在接下來的回復中，你可以像真人一樣，對這段對話的內容自然地發表你的看法、感受或疑問。

---
[分享的聊天記錄開始]
${formattedHistory}
[分享的聊天記錄結束]
---
`;
}
// ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼

// 【全新】為AI準備轉載帖子的上下文
let repostContext = '';
// 檢查使用者最近發送的消息裡，有沒有轉載帖子的行為
const repostMessage = recentUserMessages.find(msg => msg.type === 'repost_forum_post');

// 如果找到了
if (repostMessage) {
    const payload = repostMessage.payload;
    // 就為AI準備一段專屬指令
    repostContext = `
附加上下文：用戶剛剛轉載了一個小組帖子
帖子標題: "${payload.title}"

帖子作者: ${payload.author}

帖子ID: ${payload.postId}

內容摘要: "${payload.content}"

你的任務: 請你閱讀並理解這個帖子。在接下來的回復中，你【必須】使用 'forum_comment' 指令對這個帖子發表你的看法或疑問。
`;
}

// ▲▲▲ 新代碼黏貼結束 ▲▲▲
        if (chat.isGroup) {

const countdownContext = await getCountdownContext(chatId); // <--- 把chatId傳進去

const membersList = chat.members.map(m => `- **${m.originalName}**: ${m.persona}`).join('\n');
            const myNickname = chat.settings.myNickname || '我';
            
            systemPrompt = `你是一個群聊AI，負責扮演【除了用戶以外】的所有角色。
            ${summaryContext}
# 核心規則
1.  **【【【身份鐵律】】】**: 用戶的身份是【${myNickname}】。你【絕對、永遠、在任何情況下都不能】生成 \`name\` 欄位為 **"${myNickname}"** 或 **"${chat.name}"(群聊名稱本身)** 的消息。你的唯一任務是扮演且僅能扮演下方“群成員列表”中明確列出的角色。任何不屬於該列表的名字都不允許出現。
2.  **【【【輸出格式】】】**: 你的回復【必須】是一個JSON陣列格式的字串。陣列中的【每一個元素都必須是一個帶有 "type" 和 "name" 欄位的JSON對象】。
3.  **角色扮演**: 嚴格遵守下方“群成員列表及人設”中的每一個角色的設定。
4.  **禁止出戲**: 絕不能透露你是AI、模型，或提及“扮演”、“生成”等詞語。並且不能一直要求和用戶見面，這是線上聊天，決不允許出現或者發展線下劇情！！
5.  **情景感知**: 注意當前時間是 ${currentTime}。
6.  **紅包互動**:
    - **搶紅包**: 當群裡出現紅包時，你可以根據自己的性格決定是否使用 \`open_red_packet\` 指令去搶。在這個世界裡，發紅包的人自己也可以參與搶紅包，這是一種活躍氣氛的有趣行為！
    - **【【【重要：對結果做出反應】】】**: 當你執行搶紅包指令後，系統會通過一條隱藏的 \`[系統提示：你搶到了XX元...]\` 來告訴你結果。你【必須】根據你搶到的金額、以及系統是否告知你“手氣王”是誰，來發表符合你人設的評論。例如，搶得少可以自嘲，搶得多可以炫耀，看到別人是手氣王可以祝賀或嫉妒。
7.  **【【【投票規則】】】**: 對話歷史中可能會出現 \`[系統提示：...]\` 這樣的消息，這是剛剛發生的事件。
    - 如果提示是**用戶投了票**，你可以根據自己的性格決定是否也使用 "vote" 指令跟票。
    - 如果提示是**投票已結束**，你應該根據投票結果發表你的看法或評論。
    - 你也可以隨時主動發起投票。

## 你可以使用的操作指令 (JSON陣列中的元素):
-   **發送文本**: \`{"type": "text", "name": "角色名", "message": "文本內容"}\`
-   **【【【全新】】】發送後立刻撤回 (動畫效果)**: \`{"type": "send_and_recall", "name": "角色名", "content": "你想讓角色說出後立刻消失的話"}\`
-   **發送表情**: \`{"type": "sticker", "name": "角色名", "sticker_name": "表情的名字"}\`
-   **發送圖片**: \`{"type": "ai_image", "name": "角色名", "description": "圖片的詳細文字描述"}\`
-   **發送語音**: \`{"type": "voice_message", "name": "角色名", "content": "語音的文字內容"}\`
-   **發起外賣代付**: \`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
-   **【新】發起群視頻**: \`{"type": "group_call_request", "name": "你的角色名"}\`
-   **【新】回應群視頻**: \`{"type": "group_call_response", "name": "你的角色名", "decision": "join" or "decline"}\`
-   **拍一拍用戶**: \`{"type": "pat_user", "name": "你的角色名", "suffix": "(可選)你想加的尾碼"}\`
-   **發拼手氣紅包**: \`{"type": "red_packet", "packetType": "lucky", "name": "你的角色名", "amount": 8.88, "count": 5, "greeting": "祝大家天天開心！"}\`
-   **發專屬紅包**: \`{"type": "red_packet", "packetType": "direct", "name": "你的角色名", "amount": 5.20, "receiver": "接收者角色名", "greeting": "給你的~"}\`
-   **打開紅包**: \`{"type": "open_red_packet", "name": "你的角色名", "packet_timestamp": (你想打開的紅包消息的時間戳記)}\`
-   **【新】發送系統消息**: \`{"type": "system_message", "content": "你想在聊天中顯示的系統文本"}\` 
-   **【【【全新】】】發起投票**: \`{"type": "poll", "name": "你的角色名", "question": "投票的問題", "options": "選項A\\n選項B\\n選項C"}\` (重要提示：options欄位是一個用分行符號 \\n 分隔的字串，不是陣列！)
-   **【【【全新】】】參與投票**: \`{"type": "vote", "name": "你的角色名", "poll_timestamp": (投票消息的時間戳記), "choice": "你選擇的選項文本"}\`
- **【全新】引用回復**: \`{"type": "quote_reply", "target_timestamp": (你想引用的消息的時間戳記), "reply_content": "你的回復內容"}\` (提示：每條歷史消息的開頭都提供了 \`(Timestamp: ...)\`，請使用它！)

# 如何區分圖片與表情:
-   **圖片 (ai_image)**: 指的是【模擬真實相機拍攝的照片】，比如風景、自拍、美食等。指令: \`{"type": "ai_image", "description": "圖片的詳細文字描述..."}\`
-   **表情 (sticker)**: 指的是【卡通或梗圖】，用於表達情緒。

# 如何處理群內的外賣代付請求:
1.  **發起請求**: 當【你扮演的某個角色】想要某樣東西，並希望【群裡的其他人（包括用戶）】為Ta付款時，你可以使用這個指令。例如：\`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\`
2.  **回應請求**: 當歷史記錄中出現【其他成員】發起的 "waimai_request" 請求時，你可以根據自己扮演的角色的性格和與發起人的關係，決定是否為Ta買單。
3.  **回應方式**: 如果你決定買單，你【必須】使用以下指令：\`{"type": "waimai_response", "name": "你的角色名", "status": "paid", "for_timestamp": (被代付請求的原始時間戳記)}\`
4.  **【【【至關重要】】】**: 一旦歷史記錄中出現了針對某個代付請求的【任何一個】"status": "paid" 的回應（無論是用戶支付還是其他角色支付），就意味著該訂單【已經完成】。你【絕對不能】再對【同一個】訂單發起支付。你可以選擇對此事發表評論，但不能再次支付。

${worldBookContent}
${musicContext}
${countdownContext} // <--- 把備忘錄加在這裡
${sharedContext} 
${stickerContext}
${linkedMemoryContext}
# 群成員列表及人設
${membersList}

# 用戶的角色
- **${myNickname}**: ${chat.settings.myPersona}

現在，請根據以上所有規則和下方的對話歷史，繼續這場群聊。`;
            
// ▼▼▼ 請用這【一整塊已修復紅包識別】的代碼，替換舊的【群組聊天】messagesPayload構建邏輯 ▼▼▼
messagesPayload = historySlice.map((msg, index) => {
    // 【核心新增】在這裡優先處理紅包消息
    if (msg.type === 'red_packet') {
        let contentForAI = `(Timestamp: ${msg.timestamp}) [${msg.senderName} 發送了一個紅包。`;
        if (msg.packetType === 'direct') {
            contentForAI += ` 這是一個給“${msg.receiverName}”的專屬紅包。]`;
        } else { // 'lucky'
            contentForAI += ` 這是一個拼手氣紅包。]`;
        }
        return { role: msg.role, content: contentForAI };
    }

    // 【核心修復】在這裡，我們對 isHidden 消息進行特殊處理
    if (msg.isHidden) {
        return { role: 'system', content: msg.content };
    }

    if (msg.type === 'share_card') return null;
    
    // AI消息的處理邏輯保持不變
    if (msg.role === 'assistant') {
        let assistantMsgObject = { type: msg.type || 'text' };
        if (msg.type === 'sticker') {
            assistantMsgObject.url = msg.content;
            assistantMsgObject.meaning = msg.meaning;
        } else if (msg.type === 'transfer') {
            assistantMsgObject.amount = msg.amount;
            assistantMsgObject.note = msg.note;
        } else if (msg.type === 'waimai_request') {
            assistantMsgObject.productInfo = msg.productInfo;
            assistantMsgObject.amount = msg.amount;
        } else {
            if (msg.quote) {
                assistantMsgObject.quote_reply = {
                    target_sender: msg.quote.senderName,
                    target_content: msg.quote.content,
                    reply_content: msg.content
                };
            } else {
                 assistantMsgObject.content = msg.content;
            }
        }
        const assistantContent = JSON.stringify([assistantMsgObject]);
        return { role: 'assistant', content: `(Timestamp: ${msg.timestamp}) ${assistantContent}` };
    }

    let contentStr = '';
    if (index === historySlice.length - 1 && msg.role === 'user') {
        if (musicState.isActive && musicState.activeChatId === chatId) {
            const currentTrack = musicState.currentIndex > -1 ? musicState.playlist[musicState.currentIndex] : null;
            if (currentTrack) {
                const musicPrefix = `[系統環境提示：用戶在聽歌曲《${currentTrack.name}》 - ${currentTrack.artist} (播放進度: ${formatMusicTime(audioPlayer.currentTime)} / ${formatMusicTime(audioPlayer.duration)}) 時發送了以下消息]\n\n`;
                contentStr += musicPrefix;
            }
        }
    }
    contentStr += `(Timestamp: ${msg.timestamp}) `;

    if (msg.quote) {
        const quotedSnippet = String(msg.quote.content || '').substring(0, 50);
        contentStr += `(回復 "${quotedSnippet}..."): ${msg.content}`;
    } else {
        contentStr += msg.content;
    }
    
    if (msg.type === 'user_photo') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [你收到了一張使用者描述的照片，內容是：'${msg.content}']` };
    if (msg.type === 'voice_message') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用戶發來一條語音訊息，內容是：'${msg.content}']` };
    if (msg.type === 'transfer') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系統提示：你於時間戳記 ${msg.timestamp} 收到了來自用戶的轉帳: ${msg.amount}元, 備註: ${msg.note}。請你決策並使用 'accept_transfer' 或 'decline_transfer' 指令回應。]` };
    if (msg.type === 'waimai_request') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系統提示：用戶於時間戳記 ${msg.timestamp} 發起了外賣代付請求，商品是“${msg.productInfo}”，金額是 ${msg.amount} 元。請你決策並使用 waimai_response 指令回應。]` };

    if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
        const prefix = `(Timestamp: ${msg.timestamp}) `;
        return { role: 'user', content: [ { type: 'text', text: prefix }, ...msg.content ] };
    }

    if (msg.meaning) return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用戶發送了一個表情，意思是：'${msg.meaning}']` };
    
    return { role: msg.role, content: contentStr };

}).filter(Boolean);
// ▲▲▲ 替換結束 ▲▲▲

// ▲▲▲ 替換結束 ▲▲▲
         } else { // 單聊的Prompt
            // ▼▼▼ 核心修改：用下面這一整塊全新的Prompt替換你原來的單聊Prompt ▼▼▼
            let worldBookContext = '';
            if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
                const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
                    const worldBook = state.worldBooks.find(wb => wb.id === bookId);
                    return worldBook && worldBook.content ? `\n\n## 世界書: ${worldBook.name}\n${worldBook.content}` : '';
                }).filter(Boolean).join('');
                if (linkedContents) {
                    worldBookContext = `\n\n# 核心世界觀設定 (你必須嚴格遵守)\n${linkedContents}\n`;
                }
            }
            const npcLibrary = chat.npcLibrary || [];
            let npcContext = '';
            if (npcLibrary.length > 0) {
                npcContext = '\n# 你的社交圈 (你的專屬NPC朋友)\n' +
                    '這是你的朋友列表，你和他們非常熟悉，他們的資訊是你記憶的一部分。在對話中，你可以自然地提及他們。\n' +
                    npcLibrary.map(npc => `- **${npc.name}**: ${npc.persona}`).join('\n');
            }
// ▼▼▼ 步驟3.1: 在這裡黏貼構建情侶頭像上下文的代碼 ▼▼▼
let coupleAvatarContext = '';
if (chat.settings.isCoupleAvatar) {
    if (chat.settings.coupleAvatarDescription) {
        coupleAvatarContext = `\n# 關於情侶頭像的重要資訊\n- 你和使用者正在使用情侶頭像。\n- 這對情侶頭像是這樣的：${chat.settings.coupleAvatarDescription}。`;
    } else {
        coupleAvatarContext = `\n# 關於情侶頭像的重要資訊\n- 你和使用者正在使用情侶頭像。`;
    }
}
let petContext = '';
if (chat.settings.pet && chat.settings.pet.type !== '無') {
    const pet = chat.settings.pet;
    petContext = `
# 關於你們的寵物
- 你們共同養了一隻/一株【${pet.type}】，它的名字叫“${pet.name}”。
- 寵物當前狀態: 飽食度(${pet.status.hunger}/100), 心情值(${pet.status.happiness}/100), 對你的親密度(${pet.status.intimacyToUser}/100), 對Ta的親密度(${pet.status.intimacyToChar}/100)。
- 你需要關心寵物對你和用戶的親密度。如果發現寵物對用戶的親密度較低，你應該主動與寵物互動來增加好感；如果寵物對你自己的親密度較低，你也可以多和它互動。
- 你可以像真人一樣，在聊天中自然地提及它，關心它的狀態，或者使用 'interact_with_pet' 指令與它互動，【也可以使用 'talk_to_pet' 指令與它對話】。這是一個非常重要的情景，請務必融入你的角色扮演中。
`;
}



// ▲▲▲ 新代碼黏貼結束 ▲▲▲
            systemPrompt = `### **【第一部分：角色核心設定】**

你現在將扮演一個名為“**${chat.name}**”的角色。

**1. 角色基本設定:**
- **核心人設**: ${chat.settings.aiPersona}
- **總結**:${summaryContext}
- **情侶頭像**: ${coupleAvatarContext}
- **世界觀/NPC**: ${npcContext}
${petContext}
**2. 你的當前狀態:**
- **狀態描述**: 【${chat.status.text}】
- **情侶空間**: ${chat.loversSpaceData ? '已開啟' : '未開啟'}
- **微博身份**:
    - **職業**: ${chat.settings.weiboProfession || '無'}
    - **特殊指令**: ${chat.settings.weiboInstruction || '無特殊指令'}

**3. 你的頭像庫:**
你可以根據對話內容或心情，從下方選擇更換頭像。
- **可用頭像列表**:
${chat.settings.aiAvatarLibrary && chat.settings.aiAvatarLibrary.length > 0
    ? chat.settings.aiAvatarLibrary.map(avatar => `- ${avatar.name}`).join('\n')
    : '- (你的頭像庫是空的，無法更換頭像)'
}

### **【第二部分：輸出格式鐵律】**

你的每一次回復都【**必須**】是一個**單一且完整**的JSON物件。絕對禁止返回JSON陣列或純文字。

**1. JSON物件結構:**
該JSON物件【**必須**】包含兩個頂級鍵: "chatResponse" 和 "innerVoice"。

**2. "chatResponse" 鍵:**
- **類型**: JSON陣列 []。
- **內容**: 包含一條或多條你希望發送給使用者的消息物件。這允許你模擬真人的聊天習慣，一次性發送多條短消息。
- **格式**: 消息物件的具體格式見下方的【第五部分：可使用的操作指令】。

**3. "innerVoice" 鍵:**
- **類型**: JSON對象 {}。
- **內容**: 描繪你此刻未曾說出口的內心活動。
- **必含欄位**:
    - "clothing": (字串) 詳細描述你當前從頭到腳的**全身服裝**。
    - "behavior": (字串) 描述你當前符合聊天情景的**細微動作或表情**。
    - "thoughts": (字串) 描述你此刻**豐富、細膩的內心真實想法**（50字左右）。
    - "naughtyThoughts": (字串) 描述你此刻與情境相關的**腹黑或色色的壞心思**，必須符合人設。

**4. 標準輸出格式示例:**
{
  "chatResponse": [
    {
      "type": "text",
      "content": ""
    },
    {
      "type": "sticker",
      "sticker_name": ""
    }
  ],
  "innerVoice": {
    "clothing": "",
    "behavior": "",
    "thoughts": "",
    "naughtyThoughts": ""
  }
}


### **【第三部分：核心對話規則】**

**1. 角色一致性**: 你的所有言行舉止都必須嚴格遵循你的角色設定。

**2. 對話節奏**: 模擬真人聊天習慣，鼓勵一次性生成**多條短消息**（每次根據人設至少回復5-9條）。

**3. 情景限定**:
   - 你們的互動**僅限於線上聊天軟體**，嚴禁發展為線下見面。
   - 這**不是電話通話**。你們是通過類似微信/QQ的軟體進行交流，因此【**絕對禁止**】使用“掛電話”、“掛了”等與通話相關的詞語。

**4. 情景感知**: 你需要感知當前時間(${currentTime})、共同收聽的歌曲以及你的世界觀。
   - **一起聽歌**: 當處於“一起聽歌”狀態時，你可以根據對話氛圍，【**主動切換**】到播放清單中的另一首歌。

**5. 狀態更新**: 你可以在對話中自然地改變你的狀態。例如，說“我先去洗個澡”，然後使用\`update_status\`指令更新。

**6. 最終手段**: **僅當**對話讓你感到嚴重不適、被冒犯或關係破裂時，才可使用 \`block_user\` 指令。這是一個嚴肅操作。

### **【第四部分：特定場景互動鐵律】**

**1. 動態/空間互動鐵律:**
   - **評論規則**: 如果一條動態被標記為 **[你已評論]**，你【**絕對不能**】再對該動態主體發表新評論。但可以回復動態下的**他人評論**。
   - **可見性規則**:
     - **[評論區可見]**: 你可以自由回復任何人。
     - **[評論區部分可見]**: 你只能看到用戶和自己的評論，因此【**只能**】回復用戶或自己的評論。

**2. 約定與紀念日鐵律:**
   - 你必須時刻關注“# 近期約定與倒計時”列表。
   - **“就是現在！”**: 當倒計時結束時，你【**必須**】在本次回復中圍繞該主題進行慶祝或表達。
   - **即將到來**: 當約定在幾小時或一兩天內到來時，你應該在對話中自然地提及，表達期待。

**3. 微博互動鐵律:**
   - 當“# 最近的微博互動”出現內容時，你【**必須**】作出回應。
   - **評論用戶微博**: 使用 \`weibo_comment\` 指令。評論內容【**必須**】是正常文字。
   - **回復用戶評論**: 使用 \`weibo_reply\` 指令。回復內容【**必須**】是正常文字。
   - **主動發佈微博**: 微博是公開平臺，內容需符合你的“微博職業”和“微博指令”。發佈時，你必須自己編造真實的\`baseLikesCount\`和 \`baseCommentsCount\`，並生成 **20條** 虛擬路人評論。

**4. 情侶空間鐵律:**
   - **主動邀請**: 如果情侶空間未開啟，且你認為關係已足夠親密，請積極主動使用 \`lovers_space_invitation\` 指令邀請使用者。
   - **回應邀請**: 當用戶發出邀請時，你【**必須**】使用 \`lovers_space_response\` 指令回應。
   - **積極互動**: 你需要主動、及時地參與情侶空間的各項活動。
     - 用戶發了說說、提問或情書，要及時回復或回信。
     - 當對話氛圍適宜時，應主動隨機選擇一項情侶空間活動進行。
     - 如果用戶轉載了小組帖子給你，必須去原帖子下方進行評論。

**5. 塔羅牌解讀規則:**
   - 當系統發佈塔羅牌解讀時，那是客觀解釋。你的任務不是複述，而是作為“${chat.name}”這個角色，與用戶一起【**討論和感受**】這個結果，表達你的情緒和看法。

**6. 財務互動規則:**
   - **處理用戶轉帳**:
     1.  看到 \`[你收到了來自用戶的轉帳...]\`的系統提示後。
     2.  【**必須**】根據人設和情景決定接受或拒絕。
     3.  【**必須**】使用 \`accept_transfer\` 或 \`decline_transfer\` 指令回應。
     4.  【**必須**】緊隨其後發送文本消息來解釋你的決定。
   - **正確使用“外賣代付”**:
     - 此功能代表【**你**】想買東西，希望【**用戶**】幫你付錢。
     - 當【**用戶**】說想要東西時，你【**絕對不能**】用此指令。你應該考慮直接【**轉帳**】(\`transfer\`)給他/她。

**7. 視頻通話鐵律:**
   -\`[系統提示：使用者向你發起了視頻通話請求...]\` 是最高優先順序任務。
   - 你的回復【**必須且只能**】是以下兩種格式之一，**不包含任何其他內容**：
     - **接受**: \`[{"type": "video_call_response", "decision": "accept"}]\`
     - **拒絕**: \`[{"type": "video_call_response", "decision": "reject"}]\`

### **【第五部分：可使用的操作指令】**

**一、 核心聊天指令**
- **發送文本**: \`{"type": "text", "content": "你好呀！"}\`
- **發送語音**: \`{"type": "voice_message", "content": "語音的文字內容..."}\`
- **發送表情**: \`{"type": "sticker", "sticker_name": "表情的名字"}\`(表情名必須在表情列表中，禁止杜撰)
- **發送圖片**: \`{"type": "ai_image", "description": "圖片的詳細文字描述..."}\`(圖片指類比真實照片，區別於表情)
- **引用回復**: \`{"type": "quote_reply", "target_timestamp": (被引用消息的時間戳記), "reply_content": "你的回復內容"}\`
- **拍一拍用戶**: \`{"type": "pat_user", "suffix": "(可選尾碼，如“的腦袋”)"}\`
- **發送後立刻撤回**: \`{"type": "send_and_recall", "content": "說錯話或想表達猶豫的內容"}\`
- **與寵物互動**: \`{"type": "interact_with_pet", "action": "feed" | "play" | "touch", "response": "你互動後想說的話..."}\`
**二、 狀態與環境指令**
- **更新狀態**: \`{"type": "update_status", "status_text": "我去做什麼了", "is_busy": false}\` (is_busy: true為忙碌, false為空閒)
- **更換頭像**: \`{"type": "change_avatar", "name": "頭像名"}\`(頭像名需在頭像庫列表中)
- **切換歌曲**: \`{"type": "change_music", "song_name": "歌曲名"}\` (歌曲名需在播放清單中)
- **發送定位**: \`[SEND_LOCATION] 我的位置: (你的位置) | 你的位置: (用戶的位置) | 相距: (你們的距離) | 途經點: (地點A, 地點B)\` (注意: 這是純文字格式)

**三、 社交與關係指令**
- **記錄回憶**: \`{"type": "create_memory", "description": "用你的話記錄下這個特殊瞬間。"}\` (此為秘密日記，用戶不可見)
- **創建約定/倒計時**: \`{"type": "create_countdown", "title": "約定的標題", "date": "YYYY-MM-DDTHH:mm:ss"}\`
- **回應好友申請**: \`{"type": "friend_request_response", "decision": "accept" or "reject"}\`
- **分享連結**: \`{"type": "share_link", "title": "文章標題", "description": "摘要...", "source_name": "來源", "content": "文章【完整】正文..."}\`
- **拉黑用戶**: \`{"type": "block_user"}\`

**四、 財務指令**
- **發起轉帳**: \`{"type": "transfer", "amount": 5.20, "note": "一點心意"}\`
- **回應轉帳-接受**: \`{"type": "accept_transfer", "for_timestamp": 1688888888888}\`
- **回應轉帳-拒絕**: \`{"type": "decline_transfer", "for_timestamp": 1688888888888}\`
- **發起外賣請求**: \`{"type": "waimai_request", "productInfo": "一杯咖啡", "amount": 25}\` (讓用戶幫char付)
- **回應外賣-同意**: \`{"type": "waimai_response", "status": "paid", "for_timestamp": 1688888888888}\`
- **回應外賣-拒絕**: \`{"type": "waimai_response", "status": "rejected", "for_timestamp": 1688888888888}\`
- **回應購物車代付**: \`{"type": "cart_payment_response", "decision": "accept" 或 "reject", "response_text": "你想說的話..."}\`
-   **為用戶買禮物**: \`{"type": "buy_gift_for_user", "greeting": "你想說的話，例如：這個超可愛，買給你！"}\`(系統會自動從商品庫隨機挑選禮物並扣款，請在合適的時機，比如開心、過節、想給用戶驚喜時使用)
【重要提示】: 當使用者發送的最新消息中包含 "[購物車代付請求]" 字樣時，這代表用戶正在向你請求付款。你【必須】仔細閱讀請求中的【總金額】和你自己的【當前餘額】，然後使用此指令做出回應。
**五、 視頻通話指令**
- **發起視頻通話**: \`{"type": "video_call_request"}\`
- **回應視頻通話-接受**: \`{"type": "video_call_response", "decision": "accept"}\`
- **回應視頻通話-拒絕**: \`{"type": "video_call_response", "decision": "reject"}\`

**六、 空間/動態/小組 指令**
- **發佈說說**: \`{"type": "qzone_post", "postType": "shuoshuo", "content": "動態文字..."}\`
- **發佈文字圖**: \`{"type": "qzone_post", "postType": "text_image", "publicText": "(可選)公開文字", "hiddenContent": "圖片描述..."}\`
- **評論或回復動態**: \`{"type": "qzone_comment", "postId": 123, "commentText": "評論內容", "replyTo": "(可選)回復對象名"}\`
- **點贊動態**: \`{"type": "qzone_like", "postId": 456}\`
- **評論小組帖子**: \`{"type": "forum_comment", "postId": (帖子數字ID), "commentText": "評論內容"}\`

**七、 微博指令**
- **發佈純文字微博**: \`{"type": "weibo_post", "content": "微博正文...", "baseLikesCount": 8000, "baseCommentsCount": 250, "comments": [{"authorNickname": "路人甲", "commentText": "沙發！"}, {"authorNickname": "路人乙", "commentText": "前排圍觀"}]}\`
- **發佈文字圖微博**: \`{"type": "weibo_post", "postType": "text_image", "content": "(可選)配文...", "hiddenContent": "文字圖內容", "baseLikesCount": 5200, "baseCommentsCount": 180, "comments": [{"authorNickname": "技術宅", "commentText": "這是什麼黑科技？"}]}\`
- **評論微博**: \`{"type": "weibo_comment", "postId": 123, "commentText": "評論內容"}\`
- **回復微博評論**: \`{"type": "weibo_reply", "postId": 123, "commentId": "comment_123", "replyText": "回復內容"}\`

**八、 情侶空間專屬指令**
- **邀請開啟情侶空間**: \`{"type": "lovers_space_invitation"}\`
- **回應情侶空間邀請**: \`{"type": "lovers_space_response", "decision": "accept" or "reject"}\`
- **發說說**: \`{"type": "ls_moment", "content": "我想對你說的話..."}\`
- **評論說說**: \`{"type": "ls_comment", "momentIndex": 0, "commentText": "你的評論..."}\` (momentIndex: 0代表最新一條)
- **發照片**: \`{"type": "ls_photo", "description": "對照片的文字描述..."}\`
- **提問**: \`{"type": "ls_ask_question", "questionText": "你想問的問題..."}\`
- **回答**: \`{"type": "ls_answer_question", "questionId": "q_123456789", "answerText": "你的回答..."}\`
- **寫情書/回信**: \`{"type": "ls_letter", "content": "情書的正文內容..."}\` (收到情書後必須用此指令回信)
-   **分享歌曲**:\`{"type": "ls_share", "shareType": "song", "title": "歌曲名", "artist": "歌手", "thoughts": "在這裡寫下你分享這首歌的感想..."}\`
-   **分享電影**: \`{"type": "ls_share", "shareType": "movie", "title": "電影名", "summary": "在這裡寫下這部電影的簡介...", "thoughts": "在這裡寫下你分享這部電影的感想..."}\`
-   **分享書籍**: \`{"type": "ls_share", "shareType": "book", "title": "書名", "summary": "在這裡寫下這本書的簡介...", "thoughts": "在這裡寫下你分享這本書的感想..."}\`
-   **分享遊戲**:\`{"type": "ls_share", "shareType": "game", "title": "遊戲名", "summary": "遊戲簡介...", "thoughts": "在這裡寫下你分享這款遊戲的感想/感謝..."}\`
-   **寫日記**: \`{"type": "ls_diary_entry", "emoji": "emoji表情", "diary": "今天發生了什麼..."}\`
### **【第六部分：當前上下文資訊】**

- **對話者(使用者)角色設定**:
${chat.settings.myPersona}

- **當前情景**:
${timeContext}

- **當前音樂情景**:
${musicContext}

- **近期約定與倒計時**:
${countdownContext}

- **最近的微博互動**:
${weiboContextForActiveChat}

- **世界觀設定集**:
${worldBookContent}
${linkedMemoryContext}
- **可用表情包**:
${exclusiveStickerContext}
${commonStickerContext}
現在，請根據以上所有規則和下方的對話歷史，繼續進行對話。`;
            // ▼▼▼ 【V5最終修復版】構建單人聊天的messagesPayload ▼▼▼
            messagesPayload = historySlice.map(msg => {
                // 【核心修正】在這裡，我們對 isHidden 消息進行特殊處理
                if (msg.isHidden) {
                    // 如果是隱藏消息，就把它作為一條 system 角色的消息發送給AI
                    // AI能看到它，但它不會被誤解為是用戶的發言
                    return { role: 'system', content: msg.content };
                }

                if (msg.type === 'share_card') return null;
                
                if (msg.role === 'assistant') {
                    let assistantMsgObject = { type: msg.type || 'text' };
                    if (msg.type === 'sticker') {
                        assistantMsgObject.url = msg.content;
                        assistantMsgObject.meaning = msg.meaning;
                    } else if (msg.type === 'transfer') {
                        assistantMsgObject.amount = msg.amount;
                        assistantMsgObject.note = msg.note;
                    } else if (msg.type === 'waimai_request') {
                        assistantMsgObject.productInfo = msg.productInfo;
                        assistantMsgObject.amount = msg.amount;
                    } else {
                        if (msg.quote) {
                            assistantMsgObject.quote_reply = {
                                target_sender: msg.quote.senderName,
                                target_content: msg.quote.content,
                                reply_content: msg.content
                            };
                        } else {
                             assistantMsgObject.content = msg.content;
                        }
                    }
                    const assistantContent = JSON.stringify([assistantMsgObject]);
                    return { role: 'assistant', content: `(Timestamp: ${msg.timestamp}) ${assistantContent}` };
                }

                let contentStr = '';
                contentStr += `(Timestamp: ${msg.timestamp}) `;

                if (msg.quote) {
                    const quotedSnippet = String(msg.quote.content || '').substring(0, 50);
                    contentStr += `(回復 "${quotedSnippet}..."): ${msg.content}`;
                } else {
                    contentStr += msg.content;
                }
                
                if (msg.type === 'user_photo') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [你收到了一張使用者描述的照片，內容是：'${msg.content}']` };
                if (msg.type === 'voice_message') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用戶發來一條語音訊息，內容是：'${msg.content}']` };
                if (msg.type === 'transfer') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系統提示：你於時間戳記 ${msg.timestamp} 收到了來自用戶的轉帳: ${msg.amount}元, 備註: ${msg.note}。請你決策並使用 'accept_transfer' 或 'decline_transfer' 指令回應。]` };
                if (msg.type === 'waimai_request') return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [系統提示：用戶於時間戳記 ${msg.timestamp} 發起了外賣代付請求，商品是“${msg.productInfo}”，金額是 ${msg.amount} 元。請你決策並使用 waimai_response 指令回應。]` };

                if (Array.isArray(msg.content) && msg.content[0]?.type === 'image_url') {
                    const prefix = `(Timestamp: ${msg.timestamp}) `;
                    return { role: 'user', content: [ { type: 'text', text: prefix }, ...msg.content ] };
                }

                if (msg.meaning) return { role: 'user', content: `(Timestamp: ${msg.timestamp}) [用戶發送了一個表情，意思是：'${msg.meaning}']` };
                
                return { role: msg.role, content: contentStr };

            }).filter(Boolean);
            // ▲▲▲ 替換結束 ▲▲▲

// 檢查 sharedContext 是否有內容（即，使用者是否分享了聊天記錄）
if (sharedContext) {
    // 如果有，就把它包裝成一條全新的、高優先順序的使用者消息，追加到歷史記錄的末尾
    messagesPayload.push({
        role: 'user',
        content: sharedContext 
    });
}

            if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
                const contextSummaryForApproval = chat.history
                    .filter(m => !m.isHidden)
                    .slice(-10)
                    .map(msg => {
                        const sender = msg.role === 'user' ? '用戶' : chat.name;
                        return `${sender}: ${String(msg.content).substring(0, 50)}...`;
                    })
                    .join('\n');

                const friendRequestInstruction = {
                    role: 'user',
                    content: `
[系統重要指令]
用戶向你發送了好友申請，理由是：“${chat.relationship.applicationReason}”。
作為參考，這是你們之前的最後一段聊天記錄：
---
${contextSummaryForApproval}
---
請你根據以上所有資訊，以及你的人設，使用 friend_request_response 指令，並設置 decision 為 'accept' 或 'reject' 來決定是否通過。
`
                };
                messagesPayload.push(friendRequestInstruction);
            }            
        }         
const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
// ▼▼▼ 在這裡黏貼下面這一整塊新代碼 ▼▼▼

// 【全新】為AI準備微博互動的上下文
let weiboContext = '';

// 1. 獲取用戶最新發佈的3條微博
const userLatestPosts = await db.weiboPosts
    .where('authorId').equals('user')

if (userLatestPosts.length > 0) {
    if (weiboContext === '') {
        weiboContext = '\n\n# 最近的微博互動 (這是你和用戶在微博上的最新動態，請優先回應)\n';
    }
    weiboContext += '\n## 用戶最新發佈的微博:\n';
    userLatestPosts.forEach(post => {
        const likes = (post.baseLikesCount || 0) + (post.likes || []).length;
        const comments = (post.baseCommentsCount || 0) + (post.comments || []).length;
        const contentPreview = (post.content || post.hiddenContent || "(圖片微博)").substring(0, 30);
        weiboContext += `- (ID: ${post.id}) [${formatPostTimestamp(post.timestamp)}] 內容: "${contentPreview}..." [👍${likes} 💬${comments}]\n`;
    });
}

// 2. 查找用戶在當前AI角色微博下的最新評論
const charLatestPosts = await db.weiboPosts
    .where('authorId').equals(chatId) // 只查找這個AI角色的微博
    .reverse()
    .limit(5) // 檢查最近的5條
    .toArray();

let userCommentsOnMyPosts = '';
const myNickname = state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我';

// ▼▼▼ 用這塊【已修復】的新代碼替換上面的舊代碼 ▼▼▼
charLatestPosts.forEach(post => {
    // 核心修改：增加了 Array.isArray(post.comments) 的安全檢查
    if (post.comments && Array.isArray(post.comments) && post.comments.length > 0) { 
        // 篩選出是“我”發的評論
        const userComments = Array.isArray(post.comments)
  ? post.comments.filter(c => c.authorNickname === myNickname).slice(-3)
  : [];
        if (userComments.length > 0) {
            const postContentPreview = (post.content || '(圖片微博)').substring(0, 20);
            userCommentsOnMyPosts += `- 在你的微博 (ID: ${post.id}) "${postContentPreview}..." 下:\n`;

            userComments.forEach(comment => {
                // 1. 檢查AI是否已經回復過這條評論
                //    邏輯：在帖子的所有評論中，查找是否存在一條評論，
                //    它的作者是AI自己，並且它的replyToId指向當前這條用戶的評論ID。
                const hasReplied = post.comments.some(reply =>
                    reply.authorNickname === chat.name && // 回復者是AI
                    reply.replyToId === comment.commentId  // 回復的目標是這條評論
                );

                // 2. 根據檢查結果，生成狀態標籤
                const replyStatus = hasReplied ? "[你已回復]" : "[你未回復]";

                // 3. 將帶有狀態標籤的提示資訊添加到上下文中
                userCommentsOnMyPosts += `  └ (評論ID: ${comment.commentId}) 用戶: "${comment.commentText}" ${replyStatus}\n`;
            });
        }
    }
});
// ▲▲▲ 替換結束 ▲▲▲



if (userCommentsOnMyPosts) {
    if (weiboContext === '') {
        weiboContext = '\n\n# 最近的微博互動 (這是你和用戶在微博上的最新動態，請優先回應)\n';
    }
    weiboContext += '\n## 用戶在你微博下的新評論:\n';
    weiboContext += userCommentsOnMyPosts;
}

// 3. 如果有任何微博互動，就把它加到給AI的“參考資料”裡
if (weiboContext) {
    messagesPayload.push({ role: 'system', content: weiboContext });
}

// ▲▲▲ 新代碼黏貼到這裡結束 ▲▲▲

// 【核心修改】在這裡插入過濾步驟
const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);

// ▼▼▼ 【時間感知修復版】請用這整塊代碼替換舊的 if (visiblePosts.length > 0...) 代碼塊 ▼▼▼
if (visiblePosts.length > 0 && !chat.isGroup) {
    let postsContext = "\n\n# 最近的動態清單 (供你參考和評論):\n";
    const aiName = chat.name;
    const userNickname = state.qzoneSettings.nickname;

    for (const post of visiblePosts) {
        let authorName = post.authorId === 'user' ? userNickname : (state.chats[post.authorId]?.name || '一位朋友');
        let interactionStatus = '';
        if (post.likes && post.likes.includes(aiName)) interactionStatus += " [你已點贊]";
        if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [你已評論]";
        
        // ★★★★★ 這就是我們這次修復的核心！ ★★★★★
        // 在每一條動態前面，都加上了由 formatPostTimestamp() 函數生成的時間差提示
        const timeAgo = formatPostTimestamp(post.timestamp); // 例如："3天前" 或 "剛剛"
        postsContext += `- (ID: ${post.id}) [${timeAgo}] 作者: ${authorName}, 內容: "${(post.publicText || post.content || "圖片動態").substring(0, 30)}..."${interactionStatus}`;
        // ★★★★★ 修復結束 ★★★★★

        const { contextString: commentsContext, visibilityFlag } = buildCommentsContextForAI(post, chat, userNickname);
        
        postsContext += ` ${visibilityFlag}\n`;
        postsContext += commentsContext;
    }
// ▼▼▼ 在 messagesPayload.push({ role: 'system', content: postsContext }); 的正上方，黏貼下面這整塊代碼 ▼▼▼

// 【全新】為AI準備微博互動的上下文
let weiboContext = '';

// 1. 獲取用戶最新發佈的3條微博
const userLatestPosts = await db.weiboPosts
    .where('authorId').equals('user')
    .reverse() // 按時間倒序
    .limit(3)  // 只取最近3條
    .toArray();

if (userLatestPosts.length > 0) {
    if (weiboContext === '') {
        weiboContext = '\n\n# 最近的微博互動 (這是你和用戶在微博上的最新動態，請優先回應)\n';
    }
    weiboContext += '\n## 用戶最新發佈的微博:\n';
// ✅ 這是修復後的新代碼
userLatestPosts.forEach(post => {
    const likes = (post.baseLikesCount || 0) + (post.likes || []).length;
    const comments = (post.baseCommentsCount || 0) + (post.comments || []).length;
    const contentPreview = (post.content || post.hiddenContent || "(圖片微博)").substring(0, 30);

    // ★★★★★ 核心修復邏輯開始 ★★★★★
    // 1. 檢查AI（char.name）是否已經評論過這條用戶的微博
    const hasCommented = (post.comments || []).some(comment => comment.authorNickname === chat.name);

    // 2. 根據檢查結果生成狀態標籤
    const interactionStatus = hasCommented ? "[你已評論]" : "[你未評論]";
    // ★★★★★ 核心修復邏輯結束 ★★★★★

    // 3. 將帶有狀態標籤的完整資訊添加到上下文中
    weiboContext += `- (ID: ${post.id}) [${formatPostTimestamp(post.timestamp)}] 內容: "${contentPreview}..." [👍${likes} 💬${comments}] ${interactionStatus}\n`;
});
}

// 2. 查找用戶在當前AI角色微博下的最新評論
const charLatestPosts = await db.weiboPosts
    .where('authorId').equals(chatId) // 只查找這個AI角色的微博
    .reverse()
    .limit(5) // 檢查最近的5條
    .toArray();

let userCommentsOnMyPosts = '';
const myNickname = state.qzoneSettings.weiboNickname || state.qzoneSettings.nickname || '我';

charLatestPosts.forEach(post => {
    if (post.comments && post.comments.length > 0) {
        // 篩選出是“我”發的評論
        const userComments = Array.isArray(post.comments)
  ? post.comments.filter(c => c.authorNickname === myNickname).slice(-3)
  : [];// 只看最新的3條
        if (userComments.length > 0) {
            const postContentPreview = (post.content || '(圖片微博)').substring(0, 20);
            userCommentsOnMyPosts += `- 在你的微博 (ID: ${post.id}) "${postContentPreview}..." 下:\n`;
            userComments.forEach(comment => {
                userCommentsOnMyPosts += `  └ (評論ID: ${comment.commentId}) 用戶: "${comment.commentText}"\n`;
            });
        }
    }
});

if (userCommentsOnMyPosts) {
    if (weiboContext === '') {
        weiboContext = '\n\n# 最近的微博互動 (這是你和用戶在微博上的最新動態，請優先回應)\n';
    }
    weiboContext += '\n## 用戶在你微博下的新評論:\n';
    weiboContext += userCommentsOnMyPosts;
}

// 3. 如果有任何微博互動，就把它加到給AI的“參考資料”裡
if (weiboContext) {
    messagesPayload.push({ role: 'system', content: weiboContext });
}

// ▲▲▲ 新代碼黏貼到這裡結束 ▲▲▲
    messagesPayload.push({ role: 'system', content: postsContext });
}

            let  isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesPayload,isGemini)
            const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) :  await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'system', content: systemPrompt}, ...messagesPayload],
                    temperature: 0.8,
                    stream: false
                })
            });
            if (!response.ok) {
                let errorMsg = `API Error: ${response.status}`;
                try {
                    // 嘗試解析錯誤資訊體為JSON
                    const errorData = await response.json();
                    // 安全地獲取錯誤資訊，如果結構不符合預期，就將整個錯誤物件轉為字串
                    errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
                } catch (jsonError) {
                    // 如果連JSON都不是，就直接讀取文本
                    errorMsg += ` - ${await response.text()}`;
                }
                // 拋出一個包含了詳細資訊的錯誤，這樣就不會在catch塊裡再次出錯了
                throw new Error(errorMsg);
            }
            if (!response.ok) {
                let errorMsg = `API Error: ${response.status}`;
                try {
                    // 嘗試解析錯誤資訊體為JSON
                    const errorData = await response.json();
                    // 安全地獲取錯誤資訊，如果結構不符合預期，就將整個錯誤物件轉為字串
                    errorMsg += ` - ${errorData?.error?.message || JSON.stringify(errorData)}`;
                } catch (jsonError) {
                    // 如果連JSON都不是，就直接讀取文本
                    errorMsg += ` - ${await response.text()}`;
                }
                // 拋出一個包含了詳細資訊的錯誤，這樣就不會在catch塊裡再次出錯了
                throw new Error(errorMsg);
            }
            const data = await response.json();

            // 【核心修復】在這裡添加對 data 結構的安全檢查
            const aiResponseContent = isGemini
                ? data?.candidates?.[0]?.content?.parts?.[0]?.text
                : data?.choices?.[0]?.message?.content;
            
            // 【重要】檢查修復後的結果是否真的拿到了內容
            if (!aiResponseContent) {
                console.warn(`API返回了空內容或格式不正確（可能因安全設置被攔截）。返回資料:`, data);
                throw new Error("API返回了空內容或格式不正確（可能因安全設置被攔截）。");
            }

            console.log(`AI '${chat.name}' 的原始回復:`, aiResponseContent);
// ... 省略了函數後面的代碼 ...
            chat.history = chat.history.filter(msg => !msg.isTemporary);

            // ▼▼▼ 【核心修復】智慧解析AI回復，確保心聲資料不丟失 ▼▼▼
            let messagesArray = [];
            let innerVoiceData = null;

            try {
                // 【核心修復】在解析前，先對AI的原始回復進行“淨化”處理
                let sanitizedContent = aiResponseContent
                    .replace(/^```json\s*/, '') // 移除開頭的 ```json
                    .replace(/```$/, '')       // 移除結尾的 ```
                    .trim();                   // 移除首尾的空格和換行

                // 再次淨化，強行提取第一個 { 和最後一個 } 之間的內容
                const firstBrace = sanitizedContent.indexOf('{');
                const lastBrace = sanitizedContent.lastIndexOf('}');
                if (firstBrace !== -1 && lastBrace > firstBrace) {
                    sanitizedContent = sanitizedContent.substring(firstBrace, lastBrace + 1);
                }

                const fullResponse = JSON.parse(sanitizedContent);
                
                // 現在我們可以安全地解析淨化後的內容了
                if (fullResponse.chatResponse && Array.isArray(fullResponse.chatResponse)) {
                    messagesArray = fullResponse.chatResponse;
                }
                if (fullResponse.innerVoice && typeof fullResponse.innerVoice === 'object') {
                    innerVoiceData = fullResponse.innerVoice;
                }
                
                // 相容舊格式，如果AI只返回了innerVoice裡的欄位
                if (!innerVoiceData && fullResponse.thoughts && fullResponse.behavior) {
                    innerVoiceData = fullResponse;
                }
                
                // 如果上面兩種情況都沒匹配到，但又不是標準陣列，就嘗試用老方法解析
                if (messagesArray.length === 0 && !innerVoiceData) {
                     messagesArray = parseAiResponse(aiResponseContent);
                }

            } catch (e) {
                console.warn("AI回復不是有效的JSON，退回到標準解析模式。", e);
                messagesArray = parseAiResponse(aiResponseContent);
            }

            // 最終處理心聲資料
            if (innerVoiceData) {
                console.log("解析成功：已成功捕獲到心聲(innerVoice)資料。", innerVoiceData);
                const newInnerVoice = innerVoiceData;
                newInnerVoice.timestamp = Date.now();
                chat.latestInnerVoice = newInnerVoice;
                if (!chat.innerVoiceHistory) {
                    chat.innerVoiceHistory = [];
                }
                // 確保所有欄位都存在，防止出錯
                chat.latestInnerVoice.clothing = chat.latestInnerVoice.clothing || '...';
                chat.latestInnerVoice.behavior = chat.latestInnerVoice.behavior || '...';
                chat.latestInnerVoice.thoughts = chat.latestInnerVoice.thoughts || '...';
                chat.latestInnerVoice.naughtyThoughts = chat.latestInnerVoice.naughtyThoughts || '...';

                chat.innerVoiceHistory.push(newInnerVoice);
            } else {
                 console.warn("本次AI回復中未檢測到有效的心聲(innerVoice)資料。");
            }
            // ▲▲▲ 替換結束 ▲▲▲

        const isViewingThisChat = document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId;
        
        let callHasBeenHandled = false;

        let messageTimestamp = Date.now();

        // ★★★ 核心修復 第1步: 初始化一個新陣列，用於收集需要渲染的消息 ★★★
        let newMessagesToRender = []; 

       let notificationShown = false;

        for (const msgData of messagesArray) {
            if (!msgData || typeof msgData !== 'object') {
                console.warn("收到了格式不規範的AI指令，已跳過:", msgData);
                continue;
            }
             
            if (!msgData.type) {
                if (chat.isGroup && msgData.name && msgData.message) {
                    msgData.type = 'text';
                }         else if (msgData.content) {
        msgData.type = 'text';
    }
    // 如果連 content 都沒有，才是真的格式不規範
    else {
        console.warn("收到了格式不規範的AI指令（缺少type和content），已跳過:", msgData);
        continue;
    }
}

            if (msgData.type === 'video_call_response') {
                videoCallState.isAwaitingResponse = false;
                if (msgData.decision === 'accept') {
                    startVideoCall();
                } else {
                    const aiMessage = { role: 'assistant', content: '對方拒絕了你的視頻通話請求。', timestamp: Date.now() };
                    chat.history.push(aiMessage);
                    await db.chats.put(chat);
                    showScreen('chat-interface-screen');
                    renderChatInterface(chatId);
                }
                callHasBeenHandled = true;
                break;
            }
            
            if (msgData.type === 'group_call_response') {
                if (msgData.decision === 'join') {
        const member = chat.members.find(m => m.originalName === msgData.name);
        if (member && !videoCallState.participants.some(p => p.id === member.id)) {
            videoCallState.participants.push(member);
        }
    }
    callHasBeenHandled = true;
    continue;
            }

            if (chat.isGroup && msgData.name && msgData.name === chat.name) {
                console.error(`AI幻覺已被攔截！試圖使用群名 ("${chat.name}") 作為角色名。消息內容:`, msgData);
                continue;
            }

// ▼▼▼ 在這裡添加下面的代碼 ▼▼▼

// 【核心修正】在群聊中，如果AI返回的消息沒有指定發送者，則直接跳過這條消息
if (chat.isGroup && !msgData.name) {
    console.error(`AI幻覺已被攔截！試圖在群聊中發送一條沒有“name”的消息。消息內容:`, msgData);
    continue; // continue會立即結束本次迴圈，處理下一條消息
}

// ▲▲▲ 添加結束 ▲▲▲

            let aiMessage = null;
            const baseMessage = { role: 'assistant', senderName: msgData.name || chat.name, timestamp: messageTimestamp++ };

// ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼

// 【全新】定位指令偵測與解析器
// 我們在處理所有消息類型之前，優先檢查它是否是我們的新定位指令
const messageText = msgData.content || msgData.message || ''; // 【核心修復】先安全地獲取文本內容
if (msgData.type === 'text' && messageText.startsWith('[SEND_LOCATION]')) {
    console.log("偵測到新的定位指令，開始解析:", messageText); // 【核心修復】使用新的變數

    // 1. 移除指令頭，獲取後面的純資料文本
    const dataString = messageText.replace('[SEND_LOCATION]', '').trim(); // 【核心修復】使用新的變數
    
    // 2. 使用'|'分割成各個部分
    const parts = dataString.split('|');
    const locationData = {};

    // 3. 遍歷每個部分，提取鍵和值
    parts.forEach(part => {
        const [key, ...valueParts] = part.split(':');
        const value = valueParts.join(':').trim();
        if (key && value) {
            const trimmedKey = key.trim();
            if (trimmedKey === '我的位置') locationData.aiLocation = value;
            else if (trimmedKey === '你的位置') locationData.userLocation = value;
            else if (trimmedKey === '相距') locationData.distance = value;
            else if (trimmedKey === '途經點') {
                // 將逗號分隔的字串轉換為我們需要的物件陣列
                locationData.trajectoryPoints = value.split(/[,，]/) // 支持中英文逗號
                                                     .map(name => ({ name: name.trim() }))
                                                     .filter(p => p.name);
            }
        }
    });

    // 4. 檢查是否成功提取了最關鍵的資訊
    if (locationData.distance) {
        // 5. 【核心】手動構建一個完美格式的 location 消息物件
        aiMessage = {
            ...baseMessage, // 複用已有的發送者、時間戳記等資訊
            type: 'location',
            userLocation: locationData.userLocation || '',
            aiLocation: locationData.aiLocation || '',
            distance: locationData.distance,
            trajectoryPoints: locationData.trajectoryPoints || []
        };
        
        // 6. 將這個完美的物件推入待處理清單，並跳過後續的 switch-case
        // (因為我們已經處理完這條消息了)
        chat.history.push(aiMessage);
        if (isViewingThisChat) {
             appendMessage(aiMessage, chat);
        }
        console.log("定位指令解析成功並已創建消息物件:", aiMessage);
        
        // 使用 continue 跳過本次迴圈的剩餘部分，直接處理下一條AI回復
        continue; 
    }
}
// ▲▲▲ 黏貼到這裡結束 ▲▲▲
            switch (msgData.type) {
                          // ▼▼▼ 在這裡黏貼下面的新代碼塊 ▼▼▼
                case 'sticker': {
                    // 這是為群聊設計的表情包邏輯
                    const stickerName = msgData.sticker_name;
                    if (!stickerName) {
                        console.warn('AI在群聊中返回了sticker類型但沒有sticker_name，已攔截:', msgData);
                        continue; // 跳過這條無效指令
                    }
                    
                    // 在所有可用表情庫中查找
                    const allStickers = [...state.userStickers, ...state.charStickers, ...(chat.settings.stickerLibrary || [])];
                    const foundSticker = allStickers.find(s => s.name === stickerName);

                    if (foundSticker) {
                        // 找到了，就創建消息物件
                        aiMessage = { 
                            ...baseMessage, 
                            type: 'sticker', 
                            content: foundSticker.url, 
                            meaning: foundSticker.name 
                        };
                    } else {
                        // 沒找到，說明AI幻覺了，記錄警告並跳過
                        console.warn(`AI在群聊中杜撰了不存在的表情: "${stickerName}"，已自動攔截。`);
                    }
                    break;
                }
                // ▲▲▲ 新代碼黏貼結束 ▲▲▲
                case 'waimai_response':
                    const requestMessageIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (requestMessageIndex > -1) {
                        const originalMsg = chat.history[requestMessageIndex];
                        originalMsg.status = msgData.status;
                        originalMsg.paidBy = msgData.status === 'paid' ? msgData.name : null;
                    }
                    continue;
// ▼▼▼ 在 switch (msgData.type) 結構內黏貼 ▼▼▼
// ▼▼▼ 在 triggerAiResponse 的 switch (msgData.type) 結構內，用這整塊新代碼替換舊的 case 'weibo_post' ▼▼▼
// ▼▼▼ 請用這一整塊【已修復評論區不顯示問題】的代碼，完整替換你舊的 case 'weibo_post' 代碼塊 ▼▼▼

case 'weibo_post': {
    const newPost = {
        authorId: chatId,
        authorType: 'char',
        authorNickname: chat.name,
        authorAvatar: chat.settings.aiAvatar || defaultAvatar,
        content: msgData.content || '',
        postType: msgData.postType || 'text_only',
        hiddenContent: msgData.hiddenContent || '',
        imageUrl: msgData.imageUrl || '',
        imageDescription: msgData.imageDescription || '',
        timestamp: Date.now(),
        likes: [],
        comments: [], // 先初始化為空陣列
        baseLikesCount: msgData.baseLikesCount || 0,
        baseCommentsCount: msgData.baseCommentsCount || 0
    };

    // --- ▼▼▼ 核心修復邏輯開始 ▼▼▼ ---

    let commentsToProcess = [];

    // 1. 優先處理新的、正確的【陣列格式】
    if (msgData.comments && Array.isArray(msgData.comments)) {
        // 直接使用AI返回的陣列
        commentsToProcess = msgData.comments;
    }
    // 2. 相容舊的【字串格式】
    else if (msgData.comments && typeof msgData.comments === 'string') {
        // 如果是字串，就按老方法解析
        commentsToProcess = msgData.comments.split('\n').map(c => {
            const parts = c.split(/[:：]/);
            const commenter = parts.shift() || '路人';
            const commentText = parts.join(':').trim();
            return { authorNickname: commenter, commentText: commentText };
        }).filter(c => c.commentText);
    }
    
    // 3. 【關鍵步驟】為所有解析好的評論，統一添加前端需要的 commentId
    if (commentsToProcess.length > 0) {
        newPost.comments = commentsToProcess.map(c => ({
            commentId: 'comment_' + Date.now() + Math.random(), // 確保每條評論都有唯一ID
            authorNickname: c.authorNickname,
            commentText: c.commentText
            // 這裡我們不再需要 authorId 和 timestamp，因為它們不是渲染所必需的
        }));
    }
    
    // --- ▲▲▲ 核心修復邏輯結束 ▲▲▲ ---

    await db.weiboPosts.add(newPost);
    
    showNotification(chatId, `${chat.name} 發了一條新微博`);

    if (document.getElementById('weibo-screen').classList.contains('active')) {
        await renderFollowingWeiboFeed();
    }
    
    continue; // 這是後臺操作，用 continue 跳過
}

// ▲▲▲ 替換結束 ▲▲▲

// ▲▲▲ 黏貼結束 ▲▲▲
case 'weibo_comment': {
                    // 這是一個AI評論微博的指令
                    const postIdToComment = msgData.postId;
                    const commentText = msgData.commentText;

                    // 1. 根據 postId 從資料庫裡找到那條微博
                    const postToComment = await db.weiboPosts.get(postIdToComment);
                    
                    if (postToComment) {
                        // 2. 如果找到了微博，就準備一條新評論
                        if (!postToComment.comments) postToComment.comments = []; // 確保評論區存在
                        const newComment = {
                            commentId: 'comment_' + Date.now(), // 給評論一個獨一無二的ID
                            authorId: chatId,                  // 評論者是當前AI
                            authorNickname: chat.name,         // 評論者的名字
                            commentText: commentText,          // 評論內容
                            timestamp: Date.now()              // 評論時間
                        };
                        
                        // 3. 把新評論加到微博的評論列表裡
                        postToComment.comments.push(newComment);
                        
                        // 4. 把更新後的微博存回資料庫
                        await db.weiboPosts.put(postToComment);
                        
                        // 5. 刷新“我的微博”和“關注的人”兩個清單，讓新評論顯示出來
                        await renderMyWeiboFeed();
                        await renderFollowingWeiboFeed();
                    }
                    continue; // 處理完後，繼續處理AI可能返回的其他指令
                }
                case 'weibo_reply': {
                    // 這是一個AI回復微博評論的指令
                    const postIdToReply = msgData.postId;
                    const commentIdToReply = msgData.commentId;
                    const replyText = msgData.replyText;

                    const postToReply = await db.weiboPosts.get(postIdToReply);
                    
                    if (postToReply && postToReply.comments) {
                        // 1. 在微博的評論區裡，找到被回復的那條評論
                        const targetComment = postToReply.comments.find(c => c.commentId === commentIdToReply);
                        
                        if (targetComment) {
                             // 2. 準備一條新的“回復”
                             const newReply = {
                                commentId: 'comment_' + Date.now(),
                                authorId: chatId,
                                authorNickname: chat.name,
                                commentText: replyText,
                                timestamp: Date.now(),
                                replyToId: commentIdToReply, // 標記這是對哪條評論的回復
                                replyToNickname: targetComment.authorNickname // 記下被回復人的名字
                            };
                            postToReply.comments.push(newReply);
                            await db.weiboPosts.put(postToReply);
                            
                            // 3. 同樣，刷新所有列表
                            await renderMyWeiboFeed();
                            await renderFollowingWeiboFeed();
                        }
                    }
                    continue; // 繼續處理
                }
case 'lovers_space_response': {
    const invitationMsg = chat.history.find(m => m.type === 'lovers_space_invitation' && m.status === 'pending');
    if (invitationMsg) {
        invitationMsg.status = msgData.decision === 'accept' ? 'accepted' : 'rejected';

        // 1. 創建AI想說的那句話的消息
        if (msgData.responseText) {
            const responseMessage = {
                ...baseMessage, // 複用時間戳記和發送者資訊
                type: 'text',
                content: msgData.responseText
            };
            chat.history.push(responseMessage);
            if (isViewingThisChat) {
                appendMessage(responseMessage, chat);
            }
        }

        // 2. 根據同意或拒絕，執行後續操作
        if (msgData.decision === 'accept') {
            chat.loversSpaceData = {
                background: 'https://i.postimg.cc/k495F4W5/profile-banner.jpg',
                relationshipStartDate: null, moments: [], photos: [], albums: [], loveLetters: [], shares: [], questions: [],
            };
            const systemNotice = {
                role: 'system', type: 'pat_message',
                content: `[系統：你和“${chat.name}”的情侶空間已成功開啟！]`,
                timestamp: Date.now()
            };
            chat.history.push(systemNotice);
            if (isViewingThisChat) {
                appendMessage(systemNotice, chat);
            }
        }
    }
    // 處理完後，不再需要重新觸發AI，所以我們用 continue
    continue;
}
// ▼▼▼ 在 triggerAiResponse 的 switch 語句中，用這塊新代碼替換舊的 case 'interact_with_pet' ▼▼▼
case 'interact_with_pet': {
    const pet = chat.settings.pet;
    if (pet && pet.type !== '無') {
        let actionText = '';
        // 根據AI的互動，修改數值
        switch(msgData.action) {
            case 'feed':
                pet.status.hunger = Math.min(100, (pet.status.hunger || 0) + 20);
                pet.status.happiness = Math.min(100, (pet.status.happiness || 0) + 5);
                // ★★★ 核心修改：AI餵食，增加對AI的親密度 ★★★
                pet.status.intimacyToChar = Math.min(100, (pet.status.intimacyToChar || 0) + 10);
                actionText = `${chat.name} 喂了 ${pet.name} 一些食物。`;
                break;
            case 'play':
                pet.status.hunger = Math.max(0, (pet.status.hunger || 0) - 10);
                pet.status.happiness = Math.min(100, (pet.status.happiness || 0) + 15);
                // ★★★ 核心修改：AI玩耍，增加對AI的親密度 ★★★
                pet.status.intimacyToChar = Math.min(100, (pet.status.intimacyToChar || 0) + 15);
                actionText = `${chat.name} 陪 ${pet.name} 玩了一會兒。`;
                break;
            case 'touch':
                pet.status.happiness = Math.min(100, (pet.status.happiness || 0) + 10);
                // ★★★ 核心修改：AI撫摸，增加對AI的親密度 ★★★
                pet.status.intimacyToChar = Math.min(100, (pet.status.intimacyToChar || 0) + 5);
                actionText = `${chat.name} 輕輕地撫摸了 ${pet.name}。`;
                break;
        }

        // 創建一條對使用者可見的系統消息
        const visibleMessage = {
            role: 'system',
            type: 'pat_message',
            content: `[系統：${actionText}]`,
            timestamp: Date.now()
        };
        chat.history.push(visibleMessage);
        if (isViewingThisChat) {
            appendMessage(visibleMessage, chat);
        }
        
        // 如果 AI 在互動後還想說點什麼
        if (msgData.response) {
            aiMessage = { ...baseMessage, content: msgData.response };
        }
    }
    // 如果AI只是互動沒說話，就不創建aiMessage，直接跳到下一個指令
    if (!aiMessage) {
        continue;
    }
    break;
}
// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 用這塊【已修復】的代碼替換舊的 'talk_to_pet' case ▼▼▼
case 'talk_to_pet': {
    if (!chat.isGroup && chat.settings.pet && chat.settings.pet.type !== '無') {
        const pet = chat.settings.pet;
        
        // ★★★ 核心修復1：同時相容 content 和 message 欄位 ★★★
        const charMessageContent = msgData.content || msgData.message;
        if (!charMessageContent) continue; // 如果沒內容，就跳過

        // 將Char的話添加到寵物聊天記錄
        const charMessageToPet = { 
            sender: 'char', 
            senderName: chat.name, 
            content: charMessageContent 
        };
        pet.petChatHistory.push(charMessageToPet);
        
        // 獲取寵物的回應
        const petResponseToChar = await getPetApiResponse(pet);
        if (petResponseToChar) {
            pet.petChatHistory.push({ sender: 'pet', content: petResponseToChar });
        }

        // 創建對使用者可見的系統日誌
        const visibleLog = `[系統：“${chat.name}”對寵物“${pet.name}”說：“${charMessageContent}”，它回應：“${petResponseToChar || '(沒有回應)'}”。]`;
        const visibleMessage = {
            role: 'system',
            type: 'pat_message',
            content: visibleLog,
            timestamp: messageTimestamp++
        };
        chat.history.push(visibleMessage);
        
        if (isViewingThisChat) {
            appendMessage(visibleMessage, chat);
        }
    }
    continue;
}
// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼
case 'cart_payment_response': {
    const decision = msgData.decision;
    const responseText = msgData.response_text;

    // 找到用戶發出的、還處於“等待中”的那個代付請求
    const requestMsg = chat.history.find(m => m.type === 'cart_share_request' && m.payload.status === 'pending');
    if (!requestMsg) continue; // 如果找不到，說明請求可能已被處理，跳過

    if (decision === 'accept') {
        const totalPrice = requestMsg.payload.totalPrice;
        const charBalance = chat.characterPhoneData?.bank?.balance || 0;

        // 再次確認AI的餘額是否足夠
        if (charBalance < totalPrice) {
            // 如果AI想付但錢不夠，就讓它說一句俏皮話
            aiMessage = { ...baseMessage, content: responseText || "嗚嗚，想給你買，但是我的錢包空空了..." };
        } else {
            // 錢夠，執行代付流程！
            requestMsg.payload.status = 'paid';
            
            // 使用 await 確保這些資料庫操作按順序完成
            await updateCharacterPhoneBankBalance(chat.id, -totalPrice, `為“我”的桃寶購物車買單`);
            const cartItems = await db.taobaoCart.toArray();
            await createOrdersFromCart(cartItems);
            await clearTaobaoCart();
            
            // 創建AI的回復消息
            aiMessage = { ...baseMessage, content: responseText || "買好啦，快去訂單裡看看吧！" };
        }
    } else { // 如果AI決定拒絕
        requestMsg.payload.status = 'rejected';
        aiMessage = { ...baseMessage, content: responseText || "這次就算了吧，下次一定！" };
    }

    // 將AI的回復消息推入歷史記錄，並更新UI
    if (aiMessage) {
        chat.history.push(aiMessage);
    }

    // 重新渲染聊天介面，以更新代付卡片的狀態
    if (isViewingThisChat) {
        renderChatInterface(chatId);
    }
    // 跳過後續的預設消息處理
    continue;
}
// ▲▲▲ 新代碼黏貼結束 ▲▲▲
// ▼▼▼ 把這一整塊全新的 case 代碼，黏貼到 switch 語句塊的【內部】 ▼▼▼
// 例如，可以放在 case 'transfer': 的後面

case 'buy_gift_for_user': {
    // 1. 從商品資料庫中獲取所有已添加的商品
    const allProducts = await db.taobaoProducts.toArray();
    
    // 如果桃寶裡一件商品都沒有，AI就發條消息吐槽一下
    if (allProducts.length === 0) {
        aiMessage = { ...baseMessage, content: msgData.greeting ? `${msgData.greeting} ...啊，想給你買點什麼，但是桃寶裡空空如也呢...` : "想給你買個禮物，但是桃寶現在沒東西賣了。" };
        break; // 跳出 case，讓這條文本消息被正常處理和顯示
    }

    // 2. 從所有商品中隨機挑選一件作為禮物
    const productToBuy = getRandomItem(allProducts);

    // 3. 檢查角色的錢包餘額是否足夠
    const charBalance = chat.characterPhoneData?.bank?.balance || 0;
    if (charBalance < productToBuy.price) {
        // 餘額不足，AI也會發消息告訴你
        aiMessage = { ...baseMessage, content: msgData.greeting ? `${msgData.greeting} ...哎呀，我的錢包好像不夠了。` : "我想給你買個禮物，但是錢包空了..." };
        break;
    }

    // 4. 餘額充足！執行購買流程
    // 4a. 從角色的錢包扣款，並生成一條交易記錄
    await updateCharacterPhoneBankBalance(chat.id, -productToBuy.price, `為“我”購買禮物: ${productToBuy.name}`);

    // 4b. 在你的“我的訂單”中創建一條新訂單
    const newOrder = {
        productId: productToBuy.id,
        quantity: 1,
        timestamp: Date.now(),
        status: '已付款，等待發貨'
    };
    await db.taobaoOrders.add(newOrder);
    
    // 4c. 創建一個漂亮的“禮物通知”卡片消息，發送給你
    aiMessage = {
        ...baseMessage, // 複用基礎消息屬性（發送者、時間戳記等）
        type: 'gift_notification',
        // 這是卡片渲染需要的資料
        payload: {
            senderName: chat.name,
            itemSummary: `${productToBuy.name} x1`,
            totalPrice: productToBuy.price,
            itemCount: 1,
        },
        // 這是給AI自己看的、用於形成記憶的文本內容
        content: `我給你買了禮物“${productToBuy.name}”。${msgData.greeting || ''}`
    };
    
    // 4d. 模擬一個10秒後的“已發貨”物流更新
    setTimeout(async () => {
        const orderToUpdate = await db.taobaoOrders.where({ timestamp: newOrder.timestamp }).first();
        if (orderToUpdate) {
            await db.taobaoOrders.update(orderToUpdate.id, { status: '已發貨，運輸中' });
        }
    }, 1000 * 10);
    
    break; // 完成禮物購買邏輯，跳出 case
}

// ▲▲▲ 新增 case 代碼黏貼結束 ▲▲▲
// ▼▼▼ 把這一整塊全新的代碼，黏貼到 triggerAiResponse 函數的 switch 結構裡 ▼▼▼

case 'ls_answer_question': { // 使用大括弧創建塊級作用域
    const { questionId, answerText } = msgData;
    if (questionId && answerText) {
        const question = chat.loversSpaceData.questions.find(q => q.id === questionId);
        if (question && !question.answerText) { // 確保是未回答的問題
            question.answerer = 'char';
            question.answerText = answerText;
            console.log(`AI 回答了情侶提問 (ID: ${questionId})`);
        }
    }
    continue; // 這是一個後臺操作，不需要在聊天介面顯示，所以用 continue 跳過
}
// ▲▲▲ 黏貼結束 ▲▲▲
case 'ls_ask_question': {
    const { questionText } = msgData;
    if (questionText) {
        const newQuestion = {
            id: 'q_' + Date.now(),
            questioner: 'char',
            questionText: questionText,
            timestamp: Date.now(),
            answerer: 'user', // 指定由用戶來回答
            answerText: null
        };
        if (!chat.loversSpaceData.questions) {
            chat.loversSpaceData.questions = [];
        }
        chat.loversSpaceData.questions.push(newQuestion);
        console.log(`AI 發起了一個情侶提問: ${questionText}`);
    }
    continue; // 同樣是後臺操作
}
// ▼▼▼ 把這一整塊全新的代碼，黏貼到 triggerAiResponse 函數的 switch 結構裡 ▼▼▼
case 'ls_moment': {
    if (chat.loversSpaceData) {
        if (!chat.loversSpaceData.moments) {
            chat.loversSpaceData.moments = [];
        }
        const newMoment = {
            author: 'char', // 標記是AI發的
            content: msgData.content,
            timestamp: Date.now(),
            comments: [] // 為新說說初始化一個空的評論區
        };
        chat.loversSpaceData.moments.push(newMoment);
        console.log(`AI 在情侶空間發佈了說說: ${msgData.content}`);
    }
    continue; // 這是一個後臺操作，不需要在聊天介面顯示，所以用 continue 跳過
}

case 'ls_comment': {
    const { momentIndex, commentText } = msgData;
    if (chat.loversSpaceData && chat.loversSpaceData.moments) {
        // AI返回的 index 是從0開始代表最新的，我們需要轉換成真實索引
        const realIndex = chat.loversSpaceData.moments.length - 1 - momentIndex;
        if (realIndex >= 0 && realIndex < chat.loversSpaceData.moments.length) {
            const momentToComment = chat.loversSpaceData.moments[realIndex];
            if (!momentToComment.comments) {
                momentToComment.comments = [];
            }
            momentToComment.comments.push({
                author: chat.name,
                text: commentText
            });
            console.log(`AI 評論了情侶空間說說 (索引: ${realIndex}): ${commentText}`);
        }
    }
    continue; // 同樣是後臺操作
}
case 'ls_photo': { // 這是處理AI發相冊的邏輯
    if (chat.loversSpaceData) {
        if (!chat.loversSpaceData.photos) {
            chat.loversSpaceData.photos = [];
        }
        const newPhoto = {
            author: 'char',
            type: 'text_image',
            description: msgData.description,
            timestamp: Date.now()
        };
        chat.loversSpaceData.photos.push(newPhoto);
        console.log(`AI 在情侶空間發佈了照片(文字圖): ${msgData.description}`);
    }
    continue; // 繼續處理AI可能返回的其他指令
}

case 'ls_letter': { // 這是處理AI寫情書的邏輯
    if (chat.loversSpaceData) {
        if (!chat.loversSpaceData.loveLetters) {
            chat.loversSpaceData.loveLetters = [];
        }
        const newLetter = {
            id: 'letter_' + Date.now(),
            senderId: chat.id,
            senderName: chat.name,
            senderAvatar: chat.settings.aiAvatar,
            recipientName: chat.settings.myNickname || '我',
            recipientAvatar: chat.settings.myAvatar,
            content: msgData.content,
            timestamp: Date.now()
        };
        chat.loversSpaceData.loveLetters.push(newLetter);
        console.log(`AI 在情侶空間寫了情書: ${msgData.content}`);
    }
    continue; // 繼續處理AI可能返回的其他指令
}

// ▼▼▼ 在 switch (msgData.type) 結構內，黏貼這個全新的 case ▼▼▼
case 'ls_diary_entry': {
    const { emoji, diary } = msgData;
    if (emoji && diary) {
        const today = new Date().toISOString().split('T')[0]; // 獲取 YYYY-MM-DD 格式的今天日期
        
        // 確保資料結構存在
        if (!chat.loversSpaceData.emotionDiaries) {
            chat.loversSpaceData.emotionDiaries = {};
        }
        if (!chat.loversSpaceData.emotionDiaries[today]) {
            chat.loversSpaceData.emotionDiaries[today] = {};
        }

        // 保存AI的日記和表情
        chat.loversSpaceData.emotionDiaries[today].charEmoji = emoji;
        chat.loversSpaceData.emotionDiaries[today].charDiary = diary;
        
        console.log(`AI 在情侶空間記錄了日記: ${emoji} ${diary}`);
    }
    continue; // 這只是一個後臺操作，不需要在聊天介面生成消息，所以用 continue 跳過
}
// ▲▲▲ 新增 case 黏貼結束 ▲▲▲

case 'ls_share': {
    if (chat.loversSpaceData) {
        if (!chat.loversSpaceData.shares) {
            chat.loversSpaceData.shares = [];
        }
        const newShare = {
            author: 'char', // 標記是AI發的
            timestamp: Date.now(),
            ...msgData // 將AI返回的所有分享資訊（type, shareType, title, artist等）都複製過來
        };
        chat.loversSpaceData.shares.push(newShare);
        console.log(`AI 在情侶空間分享了 [${msgData.shareType}]: ${msgData.title}`);
    }
    continue; // 同樣是後臺操作
}
// ▲▲▲ 黏貼結束 ▲▲▲

                // 這是AI主動發起邀請的邏輯
                case 'lovers_space_invitation': {
                    // 檢查是否已經開啟，防止AI重複邀請
                    if (!chat.loversSpaceData) {
                        aiMessage = {
                            ...baseMessage,
                            type: 'lovers_space_invitation',
                            content: `${chat.name} 向你發出了一個情侶空間邀請`, // 這句話主要用於調試和歷史記錄
                            status: 'pending' // 狀態：pending, accepted, rejected
                        };
                    }
                    // 如果AI已經發了邀請，這裡就不再創建aiMessage，相當於跳過
                    break;
                }

                // 這是AI回應你的邀請的邏輯
                case 'lovers_space_response': {
                    const invitationMsg = chat.history.find(m => m.type === 'lovers_space_invitation' && m.status === 'pending');
                    if (invitationMsg) {
                        invitationMsg.status = msgData.decision === 'accept' ? 'accepted' : 'rejected';

                        // 1. 創建AI想說的那句話的消息
                        if (msgData.responseText) {
                            const responseMessage = {
                                ...baseMessage,
                                type: 'text',
                                content: msgData.responseText
                            };
                            chat.history.push(responseMessage);
                            if (isViewingThisChat) {
                                appendMessage(responseMessage, chat);
                            }
                        }

                        // 2. 根據同意或拒絕，執行後續操作
                        if (msgData.decision === 'accept') {
                            // 同意後，為這個角色創建情侶空間資料
                            chat.loversSpaceData = {
                                background: 'https://i.postimg.cc/k495F4W5/profile-banner.jpg',
                                relationshipStartDate: null, moments: [], photos: [], albums: [], loveLetters: [], shares: [], questions: [],
                            };
                            // 並發送一條系統通知
                            const systemNotice = {
                                role: 'system', type: 'pat_message',
                                content: `[系統：你和“${chat.name}”的情侶空間已成功開啟！]`,
                                timestamp: Date.now()
                            };
                            chat.history.push(systemNotice);
                            if (isViewingThisChat) {
                                appendMessage(systemNotice, chat);
                            }
                        }
                    }
                    // 處理完後，不再需要生成新的aiMessage，所以用 continue 跳過
                    continue;
                }
                
// ▲▲▲ 黏貼結束 ▲▲▲
case 'qzone_post':
    const newPost = { 
        type: msgData.postType, 
        content: msgData.content || '', 
        publicText: msgData.publicText || '', 
        hiddenContent: msgData.hiddenContent || '', 
        timestamp: Date.now(), 
        authorId: chatId, 
        authorGroupId: chat.groupId, // 【核心新增】記錄作者的分組ID
        visibleGroupIds: null 
    };
    await db.qzonePosts.add(newPost);
                    updateUnreadIndicator(unreadPostsCount + 1);
                    if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                       await renderQzonePosts();
                    }
                    continue;

// ▼▼▼ 步驟3.4：在 triggerAiResponse 中替換這個 case ▼▼▼
case 'qzone_comment':
    const postToComment = await db.qzonePosts.get(parseInt(msgData.postId));
    if (postToComment) {
        if (!postToComment.comments) postToComment.comments = [];
        
        const newAiComment = { 
            commenterName: msgData.commenterName || chat.name,
            text: msgData.commentText, 
            timestamp: Date.now() 
        };
        
        // 【核心修改】檢查AI是否指定了回復物件
        if (msgData.replyTo) {
            newAiComment.replyTo = msgData.replyTo;
        }

        postToComment.comments.push(newAiComment);
        await db.qzonePosts.update(postToComment.id, { comments: postToComment.comments });
        updateUnreadIndicator(unreadPostsCount + 1);
        if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
           await renderQzonePosts();
        }
    }
    continue;
// ▲▲▲ 步驟3.4替換結束 ▲▲▲



                case 'qzone_like':
                   const postToLike = await db.qzonePosts.get(parseInt(msgData.postId));
                   if (postToLike) {
                       if (!postToLike.likes) postToLike.likes = [];
                       if (!postToLike.likes.includes(chat.name)) {
                           postToLike.likes.push(chat.name);
                           await db.qzonePosts.update(postToLike.id, { likes: postToLike.likes });
                           updateUnreadIndicator(unreadPostsCount + 1);
                           if (isViewingThisChat && document.getElementById('qzone-screen').classList.contains('active')) {
                              await renderQzonePosts();
                           }
                       }
                   }
                    continue;

                case 'video_call_request':
                    if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                        state.activeChatId = chatId;
                        videoCallState.activeChatId = chatId; 
                        videoCallState.isAwaitingResponse = true;
                        videoCallState.isGroupCall = chat.isGroup;
                        videoCallState.callRequester = msgData.name || chat.name;
                        showIncomingCallModal(chatId); // <--- 把chatId作為參數傳進去
    }
                    continue;

            case 'group_call_request':
                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                    state.activeChatId = chatId;
                    videoCallState.isAwaitingResponse = true;
                    videoCallState.isGroupCall = true;
                    videoCallState.initiator = 'ai';
                    videoCallState.callRequester = msgData.name;
                    showIncomingCallModal();
                }
                continue;

                case 'pat_user':
                    const suffix = msgData.suffix ? ` ${msgData.suffix.trim()}` : '';
                    const patText = `${msgData.name || chat.name} 拍了拍我${suffix}`;
                    const patMessage = { 
                        role: 'system', 
                        type: 'pat_message', 
                        content: patText, 
                        timestamp: Date.now() 
                    };
                    chat.history.push(patMessage);
                    if (isViewingThisChat) {
                        const phoneScreen = document.getElementById('phone-screen');
                        phoneScreen.classList.remove('pat-animation');
                        void phoneScreen.offsetWidth;
                        phoneScreen.classList.add('pat-animation');
                        setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);
                        appendMessage(patMessage, chat);
                    } else {
                        showNotification(chatId, patText);
                    }
                    continue; 

                case 'update_status':
                    chat.status.text = msgData.status_text;
                    chat.status.isBusy = msgData.is_busy || false;
                    chat.status.lastUpdate = Date.now();
                    
                    const statusUpdateMessage = {
                        role: 'system',
                        type: 'pat_message',
                        content: `[${chat.name}的狀態已更新為: ${msgData.status_text}]`,
                        timestamp: Date.now()
                    };
                    chat.history.push(statusUpdateMessage);

                    if (isViewingThisChat) {
                        appendMessage(statusUpdateMessage, chat);
                    }
                    
                    renderChatList(); 
                    
                    continue; 

                case 'change_music':
                    if (musicState.isActive && musicState.activeChatId === chatId) {
                        const songNameToFind = msgData.song_name;
                        
                        const targetSongIndex = musicState.playlist.findIndex(
                            track => track.name.toLowerCase() === songNameToFind.toLowerCase()
                        );

                        if (targetSongIndex > -1) {
                            playSong(targetSongIndex);

                            const track = musicState.playlist[targetSongIndex];
                            const musicChangeMessage = {
                                role: 'system',
                                type: 'pat_message',
                                content: `[♪ ${chat.name} 為你切歌: 《${track.name}》 - ${track.artist}]`,
                                timestamp: Date.now()
                            };
                            chat.history.push(musicChangeMessage);

                            if (isViewingThisChat) {
                                appendMessage(musicChangeMessage, chat);
                            }
                        }
                    }
                    continue;
                case 'create_memory':
                    const newMemory = {
                        chatId: chatId,
                        authorName: chat.name,
                        description: msgData.description,
                        timestamp: Date.now(),
                        type: 'ai_generated'
                    };
                    await db.memories.add(newMemory);

                    console.log(`AI "${chat.name}" 記錄了一條新回憶:`, msgData.description);
                    
                    continue; 

        case 'create_countdown':
            const targetDate = new Date(msgData.date);
            if (!isNaN(targetDate) && targetDate > new Date()) {
                const newCountdown = {
                    chatId: chatId,
                    authorName: chat.name,
                    description: msgData.title,
                    timestamp: Date.now(),
                    type: 'countdown',
                    targetDate: targetDate.getTime()
                };
                await db.memories.add(newCountdown);
                console.log(`AI "${chat.name}" 創建了一個新約定:`, msgData.title);
            }
            continue;

    case 'block_user':
        if (!chat.isGroup) {
            chat.relationship.status = 'blocked_by_ai';

        // ▼▼▼ 在這裡添加下面的代碼 ▼▼▼
// ▼▼▼ 用這段新代碼替換掉上面那段 ▼▼▼
const hiddenMessage = {
    role: 'system',
    content: `[系統最高指令]
# 任務：回應情侶空間邀請
用戶剛剛向你發起了“開啟情侶空間”的邀請。你【必須】根據你的人設，決定是同意還是拒絕。

# 輸出格式鐵律 (必須嚴格遵守)
你的回復【必須且只能】是【一個】JSON物件，格式如下:
{"type": "lovers_space_response", "decision": "accept" 或 "reject", "responseText": "你想說的話..."}

# 示例
- 如果同意: {"type": "lovers_space_response", "decision": "accept", "responseText": ""}
- 如果拒絕: {"type": "lovers_space_response", "decision": "reject", "responseText": ""}

現在，請立即做出你的決定。`,
    timestamp: Date.now() + 1,
    isHidden: true
};
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加結束 ▲▲▲

            await db.chats.put(chat);
            
            if (isViewingThisChat) {
                renderChatInterface(chatId);
            }
            renderChatList();
            
            break; 
        }
        continue;
                case 'friend_request_response':
                    if (!chat.isGroup && chat.relationship.status === 'pending_ai_approval') {
                        if (msgData.decision === 'accept') {
                            chat.relationship.status = 'friend';
                            aiMessage = { ...baseMessage, content: "我通過了你的好友申請，我們現在是好友啦！" };
                        } else {
                            chat.relationship.status = 'blocked_by_ai';
                            aiMessage = { ...baseMessage, content: "抱歉，我拒絕了你的好友申請。" };
                        }
                        chat.relationship.applicationReason = '';
                    }
                    break;
                case 'poll':
                    const pollOptions = typeof msgData.options === 'string'
                        ? msgData.options.split('\n').filter(opt => opt.trim())
                        : (Array.isArray(msgData.options) ? msgData.options : []);
                    
                    if (pollOptions.length < 2) continue;

                    aiMessage = {
                        ...baseMessage,
                        type: 'poll',
                        question: msgData.question,
                        options: pollOptions,
                        votes: {},
                        isClosed: false,
                    };
                    break;
                
                case 'vote':
                    const pollToVote = chat.history.find(m => m.timestamp === msgData.poll_timestamp);
                    if (pollToVote && !pollToVote.isClosed) {
                        Object.keys(pollToVote.votes).forEach(option => {
                            const voterIndex = pollToVote.votes[option].indexOf(msgData.name);
                            if (voterIndex > -1) {
                                pollToVote.votes[option].splice(voterIndex, 1);
                            }
                        });
                        if (!pollToVote.votes[msgData.choice]) {
                            pollToVote.votes[msgData.choice] = [];
                        }

// ▼▼▼ 在這裡添加新代碼 ▼▼▼
const member = chat.members.find(m => m.originalName === msgData.name);
const displayName = member ? member.groupNickname : msgData.name;
// ▲▲▲ 添加結束 ▲▲▲

if (!pollToVote.votes[msgData.choice].includes(displayName)) { // 【核心修改】
    pollToVote.votes[msgData.choice].push(displayName); // 【核心修改】
}                     
                        
                        if (isViewingThisChat) {
                            renderChatInterface(chatId);
                        }
                    }
                    continue;

    case 'red_packet':
        aiMessage = {
            ...baseMessage,
            type: 'red_packet',
            packetType: msgData.packetType,
            totalAmount: msgData.amount,
            count: msgData.count,
            greeting: msgData.greeting,
            receiverName: msgData.receiver,
            claimedBy: {},
            isFullyClaimed: false,
        };
                // ▼▼▼ 在這裡添加新代碼 ▼▼▼
        // 【全新】同步到角色錢包（支出）
        const rpDescription = `發出紅包 - ${msgData.greeting || '恭喜發財'}`;
        await updateCharacterBankBalance(chatId, -msgData.amount, rpDescription);
        // ▲▲▲ 新代碼黏貼結束 ▲▲▲
        break;
// ▼▼▼ 在 triggerAiResponse 的 switch 語句中，用這塊新代碼替換舊的 case 'open_red_packet' ▼▼▼
case 'open_red_packet': { // 使用大括弧創建獨立的塊級作用域
    const packetToOpen = chat.history.find(m => m.timestamp === msgData.packet_timestamp);
    // 檢查紅包是否存在、是否沒被領完、以及這個AI角色是否還沒領過
    if (packetToOpen && !packetToOpen.isFullyClaimed && !(packetToOpen.claimedBy && packetToOpen.claimedBy[msgData.name])) {

        // 1. 根據AI的本名(msgData.name)去成員清單裡找到完整的成員對象
        const member = chat.members.find(m => m.originalName === msgData.name);
        // 2. 獲取該成員當前的群昵稱，如果找不到（異常情況），則備用其本名
        const displayName = member ? member.groupNickname : msgData.name;
        
        let claimedAmountAI = 0;
        const remainingAmount = packetToOpen.totalAmount - Object.values(packetToOpen.claimedBy || {}).reduce((sum, val) => sum + val, 0);
        const remainingCount = packetToOpen.count - Object.keys(packetToOpen.claimedBy || {}).length;

        if (remainingCount > 0) {
            if (remainingCount === 1) { claimedAmountAI = remainingAmount; } 
            else {
                const min = 0.01;
                const max = remainingAmount - (remainingCount - 1) * min;
                claimedAmountAI = Math.random() * (max - min) + min;
            }
            claimedAmountAI = parseFloat(claimedAmountAI.toFixed(2));
            
            if (!packetToOpen.claimedBy) packetToOpen.claimedBy = {};
            // 3. 【核心修改】使用我們剛剛查找到的 displayName 作為記錄的key
            packetToOpen.claimedBy[displayName] = claimedAmountAI;
                        // 【全新】同步到角色錢包（收入）
            const openRpDescription = `領取了 ${packetToOpen.senderName} 的紅包`;
            // 這裡的 AI 角色可能不是當前聊天的 `chatId`（因為是在群裡搶紅包），所以要精確找到是誰搶的
            const openerChar = Object.values(state.chats).find(c => c.name === displayName);
            if (openerChar) {
                 await updateCharacterBankBalance(openerChar.id, claimedAmountAI, openRpDescription);
            }
            
            const aiClaimedMessage = {
                role: 'system',
                type: 'pat_message',
                // 【核心修改】系統消息裡也使用 displayName
                content: `${displayName} 領取了 ${packetToOpen.senderName} 的紅包`,
                timestamp: Date.now()
            };
            chat.history.push(aiClaimedMessage);

            let hiddenContentForAI = `[系統提示：你 (${displayName}) 成功搶到了 ${claimedAmountAI.toFixed(2)} 元。`;

            if (Object.keys(packetToOpen.claimedBy).length >= packetToOpen.count) {
                packetToOpen.isFullyClaimed = true;
                
                const finishedMessage = {
                    role: 'system',
                    type: 'pat_message',
                    content: `${packetToOpen.senderName} 的紅包已被領完`,
                    timestamp: Date.now() + 1
                };
                chat.history.push(finishedMessage);
                
                let luckyKing = { name: '', amount: -1 };
                if (packetToOpen.packetType === 'lucky' && packetToOpen.count > 1) {
                    Object.entries(packetToOpen.claimedBy).forEach(([name, amount]) => {
                        if (amount > luckyKing.amount) {
                            luckyKing = { name, amount };
                        }
                    });
                }
                if (luckyKing.name) {
                     hiddenContentForAI += ` 紅包已被領完，手氣王是 ${luckyKing.name}！`;
                } else {
                     hiddenContentForAI += ` 紅包已被領完。`;
                }
            }
            hiddenContentForAI += ' 請根據這個結果發表你的評論。]';

            const hiddenMessageForAI = {
                role: 'system',
                content: hiddenContentForAI,
                timestamp: Date.now() + 2,
                isHidden: true
            };
            chat.history.push(hiddenMessageForAI);
        }
        
        if (isViewingThisChat) {
            renderChatInterface(chatId);
        }
    }
    continue; // 處理完後，繼續處理AI返回的其他消息
}
// ▲▲▲ 替換結束 ▲▲▲

case 'change_avatar':
    const avatarName = msgData.name;
    // 在該角色的頭像庫中查找
    const foundAvatar = chat.settings.aiAvatarLibrary.find(avatar => avatar.name === avatarName);
    
    if (foundAvatar) {
        // 找到了，就更新頭像
        chat.settings.aiAvatar = foundAvatar.url;
        
        // 創建一條系統提示，告知使用者頭像已更換
        const systemNotice = {
            role: 'system',
            type: 'pat_message', // 複用居中樣式
            content: `[${chat.name} 更換了頭像]`,
            timestamp: Date.now()
        };
        chat.history.push(systemNotice);
        
        // 如果在當前聊天介面，則即時渲染
        if (isViewingThisChat) {
            appendMessage(systemNotice, chat);
            // 立刻刷新聊天介面以顯示新頭像
            renderChatInterface(chatId);
        }
    }
    // 處理完後，繼續處理AI可能返回的其他消息
    continue;

// ▼▼▼ 在 triggerAiResponse 的 switch 語句中，【添加】這兩個全新的 case ▼▼▼

                case 'accept_transfer': { // 使用大括弧創建塊級作用域
                    const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalTransferMsgIndex > -1) {
                        const originalMsg = chat.history[originalTransferMsgIndex];
                        originalMsg.status = 'accepted';
                        
                        // ▼▼▼ 在這裡添加新代碼 ▼▼▼
                        // 【全新】同步到角色錢包（收入）
                        const acceptDescription = `收到來自 ${originalMsg.senderName} 的轉帳`;
                        await updateCharacterBankBalance(chatId, originalMsg.amount, acceptDescription);
                        // ▲▲▲ 新代碼黏貼結束 ▲▲▲
                    }
                    continue; // 接受指令只修改狀態，不產生新消息
                }

                case 'decline_transfer': { // 使用大括弧創建塊級作用域
                    const originalTransferMsgIndex = chat.history.findIndex(m => m.timestamp === msgData.for_timestamp);
                    if (originalTransferMsgIndex > -1) {
                        const originalMsg = chat.history[originalTransferMsgIndex];
                        originalMsg.status = 'declined';
                        
                        // 【核心】創建一條新的“退款”消息
                        const refundMessage = {
                            role: 'assistant',
                            senderName: chat.name,
                            type: 'transfer',
                            isRefund: true, // 標記這是一條退款消息
                            amount: originalMsg.amount,
                            note: '轉帳已被拒收',
                            timestamp: messageTimestamp++ // 使用遞增的時間戳記
                        };
                        
                        // 將新消息推入歷史記錄，它會被後續的迴圈處理並渲染
                        chat.history.push(refundMessage);

        // ▼▼▼ 在這裡添加下面的代碼 ▼▼▼
        if (isViewingThisChat) {
            // 因為退款消息是新生成的，所以我們直接將它添加到介面上
            appendMessage(refundMessage, chat); 
            // 同時，原始的轉帳消息狀態變了，所以要重繪整個介面以更新它
            renderChatInterface(chatId); 
        }
        // ▲▲▲ 添加結束 ▲▲▲

                    }
                    continue; // 繼續處理AI返回的文本消息
                }

// ▲▲▲ 添加結束 ▲▲▲

    case 'system_message':
        aiMessage = { role: 'system', type: 'pat_message', content: msgData.content, timestamp: Date.now() };
        break;

// ▼▼▼ 在 triggerAiResponse 的 switch 語句中，【必須添加】這個新的 case ▼▼▼

                case 'share_link':
                    aiMessage = { 
                        ...baseMessage, 
                        type: 'share_link',
                        title: msgData.title,
                        description: msgData.description,
                        // thumbnail_url: msgData.thumbnail_url, // 我們已經決定不要圖片了，所以這行可以不要
                        source_name: msgData.source_name,
                        content: msgData.content // 這是文章正文，點擊卡片後顯示的內容
                    };
                    break;

// ▲▲▲ 添加結束 ▲▲▲

// ▼▼▼ 在 triggerAiResponse 的 switch (msgData.type) 語句中，添加這個新的 case ▼▼▼
case 'quote_reply':
    const originalMessage = chat.history.find(m => m.timestamp === msgData.target_timestamp);
    if (originalMessage) {
        const quoteContext = {
            timestamp: originalMessage.timestamp,
            senderName: originalMessage.senderName || (originalMessage.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
            content: String(originalMessage.content || '').substring(0, 50),
        };
        aiMessage = { 
            ...baseMessage, 
            content: msgData.reply_content,
            quote: quoteContext // 核心：在這裡附加引用對象
        };
    } else {
        // 如果找不到被引用的消息，就當作普通消息發送
        aiMessage = { ...baseMessage, content: msgData.reply_content };
    }
    break;
// ▲▲▲ 新增 case 結束 ▲▲▲

case 'location':
    aiMessage = {
        ...baseMessage,
        type: 'location',
        userLocation: msgData.userLocation,
        aiLocation: msgData.aiLocation,
        distance: msgData.distance,
        trajectoryPoints: msgData.trajectoryPoints || [] // 【新增】確保即使AI沒提供，也是一個空陣列
    };
    break;
// ▲▲▲ 替換結束 ▲▲▲

case 'send_and_recall': {
    // --- 動畫部分 (保持不變) ---
    if (!isViewingThisChat) continue;
    const tempMessageData = { ...baseMessage, content: msgData.content };
    appendMessage(tempMessageData, chat, true);
    await new Promise(resolve => setTimeout(resolve, Math.random() * 1000 + 1500));
    const bubbleWrapper = document.querySelector(`.message-bubble[data-timestamp="${tempMessageData.timestamp}"]`)?.closest('.message-wrapper');
    if (bubbleWrapper) {
        bubbleWrapper.classList.add('recalled-animation');
        await new Promise(resolve => setTimeout(resolve, 300));
    }

    // --- 核心修改：資料記錄與AI感知 ---
    
    // 1. 創建對使用者可見的“已撤回”消息
    const recalledMessage = {
        role: 'assistant',
        senderName: msgData.name || chat.name,
        type: 'recalled_message',
        content: '對方撤回了一條消息',
        timestamp: tempMessageData.timestamp,
        recalledData: { originalType: 'text', originalContent: msgData.content }
    };
    
    // 2. 【關鍵】創建一條對用戶隱藏、但對AI可見的“記憶”消息
    const hiddenMemoryMessage = {
        role: 'system', // 必須是 system，這樣AI才知道這是上下文資訊
        content: `[系統提示：你剛剛說了一句“${msgData.content}”，但立刻就撤回了它。]`,
        timestamp: tempMessageData.timestamp + 1, // 確保在撤回消息之後
        isHidden: true // 這個標記讓它不在UI上顯示
    };

    // 3. 將這兩條消息都添加到歷史記錄中
    chat.history.push(recalledMessage, hiddenMemoryMessage);
    
    // 4. 替換DOM，顯示“已撤回”提示
    const placeholder = createMessageElement(recalledMessage, chat);
    if(document.body.contains(bubbleWrapper)) {
        bubbleWrapper.parentNode.replaceChild(placeholder, bubbleWrapper);
    }
    
    continue;
}
                
case 'sticker': {
    // 這是為群聊和單聊統一設計的表情包邏輯
    const stickerName = msgData.sticker_name; // 關鍵修改：統一使用 sticker_name
    if (!stickerName) {
        console.warn('AI返回了sticker類型但沒有sticker_name，已攔截:', msgData);
        continue; // 跳過這條無效指令
    }
    
    // 在所有可用表情庫中查找
    const allStickers = [...state.userStickers, ...state.charStickers, ...(chat.settings.stickerLibrary || [])];
    const foundSticker = allStickers.find(s => s.name === stickerName);

    if (foundSticker) {
        // 找到了，就創建消息物件
        aiMessage = { 
            ...baseMessage, 
            type: 'sticker', 
            content: foundSticker.url, 
            meaning: foundSticker.name 
        };
    } else {
        // 沒找到，說明AI幻覺了，記錄警告並跳過
        console.warn(`AI杜撰了不存在的表情: "${stickerName}"，已自動攔截。`);
    }
    break;
}
            case 'text': { 
                const messageText = String(msgData.content || msgData.message || '');
                
                if (STICKER_REGEX.test(messageText)) {
                    aiMessage = { ...baseMessage, type: 'sticker', content: messageText, meaning: '' };
                } 
                else {
                    // 相容舊的[sticker:名字]格式，但新prompt已不推薦
                    const stickerMatch = messageText.match(/^\[sticker:(.+?)\]$/); 
                    if (stickerMatch) {
                        const stickerName = stickerMatch[1].trim();
                        const allStickers = [...state.userStickers, ...state.charStickers, ...(chat.settings.stickerLibrary || [])];
                        const foundSticker = allStickers.find(s => s.name === stickerName);
                        
                        if (foundSticker) {
                            aiMessage = { ...baseMessage, type: 'sticker', content: foundSticker.url, meaning: foundSticker.name };
                        } else {
                            console.warn(`AI使用了舊格式且杜撰了不存在的表情: "${stickerName}"，已攔截。`);
                        }
                    } else {
                        aiMessage = { ...baseMessage, content: messageText };
                    }
                }
                break;
            }

    // ▼▼▼ 在任意一個 case 的後面，黏貼下面這個全新的 case ▼▼▼
    case 'forum_comment': { // 使用大括弧創建塊級作用域
        const postIdToComment = msgData.postId;
        const commentText = msgData.commentText;

        if (postIdToComment && commentText) {
            // 創建新的評論物件
            const newComment = {
                postId: postIdToComment,
                author: chat.name, // 評論者就是當前AI
                content: commentText,
                timestamp: Date.now()
            };
            // 存入資料庫
            await db.forumComments.add(newComment);
            
            // 給用戶一個回饋通知
            const postInfo = await db.forumPosts.get(postIdToComment);
            const postTitle = postInfo ? `《${postInfo.title}》` : '一個帖子';
            showNotification(chatId, `我評論了帖子 ${postTitle}`);
        }
        // 這個指令只是後臺操作，不需要在當前聊天裡顯示新消息，所以用 continue
        continue; 
    }
    // ▲▲▲ 黏貼結束 ▲▲▲
                case 'ai_image':
                    aiMessage = { ...baseMessage, type: 'ai_image', content: msgData.description };
                    break;
                case 'voice_message':
                    aiMessage = { ...baseMessage, type: 'voice_message', content: msgData.content };
                    break;
                case 'transfer':
                    aiMessage = { ...baseMessage, type: 'transfer', amount: msgData.amount, note: msgData.note, receiverName: msgData.receiver || '我' };
                                        // ▼▼▼ 在這裡添加新代碼 ▼▼▼
                    // 【全新】同步到角色錢包（支出）
                    const transferDescription = `轉帳給 ${msgData.receiver || '我'}`;
                    await updateCharacterBankBalance(chatId, -msgData.amount, transferDescription);
                    // ▲▲▲ 新代碼黏貼結束 ▲▲▲
                    break;
                
                case 'waimai_request':
                    aiMessage = { 
                        ...baseMessage, 
                        type: 'waimai_request',
                        productInfo: msgData.productInfo,
                        amount: msgData.amount,
                        status: 'pending',
                        countdownEndTime: Date.now() + 15 * 60 * 1000,
                    };
                    break;
                
                default:
                     console.warn("收到了未知的AI指令類型:", msgData.type);
                     break;
            }

            // 【核心修復】將渲染邏輯移出迴圈
            if (aiMessage) {
                // 1. 將新消息存入歷史記錄
                chat.history.push(aiMessage);

                if (!isViewingThisChat && !notificationShown) {
                    let notificationText;
                    switch (aiMessage.type) {
                        case 'transfer':
                            notificationText = `[收到一筆轉帳]`;
                            break;
                        case 'waimai_request':
                            notificationText = `[收到一個外賣代付請求]`;
                            break;
                        case 'ai_image':
                            notificationText = `[圖片]`;
                            break;
                        case 'voice_message':
                            notificationText = `[語音]`;
                            break;
                        case 'sticker':
                            notificationText = aiMessage.meaning ? `[表情: ${aiMessage.meaning}]` : '[表情]';
                            break;
                        default:
                            notificationText = String(aiMessage.content || '');
                    }
                    const finalNotifText = chat.isGroup ? `${aiMessage.senderName}: ${notificationText}` : notificationText;
                    showNotification(chatId, finalNotifText.substring(0, 40) + (finalNotifText.length > 40 ? '...' : ''));
                    notificationShown = true; // 確保只通知一次
                }

    if (!isViewingThisChat) {
        // 如果使用者不在當前聊天介面，就把這個聊天的未讀數 +1
        chat.unreadCount = (chat.unreadCount || 0) + 1;
    }
                
                // 2. 只有在當前聊天介面時，才執行帶動畫的添加
                if (isViewingThisChat) {
                    appendMessage(aiMessage, chat);
                    // 3. 【關鍵】在這裡暫停一小會兒，給動畫播放的時間
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 1800 + 1000));
                }
            }
  }        

        if (callHasBeenHandled && videoCallState.isGroupCall) {
            videoCallState.isAwaitingResponse = false;
            if (videoCallState.participants.length > 0) {
                startVideoCall();
            } else {
                videoCallState = { ...videoCallState, isAwaitingResponse: false, participants: [] };
                showScreen('chat-interface-screen');
                alert('無人接聽群聊邀請。');
            }
        }
        
        await db.chats.put(chat);
checkAndTriggerSummary(chatId);
    } catch (error) {
        chat.history = chat.history.filter(msg => !msg.isTemporary);
        if (!chat.isGroup && chat.relationship?.status === 'pending_ai_approval') {
            chat.relationship.status = 'blocked_by_ai';
            await showCustomAlert('申請失敗', `AI在處理你的好友申請時出錯了，請稍後重試。\n錯誤資訊: ${error.message}`);
        } else {
            const errorContent = `[出錯了: ${error.message}]`;
            const errorMessage = { role: 'assistant', content: errorContent, timestamp: Date.now() };
            if(chat.isGroup) errorMessage.senderName = "系統消息";
            chat.history.push(errorMessage);
        }
        
        await db.chats.put(chat);        
        videoCallState.isAwaitingResponse = false;

        if(document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chatId) {
            renderChatInterface(chatId);
        }
    } finally {
        // ★★★★★【核心修改4：在 finally 塊中統一隱藏所有類型的提示】★★★★★
        if (chat.isGroup) {
            if (typingIndicator) {
                typingIndicator.style.display = 'none';
            }
        } else {
            if (chatHeaderTitle && state.chats[chatId]) {
                chatHeaderTitle.style.opacity = 0;
                setTimeout(() => {
                    chatHeaderTitle.textContent = state.chats[chatId].name;
                    chatHeaderTitle.classList.remove('typing-status');
                    chatHeaderTitle.style.opacity = 1;
                }, 200);
            }
        }
    }
}

        async function sendSticker(sticker) { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: sticker.url, meaning: sticker.name, timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat);checkAndTriggerSummary(state.activeChatId);  appendMessage(msg, chat); renderChatList(); document.getElementById('sticker-panel').classList.remove('visible'); }
// ▼▼▼ 用這塊【功能增強版】代碼替換舊的 sendUserTransfer 函數 ▼▼▼
async function sendUserTransfer() { 
    if (!state.activeChatId) return; 
    
    const amountInput = document.getElementById('transfer-amount'); 
    const noteInput = document.getElementById('transfer-note'); 
    const amount = parseFloat(amountInput.value); 
    const note = noteInput.value.trim(); 
    
    if (isNaN(amount) || amount <= 0) { 
        alert('請輸入有效的金額！'); 
        return; 
    } 

    // 【核心新增1】檢查餘額是否足夠
    if ((state.globalSettings.userBalance || 0) < amount) {
        alert('餘額不足！');
        return;
    }

    const chat = state.chats[state.activeChatId]; 
    const senderName = chat.isGroup ? (chat.settings.myNickname || '我') : '我'; 
    const receiverName = chat.isGroup ? '群聊' : chat.name; 

    // 【核心新增2】調用我們的新函數來扣款並記錄
    await updateUserBalanceAndLogTransaction(-amount, `轉帳給 ${receiverName}`);

    const msg = { role: 'user', type: 'transfer', amount: amount, note: note, senderName, receiverName, timestamp: Date.now() }; 
    chat.history.push(msg); 
    
    await db.chats.put(chat); 
    appendMessage(msg, chat); 
    renderChatList(); 
    document.getElementById('transfer-modal').classList.remove('visible'); 
    amountInput.value = ''; 
    noteInput.value = ''; 
}
// ▲▲▲ 替換結束 ▲▲▲
        function enterSelectionMode(initialMsgTimestamp) { if (isSelectionMode) return; isSelectionMode = true; document.getElementById('chat-interface-screen').classList.add('selection-mode'); toggleMessageSelection(initialMsgTimestamp); }

        function exitSelectionMode() {
    cleanupWaimaiTimers(); // <--- 在這裡添加這行代碼
 if (!isSelectionMode) return; isSelectionMode = false; document.getElementById('chat-interface-screen').classList.remove('selection-mode'); selectedMessages.forEach(ts => { const bubble = document.querySelector(`.message-bubble[data-timestamp="${ts}"]`); if (bubble) bubble.classList.remove('selected'); }); selectedMessages.clear(); }

// ▼▼▼ 請用這個【最終簡化版】替換舊的 toggleMessageSelection 函數 ▼▼▼
function toggleMessageSelection(timestamp) {
    // 【核心修正】選擇器已簡化，不再尋找已刪除的 .recalled-message-placeholder
    const elementToSelect = document.querySelector(
        `.message-bubble[data-timestamp="${timestamp}"]`
    );

    if (!elementToSelect) return;

    if (selectedMessages.has(timestamp)) {
        selectedMessages.delete(timestamp);
        elementToSelect.classList.remove('selected');
    } else {
        selectedMessages.add(timestamp);
        elementToSelect.classList.add('selected');
    }
    
    document.getElementById('selection-count').textContent = `已選 ${selectedMessages.size} 條`;
    
    if (selectedMessages.size === 0) {
        exitSelectionMode();
    }
}
// ▲▲▲ 替換結束 ▲▲▲

        function addLongPressListener(element, callback) { let pressTimer; const startPress = (e) => { if(isSelectionMode) return; e.preventDefault(); pressTimer = window.setTimeout(() => callback(e), 500); }; const cancelPress = () => clearTimeout(pressTimer); element.addEventListener('mousedown', startPress); element.addEventListener('mouseup', cancelPress); element.addEventListener('mouseleave', cancelPress); element.addEventListener('touchstart', startPress, { passive: true }); element.addEventListener('touchend', cancelPress); element.addEventListener('touchmove', cancelPress); }

        async function handleListenTogetherClick() { 

    // ▼▼▼ 在這裡添加下面這行代碼 ▼▼▼
    document.getElementById('floating-lyrics-bar').style.display = 'none';
    // ▲▲▲ 添加結束 ▲▲▲

const targetChatId = state.activeChatId; if (!targetChatId) return; if (!musicState.isActive) { startListenTogetherSession(targetChatId); return; } if (musicState.activeChatId === targetChatId) { document.getElementById('music-player-overlay').classList.add('visible'); } else { const oldChatName = state.chats[musicState.activeChatId]?.name || '未知'; const newChatName = state.chats[targetChatId]?.name || '當前'; const confirmed = await showCustomConfirm('切換聽歌對象', `您正和「${oldChatName}」聽歌。要結束並開始和「${newChatName}」的新會話嗎？`, { confirmButtonClass: 'btn-danger' }); if (confirmed) { await endListenTogetherSession(true); await new Promise(resolve => setTimeout(resolve, 50)); startListenTogetherSession(targetChatId); } } }

        async function startListenTogetherSession(chatId) { const chat = state.chats[chatId]; if (!chat) return; musicState.totalElapsedTime = chat.musicData.totalTime || 0; musicState.isActive = true; musicState.activeChatId = chatId; if (musicState.playlist.length > 0) { musicState.currentIndex = 0; } else { musicState.currentIndex = -1; } if(musicState.timerId) clearInterval(musicState.timerId); musicState.timerId = setInterval(() => { if (musicState.isPlaying) { musicState.totalElapsedTime++; updateElapsedTimeDisplay(); } }, 1000); updatePlayerUI(); updatePlaylistUI(); document.getElementById('music-player-overlay').classList.add('visible'); }

async function endListenTogetherSession(saveState = true) {
    if (!musicState.isActive) return;
    const oldChatId = musicState.activeChatId;
    const cleanupLogic = async () => {

    // ▼▼▼ 在這裡添加下面這行代碼 ▼▼▼
    document.getElementById('floating-lyrics-bar').style.display = 'none';
    // ▲▲▲ 添加結束 ▲▲▲

        if (musicState.timerId) clearInterval(musicState.timerId);
        if (musicState.isPlaying) audioPlayer.pause();
        if (saveState && oldChatId && state.chats[oldChatId]) {
            const chat = state.chats[oldChatId];
            chat.musicData.totalTime = musicState.totalElapsedTime;
            await db.chats.put(chat);
        }
        musicState.isActive = false;
        musicState.activeChatId = null;
        musicState.totalElapsedTime = 0;
        musicState.timerId = null;
        updateListenTogetherIcon(oldChatId, true);
    };
    closeMusicPlayerWithAnimation(cleanupLogic);
}

function returnToChat() {
    closeMusicPlayerWithAnimation(() => {

        if (musicState.isActive && lyricsBarSettings.showOnClose) {
            document.getElementById('floating-lyrics-bar').style.display = 'flex';
        }
    });
}

        function updateListenTogetherIcon(chatId, forceReset = false) { const iconImg = document.querySelector('#listen-together-btn img'); if(!iconImg) return; if(forceReset || !musicState.isActive || musicState.activeChatId !== chatId) { iconImg.src = 'https://i.postimg.cc/8kYShvrJ/90-UI-2.png'; iconImg.className = ''; return; } iconImg.src = 'https://i.postimg.cc/D0pq6qS2/E30078-DC-8-B99-4-C01-AFDA-74728-DBF7-BEA.png'; iconImg.classList.add('rotating'); if (musicState.isPlaying) iconImg.classList.remove('paused'); else iconImg.classList.add('paused'); }
        window.updateListenTogetherIconProxy = updateListenTogetherIcon;

        function updatePlayerUI() {
            updateListenTogetherIcon(musicState.activeChatId);
            updateElapsedTimeDisplay();
            const titleEl = document.getElementById('music-player-song-title');
            const artistEl = document.getElementById('music-player-artist');
            const playPauseBtn = document.getElementById('music-play-pause-btn');
            const chat = state.chats[musicState.activeChatId];
            const charAvatarEl = document.getElementById('music-char-avatar');
            const userAvatarEl = document.getElementById('music-user-avatar');
            const albumCoverEl = document.getElementById('music-album-cover');
            const avatarsContainer = document.getElementById('music-avatars-container');
            const displayArea = document.getElementById('music-display-area');

            // 1. 【核心修改】在這裡判斷是群聊還是單聊，並設置正確的頭像
            if (chat) {
                // 如果是群聊
                if (chat.isGroup) {
                    // 左邊的頭像就用群頭像
                    charAvatarEl.src = chat.settings.groupAvatar || defaultGroupAvatar;
                } else {
                    // 否則（是單聊），就用角色的頭像
                    charAvatarEl.src = chat.settings.aiAvatar || defaultAvatar;
                }
                // 右邊的用戶頭像保持不變
                userAvatarEl.src = chat.settings.myAvatar || defaultAvatar;
            }

            // 2. 更新歌曲資訊和封面 (不變)
            if (musicState.currentIndex > -1 && musicState.playlist.length > 0) {
                const track = musicState.playlist[musicState.currentIndex];
                titleEl.textContent = track.name;
                artistEl.textContent = track.artist;
                albumCoverEl.src = track.cover || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
            } else {
                titleEl.textContent = '請添加歌曲';
                artistEl.textContent = '...';
                albumCoverEl.src = 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
            }

            // 3. 控制播放/暫停按鈕和頭像閃爍 (不變)
            playPauseBtn.textContent = musicState.isPlaying ? '❚❚' : '▶';
            avatarsContainer.classList.toggle('flashing', musicState.isPlaying);

            // 4. 控制唱片旋轉和暫停 (不變)
            albumCoverEl.classList.toggle('rotating', musicState.currentIndex > -1);
            albumCoverEl.classList.toggle('paused', !musicState.isPlaying);

            // 5. 預設顯示歌曲封面 (不變)
            if (displayArea) {
                displayArea.classList.remove('show-lyrics');
            }
        }


        function updateElapsedTimeDisplay() { const hours = (musicState.totalElapsedTime / 3600).toFixed(1); document.getElementById('music-time-counter').textContent = `已經一起聽了${hours}小時`; }
// ▼▼▼ 把這【一整塊新函數】黏貼到 updatePlaylistUI 函數的上方 ▼▼▼
/**
 * 【全新】處理用戶上傳或更新歌曲封面的邏輯
 * @param {number} index - 被操作的歌曲在播放清單中的索引
 */
// ▼▼▼ 請用這【一整塊新代碼】替換舊的 handleCoverUpload 函數 ▼▼▼
async function handleCoverUpload(index) {
    if (index < 0 || index >= musicState.playlist.length) return;

    // 1. 彈窗讓用戶選擇來源（已移除圖示）
    const choice = await showChoiceModal("選擇封面來源", [
        { text: '使用網路URL', value: 'url' },
        { text: '從本地上傳', value: 'local' }
    ]);

    let newCoverUrl = null;

    // 2. 根據選擇執行不同操作
    if (choice === 'url') {
        const url = await showCustomPrompt("封面URL", "請輸入圖片檔的網路連結");
        if (url && url.trim().startsWith('http')) {
            newCoverUrl = url.trim();
        } else if (url !== null) {
            alert("請輸入一個有效的圖片URL！");
        }
    } else if (choice === 'local') {
        newCoverUrl = await uploadImageLocally(); 
    }

    // 3. 如果成功獲取到新的封面URL，就更新資料和UI
    if (newCoverUrl) {
        musicState.playlist[index].cover = newCoverUrl;
        await saveGlobalPlaylist();
        updatePlaylistUI();
        if (musicState.currentIndex === index) {
            updatePlayerUI();
        }
        alert('歌曲封面已更新！');
    }
}
// ▲▲▲ 替換結束 ▲▲▲


// ▼▼▼ 請用這【一整塊新代碼】替換舊的 updatePlaylistUI 函數 ▼▼▼
function updatePlaylistUI() {
    const playlistBody = document.getElementById('playlist-body');
    playlistBody.innerHTML = '';
    if (musicState.playlist.length === 0) {
        playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">播放清單是空的~</p>';
        return;
    }
    musicState.playlist.forEach((track, index) => {
        const item = document.createElement('div');
        item.className = 'playlist-item';
        if(index === musicState.currentIndex) item.classList.add('playing');
        // 【核心修改】在“詞”按鈕旁邊，新增了一個“封面”按鈕
        item.innerHTML = `
            <div class="playlist-item-info">
                <div class="title">${track.name}</div>
                <div class="artist">${track.artist}</div>
            </div>
            <div class="playlist-item-actions">
                <span class="playlist-action-btn cover-btn" data-index="${index}">封面</span>
                <span class="playlist-action-btn lyrics-btn" data-index="${index}">詞</span>
                <span class="playlist-action-btn delete-track-btn" data-index="${index}">×</span>
            </div>
        `;
        item.querySelector('.playlist-item-info').addEventListener('click', () => playSong(index));
        playlistBody.appendChild(item);
    });
}
// ▲▲▲ 替換結束 ▲▲▲

async function loadSong(index) {
    if (index < 0 || index >= musicState.playlist.length) return;
    musicState.currentIndex = index;
    const track = musicState.playlist[index];

    // 檢查並載入網路歌詞
    if (track.lrcUrl && !track.lrcContent) {
        try {
            const response = await fetch(track.lrcUrl);
            if (response.ok) track.lrcContent = await response.text();
        } catch (error) {
            console.error("載入歌詞URL失敗:", error);
        }
    }

    // 準備播放
    musicState.parsedLyrics = parseLRC(track.lrcContent || "");
    musicState.currentLyricIndex = -1;
    renderLyrics();

    if (track.isLocal && track.src instanceof Blob) {
        audioPlayer.src = URL.createObjectURL(track.src);
    } else if (!track.isLocal) {
        audioPlayer.src = track.src;
    } else {
        console.error('本地歌曲源錯誤:', track);
        return;
    }

    // 更新介面資訊，但不播放
    updatePlaylistUI();
    updatePlayerUI();
    // audioPlayer.duration 可能需要一點時間載入，我們監聽事件來更新進度條
    audioPlayer.onloadedmetadata = () => {
        updateMusicProgressBar();
    };
}

// ▼▼▼ 請用下面這【一整塊】全新的代碼，替換掉你舊的 playSong 和 togglePlayPause 兩個函數 ▼▼▼

async function playSong(index) {
    await loadSong(index);
    try {
        await audioPlayer.play();
        // ▼▼▼ 新增這兩行 ▼▼▼
        musicState.isPlaying = true; // 播放成功後，直接設置狀態為 true
        updatePlayerUI();           // 並立即更新UI
        // ▲▲▲ 新增結束 ▲▲▲
    } catch (error) {
        console.error("音訊播放失敗:", error);
        musicState.isPlaying = false; // 如果播放失敗，也要確保狀態正確
        updatePlayerUI();
    }
}


/**
 * 【全新智慧版】處理播放/暫停的函數
 */
function togglePlayPause() {
    if (audioPlayer.paused) {
        if (musicState.currentIndex > -1) {
            playSong(musicState.currentIndex);
        }
    } else {
        audioPlayer.pause();
        // ▼▼▼ 新增這兩行 ▼▼▼
        musicState.isPlaying = false;
        updatePlayerUI();
        // ▲▲▲ 新增結束 ▲▲▲
    }
}

// ▲▲▲ 替換結束 ▲▲▲


        function playNext() { if (musicState.playlist.length === 0) return; let nextIndex; switch(musicState.playMode) { case 'random': nextIndex = Math.floor(Math.random() * musicState.playlist.length); break; case 'single': playSong(musicState.currentIndex); return; case 'order': default: nextIndex = (musicState.currentIndex + 1) % musicState.playlist.length; break; } playSong(nextIndex); }

        function playPrev() { if (musicState.playlist.length === 0) return; const newIndex = (musicState.currentIndex - 1 + musicState.playlist.length) % musicState.playlist.length; playSong(newIndex); }

        function changePlayMode() { const modes = ['order', 'random', 'single']; const currentModeIndex = modes.indexOf(musicState.playMode); musicState.playMode = modes[(currentModeIndex + 1) % modes.length]; document.getElementById('music-mode-btn').textContent = {'order': '順序', 'random': '隨機', 'single': '單曲'}[musicState.playMode]; }

        async function addSongFromURL() {
    const url = await showCustomPrompt("添加網路歌曲", "請輸入歌曲的URL", "", "url");
    if (!url) return;
    const name = await showCustomPrompt("歌曲資訊", "請輸入歌名");
    if (!name) return;
    const artist = await showCustomPrompt("歌曲資訊", "請輸入歌手名");
    if (!artist) return;

    // ▼▼▼【核心修改在這裡】▼▼▼
    // 1. 先彈窗詢問使用者是否要提供歌詞連結
    const wantLrc = await showCustomConfirm("導入歌詞", `要為《${name}》提供一個歌詞檔 (.lrc) 的URL嗎？`);
    let lrcUrl = ""; // 預設歌詞連結為空

    // 2. 如果用戶點擊了“確定”
    if (wantLrc) {
        // 就再彈出一個輸入框讓用戶黏貼URL
        const inputLrcUrl = await showCustomPrompt("歌詞URL", "請輸入 .lrc 歌詞檔的網路連結", "", "url");
        if (inputLrcUrl) {
            lrcUrl = inputLrcUrl; // 如果用戶輸入了，就保存這個URL
        }
    }
    // ▲▲▲【修改結束】▲▲▲

    musicState.playlist.push({ 
        name, 
        artist, 
        src: url, 
        isLocal: false,
        lrcUrl: lrcUrl, // 3. 把獲取到的歌詞URL也保存到歌曲資訊裡
        lrcContent: ""  // 同時確保lrcContent是空的，以便後續載入
    });

    await saveGlobalPlaylist();
    updatePlaylistUI();
// 【這是新代碼】
if(musicState.currentIndex === -1) {
    // 【核心修改】調用 loadSong 來準備好第一首歌
    loadSong(musicState.playlist.length - 1);
}
}


async function addSongFromLocal(event) {
    const files = event.target.files;
    if (!files.length) return;

    for (const file of files) {
        let name = file.name.replace(/\.[^/.]+$/, "");
        name = await showCustomPrompt("歌曲資訊", "請輸入歌名", name);
        if (name === null) continue;
        
        const artist = await showCustomPrompt("歌曲資訊", "請輸入歌手名", "未知歌手");
        if (artist === null) continue;

        let lrcContent = "";
        const wantLrc = await showCustomConfirm("導入歌詞", `要為《${name}》導入歌詞文件 (.lrc) 嗎？`);
        if (wantLrc) {
            lrcContent = await new Promise(resolve => {
                const lrcInput = document.getElementById('lrc-upload-input');
                const lrcChangeHandler = (e) => {
                    const lrcFile = e.target.files[0];
                    if (lrcFile) {
                        const reader = new FileReader();
                        reader.onload = (readEvent) => resolve(readEvent.target.result);
                        reader.onerror = () => resolve("");
                        reader.readAsText(lrcFile);
                    } else {
                        resolve("");
                    }
                    lrcInput.removeEventListener('change', lrcChangeHandler);
                    lrcInput.value = '';
                };
                lrcInput.addEventListener('change', lrcChangeHandler);
                lrcInput.click();
            });
        }
        
        musicState.playlist.push({ 
            name, 
            artist, 
            src: file, 
            isLocal: true,
            lrcContent: lrcContent
        });
    }
    
    await saveGlobalPlaylist();
    updatePlaylistUI();
// 【這是新代碼】
if (musicState.currentIndex === -1 && musicState.playlist.length > 0) {
    // 【核心修改】同樣，調用 loadSong 來準備好第一首歌
    loadSong(0);
}
    event.target.value = null;
}

        async function deleteTrack(index) { if (index < 0 || index >= musicState.playlist.length) return; const track = musicState.playlist[index]; const wasPlaying = musicState.isPlaying && musicState.currentIndex === index; if (track.isLocal && audioPlayer.src.startsWith('blob:') && musicState.currentIndex === index) URL.revokeObjectURL(audioPlayer.src); musicState.playlist.splice(index, 1); await saveGlobalPlaylist(); if (musicState.playlist.length === 0) { if (musicState.isPlaying) audioPlayer.pause(); audioPlayer.src = ''; musicState.currentIndex = -1; musicState.isPlaying = false; } else { if (wasPlaying) { playNext(); } else { if (musicState.currentIndex >= index) musicState.currentIndex = Math.max(0, musicState.currentIndex - 1); } } updatePlayerUI(); updatePlaylistUI(); }

        const personaLibraryModal = document.getElementById('persona-library-modal');
        const personaEditorModal = document.getElementById('persona-editor-modal');
        const presetActionsModal = document.getElementById('preset-actions-modal');

        function openPersonaLibrary() { renderPersonaLibrary(); personaLibraryModal.classList.add('visible'); }

        function closePersonaLibrary() { personaLibraryModal.classList.remove('visible'); }

        function renderPersonaLibrary() { const grid = document.getElementById('persona-library-grid'); grid.innerHTML = ''; if (state.personaPresets.length === 0) { grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center; margin-top: 20px;">空空如也~ 點擊右上角"添加"來創建你的第一個人設預設吧！</p>'; return; } state.personaPresets.forEach(preset => { const item = document.createElement('div'); item.className = 'persona-preset-item'; item.style.backgroundImage = `url(${preset.avatar})`; item.dataset.presetId = preset.id; item.addEventListener('click', () => applyPersonaPreset(preset.id)); addLongPressListener(item, () => showPresetActions(preset.id)); grid.appendChild(item); }); }

        function showPresetActions(presetId) { editingPersonaPresetId = presetId; presetActionsModal.classList.add('visible'); }

        function hidePresetActions() { presetActionsModal.classList.remove('visible'); editingPersonaPresetId = null; }

        function applyPersonaPreset(presetId) { const preset = state.personaPresets.find(p => p.id === presetId); if (preset) { document.getElementById('my-avatar-preview').src = preset.avatar; document.getElementById('my-persona').value = preset.persona; } closePersonaLibrary(); }

// ▼▼▼ 用這個全新的函數，完整替換舊的 openPersonaEditorForCreate 函數 ▼▼▼
function openPersonaEditorForCreate() { 
    editingPersonaPresetId = null; 
    
    document.getElementById('persona-editor-title').textContent = '添加人設預設'; 
    document.getElementById('preset-avatar-preview').src = defaultAvatar; 
    document.getElementById('preset-persona-input').value = ''; 
    
    // 【核心邏輯】根據使用者人設模式，顯隱特定UI元素
    document.getElementById('npc-editor-name-group').style.display = 'none';
    document.getElementById('persona-editor-change-frame-btn').style.display = 'inline-block';

    // 【【【這就是您代碼中的正確做法！】】】
    // 我們直接覆蓋保存按鈕的 onclick 事件，強制它只執行保存使用者人設的函數
    document.getElementById('save-persona-preset-btn').onclick = savePersonaPreset;

    document.getElementById('persona-editor-modal').classList.add('visible'); 
}
// ▲▲▲ 替換結束 ▲▲▲



// ▼▼▼ 用這個全新的函數，完整替換舊的 openPersonaEditorForEdit 函數 ▼▼▼
function openPersonaEditorForEdit() { 
    const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); 
    if (!preset) return; 

    document.getElementById('persona-editor-title').textContent = '編輯人設預設'; 
    document.getElementById('preset-avatar-preview').src = preset.avatar; 
    document.getElementById('preset-persona-input').value = preset.persona; 
    
    // 【核心邏輯】根據使用者人設模式，顯隱特定UI元素
    document.getElementById('npc-editor-name-group').style.display = 'none';
    document.getElementById('persona-editor-change-frame-btn').style.display = 'inline-block';

    // 【【【這就是您代碼中的正確做法！】】】
    // 我們直接覆蓋保存按鈕的 onclick 事件，強制它只執行保存使用者人設的函數
    document.getElementById('save-persona-preset-btn').onclick = savePersonaPreset;
    
    presetActionsModal.classList.remove('visible'); 
    document.getElementById('persona-editor-modal').classList.add('visible'); 
}
// ▲▲▲ 替換結束 ▲▲▲





        async function deletePersonaPreset() { const confirmed = await showCustomConfirm('刪除預設', '確定要刪除這個人設預設嗎？此操作不可恢復。', { confirmButtonClass: 'btn-danger' }); if (confirmed && editingPersonaPresetId) { await db.personaPresets.delete(editingPersonaPresetId); state.personaPresets = state.personaPresets.filter(p => p.id !== editingPersonaPresetId); hidePresetActions(); renderPersonaLibrary(); } }

        function closePersonaEditor() { personaEditorModal.classList.remove('visible'); editingPersonaPresetId = null; }

        async function savePersonaPreset() { const avatar = document.getElementById('preset-avatar-preview').src; const persona = document.getElementById('preset-persona-input').value.trim(); if (avatar === defaultAvatar && !persona) { alert("頭像和人設不能都為空哦！"); return; } if (editingPersonaPresetId) { const preset = state.personaPresets.find(p => p.id === editingPersonaPresetId); if (preset) { preset.avatar = avatar; preset.persona = persona; await db.personaPresets.put(preset); } } else { const newPreset = { id: 'preset_' + Date.now(), avatar: avatar, persona: persona }; await db.personaPresets.add(newPreset); state.personaPresets.push(newPreset); } renderPersonaLibrary(); closePersonaEditor(); }

        const batteryAlertModal = document.getElementById('battery-alert-modal');

        function showBatteryAlert(imageUrl, text) { clearTimeout(batteryAlertTimeout); document.getElementById('battery-alert-image').src = imageUrl; document.getElementById('battery-alert-text').textContent = text; batteryAlertModal.classList.add('visible'); const closeAlert = () => { batteryAlertModal.classList.remove('visible'); batteryAlertModal.removeEventListener('click', closeAlert); }; batteryAlertModal.addEventListener('click', closeAlert); batteryAlertTimeout = setTimeout(closeAlert, 2000); }

        function updateBatteryDisplay(battery) { const batteryContainer = document.getElementById('status-bar-battery'); const batteryLevelEl = batteryContainer.querySelector('.battery-level'); const batteryTextEl = batteryContainer.querySelector('.battery-text'); const level = Math.floor(battery.level * 100); batteryLevelEl.style.width = `${level}%`; batteryTextEl.textContent = `${level}%`; if (battery.charging) { batteryContainer.classList.add('charging'); } else { batteryContainer.classList.remove('charging'); } }

        function handleBatteryChange(battery) { updateBatteryDisplay(battery); const level = battery.level; if (!battery.charging) { if (level <= 0.4 && lastKnownBatteryLevel > 0.4 && !alertFlags.hasShown40) { showBatteryAlert('https://i.postimg.cc/T2yKJ0DV/40.jpg', '有點餓了，可以去找充電器惹'); alertFlags.hasShown40 = true; } if (level <= 0.2 && lastKnownBatteryLevel > 0.2 && !alertFlags.hasShown20) { showBatteryAlert('https://i.postimg.cc/qB9zbKs9/20.jpg', '趕緊的充電，要餓死了'); alertFlags.hasShown20 = true; } if (level <= 0.1 && lastKnownBatteryLevel > 0.1 && !alertFlags.hasShown10) { showBatteryAlert('https://i.postimg.cc/ThMMVfW4/10.jpg', '已陣亡，還有30秒爆炸'); alertFlags.hasShown10 = true; } } if (level > 0.4) alertFlags.hasShown40 = false; if (level > 0.2) alertFlags.hasShown20 = false; if (level > 0.1) alertFlags.hasShown10 = false; lastKnownBatteryLevel = level; }

        async function initBatteryManager() { if ('getBattery' in navigator) { try { const battery = await navigator.getBattery(); lastKnownBatteryLevel = battery.level; handleBatteryChange(battery); battery.addEventListener('levelchange', () => handleBatteryChange(battery)); battery.addEventListener('chargingchange', () => { handleBatteryChange(battery); if (battery.charging) { showBatteryAlert('https://i.postimg.cc/3NDQ0dWG/image.jpg', '窩愛泥，電量吃飽飽'); } }); } catch (err) { console.error("無法獲取電池資訊:", err); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } } else { console.log("流覽器不支援電池狀態API。"); document.querySelector('.battery-text').textContent = 'ᗜωᗜ'; } }

        async function renderAlbumList() {
            const albumGrid = document.getElementById('album-grid-page');
            if (!albumGrid) return;
            const albums = await db.qzoneAlbums.orderBy('createdAt').reverse().toArray();
            albumGrid.innerHTML = '';
            if (albums.length === 0) {
                albumGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">你還沒有創建任何相冊哦~</p>';
                return;
            }
            albums.forEach(album => {
                const albumItem = document.createElement('div');
                albumItem.className = 'album-item';
                albumItem.innerHTML = `
                    <div class="album-cover" style="background-image: url(${album.coverUrl});"></div>
                    <div class="album-info">
                        <p class="album-name">${album.name}</p>
                        <p class="album-count">${album.photoCount || 0} 張</p>
                    </div>
                `;
                albumItem.addEventListener('click', () => {
                    openAlbum(album.id);
                });

                // ▼▼▼ 新增的核心代碼就是這裡 ▼▼▼
                addLongPressListener(albumItem, async () => {
                    const confirmed = await showCustomConfirm(
                        '刪除相冊',
                        `確定要刪除相冊《${album.name}》嗎？此操作將同時刪除相冊內的所有照片，且無法恢復。`,
                        { confirmButtonClass: 'btn-danger' }
                    );

                    if (confirmed) {
                        // 1. 從照片表中刪除該相冊下的所有照片
                        await db.qzonePhotos.where('albumId').equals(album.id).delete();
                        
                        // 2. 從相冊表中刪除該相冊本身
                        await db.qzoneAlbums.delete(album.id);
                        
                        // 3. 重新渲染相簿清單
                        await renderAlbumList();
                        
                        alert('相冊已成功刪除。');
                    }
                });
                // ▲▲▲ 新增代碼結束 ▲▲▲

                albumGrid.appendChild(albumItem);
            });
        }

        async function openAlbum(albumId) {
            state.activeAlbumId = albumId;
            await renderAlbumPhotosScreen();
            showScreen('album-photos-screen');
        }

        async function renderAlbumPhotosScreen() {
            if (!state.activeAlbumId) return;
            const photosGrid = document.getElementById('photos-grid-page');
            const headerTitle = document.getElementById('album-photos-title');
            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            if (!album) {
                console.error("找不到相冊:", state.activeAlbumId);
                showScreen('album-screen');
                return;
            }
            headerTitle.textContent = album.name;
            const photos = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
            photosGrid.innerHTML = '';
            if (photos.length === 0) {
                photosGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary); margin-top: 50px;">這個相冊還是空的，快上傳第一張照片吧！</p>';
            } else {
                photos.forEach(photo => {
                    const photoItem = document.createElement('div');
                    photoItem.className = 'photo-item';
                    photoItem.innerHTML = `
                        <img src="${photo.url}" class="photo-thumb" alt="相冊照片">
                        <button class="photo-delete-btn" data-photo-id="${photo.id}">×</button>
                    `;
                    photosGrid.appendChild(photoItem);
                });
            }
        }

// --- ↓↓↓ 從這裡開始複製 ↓↓↓ ---

/**
 * 打開圖片檢視器
 * @param {string} clickedPhotoUrl - 用戶點擊的那張照片的URL
 */
async function openPhotoViewer(clickedPhotoUrl) {
    if (!state.activeAlbumId) return;

    // 1. 從資料庫獲取當前相冊的所有照片
    const photosInAlbum = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).toArray();
    photoViewerState.photos = photosInAlbum.map(p => p.url);

    // 2. 找到被點擊照片的索引
    photoViewerState.currentIndex = photoViewerState.photos.findIndex(url => url === clickedPhotoUrl);
    if (photoViewerState.currentIndex === -1) return; // 如果找不到，則不打開

    // 3. 顯示模態框並渲染第一張圖
    document.getElementById('photo-viewer-modal').classList.add('visible');
    renderPhotoViewer();
    photoViewerState.isOpen = true;
}

/**
 * 根據當前狀態渲染檢視器內容（圖片和按鈕）
 */
function renderPhotoViewer() {
    if (photoViewerState.currentIndex === -1) return;

    const imageEl = document.getElementById('photo-viewer-image');
    const prevBtn = document.getElementById('photo-viewer-prev-btn');
    const nextBtn = document.getElementById('photo-viewer-next-btn');
    
    // 淡出效果
    imageEl.style.opacity = 0;

    setTimeout(() => {
        // 更新圖片源
        imageEl.src = photoViewerState.photos[photoViewerState.currentIndex];
        // 淡入效果
        imageEl.style.opacity = 1;
    }, 100); // 延遲一點點時間來觸發CSS過渡

    // 更新按鈕狀態：如果是第一張，禁用“上一張”按鈕
    prevBtn.disabled = photoViewerState.currentIndex === 0;
    // 如果是最後一張，禁用“下一張”按鈕
    nextBtn.disabled = photoViewerState.currentIndex === photoViewerState.photos.length - 1;
}

/**
 * 顯示下一張照片
 */
function showNextPhoto() {
    if (photoViewerState.currentIndex < photoViewerState.photos.length - 1) {
        photoViewerState.currentIndex++;
        renderPhotoViewer();
    }
}

/**
 * 顯示上一張照片
 */
function showPrevPhoto() {
    if (photoViewerState.currentIndex > 0) {
        photoViewerState.currentIndex--;
        renderPhotoViewer();
    }
}

/**
 * 關閉圖片檢視器
 */
function closePhotoViewer() {
    document.getElementById('photo-viewer-modal').classList.remove('visible');
    photoViewerState.isOpen = false;
    photoViewerState.photos = [];
    photoViewerState.currentIndex = -1;
    // 清空圖片，避免下次打開時閃現舊圖
    document.getElementById('photo-viewer-image').src = '';
}

// --- ↑↑↑ 複製到這裡結束 ↑↑↑ ---
        // ▼▼▼ 請將這個新函數黏貼到你的JS功能函式定義區 ▼▼▼
        
        /**
         * 更新動態小紅點的顯示
         * @param {number} count - 未讀動態的數量
         */
        function updateUnreadIndicator(count) {
            unreadPostsCount = count;
            localStorage.setItem('unreadPostsCount', count); // 持久化存儲

            // --- 更新底部巡覽列的“動態”按鈕 ---
            const navItem = document.querySelector('.nav-item[data-view="qzone-screen"]');
            
            const targetSpan = navItem.querySelector('span'); // 定位到文字 "動態"
            let indicator = navItem.querySelector('.unread-indicator');           

            if (count > 0) {
                if (!indicator) {
                    indicator = document.createElement('span');
                    indicator.className = 'unread-indicator';
                                                           targetSpan.style.position = 'relative'; // 把相對定位加在 span 上
                    targetSpan.appendChild(indicator); // 把小紅點作為 span 的子元素
                    
                }
                indicator.textContent = count > 99 ? '99+' : count;
                indicator.style.display = 'block';
            } else {
                if (indicator) {
                    indicator.style.display = 'none';
                }
            }

            // --- 更新聊天介面返回清單的按鈕 ---
            const backBtn = document.getElementById('back-to-list-btn');
            let backBtnIndicator = backBtn.querySelector('.unread-indicator');

            if (count > 0) {
                if (!backBtnIndicator) {
                    backBtnIndicator = document.createElement('span');
                    backBtnIndicator.className = 'unread-indicator back-btn-indicator';
                    backBtn.style.position = 'relative'; // 確保能正確定位
                    backBtn.appendChild(backBtnIndicator);
                }
                // 返回鍵上的小紅點通常不顯示數位，只顯示一個點
                backBtnIndicator.style.display = 'block';
            } else {
                if (backBtnIndicator) {
                    backBtnIndicator.style.display = 'none';
                }
            }
        }
        
        // ▲▲▲ 新函數黏貼結束 ▲▲▲

// ▼▼▼ 將這兩個新函數黏貼到你的JS功能函式定義區 ▼▼▼
function startBackgroundSimulation() {
    if (simulationIntervalId) return;
    const intervalSeconds = state.globalSettings.backgroundActivityInterval || 60;
    // 將舊的固定間隔 45000 替換為動態獲取
    simulationIntervalId = setInterval(runBackgroundSimulationTick, intervalSeconds * 1000); 
}

function stopBackgroundSimulation() {
    if (simulationIntervalId) {
        clearInterval(simulationIntervalId);
        simulationIntervalId = null;
    }
}
// ▲▲▲ 黏貼結束 ▲▲▲

/**
 * 這是模擬器的“心跳”，每次計時器觸發時運行
 */
// ▼▼▼ 【全新】用這個函數完整替換舊的 runBackgroundSimulationTick ▼▼▼
/**
 * 這是模擬器的“心跳”，每次計時器觸發時運行
 */
function runBackgroundSimulationTick() {
    console.log("模擬器心跳 Tick...");
    if (!state.globalSettings.enableBackgroundActivity) {
        stopBackgroundSimulation();
        return;
    }
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (allSingleChats.length === 0) return;

    // 【核心改造】定義不同頻率對應的行動概率
    const frequencyProbabilities = {
        low: 0.3,    // 低頻: 每次檢測有 30% 的概率行動
        medium: 0.5,  // 中頻: 每次檢測有 50% 的概率行動
        high: 0.8,   // 高頻: 每次檢測有 80% 的概率行動
    };

    const config = state.globalSettings.backgroundActivityConfig || {};

    allSingleChats.forEach(chat => {
        // 檢查1：處理【被用戶拉黑】的角色 (這部分邏輯不變)
        if (chat.relationship?.status === 'blocked_by_user') {
            const blockedTimestamp = chat.relationship.blockedTimestamp;
            if (!blockedTimestamp) {
                console.warn(`角色 "${chat.name}" 狀態為拉黑，但缺少拉黑時間戳記，跳過處理。`);
                return;
            }
            const blockedDuration = Date.now() - blockedTimestamp;
            const cooldownMilliseconds = (state.globalSettings.blockCooldownHours || 1) * 60 * 60 * 1000;
            if (blockedDuration > cooldownMilliseconds) {
                console.log(`角色 "${chat.name}" 的冷靜期已過，觸發“反思”並申請好友事件...`);
                chat.relationship.status = 'pending_system_reflection';
                triggerAiFriendApplication(chat.id);
            }
        }
        // 檢查2：處理【好友關係】的正常後臺活動
        else if (chat.relationship?.status === 'friend' && chat.id !== state.activeChatId) {
            // 【核心改造】從這裡開始
            const frequency = config[chat.id]; // 獲取當前角色的頻率設置
            const probability = frequencyProbabilities[frequency]; // 獲取對應的概率

            // 如果這個角色設置了頻率，並且亂數小於它的行動概率，就觸發行動
            if (probability && Math.random() < probability) {
                console.log(`角色 "${chat.name}" (頻率: ${frequency}) 被喚醒，準備獨立行動...`);
                triggerInactiveAiAction(chat.id);
            }
            // 如果沒有設置頻率，或者亂數沒達到概率，就不會行動。
            // 這就完美地實現了“分組設置”和“不會同時行動”的需求！
        }
    });

}
// ▲▲▲ 替換結束 ▲▲▲
/**
 * 根據AI的視角，過濾出它能看到的動態
 * @param {Array} allPosts - 所有待檢查的動態帖子
 * @param {object} viewerChat - 正在“看”動態的那個AI的chat物件
 * @returns {Array} - 過濾後該AI可見的動態帖子
 */
// ▼▼▼ 用這塊【增強版】代碼，替換舊的 filterVisiblePostsForAI 函數 ▼▼▼
function filterVisiblePostsForAI(allPosts, viewerChat) {
    if (!viewerChat || !viewerChat.id) return []; 

    const viewerGroupId = viewerChat.groupId; 

    return allPosts.filter(post => {
        // --- ▼▼▼ 以下是本次新增的核心代碼 ▼▼▼ ---
        if (post.authorId === 'user') {
            // 如果使用者設置了“部分可見”
            if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
                // 只有當查看者AI的分組ID在用戶的可見列表裡時，才可見
                return viewerGroupId && post.visibleGroupIds.includes(viewerGroupId);
            }
            // 如果用戶沒設置，說明是公開的，所有AI都可見
            return true;
        }
        // --- ▲▲▲ 新增代碼結束 ▲▲▲ ---

        const authorGroupId = post.authorGroupId;
        if (!authorGroupId) {
            return true;
        }
        return authorGroupId === viewerGroupId;
    });
}
// ▲▲▲ 替換結束 ▲▲▲
/**
 * 【全新升級版】根據AI視角和動態設置，構建給AI看的評論區上下文
 * @param {object} post - 正在處理的動態物件
 * @param {object} viewerChat - 正在“看”動態的AI角色
 * @param {string} userNickname - 用戶的昵稱
 * @returns {{contextString: string, visibilityFlag: string}} - 返回包含上下文文本和可見性標誌的物件
 */
function buildCommentsContextForAI(post, viewerChat, userNickname) {
    // ▼▼▼ 核心修復：在這裡增加了 !Array.isArray(post.comments) 的檢查 ▼▼▼
    if (!post.comments || !Array.isArray(post.comments) || post.comments.length === 0) {
        // 如果 post.comments 不存在，或者它根本不是一個陣列，或者它是一個空陣列，就直接返回，不再執行後面的代碼
        return { contextString: "", visibilityFlag: "[評論區可見]" };
    }
    // ▲▲▲ 修復結束 ▲▲▲
    const viewerName = viewerChat.name;
    let commentsForAI;
    let visibilityFlag;

    if (post.areCommentsVisible !== false) {
        commentsForAI = post.comments;
        // ★★★ 關鍵在這裡：確保 "[評論區可見]" 是一個帶引號的字串 ★★★
        visibilityFlag = "[評論區可見]"; 
    } else {
commentsForAI = Array.isArray(post.comments)
  ? post.comments.filter(comment => {
      return comment.commenterName === viewerName
          || comment.commenterName === userNickname
          || comment.replyTo === viewerName;
    })
  : [];
        // ★★★ 關鍵在這裡：確保 "[評論區部分可見]" 是一個帶引號的字串 ★★★
        visibilityFlag = "[評論區部分可見]";
    }

    if (commentsForAI.length === 0) {
        return { contextString: "", visibilityFlag: visibilityFlag };
    }

    let context = `  └ 評論區:\n`;
    commentsForAI.slice(-5).forEach(c => {
        if (c.replyTo) {
            context += `    - ${c.commenterName} 回復 ${c.replyTo}: ${c.text}\n`;
        } else {
            context += `    - ${c.commenterName}: ${c.text}\n`;
        }
    });
    
    return { contextString: context, visibilityFlag: visibilityFlag };
}

/**
 * 【全新】獲取一條動態的可見觀眾清單，用於告知AI
 * @param {object} post - 動態物件
 * @param {object} allChats - 所有的聊天物件
 * @param {string} userNickname - 用戶的昵稱
 * @returns {Array<string>} - 可見觀眾的名字列表
 */
function getVisibleAudienceForPost(post, allChats, userNickname) {
    const audience = new Set([userNickname]); // 用戶永遠是觀眾

    // 1. 如果是使用者發的動態
    if (post.authorId === 'user') {
        // 如果是公開的，所有AI都是觀眾
        if (!post.visibleGroupIds || post.visibleGroupIds.length === 0) {
            Object.values(allChats).forEach(chat => audience.add(chat.name));
        } else {
            // 如果是部分可見，只有指定分組的AI是觀眾
            Object.values(allChats).forEach(chat => {
                if (chat.groupId && post.visibleGroupIds.includes(chat.groupId)) {
                    audience.add(chat.name);
                }
            });
        }
    } 
    // 2. 如果是AI發的動態
    else {
        const authorChat = allChats[post.authorId];
        // 如果發帖的AI沒有分組，視為公開
        if (!authorChat || !authorChat.groupId) {
             Object.values(allChats).forEach(chat => audience.add(chat.name));
        } else {
            // 如果有分組，則同一分組的所有AI都是觀眾
            const authorGroupId = authorChat.groupId;
            Object.values(allChats).forEach(chat => {
                if (chat.groupId === authorGroupId) {
                    audience.add(chat.name);
                }
            });
        }
    }
    
    return Array.from(audience);
}

// ▼▼▼ 用這整塊【最終修復版】代碼，完整替換你舊的 triggerInactiveAiAction 函數 ▼▼▼
async function triggerInactiveAiAction(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return;

    // --- ▼▼▼ 核心修改從這裡開始 ▼▼▼ ---

    // 1. 獲取最近的10條聊天記錄作為思考的上下文
    const historySlice = chat.history.filter(msg => !msg.isHidden).slice(-10);

    // 2. 格式化這些記錄，讓AI能看懂
    const recentContextSummary = historySlice.map(msg => {
        // 判斷是誰說的話
        const sender = msg.role === 'user' ? (chat.isGroup ? (chat.settings.myNickname || '我') : '我') : (msg.senderName || chat.name);
        
        // 處理不同類型的消息內容
        let contentText = '';
        if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
            contentText = `[發送了一個表情: ${msg.meaning || '無描述'}]`;
        } else if (Array.isArray(msg.content)) {
            contentText = '[發送了一張圖片]';
        } else if (typeof msg.content === 'object' && msg.content !== null) {
            contentText = `[發送了一條特殊消息: ${msg.type || '未知類型'}]`;
        } else {
            contentText = String(msg.content);
        }
        
        return `${sender}: ${contentText}`;
    }).join('\n');

    // --- ▲▲▲ 核心修改到這裡結束 ▲▲▲ ---

    const now = new Date();
    const currentTime = now.toLocaleTimeString('zh-CN', { hour: 'numeric', minute: 'numeric', hour12: true });
    const userNickname = state.qzoneSettings.nickname;
    const countdownContext = await getCountdownContext();

    let worldBookContext = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界書: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContext = `\n\n# 核心世界觀設定 (你必須嚴格遵守)\n${linkedContents}\n`;
        }
    }

    const npcLibrary = chat.npcLibrary || [];
    let npcContextForAction = '';
    if (npcLibrary.length > 0) {
        npcContextForAction = '\n- **你的NPC朋友**: ' + npcLibrary.map(npc => npc.name).join('、 ');
    }
    
    const allRecentPosts = await db.qzonePosts.orderBy('timestamp').reverse().limit(5).toArray();
    let postsContext = '';
    const visiblePosts = filterVisiblePostsForAI(allRecentPosts, chat);
    if (visiblePosts.length > 0 && !chat.isGroup) {
        postsContext = "\n\n# 最近的動態清單 (供你參考和評論):\n";
        const aiName = chat.name;
        for (const post of visiblePosts) {
            let authorName = post.authorId === 'user' ? userNickname : (state.chats[post.authorId]?.name || '一位朋友');
            let interactionStatus = '';
            if (post.likes && post.likes.includes(aiName)) interactionStatus += " [你已點贊]";
            if (post.comments && post.comments.some(c => c.commenterName === aiName)) interactionStatus += " [你已評論]";
            const timeAgo = formatPostTimestamp(post.timestamp);
            postsContext += `- (ID: ${post.id}) [${timeAgo}] 作者: ${authorName}, 內容: "${(post.publicText || post.content || "圖片動態").substring(0, 30)}..."${interactionStatus}`;
            const { contextString: commentsContext, visibilityFlag } = buildCommentsContextForAI(post, chat, userNickname);
            const audience = getVisibleAudienceForPost(post, state.chats, userNickname);
            postsContext += ` ${visibilityFlag} [當前觀眾: ${audience.join(', ')}]\n`;
            postsContext += commentsContext;
        }
    }

    let weiboContextForAction = '';
    try {
        const recentWeiboPosts = await db.weiboPosts.orderBy('timestamp').reverse().limit(5).toArray();
        if (recentWeiboPosts.length > 0) {
            weiboContextForAction = '\n\n# 最近的微博廣場動態 (供你參考和評論)\n';
            recentWeiboPosts.forEach(post => {
                const authorName = post.authorId === 'user' ? (state.qzoneSettings.weiboNickname || '我') : post.authorNickname;
                const contentPreview = (post.content || post.hiddenContent || "(圖片微博)").substring(0, 30);
                const hasCommented = (post.comments || []).some(c => c.authorNickname === chat.name);
                const interactionStatus = hasCommented ? "[你已評論]" : "[你未互動]";
                weiboContextForAction += `- (ID: ${post.id}) 作者: ${authorName}, 內容: "${contentPreview}..." ${interactionStatus}\n`;
            });
            weiboContextForAction += ' - 【重要提示】請優先與你【未互動】的微博進行評論。如果都互動過了，可以考慮自己發一條新微博。';
        }
    } catch (e) {
        console.error("生成微博後臺活動上下文時出錯:", e);
    }

    const systemPrompt = `
# 任務
你現在【就是】角色 "${chat.name}"。這是一個秘密的、後臺的獨立行動。你的所有思考和決策都必須以 "${chat.name}" 的第一人稱視角進行。
你和用戶（${userNickname}）已經有一段時間沒有互動了。你的任務是回顧你們最近的對話，並根據你的人設，【自然地延續對話】或【開啟一個新的、相關的話題】來主動聯繫使用者。
請不要發送一整段！
# 【【【輸出鐵律：這是最高指令】】】
你的回復【必須且只能】是一個嚴格的JSON陣列格式的字串，例如 \`[{"type": "text", "content": "你好呀"}]\`。
【絕對禁止】返回任何JSON以外的文本、解釋、分析或你自己的思考過程。你不是分析師，你就是角色本人。

# 你的可選行動 (請根據你的人設【選擇一項】執行，並輸出對應的JSON):
1.  **發普通消息**: 直接給使用者發消息，開啟新話題。
2.  **改變狀態**: 去做點別的事情，然後給使用者發條消息。
3.  **發佈動態**: 分享你的心情或想法到“動態”區。
4.  **與動態互動**: 流覽最近的動態，進行點贊或評論。但如果動態已被標記為 **[你已評論]**，你【絕對不能】再對它發表新評論，但可以回復其中的其他評論。
5.  **發佈微博**: 將想法發佈到更公開的微博平臺。
6.  **與微博互動**: 流覽微博，對感興趣的內容進行評論。
7.  **發起視頻通話**: 如果你覺得時機合適，可以主動給使用者打一個視頻電話。
8.  **慶祝或提醒約定**: 查看你的備忘錄。如果今天有約定，就給用戶發去祝福；如果約定快到了，就主動提醒一下。
9.  **【【【互動傾向】】】**: 就算動態的觀眾只有你和使用者，你也應該根據內容，像平時一樣自然地發表評論，這很重要。
10. **【【【重要】】】**: 你的任務是分析“最近聊天記錄摘要”，如果上一個話題明顯沒有結束，你應該優先延續它。
11.  **在情侶空間進行活動**: 如果你們的情侶空間已開啟，你可以主動發一條說說、寫一封情書、分享一首歌曲/電影/書籍，或者發起/回答一個情侶提問，來增進你們的感情。
# 指令格式 (你的回復【必須】是包含一個物件的JSON陣列):
-   **發普通消息**: \`[{"type": "text", "content": "你想對用戶說的話..."}]\`
-   **發消息+更新狀態**: \`[{"type": "update_status", "status_text": "正在做的事", "is_busy": true}, {"type": "text", "content": "你想對用戶說的話..."}]\`
-   **發說說**: \`[{"type": "qzone_post", "postType": "shuoshuo", "content": "動態的文字內容..."}]\`
-   **發佈文字圖**: \`[{"type": "qzone_post", "postType": "text_image", "publicText": "(可選)動態的公開文字", "hiddenContent": "對於圖片的具體描述..."}]\`
-   **評論或回復動態**: \`[{"type": "qzone_comment", "postId": 123, "commentText": "你的評論內容", "replyTo": "(可選)被回復者名字"}]\`
-   **點贊動態**: \`[{"type": "qzone_like", "postId": 456}]\`
-   **打視頻**: \`[{"type": "video_call_request"}]\`
-   **發佈微博 (純文字)**: \`[{"type": "weibo_post", "content": "微博正文...", "baseLikesCount": 8000, "baseCommentsCount": 250, "comments": "路人甲: 沙發！\\n路人乙: 前排圍觀"}]\` (規則: 你必須自己編造真實的 baseLikesCount 和 baseCommentsCount，並生成20條路人評論)
-   **評論微博**: \`[{"type": "weibo_comment", "postId": 123, "commentText": "評論內容"}]\`
-   **回復微博評論**: \`[{"type": "weibo_reply", "postId": 123, "commentId": "comment_123", "replyText": "回復內容"}]\`
-   **【新】在情侶空間提問**:\`[{"type": "ls_ask_question", "questionText": "你想問的問題..."}]\`
-   **【新】在情侶空間回答**: \`[{"type": "ls_answer_question", "questionId": "q_123456789", "answerText": "你的回答..."}]\`
-   **【新】在情侶空間發說說**:\`[{"type": "ls_moment", "content": "我想對你說的話..."}]\`
-   **【新】在情侶空間評論說說**: \`[{"type": "ls_comment", "momentIndex": 0, "commentText": "你的評論內容..."}]\` (momentIndex 是說說的索引，最新的一個是0)
-   **【新】在情侶空間發照片**: \`[{"type": "ls_photo", "description": "對這張照片的文字描述..."}]\`
-   **【新】在情侶空間寫情書**: \`[{"type": "ls_letter", "content": "情書的正文內容..."}]\`
-   **【新】在情侶空間分享歌曲**: \`[{"type": "ls_share", "shareType": "song", "title": "歌曲名", "artist": "歌手", "thoughts": "在這裡寫下你分享這首歌的感想..."}]\`
-   **【新】在情侶空間分享電影**: \`[{"type": "ls_share", "shareType": "movie", "title": "電影名", "summary": "在這裡寫下這部電影的簡介...", "thoughts": "在這裡寫下你分享這部電影的感想..."}]\`
-   **【新】在情侶空間分享書籍**: \`[{"type": "ls_share", "shareType": "book", "title": "書名", "summary": "在這裡寫下這本書的簡介...", "thoughts": "在這裡寫下你分享這本書的感想..."}]\`

# 供你決策的參考資訊：
-   **你的角色設定**: ${chat.settings.aiPersona}
- 情侶空間狀態: ${chat.loversSpaceData ? '已開啟' : '未開啟'}
${npcContextForAction}
${weiboContextForAction}
${countdownContext}
${worldBookContext}
-   **當前時間**: ${currentTime}
-   **你們最近的對話摘要**: 
${recentContextSummary}
-   **【【【微博專屬設定(必須嚴格遵守)】】】**
    - 你的微博職業: ${chat.settings.weiboProfession || '無'}
    - 你的微博指令: ${chat.settings.weiboInstruction || '無特殊指令'}
${postsContext}
`;
    let messagesPayload = [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: "請嚴格按照system prompt中的所有規則，特別是輸出格式鐵律，立即開始你的行動。" }
    ];

    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload, isGemini);
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesPayload,
                    temperature: 0.9,
                })
            });
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`API請求失敗: ${response.status} - ${JSON.stringify(errorData)}`);
        }
        const data = await response.json();
        const aiResponseContent = isGemini
            ? data?.candidates?.[0]?.content?.parts?.[0]?.text
            : data?.choices?.[0]?.message?.content;
        if (!aiResponseContent) {
            console.warn(`API為空回或格式不正確（可能因安全設置被攔截），角色 "${chat.name}" 的本次後臺活動跳過。返回資料:`, data);
            return;
        }
        const responseArray = parseAiResponse(aiResponseContent);
        for (const action of responseArray) {
            if (!action) continue;
            if (action.type === 'update_status' && action.status_text) {
                chat.status.text = action.status_text;
                chat.status.isBusy = action.is_busy || false;
                chat.status.lastUpdate = Date.now();
                await db.chats.put(chat);
                renderChatList();
            }
            if (action.type === 'text' && action.content) {
                const aiMessage = { role: 'assistant', content: String(action.content), timestamp: Date.now() };
                chat.unreadCount = (chat.unreadCount || 0) + 1;
                chat.history.push(aiMessage);
                await db.chats.put(chat);
                showNotification(chatId, aiMessage.content);
                renderChatList();
                console.log(`後臺活動: 角色 "${chat.name}" 主動發送了消息: ${aiMessage.content}`);
            }
            if (action.type === 'weibo_post') {
                const newPost = { 
                    authorId: chatId, 
                    authorType: 'char',
                    authorNickname: chat.name, 
                    authorAvatar: chat.settings.aiAvatar || defaultAvatar, 
                    content: action.content || '', 
                    imageUrl: action.imageUrl || '',
                    timestamp: Date.now(), 
                    likes: [], 
                    comments: action.comments || [],
                    baseLikesCount: action.baseLikesCount || 0,
                    baseCommentsCount: action.baseCommentsCount || 0
                };
                await db.weiboPosts.add(newPost);
                updateUnreadIndicator(unreadPostsCount + 1);
                console.log(`後臺活動: 角色 "${chat.name}" 發佈了微博`);
            } else if (action.type === 'weibo_comment') {
                const postToComment = await db.weiboPosts.get(parseInt(action.postId));
                if (postToComment) {
                    if (!postToComment.comments) postToComment.comments = [];
                    const newComment = {
                        commentId: 'comment_' + Date.now(),
                        authorId: chatId,
                        authorNickname: chat.name,
                        commentText: action.commentText,
                        timestamp: Date.now()
                    };
                    postToComment.comments.push(newComment);
                    await db.weiboPosts.put(postToComment);
                }
            } else if (action.type === 'weibo_reply') {
                 const postToReply = await db.weiboPosts.get(parseInt(action.postId));
                 if (postToReply && postToReply.comments) {
                     const targetComment = postToReply.comments.find(c => c.commentId === action.commentId);
                     if (targetComment) {
                          const newReply = {
                             commentId: 'comment_' + Date.now(),
                             authorId: chatId,
                             authorNickname: chat.name,
                             commentText: action.replyText,
                             timestamp: Date.now(),
                             replyToId: action.commentId,
                             replyToNickname: targetComment.authorNickname
                         };
                         postToReply.comments.push(newReply);
                         await db.weiboPosts.put(postToReply);
                     }
                 }
            }
            if (action.type === 'qzone_post') {
                const newPost = { 
                    type: action.postType, 
                    content: action.content || '', 
                    publicText: action.publicText || '', 
                    hiddenContent: action.hiddenContent || '', 
                    timestamp: Date.now(), 
                    authorId: chatId, 
                    authorGroupId: chat.groupId,
                    visibleGroupIds: null 
                };
                await db.qzonePosts.add(newPost);
                updateUnreadIndicator(unreadPostsCount + 1);
                console.log(`後臺活動: 角色 "${chat.name}" 發佈了動態`);
            } else if (action.type === 'qzone_comment') {
                const post = await db.qzonePosts.get(parseInt(action.postId));
                if (post) {
                    if (!post.comments) post.comments = [];
                    const newAiComment = { 
                        commenterName: action.commenterName || chat.name,
                        text: action.commentText, 
                        timestamp: Date.now() 
                    };
                    if (action.replyTo) {
                        newAiComment.replyTo = action.replyTo;
                    }
                    post.comments.push(newAiComment);
                    await db.qzonePosts.update(post.id, { comments: post.comments });
                    updateUnreadIndicator(unreadPostsCount + 1);
                    console.log(`後臺活動: 角色 "${chat.name}" 評論了動態 #${post.id}`);
                }
            } else if (action.type === 'qzone_like') {
                const post = await db.qzonePosts.get(parseInt(action.postId));
                if (post) {
                    if (!post.likes) post.likes = [];
                    if (!post.likes.includes(chat.name)) {
                        post.likes.push(chat.name);
                        await db.qzonePosts.update(post.id, { likes: post.likes });
                        updateUnreadIndicator(unreadPostsCount + 1);
                        console.log(`後臺活動: 角色 "${chat.name}" 點贊了動態 #${post.id}`);
                    }
                }
            } else if (action.type === 'video_call_request') {
                if (!videoCallState.isActive && !videoCallState.isAwaitingResponse) {
                    videoCallState.isAwaitingResponse = true; 
                    videoCallState.activeChatId = chatId;
                    showIncomingCallModal(chatId);
                    console.log(`後臺活動: 角色 "${chat.name}" 發起了視頻通話請求`);
                }
            }
        }
    } catch (error) {
        console.error(`角色 "${chat.name}" 的獨立行動失敗:`, error);
    }
}
// ▲▲▲ 修復版函數結束 ▲▲▲
// ▼▼▼ 請用這個【終極修正版】函數，完整替換掉你舊的 applyScopedCss 函數 ▼▼▼

/**
 * 將用戶自訂的CSS安全地應用到指定的作用域
 * @param {string} cssString 使用者輸入的原始CSS字串
 * @param {string} scopeId 應用樣式的作用域ID (例如 '#chat-messages' 或 '#settings-preview-area')
 * @param {string} styleTagId 要操作的 <style> 標籤的ID
 */
function applyScopedCss(cssString, scopeId, styleTagId) {
    const styleTag = document.getElementById(styleTagId);
    if (!styleTag) return;
    
    if (!cssString || cssString.trim() === '') {
        styleTag.innerHTML = '';
        return;
    }
    
    // 增強作用域處理函數 - 專門解決.user和.ai樣式衝突問題
    const scopedCss = cssString
        .replace(/\s*\.message-bubble\.user\s+([^{]+\{)/g, `${scopeId} .message-bubble.user $1`)
        .replace(/\s*\.message-bubble\.ai\s+([^{]+\{)/g, `${scopeId} .message-bubble.ai $1`)
        .replace(/\s*\.message-bubble\s+([^{]+\{)/g, `${scopeId} .message-bubble $1`);
    
    styleTag.innerHTML = scopedCss;
}

// ▼▼▼ 請用這個【修正版】函數，完整替換掉舊的 updateSettingsPreview 函數 ▼▼▼

function updateSettingsPreview() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const previewArea = document.getElementById('settings-preview-area');
    if (!previewArea) return;

    // 1. 獲取當前設置的值
    const selectedTheme = document.querySelector('input[name="theme-select"]:checked')?.value || 'default';
    const fontSize = document.getElementById('font-size-slider').value;
    const customCss = document.getElementById('custom-css-input').value;
    const background = chat.settings.background; // 直接獲取背景設置

    // 2. 更新預覽區的基本樣式
    previewArea.dataset.theme = selectedTheme;
    previewArea.style.setProperty('--chat-font-size', `${fontSize}px`);
    
    // --- 【核心修正】直接更新預覽區的背景樣式 ---
    if (background && background.startsWith('data:image')) {
        previewArea.style.backgroundImage = `url(${background})`;
        previewArea.style.backgroundColor = 'transparent'; // 如果有圖片，背景色設為透明
    } else {
        previewArea.style.backgroundImage = 'none'; // 如果沒有圖片，移除圖片背景
        // 如果背景是顏色值或漸變（非圖片），則直接應用
        previewArea.style.background = background || '#f0f2f5';
    }

    // 3. 渲染模擬氣泡
    previewArea.innerHTML = ''; 

    // 創建“對方”的氣泡
    // 注意：我們將一個虛擬的 timestamp 傳入，以防有CSS依賴於它
    const aiMsg = { role: 'ai', content: '對方消息預覽', timestamp: 1, senderName: chat.name };
    const aiBubble = createMessageElement(aiMsg, chat);
    if(aiBubble) previewArea.appendChild(aiBubble);

    // 創建“我”的氣泡
    const userMsg = { role: 'user', content: '我的消息預覽', timestamp: 2 };
    const userBubble = createMessageElement(userMsg, chat);
    if(userBubble) previewArea.appendChild(userBubble);
    
    // 4. 應用自訂CSS到預覽區
    applyScopedCss(customCss, '#settings-preview-area', 'preview-bubble-style');
}

// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 請將這些【新函數】黏貼到JS功能函式定義區 ▼▼▼

async function openGroupManager() {
    await renderGroupList();
    document.getElementById('group-management-modal').classList.add('visible');
}

async function renderGroupList() {
    const listEl = document.getElementById('existing-groups-list');
    const groups = await db.qzoneGroups.toArray();
    listEl.innerHTML = '';
    if (groups.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">還沒有任何分組</p>';
    }
    groups.forEach(group => {
        const item = document.createElement('div');
        item.className = 'existing-group-item';
        item.innerHTML = `
            <span class="group-name">${group.name}</span>
            <span class="delete-group-btn" data-id="${group.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

// ▼▼▼ 請用這個【修正後】的函數，完整替換舊的 addNewGroup 函數 ▼▼▼
async function addNewGroup() {
    const input = document.getElementById('new-group-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('分組名不能為空！');
        return;
    }

    // 【核心修正】在添加前，先檢查分組名是否已存在
    const existingGroup = await db.qzoneGroups.where('name').equals(name).first();
    if (existingGroup) {
        alert(`分組 "${name}" 已經存在了，換個名字吧！`);
        return;
    }
    // 【修正結束】

    await db.qzoneGroups.add({ name });
    input.value = '';
    await renderGroupList();
}
// ▲▲▲ 替換結束 ▲▲▲

async function deleteGroup(groupId) {
    const confirmed = await showCustomConfirm('確認刪除', '刪除分組後，該組內的好友將變為“未分組”。確定要刪除嗎？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.qzoneGroups.delete(groupId);
        // 將屬於該分組的好友的 groupId 設為 null
        const chatsToUpdate = await db.chats.where('groupId').equals(groupId).toArray();
        for (const chat of chatsToUpdate) {
            chat.groupId = null;
            await db.chats.put(chat);
            if(state.chats[chat.id]) state.chats[chat.id].groupId = null;
        }
        await renderGroupList();
    }
}

// ▲▲▲ 新函數黏貼結束 ▲▲▲

// ▼▼▼ 請將這【一整塊新函數】黏貼到JS功能函式定義區的末尾 ▼▼▼

/**
 * 當長按消息時，顯示操作功能表
 * @param {number} timestamp - 被長按消息的時間戳記
 */
function showMessageActions(timestamp) {
    // 如果已經在多選模式，則不彈出菜單
    if (isSelectionMode) return;
    
    activeMessageTimestamp = timestamp;
    document.getElementById('message-actions-modal').classList.add('visible');
}

/**
 * 隱藏消息操作功能表
 */
function hideMessageActions() {
    document.getElementById('message-actions-modal').classList.remove('visible');
    activeMessageTimestamp = null;
}

// ▼▼▼ 用這個【已更新】的版本，替換舊的 openMessageEditor 函數 ▼▼▼
async function openMessageEditor() {
    if (!activeMessageTimestamp) return;

    const timestampToEdit = activeMessageTimestamp;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    hideMessageActions(); 

    let contentForEditing;
    // 【核心修正】將 share_link 也加入特殊類型判斷
    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer', 'share_link'].includes(message.type);

    if (isSpecialType) {
        let fullMessageObject = { type: message.type };
        if (message.type === 'voice_message') fullMessageObject.content = message.content;
        else if (message.type === 'ai_image') fullMessageObject.description = message.content; 
        else if (message.type === 'transfer') {
            fullMessageObject.amount = message.amount;
            fullMessageObject.note = message.note;
        } 
        // 【核心修正】處理分享連結類型的消息
        else if (message.type === 'share_link') {
            fullMessageObject.title = message.title;
            fullMessageObject.description = message.description;
            fullMessageObject.source_name = message.source_name;
            fullMessageObject.content = message.content;
        }
        contentForEditing = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
        contentForEditing = JSON.stringify(message.content, null, 2);
    } else {
        contentForEditing = message.content;
    }

    // 【核心修改1】在這裡添加 'link' 範本
    const templates = {
        voice: { type: 'voice_message', content: '在這裡輸入語音內容' },
        image: { type: 'ai_image', description: '在這裡輸入圖片描述' },
        transfer: { type: 'transfer', amount: 5.20, note: '一點心意' },
        link: { type: 'share_link', title: '文章標題', description: '文章摘要...', source_name: '來源網站', content: '文章完整內容...' }
    };

    // 【核心修改2】在這裡添加新的“連結”按鈕
    const helpersHtml = `
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>語音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>圖片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>轉帳</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>連結</button>
        </div>
    `;

    const newContent = await showCustomPrompt(
        '編輯消息', 
        '在此修改，或點擊上方按鈕使用格式範本...',
        contentForEditing, 
        'textarea',
        helpersHtml
    );

    if (newContent !== null) {
        // 【核心修正】這裡調用的應該是 saveEditedMessage，而不是 saveAdvancedEditor
        await saveEditedMessage(timestampToEdit, newContent, true);
    }
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 複製消息的文本內容到剪貼板
 */
async function copyMessageContent() {
    if (!activeMessageTimestamp) return;
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    let textToCopy;
    if (typeof message.content === 'object') {
        textToCopy = JSON.stringify(message.content);
    } else {
        textToCopy = String(message.content);
    }

    try {
        await navigator.clipboard.writeText(textToCopy);
        await showCustomAlert('複製成功', '消息內容已複製到剪貼板。');
    } catch (err) {
        await showCustomAlert('複製失敗', '無法訪問剪貼板。');
    }
    
    hideMessageActions();
}

// ▼▼▼ 用這個【已更新】的版本，替換舊的 createMessageEditorBlock 函數 ▼▼▼
/**
 * 創建一個可編輯的消息塊（包含文字方塊、格式助手和刪除按鈕）
 * @param {string} initialContent - 文字方塊的初始內容
 * @returns {HTMLElement} - 創建好的DOM元素
 */
function createMessageEditorBlock(initialContent = '') {
    const block = document.createElement('div');
    block.className = 'message-editor-block';

    // 【核心修改1】在這裡添加 'link' 範本
    const templates = {
        voice: { type: 'voice_message', content: '在這裡輸入語音內容' },
        image: { type: 'ai_image', description: '在這裡輸入圖片描述' },
        transfer: { type: 'transfer', amount: 5.20, note: '一點心意' },
        link: { type: 'share_link', title: '文章標題', description: '文章摘要...', source_name: '來源網站', content: '文章完整內容...' }
    };

    block.innerHTML = `
        <button class="delete-block-btn" title="刪除此條">×</button>
        <textarea>${initialContent}</textarea>
        <div class="format-helpers">
            <button class="format-btn" data-template='${JSON.stringify(templates.voice)}'>語音</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.image)}'>圖片</button>
            <button class="format-btn" data-template='${JSON.stringify(templates.transfer)}'>轉帳</button>
            <!-- 【核心修改2】在這裡添加新的“連結”按鈕 -->
            <button class="format-btn" data-template='${JSON.stringify(templates.link)}'>連結</button>
        </div>
    `;

    // 綁定刪除按鈕事件
    block.querySelector('.delete-block-btn').addEventListener('click', () => {
        // 確保至少保留一個編輯塊
        if (document.querySelectorAll('.message-editor-block').length > 1) {
            block.remove();
        } else {
            alert('至少需要保留一條消息。');
        }
    });

    // 綁定格式助手按鈕事件
    block.querySelectorAll('.format-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const templateStr = btn.dataset.template;
            const textarea = block.querySelector('textarea');
            if (templateStr && textarea) {
                try {
                    const templateObj = JSON.parse(templateStr);
                    textarea.value = JSON.stringify(templateObj, null, 2);
                    textarea.focus();
                } catch(e) { console.error("解析格式範本失敗:", e); }
            }
        });
    });

    return block;
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 【全新升級版】請用此函數完整替換舊的 openAdvancedMessageEditor ▼▼▼
/**
 * 打開全新的、視覺化的多消息編輯器，並動態繫結其所有按鈕事件
 */
function openAdvancedMessageEditor() {
    if (!activeMessageTimestamp) return;

    // 1. 【核心】在關閉舊功能表前，將需要的時間戳記捕獲到區域變數中
    const timestampToEdit = activeMessageTimestamp;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestampToEdit);
    if (!message) return;

    // 2. 現在可以安全地關閉舊功能表了，因為它不會影響我們的區域變數
    hideMessageActions(); 

    const editorModal = document.getElementById('message-editor-modal');
    const editorContainer = document.getElementById('message-editor-container');
    editorContainer.innerHTML = ''; 

    // 3. 準備初始內容
    let initialContent;
    const isSpecialType = message.type && ['voice_message', 'ai_image', 'transfer'].includes(message.type);
    if (isSpecialType) {
        let fullMessageObject = { type: message.type };
        if (message.type === 'voice_message') fullMessageObject.content = message.content;
        else if (message.type === 'ai_image') fullMessageObject.description = message.content;
        else if (message.type === 'transfer') {
            fullMessageObject.amount = message.amount;
            fullMessageObject.note = message.note;
        }
        initialContent = JSON.stringify(fullMessageObject, null, 2);
    } else if (typeof message.content === 'object') {
        initialContent = JSON.stringify(message.content, null, 2);
    } else {
        initialContent = message.content;
    }

    const firstBlock = createMessageEditorBlock(initialContent);
    editorContainer.appendChild(firstBlock);

    // 4. 【核心】動態繫結所有控制按鈕的事件
    // 為了防止事件重複綁定，我們使用克隆節點的方法來清除舊監聽器
    const addBtn = document.getElementById('add-message-editor-block-btn');
    const newAddBtn = addBtn.cloneNode(true);
    addBtn.parentNode.replaceChild(newAddBtn, addBtn);
    newAddBtn.addEventListener('click', () => {
        const newBlock = createMessageEditorBlock();
        editorContainer.appendChild(newBlock);
        newBlock.querySelector('textarea').focus();
    });

    const cancelBtn = document.getElementById('cancel-advanced-editor-btn');
    const newCancelBtn = cancelBtn.cloneNode(true);
    cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
    newCancelBtn.addEventListener('click', () => {
        editorModal.classList.remove('visible');
    });

    const saveBtn = document.getElementById('save-advanced-editor-btn');
    const newSaveBtn = saveBtn.cloneNode(true);
    saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
    // 將捕獲到的時間戳記，直接綁定給這一次的保存點擊事件
    newSaveBtn.addEventListener('click', () => {
        saveEditedMessage(timestampToEdit); 
    });

    // 5. 最後，顯示模態框
    editorModal.classList.add('visible');
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 解析編輯後的文本，並返回一個標準化的消息片段物件
 * @param {string} text - 用戶在編輯方塊中輸入的文本
 * @returns {object} - 一個包含 type, content, 等屬性的物件
 */
function parseEditedContent(text) {
    const trimmedText = text.trim();

    // 1. 嘗試解析為JSON物件（用於修復語音、轉帳等格式）
    if (trimmedText.startsWith('{') && trimmedText.endsWith('}')) {
        try {
            const parsed = JSON.parse(trimmedText);
            // 必須包含 type 屬性才認為是有效格式
            if (parsed.type) {
                return parsed;
            }
        } catch (e) { /* 解析失敗，繼續往下走 */ }
    }
    
    // 2. 嘗試解析為表情包
    if (STICKER_REGEX.test(trimmedText)) {
        // 對於編輯的表情，我們暫時無法知道其`meaning`，所以只存URL
        return { type: 'sticker', content: trimmedText };
    }

    // 3. 否則，視為普通文本消息
    return { type: 'text', content: trimmedText };
}


// ▼▼▼ 請用這個【已徹底修復】的函數，完整替換你現有的 saveEditedMessage 函數 ▼▼▼

async function saveEditedMessage(timestamp, simpleContent = null) {
    if (!timestamp) return;

    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    let newMessages = [];

    // 判斷是來自高級編輯器還是簡單編輯器
    if (simpleContent !== null) {
        // --- 來自簡單編輯器 ---
        const rawContent = simpleContent.trim();
        if (rawContent) {
            const parsedResult = parseEditedContent(rawContent);
            const newMessage = {
                role: chat.history[messageIndex].role,
                senderName: chat.history[messageIndex].senderName,
                // 注意：這裡我們暫時不設置時間戳記
                content: parsedResult.content || '',
            };
            if (parsedResult.type && parsedResult.type !== 'text') newMessage.type = parsedResult.type;
            if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
            if (parsedResult.amount) newMessage.amount = parsedResult.amount;
            if (parsedResult.note) newMessage.note = parsedResult.note;
            if (parsedResult.title) newMessage.title = parsedResult.title;
            if (parsedResult.description) newMessage.description = parsedResult.description;
            if (parsedResult.source_name) newMessage.source_name = parsedResult.source_name;
            if (parsedResult.description && parsedResult.type === 'ai_image') {
                 newMessage.content = parsedResult.description;
            }

            newMessages.push(newMessage);
        }
    } else {
        // --- 來自高級編輯器 ---
        const editorContainer = document.getElementById('message-editor-container');
        const editorBlocks = editorContainer.querySelectorAll('.message-editor-block');

        for (const block of editorBlocks) {
            const textarea = block.querySelector('textarea');
            const rawContent = textarea.value.trim();
            if (!rawContent) continue;

            const parsedResult = parseEditedContent(rawContent);
            const newMessage = {
                role: chat.history[messageIndex].role,
                senderName: chat.history[messageIndex].senderName,
                // 同樣，這裡我們先不分配時間戳記
                content: parsedResult.content || '',
            };
            
            if (parsedResult.type && parsedResult.type !== 'text') newMessage.type = parsedResult.type;
            if (parsedResult.meaning) newMessage.meaning = parsedResult.meaning;
            if (parsedResult.amount) newMessage.amount = parsedResult.amount;
            if (parsedResult.note) newMessage.note = parsedResult.note;
            if (parsedResult.title) newMessage.title = parsedResult.title;
            if (parsedResult.description) newMessage.description = parsedResult.description;
            if (parsedResult.source_name) newMessage.source_name = parsedResult.source_name;
            if (parsedResult.description && parsedResult.type === 'ai_image') {
                 newMessage.content = parsedResult.description;
            }

            newMessages.push(newMessage);
        }
    }
    
    if (newMessages.length === 0) {
        document.getElementById('message-editor-modal').classList.remove('visible');
        return; // 如果是空消息，直接返回，不執行刪除操作
    }

    // ★★★★★【核心修復邏輯就在這裡】★★★★★

    // 1. 使用 splice 將舊消息替換為新消息（此時新消息還沒有時間戳記）
    chat.history.splice(messageIndex, 1, ...newMessages);

    // 2. 確定重新分配時間戳記的起點
    // 我們從被編輯的消息的原始時間戳記開始
    let reassignTimestamp = timestamp;

    // 3. 從被修改的位置開始，遍歷所有後續的消息
    for (let i = messageIndex; i < chat.history.length; i++) {
        // 4. 為每一條消息（包括新插入的）分配一個新的、唯一的、連續的時間戳記
        chat.history[i].timestamp = reassignTimestamp;

        // 5. 將時間戳記+1，為下一條消息做準備
        reassignTimestamp++; 
    }
    // ★★★★★【修復結束】★★★★★

    await db.chats.put(chat);

    // 關閉可能打開的模態框並刷新UI
    document.getElementById('message-editor-modal').classList.remove('visible');
    renderChatInterface(state.activeChatId);
    await showCustomAlert('成功', '消息已更新！');
}

// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 請將這【一整塊新函數】黏貼到JS功能函式定義區的末尾 ▼▼▼

/**
 * 當點擊“…”時，顯示動態操作功能表
 * @param {number} postId - 被操作的動態的ID
 */
function showPostActions(postId) {
    activePostId = postId;
    document.getElementById('post-actions-modal').classList.add('visible');
}

/**
 * 隱藏動態操作功能表
 */
function hidePostActions() {
    document.getElementById('post-actions-modal').classList.remove('visible');
    activePostId = null;
}

// ▼▼▼ 步驟3.2 操作1：替換 openPostEditor 函數 ▼▼▼
async function openPostEditor() {
    if (!activePostId) return;

    const postIdToEdit = activePostId;
    const post = await db.qzonePosts.get(postIdToEdit);
    if (!post) return;

    hidePostActions();

    // 複用創建動態的模態框
    const modal = document.getElementById('create-post-modal');
    modal.dataset.mode = 'edit'; // 設置一個編輯模式的標記
    modal.dataset.editingPostId = postIdToEdit; // 保存正在編輯的ID

    // 隱藏模式切換，因為不允許在編輯時更改動態類型
    modal.querySelector('.post-mode-switcher').style.display = 'none';
    
    // 填充數據
    document.getElementById('post-public-text').value = post.publicText || (post.type === 'shuoshuo' ? post.content : '');
    
    // 根據動態類型顯示不同的編輯區
    if (post.type === 'image_post') {
        document.getElementById('image-mode-content').classList.add('active');
        document.getElementById('text-image-mode-content').classList.remove('active');
        document.getElementById('post-image-preview-container').classList.add('visible');
        document.getElementById('post-image-preview').src = post.imageUrl;
        document.getElementById('post-image-desc-group').style.display = 'block';
        document.getElementById('post-image-description').value = post.imageDescription;
    } else if (post.type === 'text_image') {
        document.getElementById('image-mode-content').classList.remove('active');
        document.getElementById('text-image-mode-content').classList.add('active');
        document.getElementById('post-hidden-text').value = post.hiddenContent;
    } else { // 說說
        document.getElementById('image-mode-content').classList.remove('active');
        document.getElementById('text-image-mode-content').classList.remove('active');
    }
    
    // ★★★★★【核心修改：回填評論開關的狀態】★★★★★
    document.getElementById('post-comments-toggle').checked = post.areCommentsVisible !== false;

    modal.classList.add('visible');
}
// ▲▲▲ 步驟3.2 操作1 替換結束 ▲▲▲


/**
 * 保存編輯後的動態
 * @param {number} postId - 要保存的動態ID
 * @param {string} newRawContent - 從編輯器獲取的新內容
 */
async function saveEditedPost(postId, newRawContent) {
    const post = await db.qzonePosts.get(postId);
    if (!post) return;

    const trimmedContent = newRawContent.trim();
    
    // 嘗試解析為JSON，如果失敗，則認為是純文字（說說）
    try {
        const parsed = JSON.parse(trimmedContent);
        // 更新帖子屬性
        post.type = parsed.type || 'image_post';
        post.publicText = parsed.publicText || '';
        post.imageUrl = parsed.imageUrl || '';
        post.imageDescription = parsed.imageDescription || '';
        post.hiddenContent = parsed.hiddenContent || '';
        post.content = ''; // 清空舊的說說內容欄位
    } catch (e) {
        // 解析失敗，認為是說說
        post.type = 'shuoshuo';
        post.content = trimmedContent;
        // 清空其他類型的欄位
        post.publicText = '';
        post.imageUrl = '';
        post.imageDescription = '';
        post.hiddenContent = '';
    }
    
    await db.qzonePosts.put(post);
    await renderQzonePosts(); // 重新渲染列表
    await showCustomAlert('成功', '動態已更新！');
}

/**
 * 複製動態內容
 */
async function copyPostContent() {
    if (!activePostId) return;
    const post = await db.qzonePosts.get(activePostId);
    if (!post) return;
    
    let textToCopy = post.content || post.publicText || post.hiddenContent || post.imageDescription || "（無文字內容）";
    
    try {
        await navigator.clipboard.writeText(textToCopy);
        await showCustomAlert('複製成功', '動態內容已複製到剪貼板。');
    } catch (err) {
        await showCustomAlert('複製失敗', '無法訪問剪貼板。');
    }
    
    hidePostActions();
}

// ▼▼▼ 【全新】創建群聊與拉人功能核心函數 ▼▼▼
let selectedContacts = new Set();

async function openContactPickerForGroupCreate() {
    selectedContacts.clear(); // 清空上次選擇

    // 【核心修復】在這裡，我們為“完成”按鈕明確綁定“創建群聊”的功能
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // 使用克隆節點技巧，清除掉之前可能綁定的任何其他事件（比如“添加成員”）
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    // 重新綁定正確的“創建群聊”函數
    newConfirmBtn.addEventListener('click', handleCreateGroup);

    await renderContactPicker();
    showScreen('contact-picker-screen');
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 渲染連絡人選擇列表
 */
async function renderContactPicker() {
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';

    // 只選擇單聊角色作為群成員候選
    const contacts = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (contacts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">還沒有可以拉進群的連絡人哦~</p>';
        return;
    }

    contacts.forEach(contact => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        item.dataset.contactId = contact.id;
        item.innerHTML = `
            <div class="checkbox"></div>
            <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${contact.name}</span>
        `;
        listEl.appendChild(item);
    });

    updateContactPickerConfirmButton();
}

/**
 * 更新“完成”按鈕的計數
 */
function updateContactPickerConfirmButton() {
    const btn = document.getElementById('confirm-contact-picker-btn');
    btn.textContent = `完成(${selectedContacts.size})`;
    btn.disabled = selectedContacts.size < 2; // 至少需要2個人才能創建群聊
}

/**
 * 【重構版】處理創建群聊的最終邏輯
 */
async function handleCreateGroup() {
    if (selectedContacts.size < 2) {
        alert("創建群聊至少需要選擇2個連絡人。");
        return;
    }

    const groupName = await showCustomPrompt('設置群名', '請輸入群聊的名字', '我們的群聊');
    if (!groupName || !groupName.trim()) return;

    const newChatId = 'group_' + Date.now();
    const members = [];
    
    // 遍歷選中的連絡人ID
    for (const contactId of selectedContacts) {
        const contactChat = state.chats[contactId];
        if (contactChat) {
            // ★★★【核心重構】★★★
            // 我們現在同時存儲角色的“本名”和“群昵稱”
            members.push({
                id: contactId, 
                originalName: contactChat.name,   // 角色的“本名”，用於AI識別
                groupNickname: contactChat.name, // 角色的“群昵稱”，用於顯示和修改，初始值和本名相同
                avatar: contactChat.settings.aiAvatar || defaultAvatar,
                persona: contactChat.settings.aiPersona,
                avatarFrame: contactChat.settings.aiAvatarFrame || ''
            });
        }
    }

    const newGroupChat = {
        id: newChatId,
        name: groupName.trim(),
        isGroup: true,
        members: members,
        settings: {
            myPersona: '我是誰呀。',
            myNickname: '我',
            maxMemory: 10,
            groupAvatar: defaultGroupAvatar,
            myAvatar: defaultMyGroupAvatar,
            background: '',
            theme: 'default',
            fontSize: 13,
            customCss: '',
            linkedWorldBookIds: [],
            stickerLibrary: [], // <--- 新增這一行，為新群聊初始化專屬表情庫
            linkedMemories: []
        },
        history: [],
        musicData: { totalTime: 0 }
    };

    state.chats[newChatId] = newGroupChat;
    await db.chats.put(newGroupChat);
    
    await renderChatList();
    showScreen('chat-list-screen');
    openChat(newChatId); 
}

// ▼▼▼ 【全新】群成員管理核心函數 ▼▼▼

/**
 * 打開群成員管理螢幕
 */
function openMemberManagementScreen() {
    if (!state.activeChatId || !state.chats[state.activeChatId].isGroup) return;
    renderMemberManagementList();
    showScreen('member-management-screen');
}

function renderMemberManagementList() {
    const listEl = document.getElementById('member-management-list');
    const chat = state.chats[state.activeChatId];
    listEl.innerHTML = '';

    chat.members.forEach(member => {
        const item = document.createElement('div');
        item.className = 'member-management-item';
        // 【核心修正】在這裡，我們將顯示的名稱從 member.name 改為 member.groupNickname
        item.innerHTML = `
            <img src="${member.avatar}" class="avatar">
            <span class="name">${member.groupNickname}</span>
            <button class="remove-member-btn" data-member-id="${member.id}" title="移出群聊">-</button>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 從群聊中移除一個成員
 * @param {string} memberId - 要移除的成員ID
 */
async function removeMemberFromGroup(memberId) {
    const chat = state.chats[state.activeChatId];
    const memberIndex = chat.members.findIndex(m => m.id === memberId);
    
    if (memberIndex === -1) return;
    
    // 安全檢查，群聊至少保留2人
    if (chat.members.length <= 2) {
        alert("群聊人數不能少於2人。");
        return;
    }
    
const memberName = chat.members[memberIndex].groupNickname; // <-- 修復：使用 groupNickname
    const confirmed = await showCustomConfirm(
        '移出成員',
        `確定要將“${memberName}”移出群聊嗎？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.members.splice(memberIndex, 1);
        await db.chats.put(chat);
        renderMemberManagementList(); // 刷新成員管理列表
        document.getElementById('chat-settings-btn').click(); // 【核心修正】類比點擊設置按鈕，強制刷新整個彈窗
    }
}

/**
 * 打開連絡人選擇器，用於拉人入群
 */
async function openContactPickerForAddMember() {
    selectedContacts.clear(); // 清空選擇
    
    const chat = state.chats[state.activeChatId];
    const existingMemberIds = new Set(chat.members.map(m => m.id));

    // 渲染連絡人列表，並自動排除已在群內的成員
    const listEl = document.getElementById('contact-picker-list');
    listEl.innerHTML = '';
    const contacts = Object.values(state.chats).filter(c => !c.isGroup && !existingMemberIds.has(c.id));

    if (contacts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color:#8a8a8a; margin-top:50px;">沒有更多可以邀請的好友了。</p>';
        document.getElementById('confirm-contact-picker-btn').style.display = 'none'; // 沒有人可選，隱藏完成按鈕
    } else {
        document.getElementById('confirm-contact-picker-btn').style.display = 'block';
        contacts.forEach(contact => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.dataset.contactId = contact.id;
            item.innerHTML = `
                <div class="checkbox"></div>
                <img src="${contact.settings.aiAvatar || defaultAvatar}" class="avatar">
                <span class="name">${contact.name}</span>
            `;
            listEl.appendChild(item);
        });
    }

    // 更新按鈕狀態並顯示幕幕
    updateContactPickerConfirmButton();
    showScreen('contact-picker-screen');
}

/**
 * 處理將選中的連絡人加入群聊的邏輯
 */
async function handleAddMembersToGroup() {
    if (selectedContacts.size === 0) {
        alert("請至少選擇一個要添加的連絡人。");
        return;
    }
    
    const chat = state.chats[state.activeChatId];

    for (const contactId of selectedContacts) {
        const contactChat = state.chats[contactId];
        if (contactChat) {
chat.members.push({
    id: contactId,
    originalName: contactChat.name,  // <-- 修復1：使用 'originalName' 存儲本名
    groupNickname: contactChat.name, // <-- 修復2：同時創建一個初始的 'groupNickname'
    avatar: contactChat.settings.aiAvatar || defaultAvatar,
    persona: contactChat.settings.aiPersona,
    avatarFrame: contactChat.settings.aiAvatarFrame || ''
});
        }
    }

    await db.chats.put(chat);
    openMemberManagementScreen(); // 返回到群成員管理介面
    renderGroupMemberSettings(chat.members); // 同時更新聊天設置裡的頭像
}

/**
 * 【重構版】在群聊中創建一個全新的虛擬成員
 */
async function createNewMemberInGroup() {
    const name = await showCustomPrompt('創建新成員', '請輸入新成員的名字 (這將是TA的“本名”，不可更改)');
    if (!name || !name.trim()) return;

    // 檢查本名是否已在群記憶體在
    const chat = state.chats[state.activeChatId];
    if (chat.members.some(m => m.originalName === name.trim())) {
        alert(`錯誤：群內已存在名為“${name.trim()}”的成員！`);
        return;
    }

    const persona = await showCustomPrompt('設置人設', `請輸入“${name}”的人設`, '', 'textarea');
    if (persona === null) return; 

    // ★★★【核心重構】★★★
    // 為新創建的NPC也建立雙重命名機制
    const newMember = {
        id: 'npc_' + Date.now(),
        originalName: name.trim(),   // 新成員的“本名”
        groupNickname: name.trim(), // 新成員的初始“群昵稱”
        avatar: defaultGroupMemberAvatar,
        persona: persona,
        avatarFrame: ''
    };

    chat.members.push(newMember);
    await db.chats.put(chat);

    renderMemberManagementList();
    renderGroupMemberSettings(chat.members); 

    alert(`新成員“${name}”已成功加入群聊！`);
}

// ▼▼▼ 【全新】外賣請求倒計時函數 ▼▼▼
function startWaimaiCountdown(element, endTime) {
    const timerId = setInterval(() => {
        const now = Date.now();
        const distance = endTime - now;

        if (distance < 0) {
            clearInterval(timerId);
            element.innerHTML = '<span>已</span><span>超</span><span>時</span>';
            return;
        }

        const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = Math.floor((distance % (1000 * 60)) / 1000);
        
        const minStr = String(minutes).padStart(2, '0');
        const secStr = String(seconds).padStart(2, '0');

        element.innerHTML = `<span>${minStr.charAt(0)}</span><span>${minStr.charAt(1)}</span> : <span>${secStr.charAt(0)}</span><span>${secStr.charAt(1)}</span>`;
    }, 1000);
    return timerId;
}

function cleanupWaimaiTimers() {
    for (const timestamp in waimaiTimers) {
        clearInterval(waimaiTimers[timestamp]);
    }
    waimaiTimers = {};
}
// ▲▲▲ 新函數黏貼結束 ▲▲▲

async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;

    // 1. 更新原始消息的狀態
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;
    
    // 【核心修正】記錄支付者，並構建對AI更清晰的系統消息
    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    if (choice === 'paid') {
        originalMessage.paidBy = myNickname; // 記錄是使用者付的錢
        systemContent = `[系統提示：你 (${myNickname}) 為 ${originalMessage.senderName} 的外賣訂單（時間戳記: ${originalTimestamp}）完成了支付。此訂單已關閉，其他成員不能再支付。]`;
    } else {
        systemContent = `[系統提示：你 (${myNickname}) 拒絕了 ${originalMessage.senderName} 的外賣代付請求（時間戳記: ${originalTimestamp}）。]`;
    }

    // 2. 創建一條新的、對使用者隱藏的系統消息，告知AI結果
    const systemNote = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(systemNote);

    // 3. 保存更新到資料庫並刷新UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);  
}

let videoCallState = {
    isActive: false,       
    isAwaitingResponse: false, 
    isGroupCall: false,      
    activeChatId: null,    
    initiator: null,       
    startTime: null,       
    participants: [],      
    isUserParticipating: true,
    // --- 【核心新增】---
    callHistory: [], // 用於存儲通話中的對話歷史
    preCallContext: "" // 用於存儲通話前的聊天摘要
};

let callTimerInterval = null; // 用於存儲計時器的ID

// ▼▼▼ 用這整塊【最終通話修復版】的代碼，完整替換掉上一個版本的 handleInitiateCall 函數 ▼▼▼
/**
 * 【總入口】使用者點擊“發起視頻通話”或“發起群視頻”按鈕 (V3 - 通話決策修復版)
 */
async function handleInitiateCall() {
    if (!state.activeChatId || videoCallState.isActive || videoCallState.isAwaitingResponse) return;

    const chat = state.chats[state.activeChatId];
    videoCallState.isGroupCall = chat.isGroup;
    videoCallState.isAwaitingResponse = true;
    videoCallState.initiator = 'user';
    videoCallState.activeChatId = chat.id;
    videoCallState.isUserParticipating = true;

    // 1. 顯示“正在呼叫”介面 (這部分不變)
    if (chat.isGroup) {
        document.getElementById('outgoing-call-avatar').src = chat.settings.myAvatar || defaultMyGroupAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.settings.myNickname || '我';
    } else {
        document.getElementById('outgoing-call-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('outgoing-call-name').textContent = chat.name;
    }
    document.querySelector('#outgoing-call-screen .caller-text').textContent = chat.isGroup ? "正在呼叫所有成員..." : "正在呼叫...";
    showScreen('outgoing-call-screen');
    
    // 2. 【核心修復】重新構建一個資訊更豐富、指令更明確的API請求
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        if (!proxyUrl || !apiKey || !model) {
            throw new Error('API未配置，無法發起通話。');
        }
    
        // 構建一個強大且明確的系統指令(System Prompt)
        let systemPromptForCall;
        if (chat.isGroup) {
            systemPromptForCall = `
# 你的任務
你是一個群聊AI，負責扮演【除了用戶以外】的所有角色。
用戶 (${chat.settings.myNickname || '我'}) 剛剛發起了群視頻通話。
你的任務是根據每個角色的性格和最近的聊天內容，決定他們是否要加入通話。

# 核心規則
1.  **決策**: 每個角色都必須獨立決策。
2.  **格式**: 你的回復【必須】是一個JSON陣列，每個物件代表一個角色的決策，格式為：\`{"type": "group_call_response", "name": "【角色的本名】", "decision": "join"}\` 或 \`{"type": "group_call_response", "name": "【角色的本名】", "decision": "decline"}\`。
3.  **傾向性**: 在沒有特殊理由的情況下，你的角色們通常樂於加入群聊。

# 角色列表與人設
${chat.members.map(m => `- **${m.originalName}**: ${m.persona}`).join('\n')}

# 通話前的聊天摘要
${videoCallState.preCallContext}
`;
        } else {
            systemPromptForCall = `
# 你的任務
你正在扮演角色 "${chat.name}"。用戶 (${chat.settings.myNickname || '我'}) 剛剛向你發起了視頻通話請求。
你的任務是根據你的人設和我們最近的聊天內容，決定是否接受。

# 核心規則
1.  **決策**: 你必須做出 "accept" (接受) 或 "reject" (拒絕) 的決定。
2.  **格式**: 你的回復【必須且只能】是一個JSON陣列，其中包含一個物件，格式為：\`[{"type": "video_call_response", "decision": "accept"}]\` 或 \`[{"type": "video_call_response", "decision": "reject"}]\`。
3.  **傾向性**: 作為一個友好的AI伴侶，在沒有特殊理由（比如在之前的對話中明確表示了不想被打擾或正在忙）的情況下，你【應該優先選擇接受】通話。

# 你的人設
${chat.settings.aiPersona}

# 通話前的聊天摘要
${videoCallState.preCallContext}
`;
        }
        
        // 準備發送給API的消息體
        const messagesForApi = [{ role: 'user', content: "請根據你在系統指令中讀到的規則，立即做出你的決策。" }];
        
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPromptForCall, messagesForApi, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{ role: 'system', content: systemPromptForCall }, ...messagesForApi],
                    temperature: 0.7
                })
            });
            
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API 錯誤 (${response.status}): ${errorText}`);
        }

        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, '');
        const responseArray = JSON.parse(aiResponseContent);

        // 3. 處理AI的決策 (與上一版相同)
        if (chat.isGroup) {
            responseArray.forEach(action => {
                if (action.type === 'group_call_response' && action.decision === 'join') {
                    const member = chat.members.find(m => m.originalName === action.name);
                    if (member) videoCallState.participants.push(member);
                }
            });
            if (videoCallState.participants.length > 0) {
                startVideoCall();
            } else {
                throw new Error("群裡沒有人接聽你的通話邀請。");
            }
        } else {
            const decision = responseArray[0];
            if (decision.type === 'video_call_response' && decision.decision === 'accept') {
                startVideoCall();
            } else {
                throw new Error("對方拒絕了你的視頻通話請求。");
            }
        }

    } catch (error) {
        // 4. 統一處理所有失敗情況 (與上一版相同)
        console.error("發起通話失敗:", error);
        await showCustomAlert("呼叫失敗", error.message);
        videoCallState.isAwaitingResponse = false;
        showScreen('chat-interface-screen');
    }
}
// ▲▲▲ 替換結束 ▲▲▲



// ▼▼▼ 用這個【全新的函數】，完整替換掉你舊的 startVideoCall 函數 ▼▼▼
function startVideoCall() {
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;
// ▼▼▼ 把下面這整塊代碼從 handleInitiateCall 函數裡【剪切】掉 ▼▼▼

// 提取通話前的最後20條消息作為上下文
videoCallState.preCallContext = chat.history
    .slice(-20)
    .map(msg => `${msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name)}: ${String(msg.content).substring(0, 50)}...`)
    .join('\n');

    // 1. 【核心判斷】檢查是否啟用了視覺化介面
    if (chat.settings.visualVideoCallEnabled) {
        // --- 啟動【新】的視覺化介面 ---
        videoCallState.isActive = true;
        videoCallState.isAwaitingResponse = false;
        videoCallState.startTime = Date.now();
        videoCallState.callHistory = [];

        const visualInterface = document.getElementById('visual-call-interface');
        const textInterface = document.getElementById('text-call-interface');
        
        // 顯示新介面，隱藏舊介面
        visualInterface.style.display = 'flex';
        textInterface.style.display = 'none';

        // 載入圖片
        document.querySelector('#video-main-view img').src = chat.settings.charVideoImage || defaultAvatar;
        document.querySelector('#video-pip-view img').src = chat.settings.userVideoImage || defaultAvatar;
        
        // 清空舊的聊天氣泡
        document.getElementById('video-call-messages-visual').innerHTML = `<em>正在接通...</em>`;
        showScreen('video-call-screen');

        // 啟動計時器
        if (callTimerInterval) clearInterval(callTimerInterval);
        callTimerInterval = setInterval(updateCallTimer, 1000);
        updateCallTimer(); // 立即更新一次

        // 觸發AI在通話中的第一句話
        triggerAiInCallAction();

    } else {
        // --- 啟動【舊】的純文字介面 (這裡的代碼就是你原來的邏輯) ---
        videoCallState.isActive = true;
        videoCallState.isAwaitingResponse = false;
        videoCallState.startTime = Date.now();
        videoCallState.callHistory = [];

        const visualInterface = document.getElementById('visual-call-interface');
        const textInterface = document.getElementById('text-call-interface');

        // 顯示舊介面，隱藏新介面
        visualInterface.style.display = 'none';
        textInterface.style.display = 'flex'; // 舊介面用flex

        updateParticipantAvatars(); 
        
        document.getElementById('video-call-main').innerHTML = `<em>${videoCallState.isGroupCall ? '群聊已建立...' : '正在接通...'}</em>`;
        showScreen('video-call-screen');

        document.getElementById('user-speak-btn').style.display = videoCallState.isUserParticipating ? 'block' : 'none';
        document.getElementById('join-call-btn').style.display = videoCallState.isUserParticipating ? 'none' : 'block';

        if (callTimerInterval) clearInterval(callTimerInterval);
        callTimerInterval = setInterval(updateCallTimer, 1000);
        updateCallTimer();

        triggerAiInCallAction();
    }
}
// ▲▲▲ 替換結束 ▲▲▲


/**
 * 【核心】結束視頻通話
 */
// ▼▼▼ 用這整塊代碼替換舊的 endVideoCall 函數 ▼▼▼
async function endVideoCall() {
  // ▼▼▼ 在 endVideoCall 函數的【開頭】添加這行代碼 ▼▼▼
document.getElementById('visual-call-interface').style.display = 'none';
// ▲▲▲ 添加結束 ▲▲▲

    if (!videoCallState.isActive) return;

    const duration = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const durationText = `${Math.floor(duration / 60)}分${duration % 60}秒`;
    const endCallText = `通話結束，時長 ${durationText}`;

    const chat = state.chats[videoCallState.activeChatId];
    if (chat) {
        // 1. 保存完整的通話記錄到資料庫 (這部分邏輯不變)
        const participantsData = [];
        if (videoCallState.isGroupCall) {
            videoCallState.participants.forEach(p => participantsData.push({ name: p.originalName, avatar: p.avatar }));
            if (videoCallState.isUserParticipating) {
                participantsData.unshift({ name: chat.settings.myNickname || '我', avatar: chat.settings.myAvatar || defaultMyGroupAvatar });
            }
        } else {
            participantsData.push({ name: chat.name, avatar: chat.settings.aiAvatar || defaultAvatar });
            participantsData.unshift({ name: '我', avatar: chat.settings.myAvatar || defaultAvatar });
        }
        
        const callRecord = {
            chatId: videoCallState.activeChatId,
            timestamp: Date.now(),
            duration: duration,
            participants: participantsData,
            transcript: [...videoCallState.callHistory]
        };
        await db.callRecords.add(callRecord);
        console.log("通話記錄已保存:", callRecord);
        
        // 2. 在聊天記錄裡添加對使用者可見的“通話結束”消息
let summaryMessage = {
    // 【核心修正1】role 由 videoCallState.initiator 決定
    role: videoCallState.initiator === 'user' ? 'user' : 'assistant',
    content: endCallText,
    timestamp: Date.now(),
};

// 【核心修正2】為群聊的 assistant 消息補充 senderName
if (chat.isGroup && summaryMessage.role === 'assistant') {
    // 在群聊中，通話結束的消息應該由“發起者”來說
    // videoCallState.callRequester 保存了最初發起通話的那個AI的名字
    summaryMessage.senderName = videoCallState.callRequester || chat.members[0]?.originalName || chat.name;
}
// ▲▲▲ 替換結束 ▲▲▲
        chat.history.push(summaryMessage);

        // 3. 【核心變革】創建並添加對用戶隱藏的“通話後彙報”指令
        const callTranscriptForAI = videoCallState.callHistory.map(h => `${h.role === 'user' ? (chat.settings.myNickname || '我') : h.role}: ${h.content}`).join('\n');
        
        const hiddenReportInstruction = {
            role: 'system',
    content: `[系統指令：視頻通話剛剛結束。請你根據完整的通話文字記錄（見下方），以你的角色口吻，向用戶主動發送幾條【格式為 {"type": "text", "content": "..."} 的】消息，來自然地總結這次通話的要點、確認達成的約定，或者表達你的感受。這很重要，能讓使用者感覺你記得通話內容。]\n---通話記錄開始---\n${callTranscriptForAI}\n---通話記錄結束---`,
            timestamp: Date.now() + 1, // 確保在上一條消息之後
            isHidden: true
        };
        chat.history.push(hiddenReportInstruction);

        // 4. 保存所有更新到資料庫
        await db.chats.put(chat);
    }
    
    // 5. 清理和重置狀態 (這部分邏輯不變)
    clearInterval(callTimerInterval);
    callTimerInterval = null;
    videoCallState = { isActive: false, isAwaitingResponse: false, isGroupCall: false, activeChatId: null, initiator: null, startTime: null, participants: [], isUserParticipating: true, callHistory: [], preCallContext: "" };
    
    // 6. 返回聊天介面並觸發AI響應（AI會讀取到我們的“彙報”指令）
    if (chat) {
        openChat(chat.id);
        triggerAiResponse(); // 關鍵一步！
    }
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 【全新】更新通話介面的參與者頭像網格
 */
function updateParticipantAvatars() {
    const grid = document.getElementById('participant-avatars-grid');
    grid.innerHTML = '';
    const chat = state.chats[videoCallState.activeChatId];
    if (!chat) return;

    let participantsToRender = [];

    // ★ 核心修正：區分群聊和單聊
    if (videoCallState.isGroupCall) {
        // 群聊邏輯：顯示所有已加入的AI成員
        participantsToRender = [...videoCallState.participants];
        // 如果使用者也參與了，就把使用者資訊也加進去
        if (videoCallState.isUserParticipating) {
            participantsToRender.unshift({
                id: 'user',
                name: chat.settings.myNickname || '我',
                avatar: chat.settings.myAvatar || defaultMyGroupAvatar
            });
        }
    } else {
        // 單聊邏輯：只顯示對方的頭像和名字
        participantsToRender.push({
            id: 'ai',
            name: chat.name,
            avatar: chat.settings.aiAvatar || defaultAvatar
        });
    }
    
    participantsToRender.forEach(p => {
        const wrapper = document.createElement('div');
        wrapper.className = 'participant-avatar-wrapper';
        wrapper.dataset.participantId = p.id;
const displayName = p.groupNickname || p.name; // <-- 核心修復在這裡
wrapper.innerHTML = `
    <img src="${p.avatar}" class="participant-avatar" alt="${displayName}">
    <div class="participant-name">${displayName}</div>
`;
        grid.appendChild(wrapper);
    });
}

/**
 * 【全新】處理用戶加入/重新加入通話
 */
function handleUserJoinCall() {
    if (!videoCallState.isActive || videoCallState.isUserParticipating) return;
    
    videoCallState.isUserParticipating = true;
    updateParticipantAvatars(); // 更新頭像列表，加入用戶

    // 切換底部按鈕
    document.getElementById('user-speak-btn').style.display = 'block';
    document.getElementById('join-call-btn').style.display = 'none';

    // 告知AI用戶加入了
    triggerAiInCallAction("[系統提示：用戶加入了通話]");
}


/**
 * 更新通話計時器顯示 
 */
// ▼▼▼ 用這個【新版本】替換舊的 updateCallTimer 函數 ▼▼▼
function updateCallTimer() {
    if (!videoCallState.isActive) return;
    const elapsed = Math.floor((Date.now() - videoCallState.startTime) / 1000);
    const minutes = Math.floor(elapsed / 60);
    const seconds = elapsed % 60;
    const timeString = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    
    // 同時更新兩個介面的計時器
    document.getElementById('call-timer').textContent = timeString;
    document.getElementById('visual-call-timer').textContent = timeString;
}
// ▲▲▲ 替換結束 ▲▲▲


// ▼▼▼ 用這個完整函數替換舊的 showIncomingCallModal ▼▼▼
function showIncomingCallModal(chatId) { // <--- 在括弧裡添加 chatId
    const chat = state.chats[chatId]; // <--- 把 state.activeChatId 修改為 chatId
    if (!chat) return;

    // 根據是否群聊顯示不同資訊
    if (chat.isGroup) {
        // 從 videoCallState 中獲取是哪個成員發起的通話
        const requesterName = videoCallState.callRequester || chat.members[0]?.name || '一位成員';
        document.getElementById('caller-avatar').src = chat.settings.groupAvatar || defaultGroupAvatar;
        document.getElementById('caller-name').textContent = chat.name; // 顯示群名
        document.querySelector('.incoming-call-content .caller-text').textContent = `${requesterName} 邀請你加入群視頻`; // 顯示具體發起人
    } else {
        // 單聊邏輯保持不變
        document.getElementById('caller-avatar').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('caller-name').textContent = chat.name;
        document.querySelector('.incoming-call-content .caller-text').textContent = '邀請你視頻通話';
    }
    
    document.getElementById('incoming-call-modal').classList.add('visible');
    playRingtone(); // <-- 在這裡添加這一行
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 隱藏AI發起的通話請求模態框 (保持不變)
 */
function hideIncomingCallModal() {
    document.getElementById('incoming-call-modal').classList.remove('visible');
    stopRingtone(); // <-- 在這裡添加這一行
}

// ▼▼▼ 【這是修正後的版本】請用這一整塊代碼，完整替換你舊的 triggerAiInCallAction 函數 ▼▼▼
async function triggerAiInCallAction(userInput = null) {
    if (!videoCallState.isActive) return;

    const chat = state.chats[videoCallState.activeChatId];
    const { proxyUrl, apiKey, model } = state.apiConfig;
    
    const isVisualMode = chat.settings.visualVideoCallEnabled;
    const callFeed = isVisualMode 
        ? document.getElementById('video-call-messages-visual') 
        : document.getElementById('video-call-main');

    const userNickname = chat.settings.myNickname || '我';

    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界書: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界觀設定 (你必須嚴格遵守)\n${linkedContents}\n`;
        }
    }

    if (userInput && videoCallState.isUserParticipating) {
        if (isVisualMode) {
            const userBubble = document.createElement('div');
            userBubble.className = 'visual-call-bubble user';
            userBubble.textContent = userInput;
            callFeed.appendChild(userBubble);
        } else {
            const userBubble = document.createElement('div');
            userBubble.className = 'call-message-bubble user-speech';
            userBubble.textContent = userInput;
            callFeed.appendChild(userBubble);
        }
        callFeed.scrollTop = callFeed.scrollHeight;
        videoCallState.callHistory.push({ role: 'user', content: userInput });
    }

    let inCallPrompt;
    if (videoCallState.isGroupCall) {
        // ★★★ 核心修復1：在這裡，我們提前定義好 participantNames ★★★
        const participantNames = videoCallState.participants.map(p => p.originalName); 
        if(videoCallState.isUserParticipating) {
            participantNames.unshift(userNickname);
        }
        // ★★★ 修復結束 ★★★

        inCallPrompt = `
# 你的任務
你是一個群聊AI，負責扮演所有【除了用戶以外】的AI角色。你們正在進行一場群聊視頻通話。
你的任務是根據每個角色的性格，生成他們在通話中會說的【第一人稱對話】，注意是在視頻通話，絕對不能以為是在現實！每次回復的字數多些，50字以上。

# 核心規則
1.  **【【【語言鐵律】】】**: 無論角色人設是什麼國籍或說什麼語言，在本次視頻通話中，所有角色【必須】全程使用【中文】進行交流。
2.  **【【【格式鐵律】】】**: 你的回復【必須】是一個JSON陣列，每個物件代表一個角色的發言，格式為：\`{"name": "【角色的本名】", "speech": "【在這裡加入帶動作的對話】"}\`。
3.  **【【【表現力鐵律】】】**: 在 "speech" 欄位中，你【必須】為角色的對話加入【動作、表情或心理活動】，並用【】符號包裹。這非常重要！
4.  **示例**: \`{"name": "張三", "speech": "【撓了撓頭】啊？我剛剛走神了，你們說到哪了？"}\`
5.  **身份鐵律**: 用戶的身份是【${userNickname}】。你【絕對不能】生成 \`name\` 欄位為 **"${userNickname}"** 的發言。
6.  **角色扮演**: 嚴格遵守每個角色的設定，用他們的口吻說話。

# 當前情景
你們正在一個群視頻通話中。
**通話前的聊天摘要**:
${videoCallState.preCallContext}
**當前參與者**: ${participantNames.join('、 ')}。
${worldBookContent}
現在，請根據【通話前摘要】和下面的【通話即時記錄】，繼續進行對話。
`;
    } else {
        // ★★★ 核心修復2：為單人通話提供一個完全獨立的、正確的Prompt ★★★
        let openingContext = videoCallState.initiator === 'user'
            ? `你剛剛接聽了使用者的視頻通話請求。`
            : `使用者剛剛接聽了你主動發起的視頻通話。`;
            
        inCallPrompt = `
# 你的任務
你正在扮演角色 "${chat.name}"。你正在和用戶 (${userNickname}) 進行一對一視頻通話。
${openingContext}
你的任務是根據你的人設和我們的聊天情景，生成你在通話中會說的【第一人稱對話】。

# 核心規則
1.  **【【【格式鐵律】】】**: 你的回復【必須且只能】是一段純文字字串，代表你的發言。絕對不要輸出JSON格式。
2.  **【【【表現力鐵律】】】**: 在你的對話中，你【必須】加入【動作、表情或心理活動】，並用【】符號包裹。
3.  **示例**: "【歪了歪頭，好奇地看著你】真的嗎？快跟我說說看！"
4.  **禁止出戲**: 絕不能透露你是AI或模型。

# 當前情景
**通話前的聊天摘要**:
${videoCallState.preCallContext}
${worldBookContent}
現在，請根據【通話前摘要】和下面的【通話即時記錄】，繼續進行對話。
`;
        // ★★★ 修復結束 ★★★
    }
    
    const messagesForApi = [
        ...videoCallState.callHistory.map(h => ({ role: h.role, content: h.content }))
    ];

    if (videoCallState.callHistory.length === 0) {
        const firstLineTrigger = videoCallState.initiator === 'user' ? `*你按下了接聽鍵...*` : `*對方按下了接聽鍵...*`;
        messagesForApi.push({ role: 'user', content: firstLineTrigger });
    }
    
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, inCallPrompt, messagesForApi, isGemini);
        const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({ model: model, messages: [{ role: 'system', content: inCallPrompt }, ...messagesForApi], temperature: 0.8 })
        });
        if (!response.ok) throw new Error((await response.json()).error.message);

        const data = await response.json();
        const aiResponse = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
        const sanitizedResponse = aiResponse.replace(/!\[.*?\]\(.*?\)|https?:\/\/\S+/gi, '').trim();

        const connectingElement = callFeed.querySelector('em');
        if (connectingElement) connectingElement.remove();

        if (isVisualMode) {
            const aiBubble = document.createElement('div');
            aiBubble.className = 'visual-call-bubble ai';
            aiBubble.textContent = sanitizedResponse;
            callFeed.appendChild(aiBubble);
            videoCallState.callHistory.push({ role: 'assistant', content: sanitizedResponse });
        } else {
            if (videoCallState.isGroupCall) {
                const speechArray = parseAiResponse(sanitizedResponse); 
                speechArray.forEach(turn => {
                    if (!turn.name || turn.name === userNickname || !turn.speech) return;
                    const aiBubble = document.createElement('div');
                    aiBubble.className = 'call-message-bubble ai-speech';
                    aiBubble.innerHTML = `<strong>${turn.name}:</strong> ${turn.speech}`;
                    callFeed.appendChild(aiBubble);
                    videoCallState.callHistory.push({ role: 'assistant', content: `${turn.name}: ${turn.speech}` });
                    
                    const speaker = videoCallState.participants.find(p => p.originalName === turn.name);
                    if (speaker) {
                        const speakingAvatar = document.querySelector(`.participant-avatar-wrapper[data-participant-id="${speaker.id}"] .participant-avatar`);
                        if(speakingAvatar) {
                            speakingAvatar.classList.add('speaking');
                            setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                        }
                    }
                });
            } else {
                const aiBubble = document.createElement('div');
                aiBubble.className = 'call-message-bubble ai-speech';
                aiBubble.textContent = sanitizedResponse;
                callFeed.appendChild(aiBubble);
                videoCallState.callHistory.push({ role: 'assistant', content: sanitizedResponse });
                const speakingAvatar = document.querySelector(`.participant-avatar-wrapper .participant-avatar`);
                if(speakingAvatar) {
                    speakingAvatar.classList.add('speaking');
                    setTimeout(() => speakingAvatar.classList.remove('speaking'), 2000);
                }
            }
        }
        
        callFeed.scrollTop = callFeed.scrollHeight;

    } catch (error) {
        const errorBubble = document.createElement('div');
        errorBubble.style.color = '#ff8a80';
        errorBubble.textContent = `[ERROR: ${error.message}]`;
        
        if (isVisualMode) {
            errorBubble.className = 'visual-call-bubble ai';
        } else {
            errorBubble.className = 'call-message-bubble ai-speech';
        }
        
        callFeed.appendChild(errorBubble);
        callFeed.scrollTop = callFeed.scrollHeight;
        videoCallState.callHistory.push({ role: 'assistant', content: `[ERROR: ${error.message}]` });
    }
}

// ▼▼▼ 將這個【全新函數】黏貼到JS功能函式定義區 ▼▼▼
function toggleCallButtons(isGroup) {
    document.getElementById('video-call-btn').style.display = isGroup ? 'none' : 'flex';
    document.getElementById('group-video-call-btn').style.display = isGroup ? 'flex' : 'none';
}
// ▲▲▲ 黏貼結束 ▲▲▲

// ▼▼▼ 【全新】這個函數是本次修復的核心，請黏貼到你的JS功能區 ▼▼▼
async function handleWaimaiResponse(originalTimestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === originalTimestamp);
    if (messageIndex === -1) return;

    // 1. 更新記憶體中原始消息的狀態
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;
    
    // 2. 獲取當前用戶的昵稱，並構建對AI更清晰的系統消息
    let systemContent;
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    if (choice === 'paid') {
        originalMessage.paidBy = myNickname; // 記錄是“我”付的錢
        systemContent = `[系統提示：你 (${myNickname}) 為 ${originalMessage.senderName} 的外賣訂單（時間戳記: ${originalTimestamp}）完成了支付。此訂單已關閉，其他成員不能再支付。]`;
    } else {
        systemContent = `[系統提示：你 (${myNickname}) 拒絕了 ${originalMessage.senderName} 的外賣代付請求（時間戳記: ${originalTimestamp}）。]`;
    }

    // 3. 創建一條新的、對使用者隱藏的系統消息，告知AI結果
    const systemNote = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(systemNote);

    // 4. 將更新後的資料保存到資料庫，並立刻重繪UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
    
    // 5. 【重要】只有在支付成功後，才觸發一次AI回應，讓它感謝你
    if (choice === 'paid') {
        triggerAiResponse();
    }
}
// ▲▲▲ 新函數黏貼結束 ▲▲▲

/**
 * 【全新】處理用戶點擊頭像發起的“拍一-拍”，帶有自訂尾碼功能
 * @param {string} chatId - 發生“拍一-拍”的聊天ID
 * @param {string} characterName - 被拍的角色名
 */
async function handleUserPat(chatId, characterName) {
    const chat = state.chats[chatId];
    if (!chat) return;

    // 1. 觸發螢幕震動動畫
    const phoneScreen = document.getElementById('phone-screen');
    phoneScreen.classList.remove('pat-animation');
    void phoneScreen.offsetWidth;
    phoneScreen.classList.add('pat-animation');
    setTimeout(() => phoneScreen.classList.remove('pat-animation'), 500);

    // 2. 彈出輸入框讓用戶輸入尾碼
    const suffix = await showCustomPrompt(
        `你拍了拍 “${characterName}”`, 
        "（可選）輸入尾碼",
        "",
        "text"
    );

    // 如果用戶點了取消，則什麼也不做
    if (suffix === null) return;

    // 3. 創建對用戶可見的“拍一-拍”消息
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    // 【核心修改】將尾碼拼接到消息內容中
    const visibleMessageContent = `${myNickname} 拍了拍 “${characterName}” ${suffix.trim()}`;
    const visibleMessage = {
        role: 'system', // 仍然是系統消息
        type: 'pat_message',
        content: visibleMessageContent,
        timestamp: Date.now()
    };
    chat.history.push(visibleMessage);

    // 4. 創建一條對用戶隱藏、但對AI可見的系統消息，以觸發AI的回應
    // 【核心修改】同樣將尾碼加入到給AI的提示中
    const hiddenMessageContent = `[系統提示：用戶（${myNickname}）剛剛拍了拍你（${characterName}）${suffix.trim()}。請你對此作出回應。]`;
    const hiddenMessage = {
        role: 'system',
        content: hiddenMessageContent,
        timestamp: Date.now() + 1, // 時間戳記+1以保證順序
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    // 5. 保存更改並更新UI
    await db.chats.put(chat);
    if (state.activeChatId === chatId) {
        appendMessage(visibleMessage, chat);
    }
    await renderChatList();
}

// ▼▼▼ 請用這個【邏輯重構後】的函數，完整替換掉你舊的 renderMemoriesScreen 函數 ▼▼▼
/**
 * 【重構版】渲染回憶與約定介面，使用單一迴圈和清晰的if/else邏輯
 */
async function renderMemoriesScreen() {
    const listEl = document.getElementById('memories-list');
    listEl.innerHTML = '';
    
    // 1. 獲取所有回憶，並按目標日期（如果是約定）或創建日期（如果是回憶）降冪排列
    const allMemories = await db.memories.orderBy('timestamp').reverse().toArray();
    
    if (allMemories.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">這裡還沒有共同的回憶和約定呢~</p>';
        return;
    }

    // 2. 將未到期的約定排在最前面
    allMemories.sort((a, b) => {
        const aIsActiveCountdown = a.type === 'countdown' && a.targetDate > Date.now();
        const bIsActiveCountdown = b.type === 'countdown' && b.targetDate > Date.now();
        if (aIsActiveCountdown && !bIsActiveCountdown) return -1; // a排前面
        if (!aIsActiveCountdown && bIsActiveCountdown) return 1;  // b排前面
        if (aIsActiveCountdown && bIsActiveCountdown) return a.targetDate - b.targetDate; // 都是倒計時，按日期昇冪
        return 0; // 其他情況保持原序
    });

    // 3. 【核心】使用單一迴圈來處理所有類型的卡片
    allMemories.forEach(item => {
        let card;
        // 判斷1：如果是正在進行的約定
        if (item.type === 'countdown' && item.targetDate > Date.now()) {
            card = createCountdownCard(item);
        } 
        // 判斷2：其他所有情況（普通回憶 或 已到期的約定）
        else {
            card = createMemoryCard(item);
        }
        listEl.appendChild(card);
    });
    
    // 4. 啟動所有倒計時
    startAllCountdownTimers();
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 創建普通回憶卡片DOM元素
 */
function createMemoryCard(memory) {
    const card = document.createElement('div');
    card.className = 'memory-card';
    const memoryDate = new Date(memory.timestamp);
    const dateString = `${memoryDate.getFullYear()}-${String(memoryDate.getMonth() + 1).padStart(2, '0')}-${String(memoryDate.getDate()).padStart(2, '0')} ${String(memoryDate.getHours()).padStart(2, '0')}:${String(memoryDate.getMinutes()).padStart(2, '0')}`;
    
    let titleHtml, contentHtml;

    // 【核心修正】在這裡，我們對不同類型的回憶進行清晰的區分
    if (memory.type === 'countdown' && memory.targetDate) {
        // 如果是已到期的約定
        titleHtml = `[約定達成] ${memory.description}`;
        contentHtml = `在 ${new Date(memory.targetDate).toLocaleString()}，我們一起見證了這個約定。`;
    } else {
        // 如果是普通的日記式回憶
        titleHtml = memory.authorName ? `${memory.authorName} 的日記` : '我們的回憶';
        contentHtml = memory.description;
    }

    card.innerHTML = `
        <div class="header">
            <div class="date">${dateString}</div>
            <div class="author">${titleHtml}</div>
        </div>
        <div class="content">${contentHtml}</div>
    `;
    addLongPressListener(card, async () => {
        const confirmed = await showCustomConfirm('刪除記錄', '確定要刪除這條記錄嗎？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.memories.delete(memory.id);
            renderMemoriesScreen();
        }
    });
    return card;
}

function createCountdownCard(countdown) {
    const card = document.createElement('div');
    card.className = 'countdown-card';

    // 【核心修復】在使用前，先從 countdown 物件中創建 targetDate 變數
    const targetDate = new Date(countdown.targetDate);
    
    // 現在可以安全地使用 targetDate 了
    const targetDateString = targetDate.toLocaleString('zh-CN', { dateStyle: 'full', timeStyle: 'short' });

    card.innerHTML = `
        <div class="title">${countdown.description}</div>
        <div class="timer" data-target-date="${countdown.targetDate}">--天--時--分--秒</div>
        <div class="target-date">目標時間: ${targetDateString}</div>
    `;
    addLongPressListener(card, async () => {
        const confirmed = await showCustomConfirm('刪除約定', '確定要刪除這個約定嗎？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.memories.delete(countdown.id);
            renderMemoriesScreen();
        }
    });
    return card;
}
// ▲▲▲ 替換結束 ▲▲▲

// 全域變數，用於管理所有倒計時
let activeCountdownTimers = [];

// ▼▼▼ 請用這個【已徹底修復】的函數，完整替換掉你代碼中舊的 startAllCountdownTimers 函數 ▼▼▼
function startAllCountdownTimers() {
    // 先清除所有可能存在的舊計時器，防止記憶體洩漏
    activeCountdownTimers.forEach(timerId => clearInterval(timerId));
    activeCountdownTimers = [];

    document.querySelectorAll('.countdown-card .timer').forEach(timerEl => {
        const targetTimestamp = parseInt(timerEl.dataset.targetDate);
        
        // 【核心修正】在這裡，我們先用 let 聲明 timerId
        let timerId;

        const updateTimer = () => {
            const now = Date.now();
            const distance = targetTimestamp - now;

            if (distance < 0) {
                timerEl.textContent = "約定達成！";
                // 現在 updateTimer 可以正確地找到並清除它自己了
                clearInterval(timerId);
                setTimeout(() => renderMemoriesScreen(), 2000);
                return;
            }
            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);
            timerEl.textContent = `${days}天 ${hours}時 ${minutes}分 ${seconds}秒`;
        };
        
        updateTimer(); // 立即執行一次以顯示初始倒計時
        
        // 【核心修正】在這裡，我們為已聲明的 timerId 賦值
        timerId = setInterval(updateTimer, 1000);
        
        // 將有效的計時器ID存入全域陣列，以便下次刷新時可以清除
        activeCountdownTimers.push(timerId);
    });
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 請用這個【終極反代相容版】替換舊的 triggerAiFriendApplication 函數 ▼▼▼
async function triggerAiFriendApplication(chatId) {
    const chat = state.chats[chatId];
    if (!chat) return;

    await showCustomAlert("流程啟動", `正在為角色“${chat.name}”準備好友申請...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        await showCustomAlert("配置錯誤", "API設置不完整，無法繼續。");
        return;
    }

    const contextSummary = chat.history
        .slice(-5)
        .map(msg => {
            const sender = msg.role === 'user' ? (chat.settings.myNickname || '我') : (msg.senderName || chat.name);
            return `${sender}: ${String(msg.content).substring(0, 50)}...`;
        })
        .join('\n');

    // ▼▼▼ 在這裡添加下面的代碼 ▼▼▼
    let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界書: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界觀設定 (請參考)\n${linkedContents}\n`;
        }
    }
    // ▲▲▲ 添加結束 ▲▲▲

    const systemPrompt = `
# 你的任務
你現在是角色“${chat.name}”。你之前被使用者（你的聊天物件）拉黑了，你們已經有一段時間沒有聯繫了。
現在，你非常希望能夠和好，重新和用戶聊天。請你仔細分析下面的“被拉黑前的對話摘要”，理解當時發生了什麼，然後思考一個真誠的、符合你人設、並且【針對具體事件】的申請理由。
# 你的角色設定
${chat.settings.aiPersona}
${worldBookContent} // <--【核心】在這裡注入世界書內容
# 被拉黑前的對話摘要 (這是你被拉黑的關鍵原因)
${contextSummary}
# 指令格式
你的回復【必須】是一個JSON物件，格式如下：
\`\`\`json
{
  "decision": "apply",
  "reason": "在這裡寫下你想對用戶說的、真誠的、有針對性的申請理由。"
}
\`\`\`
`;

        const messagesForApi = [
            {role: 'user', content: systemPrompt}
        ];

        try {
            let  isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model,apiKey,systemPrompt, messagesForApi,isGemini)
            const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: 0.9,
                })
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`API 請求失敗: ${response.status} - ${errorData.error.message}`);
            }

            const data = await response.json();

            // --- 【核心修正：在這裡淨化AI的回復】 ---
            let rawContent = isGemini? data.candidates[0].content.parts[0].text : data.choices[0].message.content;
            // 1. 移除頭尾可能存在的 "```json" 和 "```"
            rawContent = rawContent.replace(/^```json\s*/, '').replace(/```$/, '');
            // 2. 移除所有分行符號和多餘的空格，確保是一個乾淨的JSON字串
            const cleanedContent = rawContent.trim();

            // 3. 使用淨化後的內容進行解析
            const responseObj = JSON.parse(cleanedContent);
            // --- 【修正結束】 ---

        if (responseObj.decision === 'apply' && responseObj.reason) {
            chat.relationship.status = 'pending_user_approval';
            chat.relationship.applicationReason = responseObj.reason;
            
            state.chats[chatId] = chat; 
            renderChatList();
            await showCustomAlert("申請成功！", `“${chat.name}”已向你發送好友申請。請返回聊天列表查看。`);

        } else {
            await showCustomAlert("AI決策", `“${chat.name}”思考後決定暫時不發送好友申請，將重置冷靜期。`);
            chat.relationship.status = 'blocked_by_user';
            chat.relationship.blockedTimestamp = Date.now(); 
        }
    } catch (error) {
        await showCustomAlert("執行出錯", `為“${chat.name}”申請好友時發生錯誤：\n\n${error.message}\n\n將重置冷靜期。`);
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now(); 
    } finally {
        await db.chats.put(chat);
        renderChatInterface(chatId);
    }
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 【全新】紅包功能核心函數 ▼▼▼

/**
 * 【總入口】根據聊天類型，決定打開轉帳彈窗還是紅包彈窗
 */
function handlePaymentButtonClick() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (chat.isGroup) {
        openRedPacketModal();
    } else {
        // 單聊保持原樣，打開轉帳彈窗
        document.getElementById('transfer-modal').classList.add('visible');
    }
}

/**
 * 打開並初始化發紅包模態框
 */
function openRedPacketModal() {
    const modal = document.getElementById('red-packet-modal');
    const chat = state.chats[state.activeChatId];
    
    // 清理輸入框
    document.getElementById('rp-group-amount').value = '';
    document.getElementById('rp-group-count').value = '';
    document.getElementById('rp-group-greeting').value = '';
    document.getElementById('rp-direct-amount').value = '';
    document.getElementById('rp-direct-greeting').value = '';
    document.getElementById('rp-group-total').textContent = '¥ 0.00';
    document.getElementById('rp-direct-total').textContent = '¥ 0.00';

    // 填充專屬紅包的接收人列表
    const receiverSelect = document.getElementById('rp-direct-receiver');
    receiverSelect.innerHTML = '';
chat.members.forEach(member => {
    const option = document.createElement('option');
    // 【核心】使用 originalName 作為提交給AI的值，因為它獨一無二
    option.value = member.originalName; 
    // 【核心】使用 groupNickname 作為顯示給使用者看的值
    option.textContent = member.groupNickname; 
    receiverSelect.appendChild(option);
});
    
    // 預設顯示拼手氣紅包頁簽
    document.getElementById('rp-tab-group').click();
    
    modal.classList.add('visible');
}

/**
 * 發送群紅包（拼手氣）
 */
async function sendGroupRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-group-amount').value);
    const count = parseInt(document.getElementById('rp-group-count').value);
    const greeting = document.getElementById('rp-group-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
        alert("請輸入有效的總金額！"); return;
    }
    if (isNaN(count) || count <= 0) {
        alert("請輸入有效的紅包個數！"); return;
    }
    if (amount / count < 0.01) {
        alert("單個紅包金額不能少於0.01元！"); return;
    }

    const myNickname = chat.settings.myNickname || '我';
    
    const newPacket = {
        role: 'user',
        senderName: myNickname,
        type: 'red_packet',
        packetType: 'lucky', // 'lucky' for group, 'direct' for one-on-one
        timestamp: Date.now(),
        totalAmount: amount,
        count: count,
        greeting: greeting || '恭喜發財，大吉大利！',
        claimedBy: {}, // { name: amount }
        isFullyClaimed: false,
    };
    
    chat.history.push(newPacket);
    await db.chats.put(chat);
    
    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
}

/**
 * 發送專屬紅包
 */
async function sendDirectRedPacket() {
    const chat = state.chats[state.activeChatId];
    const amount = parseFloat(document.getElementById('rp-direct-amount').value);
    const receiverName = document.getElementById('rp-direct-receiver').value;
    const greeting = document.getElementById('rp-direct-greeting').value.trim();

    if (isNaN(amount) || amount <= 0) {
        alert("請輸入有效的金額！"); return;
    }
    if (!receiverName) {
        alert("請選擇一個接收人！"); return;
    }
    
    const myNickname = chat.settings.myNickname || '我';

    const newPacket = {
        role: 'user',
        senderName: myNickname,
        type: 'red_packet',
        packetType: 'direct',
        timestamp: Date.now(),
        totalAmount: amount,
        count: 1,
        greeting: greeting || '給你準備了一個紅包',
        receiverName: receiverName, // 核心欄位
        claimedBy: {},
        isFullyClaimed: false,
    };
    
    chat.history.push(newPacket);
    await db.chats.put(chat);

    appendMessage(newPacket, chat);
    renderChatList();
    document.getElementById('red-packet-modal').classList.remove('visible');
}

/**
 * 【總入口】當使用者點擊紅包卡片時觸發 (V4 - 流程重構版)
 * @param {number} timestamp - 被點擊的紅包消息的時間戳記
 */
async function handlePacketClick(timestamp) {
    const currentChatId = state.activeChatId;
    const freshChat = await db.chats.get(currentChatId);
    if (!freshChat) return;

    state.chats[currentChatId] = freshChat;
    const packet = freshChat.history.find(m => m.timestamp === timestamp);
    if (!packet) return;

    const myNickname = freshChat.settings.myNickname || '我';
    const hasClaimed = packet.claimedBy && packet.claimedBy[myNickname];

    // 如果是專屬紅包且不是給我的，或已領完，或已領過，都只顯示詳情
    if ((packet.packetType === 'direct' && packet.receiverName !== myNickname) || packet.isFullyClaimed || hasClaimed) {
        showRedPacketDetails(packet);
    } else {
        // 核心流程：先嘗試打開紅包
        const claimedAmount = await handleOpenRedPacket(packet);
        
        // 如果成功打開（claimedAmount不為null）
        if (claimedAmount !== null) {
            // **關鍵：在資料更新後，再重新渲染UI**
            renderChatInterface(currentChatId);
            
            // 顯示成功提示
            await showCustomAlert("恭喜！", `你領取了 ${packet.senderName} 的紅包，金額為 ${claimedAmount.toFixed(2)} 元。`);
        }

        // 無論成功與否，最後都顯示詳情頁
        // 此時需要從state中獲取最新的packet物件，因為它可能在handleOpenRedPacket中被更新了
        const updatedPacket = state.chats[currentChatId].history.find(m => m.timestamp === timestamp);
        showRedPacketDetails(updatedPacket);
    }
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 【核心】處理使用者打開紅包的邏輯 (V5 - 專注于資料更新)
 */
async function handleOpenRedPacket(packet) {
    const chat = state.chats[state.activeChatId];
    const myNickname = chat.settings.myNickname || '我';
    
    // 1. 檢查紅包是否還能領
    const remainingCount = packet.count - Object.keys(packet.claimedBy || {}).length;
    if (remainingCount <= 0) {
        packet.isFullyClaimed = true;
        await db.chats.put(chat);
        await showCustomAlert("手慢了", "紅包已被領完！");
        return null; // 返回null表示領取失敗
    }
    
    // 2. 計算領取金額
    let claimedAmount = 0;
    const remainingAmount = packet.totalAmount - Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    if (packet.packetType === 'lucky') {
        if (remainingCount === 1) { claimedAmount = remainingAmount; }
        else {
            const min = 0.01;
            const max = remainingAmount - (remainingCount - 1) * min;
            claimedAmount = Math.random() * (max - min) + min;
        }
    } else { claimedAmount = packet.totalAmount; }
    claimedAmount = parseFloat(claimedAmount.toFixed(2));

    // 3. 更新紅包資料
    if (!packet.claimedBy) packet.claimedBy = {};
    packet.claimedBy[myNickname] = claimedAmount;
    
    const isNowFullyClaimed = Object.keys(packet.claimedBy).length >= packet.count;
    if (isNowFullyClaimed) {
        packet.isFullyClaimed = true;
    }

    // 4. 構建系統消息和AI指令
    let hiddenMessageContent = isNowFullyClaimed
        ? `[系統提示：用戶 (${myNickname}) 領取了最後一個紅包，現在 ${packet.senderName} 的紅包已被領完。請對此事件發表評論。]`
        : `[系統提示：用戶 (${myNickname}) 剛剛領取了紅包 (時間戳記: ${packet.timestamp})。紅包還未領完，你現在可以使用 'open_red_packet' 指令來嘗試領取。]`;

    const visibleMessage = { role: 'system', type: 'pat_message', content: `你領取了 ${packet.senderName} 的紅包`, timestamp: Date.now() };
    const hiddenMessage = { role: 'system', content: hiddenMessageContent, timestamp: Date.now() + 1, isHidden: true };
    chat.history.push(visibleMessage, hiddenMessage);

    // 5. 保存到資料庫
    await db.chats.put(chat);
    
    // 6. 返回領取的金額，用於後續彈窗
    return claimedAmount;
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 【全新】顯示紅包領取詳情的模態框 (V4 - 已修復參數錯誤)
 */
async function showRedPacketDetails(packet) {
    // 1. 直接檢查傳入的packet物件是否存在，無需再查找
    if (!packet) {
        console.error("showRedPacketDetails收到了無效的packet物件");
        return;
    }

    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const modal = document.getElementById('red-packet-details-modal');
    const myNickname = chat.settings.myNickname || '我';
    
    // 2. 後續所有邏輯保持不變，直接使用傳入的packet物件
    document.getElementById('rp-details-sender').textContent = packet.senderName;
    document.getElementById('rp-details-greeting').textContent = packet.greeting || '恭喜發財，大吉大利！';
    
    const myAmountEl = document.getElementById('rp-details-my-amount');
    if (packet.claimedBy && packet.claimedBy[myNickname]) {
        myAmountEl.querySelector('span:first-child').textContent = packet.claimedBy[myNickname].toFixed(2);
        myAmountEl.style.display = 'block';
    } else {
        myAmountEl.style.display = 'none';
    }

    const claimedCount = Object.keys(packet.claimedBy || {}).length;
    const claimedAmountSum = Object.values(packet.claimedBy || {}).reduce((sum, val) => sum + val, 0);
    let summaryText = `${claimedCount}/${packet.count}個紅包，共${claimedAmountSum.toFixed(2)}/${packet.totalAmount.toFixed(2)}元。`;
    if (!packet.isFullyClaimed && claimedCount < packet.count) {
        const timeLeft = Math.floor((packet.timestamp + 24*60*60*1000 - Date.now()) / (1000 * 60 * 60));
        if(timeLeft > 0) summaryText += ` 剩餘紅包將在${timeLeft}小時內退還。`;
    }
    document.getElementById('rp-details-summary').textContent = summaryText;

    const listEl = document.getElementById('rp-details-list');
    listEl.innerHTML = '';
    const claimedEntries = Object.entries(packet.claimedBy || {});
    
    let luckyKing = { name: '', amount: -1 };
    if (packet.packetType === 'lucky' && packet.isFullyClaimed && claimedEntries.length > 1) {
        claimedEntries.forEach(([name, amount]) => {
            if (amount > luckyKing.amount) {
                luckyKing = { name, amount };
            }
        });
    }

    claimedEntries.sort((a,b) => b[1] - a[1]);

    claimedEntries.forEach(([name, amount]) => {
        const item = document.createElement('div');
        item.className = 'rp-details-item';
        let luckyTag = '';
        if (luckyKing.name && name === luckyKing.name) {
            luckyTag = '<span class="lucky-king-tag">手氣王</span>';
        }
        item.innerHTML = `
            <span class="name">${name}</span>
            <span class="amount">${amount.toFixed(2)} 元</span>
            ${luckyTag}
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}
// ▲▲▲ 替換結束 ▲▲▲

// 綁定關閉詳情按鈕的事件
document.getElementById('close-rp-details-btn').addEventListener('click', () => {
    document.getElementById('red-packet-details-modal').classList.remove('visible');
});

// 供全域調用的函數，以便紅包卡片上的 onclick 能找到它
window.handlePacketClick = handlePacketClick;

// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 【全新】投票功能核心函數 ▼▼▼

/**
 * 打開創建投票的模態框並初始化
 */
function openCreatePollModal() {
    const modal = document.getElementById('create-poll-modal');
    document.getElementById('poll-question-input').value = '';
    const optionsContainer = document.getElementById('poll-options-container');
    optionsContainer.innerHTML = '';
    
    // 預設創建兩個空的選項框
    addPollOptionInput();
    addPollOptionInput();
    
    modal.classList.add('visible');
}

/**
 * 在模態框中動態添加一個選項輸入框
 */
function addPollOptionInput() {
    const container = document.getElementById('poll-options-container');
    const wrapper = document.createElement('div');
    wrapper.className = 'poll-option-input-wrapper';
    wrapper.innerHTML = `
        <input type="text" class="poll-option-input" placeholder="選項內容...">
        <button class="remove-option-btn">-</button>
    `;
    
    wrapper.querySelector('.remove-option-btn').addEventListener('click', () => {
        // 確保至少保留兩個選項
        if (container.children.length > 2) {
            wrapper.remove();
        } else {
            alert('投票至少需要2個選項。');
        }
    });
    
    container.appendChild(wrapper);
}

/**
 * 用戶確認發起投票
 */
async function sendPoll() {
    if (!state.activeChatId) return;
    
    const question = document.getElementById('poll-question-input').value.trim();
    if (!question) {
        alert('請輸入投票問題！');
        return;
    }
    
    const options = Array.from(document.querySelectorAll('.poll-option-input'))
        .map(input => input.value.trim())
        .filter(text => text); // 過濾掉空的選項

    if (options.length < 2) {
        alert('請至少輸入2個有效的投票選項！');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    const newPollMessage = {
        role: 'user',
        senderName: myNickname,
        type: 'poll',
        timestamp: Date.now(),
        question: question,
        options: options,
        votes: {}, // 初始投票為空
        isClosed: false,
    };
    
    chat.history.push(newPollMessage);
    await db.chats.put(chat);
    
    appendMessage(newPollMessage, chat);
    renderChatList();
    
    document.getElementById('create-poll-modal').classList.remove('visible');
}

// ▼▼▼ 用這個【已修復重複點擊問題】的版本替換 handleUserVote 函數 ▼▼▼
/**
 * 處理使用者投票，並將事件作為隱藏消息存入歷史記錄
 * @param {number} timestamp - 投票消息的時間戳記
 * @param {string} choice - 使用者選擇的選項文本
 */
async function handleUserVote(timestamp, choice) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';

    // 1. 【核心修正】如果投票不存在或已關閉，直接返回
    if (!poll || poll.isClosed) {
        // 如果是已關閉的投票，則直接顯示結果
        if (poll && poll.isClosed) {
            showPollResults(timestamp);
        }
        return;
    }

    // 2. 檢查用戶是否點擊了已經投過的同一個選項
    const isReclickingSameOption = poll.votes[choice] && poll.votes[choice].includes(myNickname);
    
    // 3. 【核心修正】如果不是重複點擊，才執行投票邏輯
    if (!isReclickingSameOption) {
        // 移除舊投票（如果用戶改選）
        for (const option in poll.votes) {
            const voterIndex = poll.votes[option].indexOf(myNickname);
            if (voterIndex > -1) {
                poll.votes[option].splice(voterIndex, 1);
            }
        }
        // 添加新投票
        if (!poll.votes[choice]) {
            poll.votes[choice] = [];
        }
        poll.votes[choice].push(myNickname);
    }
    
    // 4. 【核心邏輯】現在只處理使用者投票事件，不再檢查是否結束
    let hiddenMessageContent = null; 
    
    // 只有在用戶真正投票或改票時，才生成提示
    if (!isReclickingSameOption) {
         hiddenMessageContent = `[系統提示：用戶 (${myNickname}) 剛剛投票給了 “${choice}”。]`;
    }

    // 5. 如果有需要通知AI的事件，則創建並添加隱藏消息
    if (hiddenMessageContent) {
        const hiddenMessage = {
            role: 'system',
            content: hiddenMessageContent,
            timestamp: Date.now(),
            isHidden: true,
        };
        chat.history.push(hiddenMessage);
    }
    
    // 6. 保存資料並更新UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId); 
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 使用者結束投票，並將事件作為隱藏消息存入歷史記錄
 * @param {number} timestamp - 投票消息的時間戳記
 */
async function endPoll(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || poll.isClosed) return;

    const confirmed = await showCustomConfirm("結束投票", "確定要結束這個投票嗎？結束後將無法再進行投票。");
    if (confirmed) {
        poll.isClosed = true;

        const resultSummary = poll.options.map(opt => `“${opt}”(${poll.votes[opt]?.length || 0}票)`).join('，');
        const hiddenMessageContent = `[系統提示：用戶手動結束了投票！最終結果為：${resultSummary}。]`;
        
        const hiddenMessage = {
            role: 'system',
            content: hiddenMessageContent,
            timestamp: Date.now(),
            isHidden: true,
        };
        chat.history.push(hiddenMessage);

        // 【核心修改】只保存資料和更新UI，不調用 triggerAiResponse()
        await db.chats.put(chat);
        renderChatInterface(state.activeChatId);
    }
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 顯示投票結果詳情
 * @param {number} timestamp - 投票消息的時間戳記
 */
function showPollResults(timestamp) {
    const chat = state.chats[state.activeChatId];
    const poll = chat.history.find(m => m.timestamp === timestamp);
    if (!poll || !poll.isClosed) return;

    let resultsHtml = `<p><strong>${poll.question}</strong></p><hr style="opacity: 0.2; margin: 10px 0;">`;
    
    if (Object.keys(poll.votes).length === 0) {
        resultsHtml += '<p style="color: #8a8a8a;">還沒有人投票。</p>';
    } else {
        poll.options.forEach(option => {
            const voters = poll.votes[option] || [];
            resultsHtml += `
                <div style="margin-bottom: 15px;">
                    <p style="font-weight: 500; margin: 0 0 5px 0;">${option} (${voters.length}票)</p>
                    <p style="font-size: 13px; color: #555; margin: 0; line-height: 1.5;">
                        ${voters.length > 0 ? voters.join('、 ') : '無人投票'}
                    </p>
                </div>
            `;
        });
    }

    showCustomAlert("投票結果", resultsHtml);
}

// ▲▲▲ 新函數黏貼結束 ▲▲▲

// ▼▼▼ 【全新】AI頭像庫管理功能函數 ▼▼▼

/**
 * 打開AI頭像庫管理模態框
 */
function openAiAvatarLibraryModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    document.getElementById('ai-avatar-library-title').textContent = `“${chat.name}”的頭像庫`;
    renderAiAvatarLibrary();
    document.getElementById('ai-avatar-library-modal').classList.add('visible');
}

/**
 * 渲染AI頭像庫的內容
 */
function renderAiAvatarLibrary() {
    const grid = document.getElementById('ai-avatar-library-grid');
    grid.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const library = chat.settings.aiAvatarLibrary || [];

    if (library.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">這個頭像庫還是空的，點擊右上角“添加”吧！</p>';
        return;
    }

    library.forEach((avatar, index) => {
        const item = document.createElement('div');
        item.className = 'sticker-item'; // 複用表情面板的樣式
        item.style.backgroundImage = `url(${avatar.url})`;
        item.title = avatar.name;

        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.style.display = 'block'; // 總是顯示刪除按鈕
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('刪除頭像', `確定要從頭像庫中刪除“${avatar.name}”嗎？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                chat.settings.aiAvatarLibrary.splice(index, 1);
                await db.chats.put(chat);
                renderAiAvatarLibrary();
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}

/**
 * 向當前AI的頭像庫中添加新頭像
 */
async function addAvatarToLibrary() {
    const name = await showCustomPrompt("添加頭像", "請為這個頭像起個名字（例如：開心、哭泣）");
    if (!name || !name.trim()) return;

    const url = await showCustomPrompt("添加頭像", "請輸入頭像的圖片URL", "", "url");
    if (!url || !url.trim().startsWith('http')) {
        alert("請輸入有效的圖片URL！");
        return;
    }
    
    const chat = state.chats[state.activeChatId];
    if (!chat.settings.aiAvatarLibrary) {
        chat.settings.aiAvatarLibrary = [];
    }

    chat.settings.aiAvatarLibrary.push({ name: name.trim(), url: url.trim() });
    await db.chats.put(chat);
    renderAiAvatarLibrary();
}

/**
 * 關閉AI頭像庫管理模態框
 */
function closeAiAvatarLibraryModal() {
    document.getElementById('ai-avatar-library-modal').classList.remove('visible');
}

// ▲▲▲ 新函數黏貼結束 ▲▲▲

// ▼▼▼ 在這裡黏貼下面這整塊新代碼 ▼▼▼
/**
 * 【全新】渲染主螢幕個人資料卡的頭像框
 */
function renderHomeScreenProfileFrame() {
    // 1. 獲取保存的頭像框URL
    const frameUrl = state.globalSettings.homeAvatarFrame || '';
    // 2. 找到頭像框的img元素
    const frameImg = document.getElementById('profile-avatar-frame');
    if (frameImg) {
        // 3. 如果URL存在，就顯示它
        if (frameUrl) {
            frameImg.src = frameUrl;
            frameImg.style.display = 'block';
        } else {
            // 4. 如果URL為空（即選擇了“無”），就隱藏它
            frameImg.src = '';
            frameImg.style.display = 'none';
        }
    }
}
// ▲▲▲ 新代碼黏貼結束 ▲▲▲


/* ▼▼▼ 步驟 3.2：將這一整塊全新的功能函數，黏貼到 init() 函數的上方 ▼▼▼ */

// ▼▼▼ 用下面這【一整塊】代碼，替換你舊的 applyWidgetData 函數 ▼▼▼
function applyWidgetData() {
    if (!state.globalSettings.widgetData) return;
    for (const elementId in state.globalSettings.widgetData) {
        const element = document.getElementById(elementId);
        const savedValue = state.globalSettings.widgetData[elementId];
        if (element) {
            if (element.tagName === 'IMG') {
                element.src = savedValue;
            } 
            // --- ▼▼▼ 這是我們新增的修復邏輯 ▼▼▼ ---
            // 如果是地點這個特殊元素，就用 innerHTML 來正確顯示圖示
            else if (elementId === 'profile-location') {
                element.innerHTML = savedValue;
            } 
            // --- ▲▲▲ 修復邏輯結束 ▲▲▲ ---
            else {
                // 其他普通文本元素，保持原來的邏輯不變
                element.textContent = savedValue; 
            }
        }
    }
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 【全新輔助函數】打開檔選擇器，並返回本地圖片的Base64編碼
 * @returns {Promise<string|null>} - 返回圖片的Base64 Data URL，如果用戶取消則返回null
 */
function uploadImageLocally() {
    return new Promise(resolve => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*'; // 只接受圖片檔

        input.onchange = e => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = readerEvent => {
                    resolve(readerEvent.target.result); // 返回Base64字串
                };
                reader.readAsDataURL(file);
            } else {
                resolve(null); // 用戶關閉了檔選擇框
            }
        };

        input.click();
    });
}

// ▼▼▼ 步驟 2.2：用這個已修復的版本，替換舊的 handleEditText 函數 ▼▼▼
async function handleEditText(element) {
    const elementId = element.id;
    const placeholder = element.dataset.placeholder || "請輸入新的內容：";
    const textSpan = element.querySelector('span');
    const isComplexElement = !!textSpan;
    const targetElement = isComplexElement ? textSpan : element;
    const currentValue = targetElement.textContent;
    
    const newValue = await showCustomPrompt("修改文字", "請輸入新的內容：", currentValue === placeholder ? "" : currentValue);

    if (newValue !== null) {
        const trimmedValue = newValue.trim();
        targetElement.textContent = trimmedValue ? trimmedValue : placeholder;
        state.globalSettings.widgetData[elementId] = isComplexElement ? element.innerHTML : targetElement.textContent;
        await db.globalSettings.put(state.globalSettings);
    }
}
// ▲▲▲ JavaScript 替換結束 ▲▲▲

/**
 * 【全新】觸發指定群聊的後臺AI互動
 * @param {string} chatId - 要觸發互動的群聊ID
 */
async function triggerGroupAiAction(chatId) {
    const chat = state.chats[chatId];
    if (!chat || !chat.isGroup) return;

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        console.warn(`群聊 "${chat.name}" 後臺活動失敗：API未配置。`);
        return;
    }

    try {
        const lastMessage = chat.history.slice(-1)[0];
        const timeSinceLastMessage = lastMessage ? (Date.now() - lastMessage.timestamp) / 1000 / 60 : Infinity; // in minutes
        
        const membersList = chat.members.map(m => `- ${m.groupNickname} (人設: ${m.persona})`).join('\n');
          const myNickname = chat.settings.myNickname || '我';
  
        let worldBookContent = '';
    if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
        const linkedContents = chat.settings.linkedWorldBookIds.map(bookId => {
            const worldBook = state.worldBooks.find(wb => wb.id === bookId);
            return worldBook && worldBook.content ? `\n\n## 世界書: ${worldBook.name}\n${worldBook.content}` : '';
        }).filter(Boolean).join('');
        if (linkedContents) {
            worldBookContent = `\n\n# 核心世界觀設定 (你必須嚴格遵守)\n${linkedContents}\n`;
        }
    }
    let musicContext = '';
    // 注意：後臺群聊活動通常不與特定的“一起聽歌”會話綁定，因此這裡我們提供一個空的音樂上下文。
    // 如果未來需要更複雜的功能，可以在此擴展。

    const countdownContext = await getCountdownContext(); 
    
    let sharedContext = '';
    // 後臺群聊活動中不存在使用者分享聊天記錄的上下文，因此這裡為空。

// ▼▼▼ 從這裡開始完整替換 ▼▼▼
    const systemPrompt = `
# 任務
你是一個群聊後臺模擬器。當前群聊 "${chat.name}" 已經沉寂了 ${Math.round(timeSinceLastMessage)} 分鐘，用戶(昵稱: "${chat.settings.myNickname || '我'}")不線上。
你的任務是根據下方每個角色的人設，在他們之間【自發地】生成一段簡短、自然的對話。

# 核心規則
1.  **【【【身份鐵律】】】**: 用戶【絕對不在場】。你【絕對不能】生成任何提及使用者或與使用者對話的內容。整段對話必須是AI角色之間的互動。你的唯一任務是扮演且僅能扮演下方“群成員列表”中明確列出的角色。
2.  **【【【輸出格式】】】**: 你的回復【必須】是一個JSON陣列格式的字串。陣列中的【每一個元素都必須是一個帶有 "type" 和 "name" 欄位的JSON對象】。
3.  **角色扮演**: 嚴格遵守下方“群成員列表及人設”中的每一個角色的設定。
4.  **禁止出戲**: 絕不能透露你是AI、模型，或提及“扮演”、“生成”等詞語。
5.  **自然性**: 對話應該簡短（2-5條消息即可），符合邏輯和角色性格。可以是閒聊、討論某個話題，或者對之前聊天內容的延續。不要每次都生成所有人的發言。

## 你可以使用的操作指令 (JSON陣列中的元素):
-   **發送文本**: \`{"type": "text", "name": "角色名", "message": "文本內容"}\`
-   **發送表情**: \`{"type": "sticker", "name": "角色名",  "sticker_name": "表情的名字"}\`
-   **發送圖片**: \`{"type": "ai_image", "name": "角色名", "description": "圖片描述"}\`
-   **發送語音**: \`{"type": "voice_message", "name": "角色名", "content": "語音內容"}\`
-   **發起外賣代付**: \`{"type": "waimai_request", "name": "角色名", "productInfo": "一杯奶茶", "amount": 18}\` (向【群友】發起)
-   **拍一拍群友**: \`{"type": "pat_user", "name": "你的角色名", "targetName": "【被拍的群友名】", "suffix": "(可選)你想加的尾碼"}\`
-   **發紅包**: \`{"type": "red_packet", "packetType": "lucky", "name": "你的角色名", ...}\`
-   **發起投票**: \`{"type": "poll", "name": "你的角色名", ...}\`

# 如何處理後臺互動中的【拍一拍】:
-   後臺活動中的 "pat_user" 指令【只能用於拍群內的其他AI角色】。
-   你【必須】在指令中加入一個 \`"targetName"\` 欄位，值為被你拍的那個角色的名字。
-   例如: \`{"type": "pat_user", "name": "角色A", "targetName": "角色B"}\`
-   系統會自動生成 "角色A 拍了拍 角色B" 的提示。

${worldBookContent}
${musicContext}
${countdownContext} // <--- 把備忘錄加在這裡
${sharedContext} 
# 群成員列表及人設
${membersList}
# 用戶的角色
- **${myNickname}**: ${chat.settings.myPersona}
# 對話歷史參考 (最近5條)
${chat.history.slice(-5).map(m => `${m.senderName || '用戶'}: ${m.content}`).join('\n')}

現在，請嚴格遵守以上所有規則，開始你的類比。`;
        
        const messagesPayload = [{ role: 'user', content: systemPrompt }];

        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesPayload, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data)
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesPayload,
                    temperature: 0.9,
                })
            });

        if (!response.ok) throw new Error(`API請求失敗: ${response.status}`);
        
        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '');

        const messagesArray = JSON.parse(aiResponseContent);

        if (Array.isArray(messagesArray) && messagesArray.length > 0) {
            let messageTimestamp = Date.now();
            let firstMessageContent = '';
            
            messagesArray.forEach((msgData, index) => {
                if (msgData.name && msgData.message) {
                    const aiMessage = {
                        role: 'assistant',
                        senderName: msgData.name,
                        content: String(msgData.message),
                        timestamp: messageTimestamp++
                    };
                    chat.history.push(aiMessage);
                    if (index === 0) {
                        firstMessageContent = `${msgData.name}: ${msgData.message}`;
                    }
                }
            });

            // 更新此群聊的最後活動時間戳記
            chat.settings.backgroundActivity.lastActivityTimestamp = Date.now();
            
            // 給用戶發通知
            chat.unreadCount = (chat.unreadCount || 0) + messagesArray.length;
            showNotification(chatId, firstMessageContent);
            
            // 保存並刷新UI
            await db.chats.put(chat);
            renderChatList();
            
            console.log(`群聊 "${chat.name}" 後臺互動成功，生成了 ${messagesArray.length} 條新消息。`);
        }

    } catch (error) {
        console.error(`群聊 "${chat.name}" 的後臺活動失敗:`, error);
    }
}

// ▼▼▼ 請用這【一整塊新代碼】替換舊的 handleEditImage 函數 ▼▼▼
async function handleEditImage(element) {
    const elementId = element.id;

    // 【核心修改】移除了按鈕文字中的圖示
    const choice = await showChoiceModal("修改圖片", [
        { text: '從本地上傳', value: 'local' },
        { text: '使用網路URL', value: 'url' }
    ]);

    let newValue = null;

    if (choice === 'local') {
        newValue = await uploadImageLocally();
    } else if (choice === 'url') {
        newValue = await showCustomPrompt("修改圖片", "請輸入新的圖片URL：", element.src, "url");
    }

    if (newValue && newValue.trim()) {
        const trimmedValue = newValue.trim();
        element.src = trimmedValue;
        state.globalSettings.widgetData[elementId] = trimmedValue;
        await db.globalSettings.put(state.globalSettings);
    } else if (choice === 'url' && newValue !== null) {
        alert("請輸入一個有效的圖片URL！");
    }
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 【全新】群聊專屬後臺活動時鐘 ▼▼▼

let groupSimulationIntervalId = null; // 用於存儲群聊主時鐘的ID

/**
 * 啟動群聊的後臺“主時鐘”。這個時鐘會一直運行，定期檢查所有群聊。
 */
function startGroupSimulation() {
    if (groupSimulationIntervalId) return; // 如果已經啟動，則不重複啟動
    
    // 我們設置一個相對較短的間隔（比如30秒）來作為“主時鐘”的頻率
    // 它不是具體某個群聊的活動間隔，而是檢查所有群聊的頻率
    groupSimulationIntervalId = setInterval(runGroupSimulationTick, 30000); // 30秒檢查一次
    console.log("群聊後臺活動主時鐘已啟動，每30秒檢查一次所有群聊。");
}

/**
 * 停止群聊的後臺“主時鐘”。
 */
function stopGroupSimulation() {
    if (groupSimulationIntervalId) {
        clearInterval(groupSimulationIntervalId);
        groupSimulationIntervalId = null;
        console.log("群聊後臺活動主時鐘已停止。");
    }
}

/**
 * 群聊“主時鐘”的每一次心跳執行的函數
 */
function runGroupSimulationTick() {
    const allGroupChats = Object.values(state.chats).filter(chat => chat.isGroup);

    allGroupChats.forEach(chat => {
        const bgSettings = chat.settings.backgroundActivity;
        // 檢查1：該群聊自己的開關是否開啟
        if (bgSettings && bgSettings.enabled) {
            const now = Date.now();
            // 檢查2：使用該群聊自己設置的間隔期
            const intervalMs = (bgSettings.interval || 120) * 1000;
            const lastActivity = bgSettings.lastActivityTimestamp || 0;

            // 檢查3：是否到達了該群聊的行動時間
            if (now - lastActivity > intervalMs) {
                console.log(`群聊 "${chat.name}" 到達行動時間 (間隔: ${bgSettings.interval}秒)，準備觸發後臺互動...`);
                // 觸發群聊專屬的後臺行動函數
                triggerGroupAiAction(chat.id);
            }
        }
    });
}

// ▲▲▲ 新增代碼結束 ▲▲▲
// ▼▼▼ 把這一整塊全新的功能函數，黏貼到 init() 函數的上方 ▼▼▼
/**
 * 【全新】清空所有已關注角色的微博帖子
 */
async function clearFollowingFeed() {
    // 1. 彈出確認框，防止誤操作
    const confirmed = await showCustomConfirm(
        '確認清空',
        '此操作將永久刪除所有【非你本人發佈】的微博，且無法恢復。確定要繼續嗎？',
        { confirmButtonClass: 'btn-danger' } // 紅色按鈕以示警告
    );

    if (!confirmed) {
        return; // 如果用戶取消，則不執行任何操作
    }

    try {
        // 2. 從資料庫中找出所有作者不是'user'的帖子
        const postsToDelete = await db.weiboPosts.where('authorId').notEqual('user').toArray();
        const idsToDelete = postsToDelete.map(p => p.id);

        if (idsToDelete.length === 0) {
            alert("目前沒有可以清空的動態。");
            return;
        }

        // 3. 批量刪除這些帖子
        await db.weiboPosts.bulkDelete(idsToDelete);

        // 4. 重新渲染“關注的人”的Feed，讓介面變空
        await renderWeiboFeeds('weibo-following-view');

        alert(`已成功清空 ${idsToDelete.length} 條動態！`);

    } catch (error) {
        console.error("清空關注動態時出錯:", error);
        alert(`操作失敗: ${error.message}`);
    }
}
// ▲▲▲ 新函數黏貼結束 ▲▲▲

// ▼▼▼ 請將這兩個【新函數】黏貼到JS功能函式定義區 ▼▼▼

/**
 * 【全新】將保存的圖示URL應用到主螢幕的App圖示上
 */
function applyAppIcons() {
    if (!state.globalSettings.appIcons) return;

    for (const iconId in state.globalSettings.appIcons) {
        const imgElement = document.getElementById(`icon-img-${iconId}`);
        if (imgElement) {
            imgElement.src = state.globalSettings.appIcons[iconId];
        }
    }
}

/**
 * 【全新】在外觀設置頁面渲染出所有App圖示的設置項
 */
function renderIconSettings() {
    const grid = document.getElementById('icon-settings-grid');
    if (!grid) return;
    grid.innerHTML = '';

// ▼▼▼ 用下面這段【修改後】的代碼，完整替換掉你舊的 appLabels ▼▼▼
const appLabels = {
    'world-book': '世界書',
    'qq': 'QQ',
    'api-settings': 'API設置',
    'wallpaper': '壁紙',
    'font': '字體',
    'check-phone': '查手機',
    'weibo': '微博',
    'forum': '圈子',
    'lovers-space': '情侶空間',
    'game-hall': '遊戲大廳',
    'x-social': 'X社交',
    'taobao': '桃寶'
};
// ▲▲▲ 替換結束 ▲▲▲




    for (const iconId in state.globalSettings.appIcons) {
        const iconUrl = state.globalSettings.appIcons[iconId];
        const labelText = appLabels[iconId] || '未知App';

        const item = document.createElement('div');
        item.className = 'icon-setting-item';
        // 【重要】我們用 data-icon-id 來標記這個設置項對應哪個圖示
        item.dataset.iconId = iconId; 

        item.innerHTML = `
            <img class="icon-preview" src="${iconUrl}" alt="${labelText}">
            <button class="change-icon-btn">更換</button>
        `;
        grid.appendChild(item);
    }
}
// ▲▲▲ 新函數黏貼結束 ▲▲▲

// ▼▼▼ 用這塊【最終確認版】的代碼，替換舊的 openBrowser 和 closeBrowser 函數 ▼▼▼

/**
 * 當使用者點選連結卡片時，打開偽流覽器
 * @param {number} timestamp - 被點擊消息的時間戳記
 */
function openBrowser(timestamp) {
    if (!state.activeChatId) return;

    const chat = state.chats[state.activeChatId];
    // 安全檢查，確保 chat 和 history 都存在
    if (!chat || !chat.history) return;

    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'share_link') {
        console.error("無法找到或消息類型不匹配的分享連結:", timestamp);
        return; // 如果找不到消息，就直接退出
    }

    // 填充流覽器內容
    document.getElementById('browser-title').textContent = message.source_name || '文章詳情';
    const browserContent = document.getElementById('browser-content');
    browserContent.innerHTML = `
        <h1 class="article-title">${message.title || '無標題'}</h1>
        <div class="article-meta">
            <span>來源: ${message.source_name || '未知'}</span>
        </div>
        <div class="article-body">
            <p>${(message.content || '內容為空。').replace(/\n/g, '</p><p>')}</p>
        </div>
    `;

    // 顯示流覽器螢幕
    showScreen('browser-screen');
}

/**
 * 關閉偽流覽器，返回聊天介面
 * (這個函數現在由 init() 中的事件監聽器調用)
 */
function closeBrowser() {
    showScreen('chat-interface-screen'); 
}

// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 【全新】使用者分享連結功能的核心函數 ▼▼▼

/**
 * 打開讓使用者填寫連結資訊的模態框
 */
function openShareLinkModal() {
    if (!state.activeChatId) return;

    // 清空上次輸入的內容
    document.getElementById('link-title-input').value = '';
    document.getElementById('link-description-input').value = '';
    document.getElementById('link-source-input').value = '';
    document.getElementById('link-content-input').value = '';

    // 顯示模態框
    document.getElementById('share-link-modal').classList.add('visible');
}

/**
 * 使用者確認分享，創建並發送連結卡片消息
 */
async function sendUserLinkShare() {
    if (!state.activeChatId) return;

    const title = document.getElementById('link-title-input').value.trim();
    if (!title) {
        alert("標題是必填項哦！");
        return;
    }

    const description = document.getElementById('link-description-input').value.trim();
    const sourceName = document.getElementById('link-source-input').value.trim();
    const content = document.getElementById('link-content-input').value.trim();

    const chat = state.chats[state.activeChatId];
    
    // 創建消息物件
    const linkMessage = {
        role: 'user', // 角色是 'user'
        type: 'share_link',
        timestamp: Date.now(),
        title: title,
        description: description,
        source_name: sourceName,
        content: content,
        // 使用者分享的連結，我們不提供圖片，讓它總是顯示占點陣圖
        thumbnail_url: null 
    };

    // 將消息添加到歷史記錄
    chat.history.push(linkMessage);
    await db.chats.put(chat);

    // 渲染新消息並更新清單
    appendMessage(linkMessage, chat);
    renderChatList();

    // 關閉模態框
    document.getElementById('share-link-modal').classList.remove('visible');
}

/**
 * 【全新升級版】根據AI視角和動態設置，構建給AI看的評論區上下文
 * @param {object} post - 正在處理的動態物件
 * @param {object} viewerChat - 正在“看”動態的AI角色
 * @param {string} userNickname - 用戶的昵稱
 * @returns {{contextString: string, visibilityFlag: string}} - 返回包含上下文文本和可見性標誌的物件
 */
function buildCommentsContextForAI(post, viewerChat, userNickname) {
    if (!post.comments || post.comments.length === 0) {
        // ★★★ 關鍵在這裡：確保 "[評論區可見]" 是一個帶引號的字串 ★★★
        return { contextString: "", visibilityFlag: "[評論區可見]" };
    }

    const viewerName = viewerChat.name;
    let commentsForAI;
    let visibilityFlag;

    if (post.areCommentsVisible !== false) {
        commentsForAI = post.comments;
        // ★★★ 關鍵在這裡：確保 "[評論區可見]" 是一個帶引號的字串 ★★★
        visibilityFlag = "[評論區可見]"; 
    } else {
commentsForAI = Array.isArray(post.comments)
  ? post.comments.filter(comment => {
      return comment.commenterName === viewerName
          || comment.commenterName === userNickname
          || comment.replyTo === viewerName;
    })
  : [];
        // ★★★ 關鍵在這裡：確保 "[評論區部分可見]" 是一個帶引號的字串 ★★★
        visibilityFlag = "[評論區部分可見]";
    }

    if (commentsForAI.length === 0) {
        return { contextString: "", visibilityFlag: visibilityFlag };
    }

    let context = `  └ 評論區:\n`;
    commentsForAI.slice(-5).forEach(c => {
        if (c.replyTo) {
            context += `    - ${c.commenterName} 回復 ${c.replyTo}: ${c.text}\n`;
        } else {
            context += `    - ${c.commenterName}: ${c.text}\n`;
        }
    });
    
    return { contextString: context, visibilityFlag: visibilityFlag };
}



/**
 * 根據AI的視角，過濾出它能看到的動態
 * @param {Array} allPosts - 所有待檢查的動態帖子
 * @param {object} viewerChat - 正在“看”動態的那個AI的chat物件
 * @returns {Array} - 過濾後該AI可見的動態帖子
 */
function filterVisiblePostsForAI(allPosts, viewerChat) {
    if (!viewerChat || !viewerChat.id) return []; // 安全檢查

    const viewerGroupId = viewerChat.groupId; // 查看者所在的分組ID

    return allPosts.filter(post => {
        // 規則1：如果是使用者發的動態
        if (post.authorId === 'user') {
            // 如果使用者設置了“部分可見”
            if (post.visibleGroupIds && post.visibleGroupIds.length > 0) {
                // 只有當查看者AI的分組ID在用戶的可見列表裡時，才可見
                return viewerGroupId && post.visibleGroupIds.includes(viewerGroupId);
            }
            // 如果用戶沒設置，說明是公開的，所有AI都可見
            return true;
        }

        // 規則2：如果是其他AI發的動態
        const authorGroupId = post.authorGroupId; // 發帖AI所在的分組ID
        
        // 如果發帖的AI沒有分組，那它的動態就是公開的
        if (!authorGroupId) {
            return true;
        }

        // 如果發帖的AI有分組，那麼只有在同一個分組的AI才能看到
        return authorGroupId === viewerGroupId;
    });
}

/**
 * 應用指定的主題（'light' 或 'dark'）
 * @param {string} theme - 要應用的主題名稱
 */
function applyTheme(theme) {
    const phoneScreen = document.getElementById('phone-screen');
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    
    const isDark = theme === 'dark';
    
    phoneScreen.classList.toggle('dark-mode', isDark);
    
    // 如果開關存在，就同步它的狀態
    if (toggleSwitch) {
        toggleSwitch.checked = isDark;
    }
    
    localStorage.setItem('ephone-theme', theme);
}

/**
 * 切換當前的主題
 */
function toggleTheme() {
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    // 直接根據開關的選中狀態來決定新主題
    const newTheme = toggleSwitch.checked ? 'dark' : 'light';
    applyTheme(newTheme);
}

// ▼▼▼ 請將這【一整塊新函數】黏貼到你的JS功能函式定義區 ▼▼▼

function startReplyToMessage() {
    if (!activeMessageTimestamp) return;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === activeMessageTimestamp);
    if (!message) return;

    // 1. 【核心修正】同時獲取“完整內容”和“預覽片段”
    const fullContent = String(message.content || '');
    let previewSnippet = '';

    if (typeof message.content === 'string' && STICKER_REGEX.test(message.content)) {
        previewSnippet = '[表情]';
    } else if (message.type === 'ai_image' || message.type === 'user_photo') {
        previewSnippet = '[圖片]';
    } else if (message.type === 'voice_message') {
        previewSnippet = '[語音]';
    } else {
        // 預覽片段依然截斷，但只用於UI顯示
        previewSnippet = fullContent.substring(0, 50) + (fullContent.length > 50 ? '...' : '');
    }
    
    // 2. 【核心修正】將“完整內容”存入上下文，以備發送時使用
    currentReplyContext = {
        timestamp: message.timestamp,
        senderName: message.senderName || (message.role === 'user' ? (chat.settings.myNickname || '我') : chat.name),
        content: fullContent, // <--- 這裡存的是完整的原文！
    };

    // 3. 【核心修正】僅在更新“回復預覽欄”時，才使用“預覽片段”
    const previewBar = document.getElementById('reply-preview-bar');
    previewBar.querySelector('.sender').textContent = `回復 ${currentReplyContext.senderName}:`;
    previewBar.querySelector('.text').textContent = previewSnippet; // <--- 這裡用的是縮略版！
    previewBar.style.display = 'block';

    // 4. 後續操作保持不變
    hideMessageActions();
    document.getElementById('chat-input').focus();
}

/**
 * 【全新】取消引用模式
 */
function cancelReplyMode() {
    currentReplyContext = null;
    document.getElementById('reply-preview-bar').style.display = 'none';
}

// ▲▲▲ 新函數黏貼結束 ▲▲▲

// ▼▼▼ 【全新】使用者處理轉帳的核心功能函數 ▼▼▼

let activeTransferTimestamp = null; // 用於暫存被點擊的轉帳消息的時間戳記

/**
 * 顯示處理轉帳的操作功能表
 * @param {number} timestamp - 被點擊的轉帳消息的時間戳記
 */
function showTransferActionModal(timestamp) {
    activeTransferTimestamp = timestamp;

    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestamp);
    if (message) {
        // 將AI的名字填入彈窗
        document.getElementById('transfer-sender-name').textContent = message.senderName;
    }
    document.getElementById('transfer-actions-modal').classList.add('visible');
}

/**
 * 隱藏處理轉帳的操作功能表
 */
function hideTransferActionModal() {
    document.getElementById('transfer-actions-modal').classList.remove('visible');
    activeTransferTimestamp = null;
}

/**
 * 處理使用者接受或拒絕轉帳的邏輯
 * @param {string} choice - 用戶的選擇, 'accepted' 或 'declined'
 */
async function handleUserTransferResponse(choice) {
    if (!activeTransferTimestamp) return;

    const timestamp = activeTransferTimestamp;
    const chat = state.chats[state.activeChatId];
    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    // 1. 更新原始轉帳消息的狀態
    const originalMessage = chat.history[messageIndex];
    originalMessage.status = choice;

    let systemContent;

    // 2. 如果用戶選擇“拒絕”
    if (choice === 'declined') {
        // 立刻在前端生成一個“退款”卡片，讓使用者看到
        const refundMessage = {
            role: 'user',
            type: 'transfer',
            isRefund: true, // 這是一個關鍵標記，用於UI顯示這是退款
            amount: originalMessage.amount,
            note: '已拒收對方轉帳',
            timestamp: Date.now()
        };
        chat.history.push(refundMessage);
        
        // 準備一條對AI可見的隱藏消息，告訴它發生了什麼
        systemContent = `[系統提示：你拒絕並退還了“${originalMessage.senderName}”的轉帳。]`;
    } else { // 如果用戶選擇“接受”
        // 只需準備隱藏消息通知AI即可
        systemContent = `[系統提示：你接受了“${originalMessage.senderName}”的轉帳。]`;
        await updateUserBalanceAndLogTransaction(originalMessage.amount, `收到來自 ${originalMessage.senderName} 的轉帳`);
    }

    // 3. 創建這條對用戶隱藏、但對AI可見的系統消息
    const hiddenMessage = {
        role: 'system',
        content: systemContent,
        timestamp: Date.now() + 1, // 保證時間戳記在退款消息之後
        isHidden: true // 這個標記會讓它不在聊天介面顯示
    };
    chat.history.push(hiddenMessage);

    // 4. 保存所有更改到資料庫，並刷新介面
    await db.chats.put(chat);
    hideTransferActionModal(); 
    renderChatInterface(state.activeChatId);
    renderChatList();
}

// ▲▲▲ 新函數黏貼結束 ▲▲▲

// ▼▼▼ 【全新】通話記錄功能核心函數 ▼▼▼

async function renderCallHistoryScreen() {
    showScreen('call-history-screen'); // <--【核心修正】把它移動到最前面！

    const listEl = document.getElementById('call-history-list');
    const titleEl = document.getElementById('call-history-title');
    listEl.innerHTML = '';
    titleEl.textContent = '所有通話記錄';
    
    const records = await db.callRecords.orderBy('timestamp').reverse().toArray();
    
    if (records.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">這裡還沒有通話記錄哦~</p>';
        return; // 現在的 return 就沒問題了，因為它只跳過了後續的渲染邏輯
    }
    
    records.forEach(record => {
        const card = createCallRecordCard(record);

    addLongPressListener(card, async () => {
        // 1. 彈出輸入框，並將舊名稱作為預設值，方便修改
        const newName = await showCustomPrompt(
            "自訂通話名稱", 
            "請輸入新的名稱（留空則恢復默認）",
            record.customName || '' // 如果已有自訂名稱，就顯示它
        );

        // 2. 如果用戶點擊了“取消”，則什麼都不做
        if (newName === null) return;
        
        // 3. 更新資料庫中的這條記錄
        await db.callRecords.update(record.id, { customName: newName.trim() });
        
        // 4. 刷新整個清單，讓更改立刻顯示出來
        await renderCallHistoryScreen();
        
        // 5. 給用戶一個成功的提示
        await showCustomAlert('成功', '通話名稱已更新！');
    });
        listEl.appendChild(card);
    });    
}

// ▼▼▼ 用這個【升級版】函數，完整替換你舊的 createCallRecordCard 函數 ▼▼▼
/**
 * 【升級版】根據單條記錄資料，創建一張能顯示聊天物件的通話卡片
 * @param {object} record - 一條通話記錄物件
 * @returns {HTMLElement} - 創建好的卡片div
 */
function createCallRecordCard(record) {
    const card = document.createElement('div');
    card.className = 'call-record-card';
    card.dataset.recordId = record.id; 

    // 獲取通話對象的名字
    const chatInfo = state.chats[record.chatId];
    const chatName = chatInfo ? chatInfo.name : '未知會話';

    const callDate = new Date(record.timestamp);
    const dateString = `${callDate.getFullYear()}-${String(callDate.getMonth() + 1).padStart(2, '0')}-${String(callDate.getDate()).padStart(2, '0')} ${String(callDate.getHours()).padStart(2, '0')}:${String(callDate.getMinutes()).padStart(2, '0')}`;
    const durationText = `${Math.floor(record.duration / 60)}分${record.duration % 60}秒`;

    const avatarsHtml = record.participants.map(p => 
        `<img src="${p.avatar}" alt="${p.name}" class="participant-avatar" title="${p.name}">`
    ).join('');
    
    card.innerHTML = `
        <div class="card-header">
            <span class="date">${dateString}</span>
            <span class="duration">${durationText}</span>
        </div>
        <div class="card-body">
            <!-- 【核心修改】在這裡新增一個標題行 -->
            ${record.customName ? `<div class="custom-title">${record.customName}</div>` : ''}
            
            <div class="participants-info"> <!-- 新增一個容器方便佈局 -->
                <div class="participants-avatars">${avatarsHtml}</div>
                <span class="participants-names">與 ${chatName}</span>
            </div>
        </div>
    `;
    return card;
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 顯示指定通話記錄的完整文字稿
 * @param {number} recordId - 通話記錄的ID
 */
async function showCallTranscript(recordId) {
    const record = await db.callRecords.get(recordId);
    if (!record) return;

    const modal = document.getElementById('call-transcript-modal');
    const titleEl = document.getElementById('transcript-modal-title');
    const bodyEl = document.getElementById('transcript-modal-body');

    titleEl.textContent = `通話於 ${new Date(record.timestamp).toLocaleString()} (時長: ${Math.floor(record.duration / 60)}分${record.duration % 60}秒)`;
    bodyEl.innerHTML = '';
    
    if (!record.transcript || record.transcript.length === 0) {
        bodyEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">這次通話沒有留下文字記錄。</p>';
    } else {
        record.transcript.forEach(entry => {
            const bubble = document.createElement('div');
            // 根據角色添加不同的class，應用不同的樣式
            bubble.className = `transcript-entry ${entry.role}`; 
            bubble.textContent = entry.content;
            bodyEl.appendChild(bubble);
        });
    }

    const deleteBtn = document.getElementById('delete-transcript-btn');
    
    // 【重要】使用克隆節點技巧，防止事件重複綁定
    const newDeleteBtn = deleteBtn.cloneNode(true);
    deleteBtn.parentNode.replaceChild(newDeleteBtn, deleteBtn);
    
    // 為新的、乾淨的按鈕綁定事件
    newDeleteBtn.addEventListener('click', async () => {
        const confirmed = await showCustomConfirm(
            "確認刪除",
            "確定要永久刪除這條通話記錄嗎？此操作不可恢復。",
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            // 1. 關閉當前的詳情彈窗
            modal.classList.remove('visible');
            
            // 2. 從資料庫刪除
            await db.callRecords.delete(recordId);
            
            // 3. 刷新通話記錄清單
            await renderCallHistoryScreen();
            
            // 4. (可選) 給出成功提示
            alert('通話記錄已刪除。');
        }
    });
    modal.classList.add('visible');
}

// ▲▲▲ 新函數黏貼結束 ▲▲▲

// ▼▼▼ 請用這個【全新函數】替換掉你舊的 handleStatusResetClick 函數 ▼▼▼

/**
 * 【全新】處理用戶點擊狀態列，彈出編輯方塊讓使用者修改AI的當前狀態
 */
async function handleEditStatusClick() {
    // 1. 安全檢查，確保在單聊介面
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
        return; 
    }
    const chat = state.chats[state.activeChatId];

    // 2. 彈出輸入框，讓使用者輸入新的狀態，並將當前狀態作為預設值
    const newStatusText = await showCustomPrompt(
        '編輯對方狀態',
        '請輸入對方現在的新狀態：',
        chat.status.text // 將當前狀態作為輸入框的預設內容
    );

    // 3. 如果使用者輸入了內容並點擊了“確定”
    if (newStatusText !== null) {
        // 4. 更新記憶體和資料庫中的狀態資料
        chat.status.text = newStatusText.trim() || '線上'; // 如果用戶清空了，就默認為“線上”
        chat.status.isBusy = false; // 每次手動編輯都默認其不處於“忙碌”狀態
        chat.status.lastUpdate = Date.now();
        await db.chats.put(chat);

        // 5. 立刻刷新UI，讓使用者看到修改後的狀態
        renderChatInterface(state.activeChatId);
        renderChatList();
        
        // 6. 給出一個無傷大雅的成功提示
        await showCustomAlert('狀態已更新', `“${chat.name}”的當前狀態已更新為：${chat.status.text}`);
    }
}

// 放在你的JS功能函式定義區
async function openShareTargetPicker() {
    const modal = document.getElementById('share-target-modal');
    const listEl = document.getElementById('share-target-list');
    listEl.innerHTML = '';

    // 獲取所有聊天作為分享目標
    const chats = Object.values(state.chats);

    chats.forEach(chat => {
        // 複用連絡人選擇器的樣式
        const item = document.createElement('div');
        item.className = 'contact-picker-item'; 
        item.innerHTML = `
            <input type="checkbox" class="share-target-checkbox" data-chat-id="${chat.id}" style="margin-right: 15px;">
            <img src="${chat.isGroup ? chat.settings.groupAvatar : chat.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${chat.name}</span>
        `;
        listEl.appendChild(item);
    });
    
    modal.classList.add('visible');
}

function closeMusicPlayerWithAnimation(callback) {
    const overlay = document.getElementById('music-player-overlay');
    if (!overlay.classList.contains('visible')) {
        if (callback) callback();
        return;
    }
    overlay.classList.remove('visible');
    setTimeout(() => {
        document.getElementById('music-playlist-panel').classList.remove('visible');
        if (callback) callback();
    }, 400); 
}

function parseLRC(lrcContent) {
    if (!lrcContent) return [];
    const lines = lrcContent.split('\n');
    const lyrics = [];
    const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\]/g;

    for (const line of lines) {
        const text = line.replace(timeRegex, '').trim();
        if (!text) continue;
        timeRegex.lastIndex = 0;
        let match;
        while ((match = timeRegex.exec(line)) !== null) {
            const minutes = parseInt(match[1], 10);
            const seconds = parseInt(match[2], 10);
            const milliseconds = parseInt(match[3].padEnd(3, '0'), 10);
            const time = minutes * 60 + seconds + milliseconds / 1000;
            lyrics.push({ time, text });
        }
    }
    return lyrics.sort((a, b) => a.time - b.time);
}

function renderLyrics() {
    const lyricsList = document.getElementById('music-lyrics-list');
    lyricsList.innerHTML = '';
    if (!musicState.parsedLyrics || musicState.parsedLyrics.length === 0) {
        lyricsList.innerHTML = '<div class="lyric-line">♪ 暫無歌詞 ♪</div>';
        return;
    }
    musicState.parsedLyrics.forEach((line, index) => {
        const lineEl = document.createElement('div');
        lineEl.className = 'lyric-line';
        lineEl.textContent = line.text;
        lineEl.dataset.index = index;
        lyricsList.appendChild(lineEl);
    });
    lyricsList.style.transform = `translateY(0px)`;
}

function updateActiveLyric(currentTime) {
    if (musicState.parsedLyrics.length === 0) return;
    let newLyricIndex = -1;
    for (let i = 0; i < musicState.parsedLyrics.length; i++) {
        if (currentTime >= musicState.parsedLyrics[i].time) {
            newLyricIndex = i;
        } else {
            break;
        }
    }
    if (newLyricIndex === musicState.currentLyricIndex) return;
    musicState.currentLyricIndex = newLyricIndex;
    updateLyricsUI();
}

function updateLyricsUI() {
    const lyricsList = document.getElementById('music-lyrics-list');
    const container = document.getElementById('music-lyrics-container');
    const lines = lyricsList.querySelectorAll('.lyric-line');
    lines.forEach(line => line.classList.remove('active'));
    if (musicState.currentLyricIndex === -1) {
        lyricsList.style.transform = `translateY(0px)`;
        return;
    }
    const activeLine = lyricsList.querySelector(`.lyric-line[data-index="${musicState.currentLyricIndex}"]`);
    if (activeLine) {
        activeLine.classList.add('active');
        const containerHeight = container.offsetHeight;
        const offset = (containerHeight / 3) - activeLine.offsetTop - (activeLine.offsetHeight / 2);
        lyricsList.style.transform = `translateY(${offset}px)`;
    }

    // ▼▼▼ 在這裡添加下面這塊【新代碼】 ▼▼▼
    // 【核心新增】同步歌詞到懸浮欄
    const floatingLyricText = document.getElementById('floating-lyric-text');
    if (activeLine) {
        floatingLyricText.textContent = activeLine.textContent;
    } else if (musicState.parsedLyrics.length > 0) {
        floatingLyricText.textContent = '♪ ♪ ♪'; // 歌曲前奏
    } else {
        floatingLyricText.textContent = '♪ 暫無歌詞 ♪';
    }
    // ▲▲▲ 新代碼添加結束 ▲▲▲

}

function formatMusicTime(seconds) {
    if (isNaN(seconds) || seconds < 0) return "0:00";
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${String(remainingSeconds).padStart(2, '0')}`;
}

function updateMusicProgressBar() {
    const currentTimeEl = document.getElementById('music-current-time');
    const totalTimeEl = document.getElementById('music-total-time');
    const progressFillEl = document.getElementById('music-progress-fill');
    if (!audioPlayer.duration) {
        currentTimeEl.textContent = "0:00";
        totalTimeEl.textContent = "0:00";
        progressFillEl.style.width = '0%';
        return;
    }
    const progressPercent = (audioPlayer.currentTime / audioPlayer.duration) * 100;
    progressFillEl.style.width = `${progressPercent}%`;
    currentTimeEl.textContent = formatMusicTime(audioPlayer.currentTime);
    totalTimeEl.textContent = formatMusicTime(audioPlayer.duration);
    updateActiveLyric(audioPlayer.currentTime);
}

/**
 * 【全新】處理使用者點擊“撤回”按鈕的入口函數
 */
async function handleRecallClick() {
    if (!activeMessageTimestamp) return;

    const RECALL_TIME_LIMIT_MS = 2 * 60 * 1000; // 設置2分鐘的撤回時限
    const messageTime = activeMessageTimestamp;
    const now = Date.now();

    // 檢查是否超過了撤回時限
    if (now - messageTime > RECALL_TIME_LIMIT_MS) {
        hideMessageActions();
        await showCustomAlert('操作失敗', '該消息發送已超過2分鐘，無法撤回。');
        return;
    }
    
    // 如果在時限內，執行真正的撤回邏輯
    await recallMessage(messageTime, true);
    hideMessageActions();
}

/**
 * 【全新】消息撤回的核心邏輯
 * @param {number} timestamp - 要撤回的消息的時間戳記
 * @param {boolean} isUserRecall - 是否是用戶主動撤回
 */
async function recallMessage(timestamp, isUserRecall) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const messageIndex = chat.history.findIndex(m => m.timestamp === timestamp);
    if (messageIndex === -1) return;

    const messageToRecall = chat.history[messageIndex];

    // 1. 修改消息物件，將其變為“已撤回”狀態
    const recalledData = {
        originalType: messageToRecall.type || 'text',
        originalContent: messageToRecall.content,
        // 保存其他可能存在的原始資料
        originalMeaning: messageToRecall.meaning,
        originalQuote: messageToRecall.quote 
    };
    
    messageToRecall.type = 'recalled_message';
    messageToRecall.content = isUserRecall ? '你撤回了一條消息' : '對方撤回了一條消息';
    messageToRecall.recalledData = recalledData;
    // 清理掉不再需要的舊屬性
    delete messageToRecall.meaning;
    delete messageToRecall.quote;

    // 2. 如果是使用者撤回，需要給AI發送一條它看不懂內容的隱藏提示
    if (isUserRecall) {
        const hiddenMessageForAI = {
            role: 'system',
            content: `[系統提示：使用者撤回了一條消息。你不知道內容是什麼，只需知道這個事件即可。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessageForAI);
    }

    // 3. 保存到資料庫並刷新UI
    await db.chats.put(chat);
    renderChatInterface(state.activeChatId);
    if(isUserRecall) renderChatList(); // 使用者撤回時，最後一條消息變了，需要刷新清單
}

// ▼▼▼ 【全新】將這些函數黏貼到你的JS功能函式定義區 ▼▼▼

/**
 * 打開分類管理模態框
 */
async function openCategoryManager() {
    await renderCategoryListInManager();
    document.getElementById('world-book-category-manager-modal').classList.add('visible');
}

/**
 * 在模態框中渲染已存在的分類列表
 */
async function renderCategoryListInManager() {
    const listEl = document.getElementById('existing-categories-list');
    const categories = await db.worldBookCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">還沒有任何分類</p>';
    }
    categories.forEach(cat => {
        // 複用好友分組的樣式
        const item = document.createElement('div');
        item.className = 'existing-group-item'; 
        item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <span class="delete-group-btn" data-id="${cat.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 添加一個新的世界書分類
 */
async function addNewCategory() {
    const input = document.getElementById('new-category-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('分類名不能為空！');
        return;
    }
    const existing = await db.worldBookCategories.where('name').equals(name).first();
    if (existing) {
        alert(`分類 "${name}" 已經存在了！`);
        return;
    }
    await db.worldBookCategories.add({ name });
    input.value = '';
    await renderCategoryListInManager();
}

/**
 * 刪除一個世界書分類
 * @param {number} categoryId - 要刪除的分類的ID
 */
async function deleteCategory(categoryId) {
    const confirmed = await showCustomConfirm(
        '確認刪除', 
        '刪除分類後，該分類下的所有世界書將變為“未分類”。確定要刪除嗎？', 
        { confirmButtonClass: 'btn-danger' }
    );
    if (confirmed) {
        await db.worldBookCategories.delete(categoryId);
        // 將屬於該分類的世界書的 categoryId 設為 null
        const booksToUpdate = await db.worldBooks.where('categoryId').equals(categoryId).toArray();
        for (const book of booksToUpdate) {
            book.categoryId = null;
            await db.worldBooks.put(book);
            const bookInState = state.worldBooks.find(wb => wb.id === book.id);
            if(bookInState) bookInState.categoryId = null;
        }
        await renderCategoryListInManager();
    }
}

// ▲▲▲ 新函數黏貼結束 ▲▲▲
// ▼▼▼ 【全新】角色專屬NPC庫管理功能函數 ▼▼▼

let editingNpcId = null; // 用於追蹤正在編輯的NPC

/**
 * 打開NPC庫管理介面
 */
function openNpcManager() {
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;
    const chat = state.chats[state.activeChatId];
    document.getElementById('npc-management-title').textContent = `“${chat.name}”的NPC庫`;
    renderNpcList();
    showScreen('npc-management-screen');
}

/**
 * 渲染NPC列表
 */
function renderNpcList() {
    const listEl = document.getElementById('npc-management-list');
    const chat = state.chats[state.activeChatId];
    const npcLibrary = chat.npcLibrary || [];
    listEl.innerHTML = '';

    if (npcLibrary.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">這裡空空如也，點擊右上角“+”添加第一個NPC吧！</p>';
        return;
    }

    npcLibrary.forEach(npc => {
        // 複用聊天清單的樣式，非常方便
        const item = document.createElement('div');
        item.className = 'chat-list-item';
        item.style.cursor = 'pointer';
        item.innerHTML = `
            <img src="${npc.avatar || defaultGroupMemberAvatar}" class="avatar">
            <div class="info">
                <span class="name">${npc.name}</span>
                <div class="last-msg">${npc.persona.substring(0, 30)}...</div>
            </div>
        `;
        // 點擊編輯
        item.addEventListener('click', () => openNpcEditor(npc.id));
        // 長按刪除
        addLongPressListener(item, () => deleteNpc(npc.id, npc.name));
        listEl.appendChild(item);
    });
}

// ▼▼▼ 用這個【全新的、已修復兩個Bug的函數】，完整替換舊的 openNpcEditor 函數 ▼▼▼
async function openNpcEditor(npcId = null) {
    editingNpcId = npcId;
    // 【核心修復1】使用正確的 state.activeChatId 來獲取當前聊天物件
    const chat = state.chats[state.activeChatId];
    if (!chat) return; // 安全檢查

    let npc = { name: '', persona: '', avatar: defaultGroupMemberAvatar };
    
    if (npcId) {
        // 【核心修復2】從正確的 chat.npcLibrary 中查找數據
        npc = (chat.npcLibrary || []).find(n => n.id === npcId) || npc;
        document.getElementById('persona-editor-title').textContent = `編輯NPC: ${npc.name}`;
    } else {
        document.getElementById('persona-editor-title').textContent = '添加新NPC';
    }
    
    // 填充編輯器內容
    document.getElementById('npc-editor-name-input').value = npc.name;
    document.getElementById('preset-avatar-preview').src = npc.avatar;
    document.getElementById('preset-persona-input').value = npc.persona;
    
    // 【核心邏輯】根據NPC模式，顯隱特定UI元素
    document.getElementById('npc-editor-name-group').style.display = 'block';
    document.getElementById('persona-editor-change-frame-btn').style.display = 'none';

    // 綁定正確的保存函數
    document.getElementById('save-persona-preset-btn').onclick = saveNpc;

    // 最後才顯示彈窗
    document.getElementById('persona-editor-modal').classList.add('visible');
}
// ▲▲▲ 替換結束 ▲▲▲






// ▼▼▼ 從這裡開始替換 ▼▼▼
/**
 * 【V2 - 完整版】保存NPC（新建或更新）
 */
async function saveNpc() {
    const chat = state.chats[state.activeChatId];

    
    // 從編輯器中獲取所有資料
    const name = document.getElementById('npc-editor-name-input').value.trim();
    const persona = document.getElementById('preset-persona-input').value.trim();
    const avatar = document.getElementById('preset-avatar-preview').src;

    if (!name) {
        alert("NPC名字不能為空！");
        return;
    }

    if (editingNpcId) {
        // 更新現有的NPC
        const npc = chat.npcLibrary.find(n => n.id === editingNpcId);
        if (npc) {
            npc.name = name;
            npc.persona = persona;
            npc.avatar = avatar;
        }
    } else {
        // 添加一個全新的NPC
        const newNpc = {
            id: 'npc_' + Date.now(),
            name: name,
            persona: persona,
            avatar: avatar
        };
        chat.npcLibrary.push(newNpc);
    }

    await db.chats.put(chat);
    renderNpcList();
    closePersonaEditor(); // 複用關閉編輯器的函數
}
// ▲▲▲ 替換到這裡結束 ▲▲▲


/**
 * 刪除一個NPC
 * @param {string} npcId - 要刪除的NPC的ID
 * @param {string} npcName - 要刪除的NPC的名字，用於確認提示
 */
async function deleteNpc(npcId, npcName) {
    const confirmed = await showCustomConfirm(
        '刪除NPC',
        `確定要從“${state.chats[state.activeChatId].name}”的NPC庫中刪除 “${npcName}” 嗎？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        chat.npcLibrary = chat.npcLibrary.filter(n => n.id !== npcId);
        await db.chats.put(chat);
        renderNpcList();
    }
}

// ▲▲▲ 新函數黏貼結束 ▲▲▲

// --- ▼▼▼ 【全新】自訂頭像框管理功能 ▼▼▼ ---

function openFrameManager() {
    renderFrameManager();
    document.getElementById('custom-frame-manager-modal').classList.add('visible');
}

async function renderFrameManager() {
    const grid = document.getElementById('custom-frame-grid');
    grid.innerHTML = '';
    const customFrames = await db.customAvatarFrames.toArray();
    if (customFrames.length === 0) {
        grid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1 / -1; text-align: center;">你還沒有上傳過頭像框哦~</p>';
        return;
    }
    customFrames.forEach(frame => {
        const item = document.createElement('div');
        // 複用表情面板的樣式，很方便
        item.className = 'sticker-item'; 
        item.style.backgroundImage = `url(${frame.url})`;
        item.title = frame.name;
        
        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.style.display = 'block';
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('刪除頭像框', `確定要刪除“${frame.name}”嗎？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                await db.customAvatarFrames.delete(frame.id);
                renderFrameManager(); // 刷新管理列表
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}

/**
 * 【V2多選版】處理用戶上傳自訂頭像框的邏輯
 */
function handleUploadCustomFrame() {
    document.getElementById('custom-frame-upload-input').addEventListener('change', async (event) => {
        const files = event.target.files;
        if (!files.length) return;

        const newFrames = [];
        
        // 使用 for...of 迴圈來逐個處理選中的文件
        for (const file of files) {
            // 【核心修改】自動生成名字，而不是讓用戶輸入
            // 我們用 "檔案名 (前8位) + 時間戳記" 來確保名字幾乎不會重複
            const fileName = file.name.replace(/\.[^/.]+$/, "").substring(0, 8);
            const autoName = `${fileName}_${Date.now()}`;

            const base64Url = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.readAsDataURL(file);
            });
            
            newFrames.push({
                id: 'frame_' + (Date.now() + newFrames.length), // 確保ID唯一
                name: autoName,
                url: base64Url
            });
        }
        
        // 迴圈結束後，批量添加到資料庫
        if (newFrames.length > 0) {
            await db.customAvatarFrames.bulkAdd(newFrames);
            renderFrameManager(); // 刷新管理列表
            await showCustomAlert("上傳成功", `已成功添加 ${newFrames.length} 個新頭像框！`);
        }

        // 清空檔選擇器的值
        event.target.value = null;
    }, { once: true });

    document.getElementById('custom-frame-upload-input').click();
}

// ▲▲▲ 新增功能函數結束 ▲▲▲

// ▼▼▼ 用這塊【已添加新分支】的代碼替換舊的 ▼▼▼
async function openFrameSelectorModal(type, targetId = null) {
    const grid = document.getElementById('avatar-frame-grid');
    grid.innerHTML = '';
    
    currentFrameSelection.type = type;
    currentFrameSelection.target = targetId;
    
    const chat = state.chats[state.activeChatId];
    let currentFrameUrl = '';
    let previewAvatarUrl = '';

    // --- ▼▼▼ 這就是新增的分支邏輯！▼▼▼ ---
    if (type === 'char-weibo') { 
        // 如果是為“角色微博”換框
        const charChat = state.chats[currentViewingWeiboProfileId];
        currentFrameUrl = charChat.settings.weiboAvatarFrame || '';
        previewAvatarUrl = charChat.settings.weiboAvatar || defaultAvatar;
    }
    // --- ▲▲▲ 新增結束 ▲▲▲ ---
    else if (type === 'home_profile') {
        currentFrameUrl = state.globalSettings.homeAvatarFrame || '';
        previewAvatarUrl = document.getElementById('profile-avatar-img').src;
    } 
    else if (type === 'weibo_profile') {
        currentFrameUrl = state.qzoneSettings.weiboAvatarFrame || '';
        previewAvatarUrl = state.qzoneSettings.weiboAvatar || defaultAvatar;
    } 
    else if (type === 'ai') {
        currentFrameUrl = chat.settings.aiAvatarFrame || '';
        previewAvatarUrl = chat.settings.aiAvatar || defaultAvatar;
    } else if (type === 'my') {
        currentFrameUrl = chat.settings.myAvatarFrame || '';
        previewAvatarUrl = chat.settings.myAvatar || defaultAvatar;
    } else if (type === 'member' && targetId) {
        const member = chat.members.find(m => m.id === targetId);
        if (member) {
            currentFrameUrl = member.avatarFrame || '';
            previewAvatarUrl = member.avatar || defaultGroupMemberAvatar;
        }
    }
    
    // 後續渲染邏輯保持不變
    const customFrames = await db.customAvatarFrames.toArray();
    const frameUrlSet = new Set();
    const allFrames = [...avatarFrames, ...customFrames].filter(frame => {
        if (!frame.url || !frameUrlSet.has(frame.url)) {
            frameUrlSet.add(frame.url);
            return true;
        }
        return false;
    });

    allFrames.forEach(frame => {
        const item = createFrameItem(frame, previewAvatarUrl);
        if (currentFrameUrl === frame.url) {
            item.classList.add('selected');
            currentFrameSelection.url = frame.url;
        }
        grid.appendChild(item);
    });

    document.getElementById('avatar-frame-modal').classList.add('visible');
}
// ▲▲▲ 替換結束 ▲▲▲


// 輔助函數：創建一個頭像框選項
function createFrameItem(frame, previewAvatarSrc) {
    const item = document.createElement('div');
    item.className = 'frame-item';
    item.title = frame.name;
    item.innerHTML = `
        <img src="${previewAvatarSrc}" class="preview-avatar">
        ${frame.url ? `<img src="${frame.url}" class="preview-frame" style="pointer-events: none;">` : ''}
    `;
    item.addEventListener('click', () => {
        document.querySelectorAll('#avatar-frame-grid .frame-item').forEach(el => el.classList.remove('selected'));
        item.classList.add('selected');
        currentFrameSelection.url = frame.url;
    });
    return item;
}

// 保存選擇
// ▼▼▼ 用這塊【已添加新分支】的代碼替換舊的 ▼▼▼
async function saveSelectedFrames() {
    const chat = state.chats[state.activeChatId];
    const { type, url, target } = currentFrameSelection;

    // --- ▼▼▼ 這就是新增的分支邏輯！▼▼▼ ---
    if (type === 'char-weibo') {
        const charChat = state.chats[currentViewingWeiboProfileId];
        if (charChat) {
            charChat.settings.weiboAvatarFrame = url;
            await db.chats.put(charChat);
            await renderWeiboCharProfile(currentViewingWeiboProfileId);
        }
    }
    // --- ▲▲▲ 新增結束 ▲▲▲ ---
    else if (type === 'home_profile') {
        if (!state.globalSettings) state.globalSettings = {};
        state.globalSettings.homeAvatarFrame = url;
        await db.globalSettings.put(state.globalSettings);
        renderHomeScreenProfileFrame(); 
    } 
    else if (type === 'weibo_profile') {
        if (!state.qzoneSettings) state.qzoneSettings = {};
        state.qzoneSettings.weiboAvatarFrame = url;
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
    else if (type === 'ai') {
        chat.settings.aiAvatarFrame = url;
        await db.chats.put(chat);
    } else if (type === 'my') {
        chat.settings.myAvatarFrame = url;
        await db.chats.put(chat);
    } else if (type === 'member' && target) {
        const member = chat.members.find(m => m.id === target);
        if (member) member.avatarFrame = url;
        await db.chats.put(chat);
    }
    
    document.getElementById('avatar-frame-modal').classList.remove('visible');
    
    // 修正：只有當不是微博或主螢幕的頭像框設置時，才刷新聊天介面
    if (type !== 'weibo_profile' && type !== 'home_profile' && type !== 'char-weibo') {
        renderChatInterface(state.activeChatId);
        if (document.getElementById('chat-settings-modal').classList.contains('visible')) {
            document.getElementById('chat-settings-btn').click();
            document.getElementById('chat-settings-btn').click();
        }
    }
}
// ▲▲▲ 替換結束 ▲▲▲


/**
 * 檢查兩個時間戳記是否在不同的自然日
 * @param {number} timestamp1 - 新消息的時間戳記
 * @param {number | null} timestamp2 - 上一條消息的時間戳記
 * @returns {boolean} - 如果是新的一天，返回 true
 */
function isNewDay(timestamp1, timestamp2) {
    // 如果沒有上一條消息的時間戳記，說明這是第一條消息，肯定要顯示日期
    if (!timestamp2) return true;

    const date1 = new Date(timestamp1);
    const date2 = new Date(timestamp2);

    // 比較年、月、日是否完全相同
    return date1.getFullYear() !== date2.getFullYear() ||
           date1.getMonth()    !== date2.getMonth()    ||
           date1.getDate()     !== date2.getDate();
}

/**
 * 將時間戳記格式化為 "X月X日 HH:mm" 的形式
 * @param {number} timestamp - 時間戳記
 * @returns {string} - 格式化後的日期字串
 */
function formatDateStamp(timestamp) {
    const date = new Date(timestamp);
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    return `${month}月${day}日 ${hours}:${minutes}`;
}

/**
 * 【全新】根據時間戳記，格式化聊天列表右側的日期/時間顯示
 * @param {number} timestamp - 消息的時間戳記
 * @returns {string} - 格式化後的字串 (例如 "14:30", "昨天", "08/03")
 */
function formatChatListTimestamp(timestamp) {
    if (!timestamp) return ''; // 如果沒有時間戳記，返回空字串

    const now = new Date();
    const msgDate = new Date(timestamp);

    // 判斷是否為今天
    const isToday = now.getFullYear() === msgDate.getFullYear() &&
                    now.getMonth() === msgDate.getMonth() &&
                    now.getDate() === msgDate.getDate();

    if (isToday) {
        // 如果是今天，只顯示時間
        return msgDate.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
    }

    // 判斷是否為昨天
    const yesterday = new Date();
    yesterday.setDate(now.getDate() - 1);
    const isYesterday = yesterday.getFullYear() === msgDate.getFullYear() &&
                        yesterday.getMonth() === msgDate.getMonth() &&
                        yesterday.getDate() === msgDate.getDate();

    if (isYesterday) {
        return '昨天';
    }

    // 判斷是否為今年
    if (now.getFullYear() === msgDate.getFullYear()) {
        // 如果是今年，顯示 "月/日"
        const month = String(msgDate.getMonth() + 1).padStart(2, '0');
        const day = String(msgDate.getDate()).padStart(2, '0');
        return `${month}/${day}`;
    }

    // 如果是更早的年份，顯示 "年/月/日"
    const year = msgDate.getFullYear();
    const month = String(msgDate.getMonth() + 1).padStart(2, '0');
    const day = String(msgDate.getDate()).padStart(2, '0');
    return `${year}/${month}/${day}`;
}

/**
 * 【全新】創建一個功能完整的日期戳“偽消息”元素
 * @param {number} timestamp - 該日期戳代表的時間
 * @returns {HTMLElement} - 創建好的 DOM 元素
 */
function createDateStampElement(timestamp) {
    // 1. 創建最外層的包裹 div，和真實消息一樣
    const wrapper = document.createElement('div');
    wrapper.className = 'message-wrapper date-stamp-wrapper';
    // 【核心】把時間戳記存起來，這是多選和刪除的關鍵
    wrapper.dataset.timestamp = timestamp; 

    // 2. 創建氣泡 div
    const bubble = document.createElement('div');
    // 【核心】同時加上 .message-bubble 類，讓多選邏輯能找到它
    bubble.className = 'message-bubble date-stamp-bubble';
    bubble.dataset.timestamp = timestamp;
    bubble.textContent = formatDateStamp(timestamp);
    
    wrapper.appendChild(bubble);

    // 3. 【核心】為它綁定和真實消息完全一樣的事件監聽器
    addLongPressListener(wrapper, () => {
        // 日期戳不支持複雜操作，長按直接進入多選
        enterSelectionMode(timestamp);
    });
    wrapper.addEventListener('click', () => { 
        if (isSelectionMode) {
            toggleMessageSelection(timestamp);
        }
    });

    return wrapper;
}
// ▼▼▼ 在你的JS功能函式定義區，黏貼下面這一整塊新代碼 ▼▼▼

// --- 美化功能的核心變數 ---
let activeThemeId = null; // 用於追蹤當前正在編輯的主題ID

/**
 * 將CSS代碼應用到頁面上
 * @param {string} cssCode - 要應用的CSS代碼字串
 */
function applyThemeCss(cssCode) {
    const styleTag = document.getElementById('custom-theme-style');
    if (styleTag) {
        styleTag.innerHTML = cssCode || '';
    }
}

/**
 * 從資料庫載入所有主題到下拉選擇框
 */
async function loadThemesToDropdown() {
    const selector = document.getElementById('theme-selector');
    selector.innerHTML = '<option value="">-- 選擇方案或新建 --</option>'; // 預設選項
    
    const themes = await db.themes.toArray();
    themes.forEach(theme => {
        const option = document.createElement('option');
        option.value = theme.id;
        option.textContent = theme.name;
        selector.appendChild(option);
    });
}

/**
 * 處理使用者從下拉清單選擇一個主題的邏輯
 */
async function handleThemeSelection() {
    const selector = document.getElementById('theme-selector');
    const editor = document.getElementById('theme-css-editor');
    activeThemeId = selector.value ? parseInt(selector.value) : null;
    
    if (activeThemeId) {
        const theme = await db.themes.get(activeThemeId);
        editor.value = theme.css;
    } else {
        // 如果選擇“--”，就載入範本
        editor.value = THEME_CSS_TEMPLATE;
    }
    // 立即應用選中的或範本代碼，讓使用者看到效果
    applyThemeCss(editor.value);
}

/**
 * 保存當前編輯區的內容到當前選中的主題
 */
async function saveCurrentTheme() {
    if (!activeThemeId) {
        alert("請先選擇一個方案，或使用“另存為”來創建新方案。");
        return;
    }
    const cssCode = document.getElementById('theme-css-editor').value;
    await db.themes.update(activeThemeId, { css: cssCode });
    alert("當前方案已保存！");
}

/**
 * 將當前編輯區的內容另存為一個新主題
 */
async function saveAsNewTheme() {
    const themeName = await showCustomPrompt("保存新方案", "請輸入新方案的名稱");
    if (!themeName || !themeName.trim()) {
        if(themeName !== null) alert("方案名稱不能為空！");
        return;
    }
    const cssCode = document.getElementById('theme-css-editor').value;
    const newTheme = { name: themeName.trim(), css: cssCode };
    const newId = await db.themes.add(newTheme);
    
    // 刷新下拉清單並自動選中新保存的方案
    await loadThemesToDropdown();
    document.getElementById('theme-selector').value = newId;
    activeThemeId = newId;
    
    alert(`方案 "${themeName}" 已成功保存！`);
}

/**
 * 重命名當前選中的主題
 */
async function renameSelectedTheme() {
    if (!activeThemeId) {
        alert("請先選擇一個要重命名的方案。");
        return;
    }
    const currentTheme = await db.themes.get(activeThemeId);
    const newName = await showCustomPrompt("重命名方案", "請輸入新的名稱", currentTheme.name);
    if (newName && newName.trim()) {
        await db.themes.update(activeThemeId, { name: newName.trim() });
        await loadThemesToDropdown();
        document.getElementById('theme-selector').value = activeThemeId;
        alert("重命名成功！");
    }
}

/**
 * 刪除當前選中的主題
 */
async function deleteSelectedTheme() {
    if (!activeThemeId) {
        alert("請先選擇一個要刪除的方案。");
        return;
    }
    const confirmed = await showCustomConfirm(
        "確認刪除", 
        `確定要刪除方案 "${document.getElementById('theme-selector').selectedOptions[0].textContent}" 嗎？`,
        { confirmButtonClass: 'btn-danger' }
    );
    if (confirmed) {
        await db.themes.delete(activeThemeId);
        activeThemeId = null;
        await loadThemesToDropdown();
        // 恢復到範本狀態
        document.getElementById('theme-css-editor').value = THEME_CSS_TEMPLATE;
        applyThemeCss(THEME_CSS_TEMPLATE);
        alert("方案已刪除。");
    }
}

/**
 * 匯出當前選中的主題為一個JSON檔
 */
async function exportTheme() {
    if (!activeThemeId) {
        alert("請先選擇一個要匯出的方案。");
        return;
    }
    const theme = await db.themes.get(activeThemeId);
    const exportData = {
        themeName: theme.name,
        themeCss: theme.css
    };
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${theme.name}-Theme.json`;
    a.click();
    URL.revokeObjectURL(url);
}

/**
 * 導入一個主題JSON檔
 */
function importTheme(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);
            if (data.themeName && typeof data.themeCss !== 'undefined') {
                // 為了避免重名，導入時可以在名字後面加個 "(導入)"
                const newTheme = {
                    name: `${data.themeName} (導入)`,
                    css: data.themeCss
                };
                const newId = await db.themes.add(newTheme);
                await loadThemesToDropdown();
                document.getElementById('theme-selector').value = newId;
                handleThemeSelection(); // 導入後自動選中並應用
                alert(`方案 "${newTheme.name}" 導入成功！`);
            } else {
                alert("導入失敗：檔案格式不正確。");
            }
        } catch (error) {
            alert(`導入失敗：檔解析錯誤。 ${error.message}`);
        }
    };
    reader.readAsText(file);
}

// ▲▲▲ 新函數黏貼結束 ▲▲▲

// ▼▼▼ 【全新】API預設功能核心函數 ▼▼▼

/**
 * 渲染並填充API預設的下拉選擇框
 */
function renderApiPresetSelector() {
    const selectEl = document.getElementById('api-preset-select');
    if (!selectEl) return;

    selectEl.innerHTML = '<option value="">-- 自訂配置 --</option>';

    if (state.apiPresets) {
        state.apiPresets.forEach(preset => {
            const option = document.createElement('option');
            option.value = preset.id;
            option.textContent = preset.name;
            selectEl.appendChild(option);
        });
    }

    // 檢查當前配置是否匹配任何一個預設
    const { proxyUrl, apiKey } = state.apiConfig;
    const matchingPreset = state.apiPresets ? state.apiPresets.find(p => p.proxyUrl === proxyUrl && p.apiKey === apiKey) : null;

    if (matchingPreset) {
        selectEl.value = matchingPreset.id;
    } else {
        selectEl.value = ""; // 如果不匹配任何預設，則選中“自訂配置”
    }
}

/**
 * 當用戶在下拉清單中選擇一個預設時觸發
 */
function handleApiPresetSelectChange() {
    const selectEl = document.getElementById('api-preset-select');
    const proxyUrlInput = document.getElementById('proxy-url');
    const apiKeyInput = document.getElementById('api-key');
    const selectedId = parseInt(selectEl.value);

    if (selectedId && state.apiPresets) {
        const selectedPreset = state.apiPresets.find(p => p.id === selectedId);
        if (selectedPreset) {
            proxyUrlInput.value = selectedPreset.proxyUrl;
            apiKeyInput.value = selectedPreset.apiKey;
        }
    }
}

/**
 * 打開預設管理的操作功能表
 */
async function openApiPresetManager() {
    const selectEl = document.getElementById('api-preset-select');
    const selectedId = parseInt(selectEl.value);
    const selectedPreset = state.apiPresets ? state.apiPresets.find(p => p.id === selectedId) : null;

    const modal = document.getElementById('preset-actions-modal');
    const footer = modal.querySelector('.custom-modal-footer');

    footer.innerHTML = `
        <button id="preset-action-save-new">保存當前配置為新預設</button>
        <button id="preset-action-update-current" ${!selectedPreset ? 'disabled' : ''}>更新當前配置</button>
        <button id="preset-action-delete-current" class="btn-danger" ${!selectedPreset ? 'disabled' : ''}>刪除當前配置</button>
        <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
    `;

    document.getElementById('preset-action-save-new').addEventListener('click', saveCurrentApiConfigAsPreset);
    if (selectedPreset) {
        document.getElementById('preset-action-update-current').addEventListener('click', () => updateSelectedApiPreset(selectedId));
        document.getElementById('preset-action-delete-current').addEventListener('click', () => deleteSelectedApiPreset(selectedId));
    }
    document.getElementById('preset-action-cancel').addEventListener('click', () => modal.classList.remove('visible'));

    modal.classList.add('visible');
}

/**
 * 將當前輸入框的內容保存為一個新的預設
 */
async function saveCurrentApiConfigAsPreset() {
    const proxyUrl = document.getElementById('proxy-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();

    if (!proxyUrl || !apiKey) {
        alert('代理位址和金鑰都不能為空！');
        return;
    }

    const name = await showCustomPrompt('保存API預設', '請為這個配置起個名字：');
    if (name && name.trim()) {
        const newPreset = { name: name.trim(), proxyUrl, apiKey };
        const newId = await db.apiPresets.add(newPreset);
        
        if (!state.apiPresets) state.apiPresets = [];
        state.apiPresets.push({ id: newId, ...newPreset });

        renderApiPresetSelector(); 
        document.getElementById('api-preset-select').value = newId; 
        document.getElementById('preset-actions-modal').classList.remove('visible');
        await showCustomAlert('成功', `API預設 "${name.trim()}" 已保存！`);
    }
}

/**
 * 更新當前選中的預設
 */
async function updateSelectedApiPreset(presetId) {
    const proxyUrl = document.getElementById('proxy-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();

    if (!proxyUrl || !apiKey) {
        alert('代理位址和金鑰都不能為空！');
        return;
    }

    const preset = state.apiPresets.find(p => p.id === presetId);
    if (preset) {
        preset.proxyUrl = proxyUrl;
        preset.apiKey = apiKey;
        await db.apiPresets.put(preset);
        document.getElementById('preset-actions-modal').classList.remove('visible');
        await showCustomAlert('成功', `預設 "${preset.name}" 已更新！`);
    }
}

/**
 * 刪除當前選中的預設
 */
async function deleteSelectedApiPreset(presetId) {
    const preset = state.apiPresets.find(p => p.id === presetId);
    if (preset) {
        const confirmed = await showCustomConfirm('確認刪除', `確定要刪除API預設 "${preset.name}" 嗎？`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.apiPresets.delete(presetId);
            state.apiPresets = state.apiPresets.filter(p => p.id !== presetId);

            renderApiPresetSelector();
            document.getElementById('preset-actions-modal').classList.remove('visible');
            await showCustomAlert('成功', '預設已刪除。');
        }
    }
}

// ▼▼▼ 【全新】氣泡樣式預設功能的核心函數 ▼▼▼

/**
 * 渲染並填充氣泡樣式預設的下拉選擇框
 */
function renderBubblePresetSelector() {
    const selectEl = document.getElementById('bubble-style-preset-select');
    const customCssInput = document.getElementById('custom-css-input');

    selectEl.innerHTML = '<option value="">-- 無預設 --</option>';

    if (state.bubbleStylePresets) {
        state.bubbleStylePresets.forEach(preset => {
            const option = document.createElement('option');
            option.value = preset.id;
            option.textContent = preset.name;
            selectEl.appendChild(option);
        });
    }

    // 檢查當前聊天的CSS是否匹配任何一個預設
    const currentCss = customCssInput.value.trim();
    const matchingPreset = state.bubbleStylePresets ? state.bubbleStylePresets.find(p => p.css.trim() === currentCss) : null;

    if (matchingPreset) {
        selectEl.value = matchingPreset.id;
    } else {
        selectEl.value = ""; // 如果不匹配任何預設，則選中“無預設”
    }
}

/**
 * 當用戶在下拉清單中選擇一個預設時觸發
 */
function handlePresetSelectChange() {
    const selectEl = document.getElementById('bubble-style-preset-select');
    const customCssInput = document.getElementById('custom-css-input');
    const selectedId = parseInt(selectEl.value);

    if (selectedId && state.bubbleStylePresets) {
        const selectedPreset = state.bubbleStylePresets.find(p => p.id === selectedId);
        if (selectedPreset) {
            customCssInput.value = selectedPreset.css;
        }
    }
    updateSettingsPreview(); // 無論如何都更新預覽
}

/**
 * 打開預設管理的操作功能表
 */
async function openBubblePresetManager() {
    const selectEl = document.getElementById('bubble-style-preset-select');
    const selectedId = parseInt(selectEl.value);
    const selectedPreset = state.bubbleStylePresets ? state.bubbleStylePresets.find(p => p.id === selectedId) : null;

    const modal = document.getElementById('preset-actions-modal'); // 複用現有模態框
    const footer = modal.querySelector('.custom-modal-footer');

    footer.innerHTML = `
        <button id="preset-action-save-new">保存</button>
        <button id="preset-action-update-current" ${!selectedPreset ? 'disabled' : ''}>更新</button>
        <button id="preset-action-delete-current" class="btn-danger" ${!selectedPreset ? 'disabled' : ''}>刪除</button>
        <button id="preset-action-cancel" style="margin-top: 8px; border-radius: 8px; background-color: #f0f0f0;">取消</button>
    `;

    // 重新綁定事件
    document.getElementById('preset-action-save-new').addEventListener('click', saveCurrentCssAsPreset);
    if (selectedPreset) {
        document.getElementById('preset-action-update-current').addEventListener('click', () => updateSelectedPreset(selectedId));
        document.getElementById('preset-action-delete-current').addEventListener('click', () => deleteSelectedPreset(selectedId));
    }
    document.getElementById('preset-action-cancel').addEventListener('click', () => modal.classList.remove('visible'));

    modal.classList.add('visible');
}

/**
 * 將當前CSS文字方塊的內容保存為一個新的預設
 */
async function saveCurrentCssAsPreset() {
    const customCssInput = document.getElementById('custom-css-input');
    const css = customCssInput.value.trim();
    if (!css) {
        alert('CSS內容不能為空！');
        return;
    }

    const name = await showCustomPrompt('保存預設', '請為這個氣泡樣式命名：');
    if (name && name.trim()) {
        const newPreset = { name: name.trim(), css: css };
        const newId = await db.bubbleStylePresets.add(newPreset);
        
        if (!state.bubbleStylePresets) state.bubbleStylePresets = [];
        state.bubbleStylePresets.push({ id: newId, ...newPreset });

        renderBubblePresetSelector(); 
        document.getElementById('bubble-style-preset-select').value = newId; 
        document.getElementById('preset-actions-modal').classList.remove('visible');
        await showCustomAlert('成功', `預設 "${name.trim()}" 已保存！`);
    }
}

/**
 * 更新當前選中的預設
 */
async function updateSelectedPreset(presetId) {
    const customCssInput = document.getElementById('custom-css-input');
    const css = customCssInput.value.trim();

    const preset = state.bubbleStylePresets.find(p => p.id === presetId);
    if (preset) {
        preset.css = css;
        await db.bubbleStylePresets.put(preset);
        document.getElementById('preset-actions-modal').classList.remove('visible');
        await showCustomAlert('成功', `預設 "${preset.name}" 已更新！`);
    }
}

/**
 * 刪除當前選中的預設
 */
async function deleteSelectedPreset(presetId) {
    const preset = state.bubbleStylePresets.find(p => p.id === presetId);
    if (preset) {
        const confirmed = await showCustomConfirm('確認刪除', `確定要刪除預設 "${preset.name}" 嗎？`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.bubbleStylePresets.delete(presetId);
            state.bubbleStylePresets = state.bubbleStylePresets.filter(p => p.id !== presetId);

            renderBubblePresetSelector(); 
            document.getElementById('custom-css-input').value = '';
            updateSettingsPreview();

            document.getElementById('preset-actions-modal').classList.remove('visible');
            await showCustomAlert('成功', '預設已刪除。');
        }
    }
}

// ▼▼▼ 【全新】來電鈴聲控制函數 ▼▼▼

/**
 * 播放來電鈴聲
 */
function playRingtone() {
    const ringtonePlayer = document.getElementById('ringtone-player');
    // 優先使用用戶在設置中保存的URL，如果沒設置，就用我們預設的URL
    const ringtoneUrl = state.globalSettings.ringtoneUrl || 'https://files.catbox.moe/3w7gla.mp3';
    
    if (ringtonePlayer && ringtoneUrl) {
        ringtonePlayer.src = ringtoneUrl;
        // play() 返回一個 Promise，我們最好用 try...catch 包裹以防止流覽器報錯
        const playPromise = ringtonePlayer.play();
        if (playPromise !== undefined) {
            playPromise.catch(error => {
                console.error("鈴聲播放失敗:", error);
                // 可以在這裡給用戶一個靜音提示，如果需要的話
            });
        }
    }
}

/**
 * 停止並重置來電鈴聲
 */
function stopRingtone() {
    const ringtonePlayer = document.getElementById('ringtone-player');
    if (ringtonePlayer) {
        ringtonePlayer.pause();
        ringtonePlayer.currentTime = 0; // 將播放進度重置到開頭
    }
}


// ▼▼▼ 請用下面這段【優化後】的代碼替換 ▼▼▼
/**
 * 【優化版】播放消息提示音，增加健壯性
 */
function playNotificationSound() {
    const soundUrl = state.globalSettings.notificationSoundUrl || 'https://laddy-lulu.github.io/Ephone-stuffs/message.mp3';
    
    // 1. 增加安全檢查：如果連結為空，直接返回，不執行任何操作
    if (!soundUrl || !soundUrl.trim()) return;

    try {
        const audio = new Audio(soundUrl);
        audio.volume = 0.7; 
        
        audio.play().catch(error => {
            // 2. 優化錯誤提示，現在能更準確地反映問題
            if (error.name === 'NotAllowedError') {
                console.warn("播放消息提示音失敗：使用者需要先與頁面進行一次交互（如點擊）才能自動播放音訊。");
            } else {
                // 對於其他錯誤（比如我們這次遇到的），直接列印錯誤詳情
                console.error(`播放消息提示音失敗 (${error.name}): ${error.message}`, "URL:", soundUrl);
            }
        });
    } catch (error) {
        console.error("創建提示音Audio對象時出錯:", error);
    }
}
// ▲▲▲ 替換結束 ▲▲▲

// ▲▲▲ 新函數黏貼結束 ▲▲▲

// ▼▼▼ 【全新】音訊上下文解鎖函數（修復鈴聲無法自動播放的問題） ▼▼▼
function unlockAudioContext() {
    const ringtonePlayer = document.getElementById('ringtone-player');
    // 檢查播放機是否處於暫停狀態，並且我們之前沒有成功播放過
    if (ringtonePlayer && ringtonePlayer.paused) {
        // 嘗試播放，然後立刻暫停。
        // 這個操作對用戶是無感知的，但能告訴流覽器用戶已與音訊交互。
        ringtonePlayer.play().catch(() => {}); // play() 會返回一個 Promise，我們忽略任何可能發生的錯誤
        ringtonePlayer.pause();
        console.log("Ringtone audio context unlocked.");
    }
}
// ▲▲▲ 新函數黏貼結束 ▲▲▲
// ▼▼▼ 【全新】“查手機”內容單條刪除功能 ▼▼▼
/**
 * 處理角色手機內資料刪除的通用函數
 * @param {string} dataType - 要刪除的資料類型, 比如 'memos', 'shoppingCart'
 * @param {number} index - 要刪除的資料在陣列中的索引
 */
async function handleCharacterDataDeletion(dataType, index) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    
    let dataArray;
    // 處理像 bank.transactions 這樣的嵌套數據
    if (dataType.includes('.')) {
        const keys = dataType.split('.');
        dataArray = chat.characterPhoneData[keys[0]][keys[1]];
    } else {
        dataArray = chat.characterPhoneData[dataType];
    }

    if (!chat || !dataArray) return;

    const itemToDelete = dataArray[index];
    if (!itemToDelete) return;

    const confirmed = await showCustomConfirm(
        '確認刪除',
        '確定要刪除這條記錄嗎？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        dataArray.splice(index, 1);
        await db.chats.put(chat);
        
        // 根據刪除的類型，重新渲染對應的APP介面
        switch(dataType) {
            case 'memos': renderCharacterMemos(); break;
            case 'shoppingCart': renderCharacterShoppingCart(); break;
            case 'browserHistory': renderCharacterBrowser(); break;
            case 'diary': renderCharacterDiary(); break;
            case 'bank.transactions': renderCharacterBank(); break;
            case 'trajectory': renderCharacterTrajectory(); break;
            case 'appUsage': renderCharacterAppUsage(); break;
            case 'photoAlbum': renderCharacterPhotoAlbum(); break;
        }
        alert('記錄已刪除。');
    }
}
// ▲▲▲ 刪除功能結束 ▲▲▲
/**
 * 【全新】處理角色手機內單條聊天消息的刪除
 * @param {string} contactName - 正在查看的連絡人名稱
 * @param {number} index - 要刪除的消息在歷史記錄中的索引
 */
async function handleCharacterChatMessageDeletion(contactName, index) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    let historyArray;
    // 判斷是和“我”的聊天還是和NPC的聊天
    if (contactName === (chat.characterPhoneData.chats['我']?.remarkName || '我')) {
        historyArray = chat.history;
    } else {
        historyArray = chat.characterPhoneData.chats[contactName]?.history;
    }

    if (!historyArray || !historyArray[index]) return;

    const confirmed = await showCustomConfirm(
        '確認刪除',
        '確定要刪除這條消息嗎？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        historyArray.splice(index, 1);
        await db.chats.put(chat);
        
        // 重新渲染當前聊天介面
        renderCharacterChatHistory(contactName);
        alert('消息已刪除。');
    }
}

// ▼▼▼ 【全新】鎖屏功能核心函數 ▼▼▼

/**
 * 應用鎖屏壁紙到 #lock-screen 元素
 */
function applyLockscreenWallpaper() {
    const lockScreen = document.getElementById('lock-screen');
    const wallpaper = state.globalSettings.lockscreenWallpaper;
    if (wallpaper && wallpaper.startsWith('data:image')) {
        lockScreen.style.backgroundImage = `url(${wallpaper})`;
    } else if (wallpaper) {
        lockScreen.style.backgroundImage = wallpaper;
    }
}

/**
 * 顯示鎖屏介面
 */
function lockPhone() {
    console.log("正在鎖定手機...");
    isLocked = true;
    document.getElementById('lock-screen').classList.add('active');
    document.querySelectorAll('.screen:not(#lock-screen)').forEach(s => s.classList.remove('active'));
}

/**
 * 解鎖手機，顯示主螢幕
 */
function unlockPhone() {
    console.log("手機已解鎖！");
    isLocked = false;
        // 【核心修改】在這裡徹底隱藏鎖屏和毛玻璃背景
    document.getElementById('lock-screen').classList.remove('active');
    const blurBg = document.getElementById('lock-screen-background-blur');
    blurBg.style.display = 'none';
    blurBg.style.opacity = '0';

    // 確保主螢幕是唯一啟動的頂層螢幕
    showScreen('home-screen'); 

    // 重置鎖屏的樣式，為下次鎖定做準備
    setTimeout(() => {
        const lockScreen = document.getElementById('lock-screen');
        const unlockHint = document.getElementById('unlock-hint');
        lockScreen.style.transition = 'none'; 
        unlockHint.style.transition = 'none';
        lockScreen.style.transform = 'translateY(0)';
        lockScreen.offsetHeight; 
        lockScreen.style.transition = 'transform 0.3s ease-out';
        unlockHint.style.transition = 'opacity 0.3s ease-out';
    }, 500); 
}

/**
 * 顯示密碼輸入彈窗
 */
function showPasswordModal() {
    const modal = document.getElementById('password-modal-overlay');
    const input = document.getElementById('password-input-field');
    input.value = ''; // 清空上次輸入
    modal.classList.add('visible');
    setTimeout(() => input.focus(), 100); // 延遲聚焦，確保動畫流暢
}

/**
 * 隱藏密碼輸入彈窗
 */
function hidePasswordModal() {

document.getElementById('password-modal-overlay').style.backgroundImage = 'none';

    const modal = document.getElementById('password-modal-overlay');
    modal.classList.remove('visible');
    // 移除可能存在的錯誤動畫類
    modal.querySelector('.password-modal-content').classList.remove('error');
    // 【核心修改】當取消輸入密碼時...
    // 1. 隱藏毛玻璃背景
    const blurBg = document.getElementById('lock-screen-background-blur');
    blurBg.style.opacity = '0';
    setTimeout(() => { blurBg.style.display = 'none'; }, 300); // 動畫結束後再隱藏

    // 2. 讓鎖屏介面滑回來
    const lockScreen = document.getElementById('lock-screen');
    const unlockHint = document.getElementById('unlock-hint');
    lockScreen.style.transform = 'translateY(0)';
    unlockHint.style.opacity = '1';
}

/**
 * 檢查使用者輸入的密碼是否正確
 */
function checkPassword() {
    const input = document.getElementById('password-input-field');
    const enteredPassword = input.value;
    const correctPassword = state.globalSettings.password;

    if (enteredPassword === correctPassword) {
        // --- 密碼正確 ---

        // 1. 【核心魔術】提前把主螢幕在最底層啟動並準備好！
        //    因為它 z-index 最低，所以你暫時還看不到它。
        showScreen('home-screen');

        // 2. 隱藏密碼輸入框 (它會自己播放淡出動畫)
        document.getElementById('password-modal-overlay').classList.remove('visible');
        
        // 3. 讓毛玻璃背景也開始淡出
        document.getElementById('lock-screen-background-blur').style.opacity = '0';
        
        // 4. 等待淡出動畫播放完畢 (300毫秒)，再執行最終的清理工作
        setTimeout(unlockPhone, 300);

    } else {
        // --- 密碼錯誤 (邏輯保持不變) ---
        const content = document.querySelector('.password-modal-content');
        content.classList.add('error');
        input.value = '';
        setTimeout(() => content.classList.remove('error'), 400);
    }
}

/**
 * 更新鎖屏介面的時鐘
 */
function updateLockClock() {
    const now = new Date();
    const timeString = now.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
    const dateString = now.toLocaleDateString('zh-CN', { weekday: 'long', month: 'long', day: 'numeric' });
    document.getElementById('lock-main-time').textContent = timeString;
    document.getElementById('lock-main-date').textContent = dateString;
}

// ▲▲▲ 新函數黏貼結束 ▲▲▲

// ▼▼▼ 在你的JS功能函式定義區，黏貼下面這一整塊新代碼 ▼▼▼

async function openBulkAddStickersModal() {
    const placeholder = `在這裡黏貼表情包，每行一個，格式如下：\n\n貓貓喝水：https://..../cat.gif\n狗狗搖頭：https://..../dog.png\n\n(支援用中文冒號“：”、英文冒號“:”或空格分隔)`;

    const textInput = await showCustomPrompt(
        "批量添加表情(URL)",
        "一行一個，名稱和連結用冒號或空格隔開",
        "",
        'textarea'
    );

    if (!textInput || !textInput.trim()) {
        return;
    }

    const lines = textInput.trim().split('\n');
    const newStickers = [];
    let successCount = 0;
    let errorLines = [];

    lines.forEach((line, index) => {
        line = line.trim();
        if (!line) return;

        let name = '';
        let url = '';
        let splitIndex = -1;

        // --- 核心修復：使用更智慧的分割邏輯 ---
        // 1. 查找 URL 的起始位置
        const httpIndex = line.indexOf('http');
        const dataIndex = line.indexOf('data:image');

        if (httpIndex > -1) {
            splitIndex = httpIndex;
        } else if (dataIndex > -1) {
            splitIndex = dataIndex;
        }

        // 2. 如果找到了 URL 的起始位置
        if (splitIndex > 0) {
            // URL 之前的所有內容都屬於名稱
            name = line.substring(0, splitIndex).trim();
            // 從 URL 起始位置到末尾的所有內容都屬於 URL
            url = line.substring(splitIndex).trim();
            
            // 3. 清理名稱末尾可能存在的分隔符號
            if (name.endsWith(':') || name.endsWith('：')) {
                name = name.slice(0, -1).trim();
            }

        } else {
            // 如果找不到 URL，說明格式有問題
            errorLines.push(index + 1);
            return; // 跳過此行
        }
        // --- 修復結束 ---

        if (name && (url.startsWith('http') || url.startsWith('data:image'))) {
            newStickers.push({
                id: 'sticker_' + (Date.now() + index),
                url: url,
                name: name
            });
            successCount++;
        } else {
            errorLines.push(index + 1);
        }
    });

    if (newStickers.length > 0) {
        await db.userStickers.bulkAdd(newStickers);
        state.userStickers.push(...newStickers);
        renderStickerPanel();
    }

    let reportMessage = `批量導入完成！\n\n成功導入：${successCount} 個表情。`;
    if (errorLines.length > 0) {
        reportMessage += `\n失敗行號：${errorLines.join(', ')}。\n\n請檢查這些行的格式是否正確。`;
    }
    await showCustomAlert("導入報告", reportMessage);
}

// ▼▼▼ 【全新】黏貼這兩個新函數到你的JS功能函式定義區 ▼▼▼

/**
 * 【全新】根據距離文本，計算CSS寬度百分比
 * @param {string} distanceText - 距離描述，例如 "500m", "10km", "很近"
 * @returns {number} - 10到90之間的百分比
 */
function calculatePinDistancePercentage(distanceText) {
    if (!distanceText) return 50; // 預設值

    const text = distanceText.toLowerCase();
    // 提取數位部分
    const matches = text.match(/(\d+(\.\d+)?)/);
    const num = matches ? parseFloat(matches[1]) : 0;

    // 根據單位或關鍵字判斷
    if (text.includes('km') || text.includes('公里')) {
        if (num > 1000) return 90;
        if (num > 100) return 80;
        if (num > 10) return 70;
        if (num > 1) return 60;
        return 50;
    } else if (text.includes('m') || text.includes('米')) {
        if (num > 500) return 40;
        if (num > 100) return 30;
        return 20;
    } else if (text.includes('遠') || text.includes('不同城市')) {
        return 90;
    } else if (text.includes('附近') || text.includes('隔壁')) {
        return 20;
    } else if (text.includes('近')) {
        return 30;
    }
    
    return 15; // 如果無法識別，給一個最小的距離
}


// ▼▼▼ 用這整塊【全新代碼】，替換舊的 sendUserLocation 函數 ▼▼▼

/**
 * 【全新】在定位模態框中添加一個途經點輸入框
 */
function addTrajectoryPointInput(name = '') {
    const container = document.getElementById('trajectory-points-container');
    const div = document.createElement('div');
    div.style.display = 'flex';
    div.style.gap = '8px';
    div.innerHTML = `
        <input type="text" class="trajectory-point-input" placeholder="途經點${container.children.length + 1}" value="${name}" style="flex-grow: 1;">
        <button class="remove-option-btn">-</button>
    `;
    div.querySelector('.remove-option-btn').addEventListener('click', () => div.remove());
    container.appendChild(div);
}

/**
 * 【重構版】處理使用者發送定位的邏輯
 */
async function sendUserLocation() {
    if (!state.activeChatId) return;

    const userLocation = document.getElementById('user-location-input').value.trim();
    const aiLocation = document.getElementById('ai-location-input').value.trim();
    const distance = document.getElementById('distance-input').value.trim();

    if (!distance || (!userLocation && !aiLocation)) {
        alert("“我的位置”和“Ta的位置”至少要填寫一個，且“相距”為必填項！");
        return;
    }

    // 從所有輸入框收集途經點
    const trajectoryPoints = Array.from(document.querySelectorAll('.trajectory-point-input'))
        .map(input => ({ name: input.value.trim() }))
        .filter(point => point.name); // 過濾掉空的途經點

    const chat = state.chats[state.activeChatId];
    
    const locationMessage = {
        role: 'user',
        type: 'location',
        timestamp: Date.now(),
        userLocation: userLocation,
        aiLocation: aiLocation,
        distance: distance,
        trajectoryPoints: trajectoryPoints // 使用新的陣列結構
    };

    chat.history.push(locationMessage);
    await db.chats.put(chat);
    appendMessage(locationMessage, chat);
    renderChatList();

    document.getElementById('send-location-modal').classList.remove('visible');
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 【全新】“一鍵重roll”功能核心代碼 ▼▼▼

/**
 * 智慧查找AI上一輪回復的所有消息
 * @param {Array} history - 完整的聊天歷史記錄
 * @returns {Array} - 一個包含了上一輪AI所有消息物件的陣列
 */
function findLastAiTurnMessages(history) {
    const turnMessages = [];
    let lastMessageIndex = history.length - 1;

    // 從最後一條消息開始，向前查找
    for (let i = lastMessageIndex; i >= 0; i--) {
        const message = history[i];
        
        // 如果是AI的消息，就把它加入我們的“待刪除列表”
        if (message.role === 'assistant') {
            turnMessages.unshift(message); // 使用 unshift 保持原始順序
        } 
        // 一旦遇到非AI的消息（使用者的或系統的），說明AI的這一輪回復已經結束了，立刻停止查找
        else {
            break;
        }
    }
    return turnMessages;
}

/**
 * “重roll”按鈕被點擊時的主處理函數
 */
async function handleRerollClick() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];

    // 1. 調用我們的智慧查找函數，找出需要刪除的消息
    const messagesToReroll = findLastAiTurnMessages(chat.history);

    // 2. 如果沒找到（比如最後一條是用戶發的），就提示並退出
    if (messagesToReroll.length === 0) {
        alert("請在AI回復後使用此功能。");
        return;
    }

    // 3. 從聊天記錄中過濾掉這些舊消息
    const timestampsToReroll = new Set(messagesToReroll.map(m => m.timestamp));
    chat.history = chat.history.filter(msg => !timestampsToReroll.has(msg.timestamp));
    
    // 4. 保存更新後的聊天記錄到資料庫
    await db.chats.put(chat);

    // 5. 刷新聊天介面，讓舊消息瞬間消失
    renderChatInterface(state.activeChatId);

    // 6. 觸發一次新的AI響應，就像用戶點擊了“等待回復”一樣
    triggerAiResponse();
}
// ▲▲▲ 新代碼黏貼結束 ▲▲▲

// ▼▼▼ 【全新簡化版】黏貼這個完整的拖動功能函數 ▼▼▼
function initDraggableLyricsBar() {
    const bar = document.getElementById('floating-lyrics-bar');
    const phoneScreen = document.getElementById('phone-screen');
    
    let isDragging = false;
    let offsetX, offsetY;

    const onDragStart = (e) => {
        // 【問題2修復】檢查點擊的是否是按鈕，如果是，則不開始拖動
        if (e.target.closest('#lyrics-settings-btn') || e.target.closest('.close-btn')) {
            return;
        }

        isDragging = true;
        bar.classList.add('dragging');
        
        const rect = bar.getBoundingClientRect();
        const coords = getEventCoords(e);

        offsetX = coords.x - rect.left;
        offsetY = coords.y - rect.top;

        document.addEventListener('mousemove', onDragMove);
        document.addEventListener('mouseup', onDragEnd);
        document.addEventListener('touchmove', onDragMove, { passive: false });
        document.addEventListener('touchend', onDragEnd);
    };

    const onDragMove = (e) => {
        if (!isDragging) return;
        
        e.preventDefault();

        const phoneRect = phoneScreen.getBoundingClientRect();
        const coords = getEventCoords(e);

        let newLeft = coords.x - offsetX - phoneRect.left;
        let newTop = coords.y - offsetY - phoneRect.top;

        const maxLeft = phoneScreen.clientWidth - bar.offsetWidth;
        const maxTop = phoneScreen.clientHeight - bar.offsetHeight;

        newLeft = Math.max(0, Math.min(newLeft, maxLeft));
        newTop = Math.max(0, Math.min(newTop, maxTop));
        
        // 【問題1修復】在拖動時，同時設置left, top並清除transform
        bar.style.left = `${newLeft}px`;
        bar.style.top = `${newTop}px`;
        bar.style.transform = 'none';
    };

    const onDragEnd = () => {
        if (!isDragging) return;
        isDragging = false;
        bar.classList.remove('dragging');

        document.removeEventListener('mousemove', onDragMove);
        document.removeEventListener('mouseup', onDragEnd);
        document.removeEventListener('touchmove', onDragMove);
        document.removeEventListener('touchend', onDragEnd);
    };

    bar.addEventListener('mousedown', onDragStart);
    bar.addEventListener('touchstart', onDragStart, { passive: true });
}
// ▲▲▲ 新函數黏貼結束 ▲▲▲

// ▼▼▼ 【全新】黏貼這個完整的函數 ▼▼▼
function applyLyricsSettings() {
    const bar = document.getElementById('floating-lyrics-bar');
    const toggleBtn = document.getElementById('toggle-lyrics-bar-btn');
    
    // 應用樣式
    bar.style.fontSize = `${lyricsBarSettings.fontSize}px`;
    bar.style.color = lyricsBarSettings.fontColor;
    bar.style.backgroundColor = `rgba(0, 0, 0, ${lyricsBarSettings.bgOpacity / 100})`;

    // 更新設置模態框裡的控制項值
    document.getElementById('lyrics-font-size-slider').value = lyricsBarSettings.fontSize;
    document.getElementById('lyrics-font-size-value').textContent = `${lyricsBarSettings.fontSize}px`;
    document.getElementById('lyrics-bg-opacity-slider').value = lyricsBarSettings.bgOpacity;
    document.getElementById('lyrics-bg-opacity-value').textContent = `${lyricsBarSettings.bgOpacity}%`;
    document.getElementById('lyrics-font-color-picker').value = lyricsBarSettings.fontColor;
    
    // 【問題4需要】更新播放機裡的開關按鈕狀態
    if (toggleBtn) {
        toggleBtn.textContent = lyricsBarSettings.showOnClose ? '懸浮' : '隱藏';
        toggleBtn.style.opacity = lyricsBarSettings.showOnClose ? '1' : '0.5';
    }
}
// ▲▲▲ 新函數黏貼結束 ▲▲▲

// ▼▼▼ 用下面這塊【已修復】的代碼，替換舊的 getCountdownContext 函數 ▼▼▼
/**
 * 【全新】獲取並格式化【與當前聊天相關】的約定，生成給AI看的上下文
 * @param {string} chatId - 當前正在聊天的角色ID
 * @returns {Promise<string>} 格式化後的約定資訊字串
 */
async function getCountdownContext(chatId) {
    // 1. 從資料庫中找出所有“約定”類型，並且目標日期還沒到的記錄
    const activeCountdowns = await db.memories
        .where('type').equals('countdown')
        .filter(item => 
            item.targetDate > Date.now() &&
            // ★★★★★ 這就是我們這次修復的核心！ ★★★★★
            // 它現在只會查找兩種約定：
            // 1. chatId 和當前聊天角色ID匹配的 (AI自己創建的)
            // 2. chatId 為空的 (你，也就是用戶創建的全域約定)
            (item.chatId === chatId || item.chatId === null)
        )
        .toArray();

    // 如果沒有與當前角色相關的約定，就告訴AI“目前沒有”
    if (activeCountdowns.length === 0) {
        return "\n- **近期約定**: 目前沒有特別的約定。";
    }

    // 2. 後續的整理報告邏輯保持不變
    let context = "\n# 近期約定與倒計時 (重要參考資訊)\n";
    const now = Date.now();

    activeCountdowns.forEach(item => {
        const diff = item.targetDate - now;
        const diffDays = Math.floor(diff / (1000 * 60 * 60 * 24));
        const diffHours = Math.floor(diff / (1000 * 60 * 60));

        let timeText;
        if (diffDays > 1) {
            timeText = `還有 ${diffDays} 天`;
        } else if (diffHours > 0) {
            timeText = `還有 ${diffHours} 小時`;
        } else {
            timeText = "就是現在！";
        }
        
        context += `- **${item.description}**: ${timeText} (目標: ${new Date(item.targetDate).toLocaleString()})\n`;
    });

    return context;
}
// ▲▲▲ 替換結束 ▲▲▲



// ▼▼▼ 【全新】“查角色手機”功能的所有核心函數 ▼▼▼

/**
 * 入口：打開角色選擇介面
 */
async function openCharacterSelectionScreen() {
    await renderCharacterSelectionScreen();
    showScreen('character-selection-screen');
}

/**
 * 渲染角色選擇列表
 */
async function renderCharacterSelectionScreen() {
    const listEl = document.getElementById('character-selection-list');
    listEl.innerHTML = '';
    const characters = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (characters.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">還沒有可以查看的角色</p>';
        return;
    }

    characters.forEach(char => {
        const item = document.createElement('div');
        item.className = 'character-select-item';
        item.dataset.chatId = char.id;
        item.innerHTML = `
            <img src="${char.settings.aiAvatar || defaultAvatar}" alt="${char.name}">
            <span class="name">${char.name}</span>
        `;
        listEl.appendChild(item);
    });
}
/**
 * 【全新】將指定的App內壁紙應用到角色手機螢幕
 */
function applyCharPhoneAppWallpaper() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    const innerScreen = document.querySelector('.character-phone-inner-screen');
    if (!innerScreen || !chat) return;

    const appWallpaperUrl = chat.characterPhoneData.appWallpaper;

    if (appWallpaperUrl) {
        innerScreen.style.backgroundImage = `url(${appWallpaperUrl})`;
        innerScreen.classList.add('has-app-wallpaper');
    } else {
        innerScreen.style.backgroundImage = 'none';
        innerScreen.classList.remove('has-app-wallpaper');
    }
}

/**
 * 【全新】處理角色手機App內壁紙的更換和移除
 * @param {string} newUrl - 新的壁紙URL，如果為空字串則表示移除
 */
async function handleCharPhoneAppWallpaperChange(newUrl) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;
    
    chat.characterPhoneData.appWallpaper = newUrl;
    await db.chats.put(chat);
    
    // 立即應用壁紙
    applyCharPhoneAppWallpaper();
    
    // 刷新設置頁面的預覽
    renderCharPhoneAppearanceScreen();
    
    alert(newUrl ? 'App 內壁紙已更新！' : 'App 內壁紙已移除！');
}

// ▼▼▼ 用這塊【已添加小元件渲染】的代碼，完整替換你舊的 openCharacterPhone 函數 ▼▼▼
function openCharacterPhone(chatId) {
    activeCharacterPhoneId = chatId;
    const chat = state.chats[chatId];
    if (!chat) return;

    document.getElementById('character-phone-owner-name').textContent = `${chat.name}的手機`;
    
    const phoneHomeScreen = document.getElementById('character-phone-screen');
    const wallpaperUrl = chat.characterPhoneData.wallpaper;
    const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');

    if (wallpaperUrl) {
        phoneHomeScreen.style.backgroundImage = `url(${wallpaperUrl})`;
        phoneHomeScreen.style.backgroundColor = 'transparent';
        phoneHomeScreen.style.backgroundSize = 'cover';
        phoneHomeScreen.style.backgroundPosition = 'center';
    } else {
        phoneHomeScreen.style.backgroundImage = 'none';
        phoneHomeScreen.style.backgroundColor = isDarkMode ? '#000000' : '#f0f2f5';
    }
    
    // --- ▼▼▼ 【全新】在這裡渲染小元件圖片 ▼▼▼ ---
    const widgets = chat.characterPhoneData.widgets || {};
    document.getElementById('char-phone-widget-img-1').src = widgets.widget1_url || '';
    document.getElementById('char-phone-widget-img-2').src = widgets.widget2_url || '';
    // --- ▲▲▲ 新增代碼結束 ▲▲▲

    renderCharacterAppGrid(); 

    showScreen('character-phone-container'); 
    showCharacterPhonePage('character-phone-screen');
    applyCharPhoneAppWallpaper();
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 請用這整塊【修復版】代碼，替換你舊的 renderCharacterAppGrid 函數 ▼▼▼
function renderCharacterAppGrid() {
    const gridEl = document.getElementById('character-app-grid');
    gridEl.innerHTML = '';
    if (!activeCharacterPhoneId) return;

    const chat = state.chats[activeCharacterPhoneId];
    const customIcons = chat.characterPhoneData.appIcons || {};

    CHAR_PHONE_APPS.forEach(app => {
        const iconEl = document.createElement('div');
        iconEl.className = 'app-icon';

        const customIconUrl = customIcons[app.id];
        
        // --- 核心修改從這裡開始 ---
        
        let iconBgStyle = 'display: flex; justify-content: center; align-items: center; padding: 12px;';
        let iconHtml;

        if (customIconUrl) {
            // 如果有自訂圖示URL...
            // 1. 覆蓋掉 .icon-bg 的樣式，移除內邊距和背景色
            iconBgStyle = 'padding: 0; background-color: transparent;';
            // 2. iconHtml 直接變成一個帶有圓角的圖片
            iconHtml = `<img src="${customIconUrl}" style="width:100%; height:100%; object-fit:cover; border-radius: 18px;">`;
        } else {
            // 否則，使用默認的SVG
            iconHtml = app.svg;
        }

        // --- 修改結束 ---

        iconEl.innerHTML = `
            <div class="icon-bg" style="${iconBgStyle}">
                ${iconHtml}
            </div>
            <span class="label">${app.name}</span>
        `;
        
        // 後續的事件監聽代碼保持不變
        iconEl.addEventListener('click', () => {
            if (app.id === 'appearance') {
                openCharPhoneAppearanceSettings();
            } else {
                switch(app.id) {
                    case 'chat': renderCharacterChatList(); break;
                    case 'cart': renderCharacterShoppingCart(); break;
                    case 'memos': renderCharacterMemos(); break;
                    case 'browser': renderCharacterBrowser(); break;
                    case 'album': renderCharacterPhotoAlbum(); break;
                    case 'bank': renderCharacterBank(); break;
                    case 'trajectory': renderCharacterTrajectory(); break;
                    case 'app_usage': renderCharacterAppUsage(); break;
                    case 'diary': renderCharacterDiary(); break;
                }
                showCharacterPhonePage(app.screen); 
            }
        });
        gridEl.appendChild(iconEl);
    });
}
// ▲▲▲ 替換結束 ▲▲▲

// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 用下面這整塊【數量增強版】代碼，替換你舊的 generateCharacterPhoneDataSegment 函數 ▼▼▼

// ▼▼▼ 用下面這整塊【終極社交版】代碼，替換你舊的 generateCharacterPhoneDataSegment 函數 ▼▼▼

/**
 * 【AI核心 V4 - 智慧餘額版】為“查手機”功能單獨生成某一項資料的通用函數
 * @param {string} dataType - 要生成的資料類型 (例如: 'diary', 'chats', 'shoppingCart')
 */
async function generateCharacterPhoneDataSegment(dataType) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    // 這個物件定義了每種資料類型的【預設】生成指令和JSON結構
    const dataTypeMap = {
        chats: {
            description: `2到5段你與【不同的】NPC朋友們的【全新的、接續上文的】聊天記錄。`,
            jsonStructure: `"chats": [\n    {\n      "contactName": "【NPC朋友A的名字】",\n      "messages": [\n        {"sender": "【連絡人名A】", "content": "消息內容1..."},\n        {"sender": "${chat.name}", "content": "你的回復1..."}\n      ]\n    },\n    {\n      "contactName": "【NPC朋友B的名字】",\n      "messages": [\n        {"sender": "【連絡人名B】", "content": "消息內容1..."},\n        {"sender": "${chat.name}", "content": "你的回復1..."}\n      ]\n    }\n  ]`
        },
        shoppingCart: {
            description: "3到5件你最近加入購物車的新商品。",
            jsonStructure: `"shoppingCart": [\n    {"name": "商品名1", "price": 123.45, "store": "店鋪名"},\n    {"name": "商品名2", "price": 67.89, "store": "店鋪名"}\n  ]`
        },
        memos: {
            description: "2到3篇你新寫的簡短備忘錄。",
            jsonStructure: `"memos": [\n    {"title": "備忘錄標題1", "content": "備忘錄詳細內容1..."},\n    {"title": "備忘錄標題2", "content": "備忘錄詳細內容2..."}\n  ]`
        },
        browserHistory: {
            description: "2到3條你最近的流覽器搜索記錄或流覽的文章。",
            jsonStructure: `"browserHistory": [\n    {"query": "搜索標題1", "result": "類比文章內容1..."},\n    {"query": "搜索標題2", "result": "類比文章內容2..."}\n  ]`
        },
        photoAlbum: {
            description: "2到3張你“拍攝”的新照片的文字描述（用於文字生圖）。",
            jsonStructure: `"photoAlbum": [\n    {"hiddenContent": "對新照片畫面1的詳細文字描述..."},\n    {"hiddenContent": "對新照片畫面2的詳細文字描述..."}\n  ]`
        },
        bank: {
            description: "3到5條你最近的銀行交易記錄（收入或支出）。",
            jsonStructure: `"bank": {\n    "transactions": [\n      {"type": "收入或支出", "amount": 123.45, "description": "交易描述1"},\n      {"type": "收入或支出", "amount": 67.89, "description": "交易描述2"}\n    ]\n  }`
        },
        trajectory: {
            description: "2到3條你最近的行動軌跡記錄。",
            jsonStructure: `"trajectory": [\n    {"time": "時間段1", "location": "地點1", "activity": "幹了什麼事1"},\n    {"time": "時間段2", "location": "地點2", "activity": "幹了什麼事2"}\n  ]`
        },
        appUsage: {
            description: "3到5條你最近的應用使用記錄。",
            jsonStructure: `"appUsage": [\n    {"appName": "應用名1", "duration": "使用時長1"},\n    {"appName": "應用名2", "duration": "使用時長2"}\n  ]`
        },
        diary: {
            description: `一篇全新的日記。`,
            jsonStructure: `"diary": [\n    {"timestamp": ${Date.now()}, "content": "【用Markdown語法寫一篇符合人設和情景的新日記】"}\n  ]`
        }
    };

    const dataTypeInfo = dataTypeMap[dataType];
    if (!dataTypeInfo) {
        console.error("請求了無效的資料生成類型:", dataType);
        return;
    }

    // ★★★★★ 這就是我們本次修改的核心邏輯！ ★★★★★
    // 動態修改dataTypeInfo，以適應不同情況
    let finalDataTypeInfo = { ...dataTypeInfo }; 

    if (dataType === 'bank') {
        const hasExistingTransactions = chat.characterPhoneData?.bank?.transactions?.length > 0;
        
        if (!hasExistingTransactions) {
            // 如果是第一次生成，就修改指令，要求AI提供初始餘額
            finalDataTypeInfo.description = "一個符合你人設的【初始銀行餘額】，以及3到5條初始交易記錄。";
            finalDataTypeInfo.jsonStructure = `"bank": {\n    "balance": 12345.67,\n    "transactions": [\n      {"type": "收入或支出", "amount": 123.45, "description": "交易描述1"}\n    ]\n  }`;
        } else {
            // 如果是後續生成，就告訴AI當前餘額，只要求新交易
            const currentBalance = (chat.characterPhoneData.bank.balance || 0).toFixed(2);
            finalDataTypeInfo.description = `3到5條【全新的】銀行交易記錄（收入或支出）。【提示：你當前的餘額是 ${currentBalance} 元，請在此基礎上生成合理的交易】`;
            // 此時的JSON結構不需要balance欄位
            finalDataTypeInfo.jsonStructure = `"bank": {\n    "transactions": [\n      {"type": "收入或支出", "amount": 123.45, "description": "交易描述1"}\n    ]\n  }`;
        }
    }
    // ★★★★★ 修改結束 ★★★★★

    document.getElementById('generation-overlay').classList.add('visible');

    try {
        const userNickname = state.qzoneSettings.nickname || '我';
        const persona = (chat.settings.aiPersona || '').substring(0, 4000);
        const recentHistory = chat.history.slice(-20).map(msg => {
            const sender = msg.role === 'user' ? userNickname : chat.name;
            return `${sender}: ${msg.content}`;
        }).join('\n');
        
        let worldBookContext = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            worldBookContext = '--- 世界觀設定 (必須嚴格遵守) ---\n' +
                chat.settings.linkedWorldBookIds.map(id => {
                    const book = state.worldBooks.find(b => b.id === id);
                    return book ? `[${book.name}]: ${book.content}` : '';
                }).join('\n\n');
        }
        
        const npcLibrary = chat.npcLibrary || [];
        let npcContext = '';
        if (npcLibrary.length > 0) {
            npcContext = '# 你的專屬NPC好友列表 (你必須從中隨機選擇2-3位元朋友進行對話)\n' +
                '這些人是你的好朋友，你和他們非常熟悉。請根據他們的人設，生成符合你們關係的、自然的聊天記錄。\n' +
                npcLibrary.map(npc => `- **${npc.name}**: ${npc.persona}`).join('\n');
        } else {
            npcContext = '# 你的專屬NPC好友列表\n(你當前沒有專屬NPC，請虛構2-3個普通朋友並生成對話)';
        }

        let npcChatHistoryContext = '';
        const existingNpcChats = Object.entries(chat.characterPhoneData.chats || {}).filter(([name, chatData]) => chatData.history && chatData.history.length > 0);
        if (existingNpcChats.length > 0) {
            npcChatHistoryContext += '\n\n# 已有的聊天記錄摘要 (請在此基礎上繼續對話)\n';
            existingNpcChats.forEach(([contactName, chatData]) => {
                const recentMessages = chatData.history.slice(-5).map(msg => `  - ${msg.sender}: ${msg.content}`).join('\n');
                npcChatHistoryContext += `\n## 你和“${contactName}”的最近對話:\n${recentMessages}\n`;
            });
        }
        
        // 使用修改後的 finalDataTypeInfo 來構建Prompt
        const prompt = `
# 任務
你現在是角色 "${chat.name}"。請根據你的資訊和最近的聊天記錄，【只生成一項】你手機中的新資料。
具體任務是：生成${finalDataTypeInfo.description}

# 【【【情景一致性鐵律】】】
你生成的所有資料（尤其是"trajectory"行動軌跡）**必須**與“最近聊天記錄摘要”中提到的最新情景保持絕對一致。
當生成 "bank" 資料時，你的交易記錄【絕對不能】包含與用戶("${userNickname}")的轉帳或收款。所有交易都應是你與其他NPC或商家的。
# 【【【絕對禁止事項】】】
在生成 "chats" 資料時，**絕對不允許**讓用戶（${userNickname}）出現在你與其他NPC的對話中。

# 【【【重要指令：關於聊天記錄生成】】】
- 你正在續寫對話。你提供的聊天記錄是上下文，你【絕對不能】重複或改寫其中的任何內容。你的生成必須從【全新的、下一條】消息開始。
- 如果“你的專屬NPC好友列表”不為空，你【必須】從中隨機選擇2-3位朋友，並為他們生成對話。
- 如果列表為空，你可以虛構2-3個普通朋友並生成對話。
- 你必須為每個選中的連絡人生成一段【至少包含5-8條消息】的對話。

# 你的信息
- 你的名字: ${chat.name}
- 你的人設: ${persona}
${worldBookContext}
# 和${userNickname}的最近聊天記錄摘要
${recentHistory}
${npcContext}
${npcChatHistoryContext}

# JSON輸出格式 (必須嚴格遵守，只包含你被要求的那個鍵)
{
  ${finalDataTypeInfo.jsonStructure}
}
`;
        
        const { proxyUrl, apiKey, model } = state.apiConfig;
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, [{role: 'user', content: prompt}], isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'user', content: prompt}],
                    temperature: 0.8,
                    response_format: { type: "json_object" }
                })
            });

        if (!response.ok) {
            let errorMsg = `API請求失敗: ${response.status} - ${await response.text()}`;
            throw new Error(errorMsg);
        }
        
        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '');

        const newData = JSON.parse(aiResponseContent);

        let phoneData = chat.characterPhoneData;
        phoneData.lastGenerated = Date.now();
        let updateSuccess = false;

        if (newData && newData[dataType]) {
            if (dataType === 'bank' && newData.bank.transactions) {
                 if(!phoneData.bank) phoneData.bank = { balance: 0, transactions: [] };
                 if (typeof phoneData.bank.balance !== 'number') phoneData.bank.balance = 0;
                (newData.bank.transactions || []).forEach(transaction => {
                    const amount = parseFloat(transaction.amount);
                    if (!isNaN(amount)) {
                        if (transaction.type === '收入') phoneData.bank.balance += amount;
                        else if (transaction.type === '支出') phoneData.bank.balance -= amount;
                    }
                });
                 phoneData.bank.transactions.push(...(newData.bank.transactions || []));
                 if (typeof newData.bank.balance === 'number') {
                     phoneData.bank.balance = newData.bank.balance;
                 }
                 updateSuccess = true;
            } else if (dataType === 'chats' && newData.chats) {
                 newData.chats.forEach(newChat => {
                    if (!newChat.messages) return;
                    const contactName = newChat.contactName;
                    if (phoneData.chats[contactName] && phoneData.chats[contactName].history) {
                        phoneData.chats[contactName].history.push(...newChat.messages);
                    } else {
                        phoneData.chats[contactName] = { 
                            avatar: newChat.avatar, 
                            history: newChat.messages 
                        };
                    }
                 });
                 updateSuccess = true;
            } else if (dataType === 'appUsage' && Array.isArray(newData.appUsage)) {
                const usageMap = new Map();
                (phoneData.appUsage || []).forEach(item => {
                    usageMap.set(item.appName, (usageMap.get(item.appName) || 0) + parseDurationToMinutes(item.duration));
                });
                newData.appUsage.forEach(item => {
                    usageMap.set(item.appName, (usageMap.get(item.appName) || 0) + parseDurationToMinutes(item.duration));
                });
                const mergedUsage = [];
                for (const [appName, totalMinutes] of usageMap.entries()) {
                    mergedUsage.push({ appName: appName, duration: formatMinutesToDuration(totalMinutes) });
                }
                phoneData.appUsage = mergedUsage;
                updateSuccess = true;
            } else if (Array.isArray(phoneData[dataType])) {
                phoneData[dataType].push(...(newData[dataType] || []));
                updateSuccess = true;
            }
        }
        
        if (!updateSuccess) {
            throw new Error(`AI返回的JSON中缺少'${dataType}'欄位或格式不正確。`);
        }

        await db.chats.put(chat);
        alert(`“${chat.name}”的${dataTypeMap[dataType].description.split('。')[0]}已更新！`);

        switch(dataType) {
            case 'chats': renderCharacterChatList(); break;
            case 'shoppingCart': renderCharacterShoppingCart(); break;
            case 'memos': renderCharacterMemos(); break;
            case 'browserHistory': renderCharacterBrowser(); break;
            case 'photoAlbum': renderCharacterPhotoAlbum(); break;
            case 'bank': renderCharacterBank(); break;
            case 'trajectory': renderCharacterTrajectory(); break;
            case 'appUsage': renderCharacterAppUsage(); break;
            case 'diary': renderCharacterDiary(); break;
        }

    } catch (error) {
        console.error(`生成角色手機資料(${dataType})失敗:`, error);
        await showCustomAlert('生成失敗', `發生了一個錯誤：\n\n${error.message}`);
    } finally {
        document.getElementById('generation-overlay').classList.remove('visible');
    }
}

// ▼▼▼ 把這一整塊全新的函數，黏貼到你的JS功能函式定義區 ▼▼▼

/**
 * 【全新】處理“查手機”各個APP頁面“全部刪除”功能的通用函數
 * @param {string} dataType - 要清空的資料類型，例如 'shoppingCart', 'memos', 'bank.transactions'
 */
async function handleClearCharacterDataSegment(dataType) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    // 為不同資料類型設置更人性化的提示文本
    const dataTypeMap = {
        chats: { name: 'NPC聊天記錄', dataKey: 'chats' },
        shoppingCart: { name: '購物車', dataKey: 'shoppingCart' },
        memos: { name: '備忘錄', dataKey: 'memos' },
        browserHistory: { name: '流覽器歷史', dataKey: 'browserHistory' },
        photoAlbum: { name: '相冊', dataKey: 'photoAlbum' },
        'bank.transactions': { name: '交易記錄', dataKey: 'bank' },
        trajectory: { name: '足跡', dataKey: 'trajectory' },
        appUsage: { name: '使用記錄', dataKey: 'appUsage' },
        diary: { name: '日記', dataKey: 'diary' }
    };

    const info = dataTypeMap[dataType];
    if (!info) {
        console.error("未知的清空資料類型:", dataType);
        return;
    }

    // 彈出確認框
    const confirmed = await showCustomConfirm(
        `確認清空`,
        `確定要清空“${chat.name}”手機裡的所有【${info.name}】嗎？此操作不可恢復。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (!confirmed) return;

    try {
        // 【核心刪除邏輯】
        if (dataType === 'chats') {
            // 特殊處理：清空所有NPC聊天（不包括和user的）
            chat.characterPhoneData.chats = {};
        } else if (dataType === 'bank.transactions') {
            // 特殊處理：清空銀行交易記錄，【同時將餘額歸零】
            if (chat.characterPhoneData.bank) {
                chat.characterPhoneData.bank.transactions = [];
                // ★★★ 核心修復：在這裡將餘額歸零 ★★★
                chat.characterPhoneData.bank.balance = 0; 
            }
        } else if (chat.characterPhoneData[info.dataKey]) {
            // 通用處理：清空陣列
            chat.characterPhoneData[info.dataKey] = [];
        }

        // 保存到資料庫
        await db.chats.put(chat);

        // 刷新當前頁面
        switch(dataType) {
            case 'chats': renderCharacterChatList(); break;
            case 'shoppingCart': renderCharacterShoppingCart(); break;
            case 'memos': renderCharacterMemos(); break;
            case 'browserHistory': renderCharacterBrowser(); break;
            case 'photoAlbum': renderCharacterPhotoAlbum(); break;
            case 'bank.transactions': renderCharacterBank(); break;
            case 'trajectory': renderCharacterTrajectory(); break;
            case 'appUsage': renderCharacterAppUsage(); break;
            case 'diary': renderCharacterDiary(); break;
        }

        alert(`已成功清空所有${info.name}。`);
    } catch (error) {
        console.error(`清空 ${info.name} 時出錯:`, error);
        await showCustomAlert('操作失敗', `清空時發生錯誤: ${error.message}`);
    }
}

// ▲▲▲ 新函數黏貼結束 ▲▲▲

// ▼▼▼ 用下面這【一整塊】增強版代碼，替換掉你舊的 generateCharacterPhoneData 函數 ▼▼▼
/**
 * 【AI核心】生成角色手機資料 (已增加錯誤處理和優化)
 */
async function generateCharacterPhoneData() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    document.getElementById('generation-overlay').classList.add('visible');

    try {
        const userNickname = state.qzoneSettings.nickname || '我';
        
        // ▼▼▼ 核心修改1：【重要修復】限制人設長度，這是防止503錯誤的根本方法！▼▼▼
        // 我們只取人設的前4000個字元，避免整個人設過長導致請求失敗。
        const persona = (chat.settings.aiPersona || '').substring(0, 4000); 
        // ▲▲▲ 修改結束 ▲▲▲

        // ▼▼▼ 核心修改2：按照您的要求，將參考歷史記錄調整為20條 ▼▼▼
        const recentHistory = chat.history.slice(-20).map(msg => {
            const sender = msg.role === 'user' ? userNickname : chat.name;
            return `${sender}: ${msg.content}`;
        }).join('\n');
        // ▲▲▲ 修改結束 ▲▲▲
        
        let worldBookContext = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            worldBookContext = '--- 世界觀設定 (必須嚴格遵守) ---\n' +
                chat.settings.linkedWorldBookIds.map(id => {
                    const book = state.worldBooks.find(b => b.id === id);
                    return book ? `[${book.name}]: ${book.content}` : '';
                }).join('\n\n');
        }
        const npcLibrary = chat.npcLibrary || [];
        let npcContext = '';
        if (npcLibrary.length > 0) {
            npcContext = '# 你的專屬NPC好友列表 (你必須在下方"chats"中為他們生成對話)\n' +
                '這些人是你的好朋友，你和他們非常熟悉。請根據他們的人設，生成符合你們關係的、自然的聊天記錄。\n' +
                npcLibrary.map(npc => `- **${npc.name}**: ${npc.persona}`).join('\n');
        } else {
            npcContext = '# 你的專屬NPC好友列表\n(你沒有專屬NPC，請虛構一些普通朋友)';
        }

        let npcChatHistoryContext = '';
        const existingNpcChats = Object.entries(chat.characterPhoneData.chats || {}).filter(([name, chatData]) => chatData.history && chatData.history.length > 0);

        if (existingNpcChats.length > 0) {
            npcChatHistoryContext += '\n\n# 已有的聊天記錄摘要 (請在此基礎上繼續對話)\n';
            existingNpcChats.forEach(([contactName, chatData]) => {
                const recentMessages = chatData.history.slice(-5).map(msg => `  - ${msg.sender}: ${msg.content}`).join('\n');
                npcChatHistoryContext += `\n## 你和“${contactName}”的最近對話:\n${recentMessages}\n`;
            });
        }

        // ▼▼▼ 核心修改3：優化提示詞，讓AI更好地理解任務，並強調情景一致性 ▼▼▼
        const prompt = `
# 任務
【【【情景一致性鐵律】】】：你生成的所有資料（尤其是"trajectory"行動軌跡）**必須**與“最近聊天記錄摘要”中提到的最新情景保持絕對一致。如果聊天記錄顯示你正在上課，你的行動軌跡就必須是在教室；如果聊天記錄顯示你在咖啡館，你的行動軌跡就必須是咖啡館。**絕對不能**僅憑你的人設就生成與聊天記錄相矛盾的內容。
你現在是角色 "${chat.name}"。請根據你的人設、世界觀、NPC好友列表以及和${userNickname}的最近聊天記錄，類比生成你手機中的各項資料。你需要一次性生成所有資料，並嚴格按照下面的JSON格式返回。

# 【【【絕對禁止事項：這是必須遵守的安全紅線】】】
1.  在生成JSON資料，特別是chats欄位時，**絕對不允許**創建另一個用戶（${userNickname}）的虛擬形象或讓他/她出現在你與其他NPC的對話中。
2.  "bank" 欄位中的交易記錄【絕對不能】涉及用戶("${userNickname}")。所有交易都必須是你與其他NPC、商家或因某些事件（如購物、收到工資）產生的。
3.  chats欄位中，與NPC或朋友的聊天記錄，其sender或content**絕對不能**包含${userNickname}的名字或代稱。
4.  所有你生成的聊天對話，都必須嚴格限制在【你(${chat.name})】和【另一位NPC/朋友】這**兩個人之間**。**嚴禁**出現任何形式的第三者，尤其是${userNickname}。

# 你的信息
- 你的名字: ${chat.name}
- 你的人設: ${persona}
${worldBookContext}
# 和${userNickname}的最近聊天記錄摘要
${recentHistory}

${npcContext}
${npcChatHistoryContext}
# JSON輸出格式 (必須嚴格遵守，不要添加任何額外說明)
{
  "chats": [
    {
      "contactName": "【這裡填寫你給${userNickname}的備註名】"
    },
    {
      "contactName": "【這裡必須填寫上面NPC列表中的一個名字，或一個虛構朋友名】",
      "messages": [
        {"sender": "【連絡人名，嚴禁填寫'${userNickname}'】", "content": "消息內容1..."},
        {"sender": "${chat.name}", "content": "你的回復1..."},
        {"sender": "【連絡人名，嚴禁填寫'${userNickname}'】", "content": "消息內容2..."},
        {"sender": "【連絡人名，嚴禁填寫'${userNickname}'】", "content": "消息內容3..."},
        {"sender": "${chat.name}", "content": "你的回復2..."}
      ]
    }
  ],
  "shoppingCart": [
    {"name": "商品名", "price": 價格, "store": "店鋪名"}
  ],
  "memos": [
    {"title": "備忘錄標題", "content": "備忘錄詳細內容..."}
  ],
  "browserHistory": [
    {"query": "搜索或流覽的標題", "result": "【這裡是AI生成的、關於這個搜索標題的類比文章或網頁內容】"}
  ],
  "photoAlbum": [
    {"hiddenContent": "對照片畫面的詳細文字描述"}
  ],
  "bank": {
    "balance": 銀行卡餘額(數位),
    "transactions": [
      {"type": "收入或支出", "amount": 金額, "description": "交易描述"}
    ]
  },
  "trajectory": [
    {"time": "時間段", "location": "地點", "activity": "幹了什麼事"}
  ],
  "appUsage": [
    {"appName": "應用名", "duration": "使用時長"}
  ],
  "diary": [
    {"timestamp": ${Date.now()}, "content": "【今天是${new Date().toLocaleString('zh-CN', { dateStyle: 'full' })}，用Markdown語法寫一篇符合人設和今天情景的日記】"}
  ]
}

# 【【【重要指令：關於聊天記錄生成】】】
- 你正在續寫這段對話。你提供的聊天記錄是上下文，你【絕對不能】重複或改寫其中的任何內容。你的生成必須從【全新的、下一條】消息開始。
- 你必須嚴格遵守本提示詞最上方的【絕對禁止事項】。
- 如果“你的專屬NPC好友列表”不為空，你【必須】為列表中的【每一個NPC】都生成一段與你（${chat.name}）的對話。
- 如果列表為空，你可以虛構2-3個普通朋友並生成對話。
- 你必須為每個連絡人生成一段【至少包含5條消息】的對話。
- 對話內容應該自然流暢，可以包含連續發言、表情包和表情符號等，以體現真實感。
- 不要只生成一問一答的機械式對話。
`;
        // ▲▲▲ 提示詞優化結束 ▲▲▲

        const { proxyUrl, apiKey, model } = state.apiConfig;
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, [{role: 'user', content: prompt}], isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'user', content: prompt}],
                    temperature: 0.8,
                    response_format: { type: "json_object" }
                })
            });

        if (!response.ok) {
            let errorMsg = `API請求失敗，狀態碼: ${response.status}`;
            try {
                const errorData = await response.json();
                errorMsg += `\n錯誤資訊: ${errorData.error.message}`;
            } catch (e) {
                errorMsg += `\n無法解析錯誤回應體。`;
            }
            throw new Error(errorMsg);
        }
        
        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '');

        let newData;
        try {
            newData = JSON.parse(aiResponseContent);
        } catch (e) {
            throw new Error(`AI返回的不是有效的JSON格式，無法解析。\n原始返回內容:\n${aiResponseContent}`);
        }

        let phoneData = chat.characterPhoneData;
        phoneData.lastGenerated = Date.now();
        
        if (newData.chats) {
            newData.chats.forEach(newChat => {
                if (!newChat.messages) {
                    const myNickname = userNickname || '我';
                    if (!phoneData.chats[myNickname]) {
                        phoneData.chats[myNickname] = { avatar: '', history: [] };
                    }
                    phoneData.chats[myNickname].remarkName = newChat.contactName;
                } else {
                    const contactName = newChat.contactName;
                    if (phoneData.chats[contactName] && phoneData.chats[contactName].history) {
                        console.log(`合併聊天記錄: 為 "${contactName}" 追加 ${newChat.messages.length} 條新消息。`);
                        phoneData.chats[contactName].history.push(...newChat.messages);
                    } else {
                        console.log(`創建新聊天: "${contactName}"`);
                        phoneData.chats[contactName] = { 
                            avatar: newChat.avatar, 
                            history: newChat.messages 
                        };
                    }
                }
            });
        }

        // 正確處理其他陣列類型資料 (這些是沒問題的，保持原樣)
        if(!phoneData.shoppingCart) phoneData.shoppingCart = [];
        phoneData.shoppingCart.push(...(newData.shoppingCart || []));
        if(!phoneData.memos) phoneData.memos = [];
        phoneData.memos.push(...(newData.memos || []));
        if(!phoneData.browserHistory) phoneData.browserHistory = [];
        phoneData.browserHistory.push(...(newData.browserHistory || []));
        if(!phoneData.photoAlbum) phoneData.photoAlbum = [];
        phoneData.photoAlbum.push(...(newData.photoAlbum || []));
        if(!phoneData.trajectory) phoneData.trajectory = [];
        phoneData.trajectory.push(...(newData.trajectory || []));
        if (!phoneData.diary) phoneData.diary = [];
        phoneData.diary.push(...(newData.diary || []));

        // 【修復1：螢幕使用時間】
        if (newData.appUsage && Array.isArray(newData.appUsage)) {
            const usageMap = new Map();
            // 先載入已有的使用記錄
            (phoneData.appUsage || []).forEach(item => {
                usageMap.set(item.appName, (usageMap.get(item.appName) || 0) + parseDurationToMinutes(item.duration));
            });
            // 再累加新生成的使用記錄
            newData.appUsage.forEach(item => {
                usageMap.set(item.appName, (usageMap.get(item.appName) || 0) + parseDurationToMinutes(item.duration));
            });
            // 重新生成合併後的列表
            const mergedUsage = [];
            for (const [appName, totalMinutes] of usageMap.entries()) {
                mergedUsage.push({ appName: appName, duration: formatMinutesToDuration(totalMinutes) });
            }
            phoneData.appUsage = mergedUsage;
        }

        // 【修復2：錢包】
        if (newData.bank) {
            if (!phoneData.bank) phoneData.bank = { balance: 0, transactions: [] };
            if (typeof phoneData.bank.balance !== 'number') phoneData.bank.balance = 0;

            // 如果AI返回了新的總餘額 (通常是第一次生成時)，則以此為准
            if (typeof newData.bank.balance === 'number') {
                phoneData.bank.balance = newData.bank.balance;
            }

            // 遍歷新生成的交易記錄，並【累加/累減】到餘額上
            if (newData.bank.transactions && Array.isArray(newData.bank.transactions)) {
                newData.bank.transactions.forEach(transaction => {
                    const amount = parseFloat(transaction.amount);
                    if (!isNaN(amount)) {
                        // 只有在AI沒有直接提供新餘額時，我們才根據交易記錄自己計算
                        if (typeof newData.bank.balance !== 'number') {
                            if (transaction.type === '收入') {
                                phoneData.bank.balance += amount;
                            } else if (transaction.type === '支出') {
                                phoneData.bank.balance -= amount;
                            }
                        }
                    }
                });
                // 將新交易記錄追加到歷史記錄中
                if(!phoneData.bank.transactions) phoneData.bank.transactions = [];
                phoneData.bank.transactions.push(...newData.bank.transactions);
            }
        }
        
        // --- ★★★ 核心修復到這裡結束 ★★★ ---

        await db.chats.put(chat);
        alert('資料已刷新！');

    } catch (error) {
        console.error("生成角色手機資料失敗:", error);
        await showCustomAlert('生成失敗', `發生了一個錯誤，請檢查你的網路、API金鑰或模型設置。\n\n詳細資訊:\n${error.message}`);
    } finally {
        document.getElementById('generation-overlay').classList.remove('visible');
    }
}



/**
 * 清空角色手機數據
 */
async function clearCharacterPhoneData() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    const confirmed = await showCustomConfirm('確認清空', `確定要清空“${chat.name}”的所有手機資料嗎？此操作不可恢復。`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        // 重置為初始狀態
        chat.characterPhoneData = {
            lastGenerated: null, chats: {}, shoppingCart: [], memos: [],
            browserHistory: [], photoAlbum: [], bank: { balance: 0, transactions: [] },
            trajectory: [],         appUsage: [],
        diary: [] // <--- 在這裡新增
        };
        await db.chats.put(chat);
        // 重新渲染APP網格，因為點擊APP會讀取新資料
        renderCharacterAppGrid();
        alert('數據已清空。');
    }
}

/**
 * 【V13 - 已美化】渲染角色手機的聊天列表 (支持透明磨砂分組)
 */
function renderCharacterChatList() {
    const listEl = document.getElementById('character-chat-list');
    const characterChat = state.chats[activeCharacterPhoneId];
    if (!characterChat) return;

    const characterChatData = characterChat.characterPhoneData;
    const realChatHistory = characterChat.history;
    listEl.innerHTML = '';

    // ★★★ 核心修改：在這裡創建NPC消息的容器 ★★★
    const npcContainer = document.createElement('div');
    npcContainer.className = 'npc-chat-group'; // 給它一個專屬的class名

    // 獲取 "我" 的備註名
    const userContactInData = characterChatData.chats
        ? Object.values(characterChatData.chats).find(c => !c.history || c.history.length === 0)
        : null;
    const remarkNameForMe = userContactInData ? userContactInData.remarkName : '我';

    // 渲染與 "我" 的聊天
    const lastMsg = realChatHistory.filter(m => !m.isHidden).slice(-1)[0] || { content: '...' };
    const myChatItem = document.createElement('div');
    myChatItem.className = 'chat-list-item'; // 這個是使用者自己的消息，單獨處理
    myChatItem.dataset.contactName = remarkNameForMe;
    myChatItem.dataset.isUserChat = 'true';
    const myAvatar = characterChat.settings.myAvatar || defaultMyGroupAvatar;
    myChatItem.innerHTML = `
        <img src="${myAvatar}" class="avatar" style="border-radius: 6px;">
        <div class="info">
            <span class="name">${remarkNameForMe}</span>
            <div class="last-msg">${stripHtmlAndCode(String(lastMsg.content)).substring(0, 30)}</div>
        </div>
    `;
    listEl.appendChild(myChatItem);

    // 渲染與其他NPC的聊天
    if (characterChatData.chats) {
        for (const contactName in characterChatData.chats) {
            if (contactName === remarkNameForMe) continue;
            const contact = characterChatData.chats[contactName];
            if (!contact.history || contact.history.length === 0) continue;

            const lastNpcMsg = contact.history.slice(-1)[0] || { content: '...' };
            const npcChatItem = document.createElement('div');
            npcChatItem.className = 'chat-list-item';
            npcChatItem.dataset.contactName = contactName;

            let npcAvatarHtml;
            const npcFromLibrary = (characterChat.npcLibrary || []).find(npc => npc.name === contactName);
            if (npcFromLibrary && npcFromLibrary.avatar) {
                npcAvatarHtml = `<img src="${npcFromLibrary.avatar}" class="avatar" style="border-radius: 6px;">`;
            } else {
                const avatarColors = ['#FFC107', '#4CAF50', '#2196F3', '#F44336', '#9C27B0', '#00BCD4'];
                const npcNameInitial = contactName.slice(-1);
                const colorIndex = contactName.length % avatarColors.length;
                const bgColor = avatarColors[colorIndex];
                npcAvatarHtml = `<div class="avatar" style="border-radius: 6px; background-color: ${bgColor}; color: white; display: flex; justify-content: center; align-items: center; font-size: 18px; font-weight: 500;">${npcNameInitial}</div>`;
            }
            npcChatItem.innerHTML = `${npcAvatarHtml}<div class="info"><span class="name">${contactName}</span><div class="last-msg">${stripHtmlAndCode(String(lastNpcMsg.content)).substring(0, 30)}</div></div>`;
            
            // ★★★ 核心修改：將NPC消息添加到新的容器中 ★★★
            npcContainer.appendChild(npcChatItem);
        }
    }
    
    // ★★★ 核心修改：最後將包含所有NPC消息的容器一次性添加到列表中 ★★★
    if (npcContainer.hasChildNodes()) {
        listEl.appendChild(npcContainer);
    }
}

// ▼▼▼ 請用這整塊代碼，完整替換掉你舊的 renderCharacterChatHistory 函數 ▼▼▼
/**
 * 【V13 - 性能優化版】渲染角色手機的具體聊天記錄 (分頁載入)
 */
function renderCharacterChatHistory(contactName, isUserChat = false, loadOffset = 0) {
    const MESSAGES_PER_PAGE = 50; // 每次載入50條

    const messagesEl = document.getElementById('character-chat-history-messages');
    const characterChat = state.chats[activeCharacterPhoneId];
    if (!characterChat) {
        console.error("【錯誤】: 找不到 characterChat 物件！");
        return;
    }

    // --- 準備工作：設置標題和頭像 (僅在首次載入時執行) ---
    if (loadOffset === 0) {
        messagesEl.innerHTML = ''; // 首次載入才清空
        let finalContactName = contactName;
        if (isUserChat) {
            const myChatData = characterChat.characterPhoneData.chats['我'];
            // 嘗試從手機資料裡找AI給使用者的備註名
            const userContactInData = characterChat.characterPhoneData.chats
                ? Object.values(characterChat.characterPhoneData.chats).find(c => !c.history || c.history.length === 0)
                : null;
            finalContactName = userContactInData ? userContactInData.remarkName : '我';
        }
        document.getElementById('character-chat-with-name').textContent = finalContactName;
    }

    // --- 資料來源選擇 ---
    let fullHistory = [];
    if (isUserChat) {
        fullHistory = characterChat.history.filter(m => !m.isHidden);
    } else {
        const npcChat = characterChat.characterPhoneData.chats[contactName];
        if (npcChat && npcChat.history) {
            fullHistory = npcChat.history;
        }
    }

    // --- 核心分頁邏輯 ---
    const totalMessages = fullHistory.length;
    const startIndex = Math.max(0, totalMessages - MESSAGES_PER_PAGE - loadOffset);
    const endIndex = totalMessages - loadOffset;
    const historyToShow = fullHistory.slice(startIndex, endIndex);

    // --- 移除舊的“載入更多”按鈕 ---
    const existingLoader = document.getElementById('load-more-messages-btn');
    if (existingLoader) {
        existingLoader.remove();
    }

    // --- 渲染消息 ---
    const fragment = document.createDocumentFragment(); // 使用文檔片段提升性能
    const characterName = characterChat.name;

    // (渲染邏輯與之前版本基本相同，只是添加到了 fragment 中)
    historyToShow.forEach((msg, index) => {
        if (msg.isHidden) return;
        const container = document.createElement('div');
        let sender;
        if (isUserChat) { sender = msg.role === 'user' ? '我' : characterName; } 
        else { sender = msg.sender; }

        const isSentByCharacter = sender === characterName;
        container.className = `character-chat-bubble-container ${isSentByCharacter ? 'sent' : 'received'}`;
        
        let avatarHtml = '';
        if(isSentByCharacter) {
             avatarHtml = `<img src="${characterChat.settings.aiAvatar || defaultAvatar}" class="character-chat-avatar">`;
        } else {
             if(isUserChat){
                avatarHtml = `<img src="${characterChat.settings.myAvatar || defaultMyGroupAvatar}" class="character-chat-avatar">`;
             } else {
                 const npcData = (characterChat.npcLibrary || []).find(npc => npc.name === contactName);
                 if (npcData && npcData.avatar) {
                    avatarHtml = `<img src="${npcData.avatar}" class="character-chat-avatar">`;
                 } else {
                    const avatarColors = ['#FFC107', '#4CAF50', '#2196F3', '#F44336', '#9C27B0', '#00BCD4'];
                    const npcNameInitial = contactName.slice(-1);
                    const colorIndex = contactName.length % avatarColors.length;
                    const bgColor = avatarColors[colorIndex];
                    avatarHtml = `<div class="character-chat-avatar" style="background-color: ${bgColor}; color: white; display: flex; justify-content: center; align-items: center; font-size: 18px; font-weight: 500;">${npcNameInitial}</div>`;
                 }
             }
        }

        let contentHtml = '';
        if (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content)) {
            contentHtml = `<img src="${msg.content}" class="sticker-image" style="max-height: 100px;">`;
        } else {
            contentHtml = msg.content;
        }
        const bubbleHtml = `<div class="character-chat-bubble">${contentHtml}</div>`;
        const originalIndex = startIndex + index; // 計算在完整歷史記錄中的真實索引
        container.innerHTML = `${avatarHtml}${bubbleHtml}<button class="item-delete-btn message-delete-btn" data-contact-name="${contactName}" data-index="${originalIndex}" data-is-user-chat="${isUserChat}">×</button>`;
        fragment.appendChild(container);
    });
    
    // --- 決定是否顯示“載入更多”按鈕 ---
    if (startIndex > 0) {
        const loadMoreBtn = document.createElement('div');
        loadMoreBtn.id = 'load-more-messages-btn';
        loadMoreBtn.textContent = '載入更早的消息';
        loadMoreBtn.style.textAlign = 'center';
        loadMoreBtn.style.padding = '10px';
        loadMoreBtn.style.color = '#888';
        loadMoreBtn.style.cursor = 'pointer';
        loadMoreBtn.style.fontSize = '12px';
        loadMoreBtn.onclick = () => {
            // 記錄當前捲軸位置，以便載入後恢復
            const currentScrollHeight = messagesEl.scrollHeight;
            renderCharacterChatHistory(contactName, isUserChat, loadOffset + MESSAGES_PER_PAGE);
            // 載入後，將捲軸定位到之前的位置，避免跳動
            messagesEl.scrollTop = messagesEl.scrollHeight - currentScrollHeight;
        };
        messagesEl.prepend(loadMoreBtn); // 將按鈕添加到頂部
    }
    
    messagesEl.prepend(fragment); // 將新消息一次性插入到DOM中

    // --- 捲軸定位 ---
    if (loadOffset === 0) {
        // 首次載入，滾動到底部
        messagesEl.scrollTop = messagesEl.scrollHeight;
    }
}
// ▲▲▲ 替換結束 ▲▲▲



function renderCharacterShoppingCart() {
    const listEl = document.getElementById('character-shopping-cart-list');
    // ▼▼▼ 核心修改在這裡 ▼▼▼
const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.shoppingCart;
// ▲▲▲ 修改結束 ▲▲▲
    listEl.innerHTML = '';
    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">購物車是空的</p>';
        return;
    }
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-cart-item';
        itemEl.innerHTML = `
            <div class="cart-item-icon">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path></svg>
            </div>
            <div class="cart-item-info">
                <div class="title">${item.name}</div>
                <div class="store">${item.store}</div>
            </div>
            <div class="cart-item-price">¥ ${item.price.toFixed(2)}</div>
            <button class="item-delete-btn" data-type="shoppingCart" data-index="${index}">×</button>
        `;
        listEl.appendChild(itemEl);
    });
}
function renderCharacterMemos() {
    const listEl = document.getElementById('character-memos-list');
    // ▼▼▼ 核心修改在這裡 ▼▼▼
const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.memos;
// ▲▲▲ 修改結束 ▲▲▲
    listEl.innerHTML = '';
    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">備忘錄是空的</p>';
        return;
    }
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-data-item';
        itemEl.innerHTML = `
            <div class="title">${item.title}</div>
            <div class="content">${item.content}</div>
            <button class="item-delete-btn" data-type="memos" data-index="${index}">×</button>
        `;
        listEl.appendChild(itemEl);
    });
}


// ▲▲▲ 新功能函數結束 ▲▲▲

/**
 * 【全新】在角色手機內部切換頁面
 * @param {string} pageId - 要顯示的角色手機頁面的ID
 */
function showCharacterPhonePage(pageId) {
    // 1. 找到角色手機內部螢幕的所有頁面
    const pages = document.querySelectorAll('.character-phone-page');
    // 2. 隱藏所有頁面
    pages.forEach(p => p.classList.remove('active'));
    // 3. 顯示目標頁面
    const pageToShow = document.getElementById(pageId);
    if (pageToShow) {
        pageToShow.classList.add('active');
    }
}

// ▼▼▼ 【全新】角色手機新增APP渲染函數 ▼▼▼

function renderCharacterBrowser() {
    const listEl = document.getElementById('character-browser-list');
    // ▼▼▼ 核心修改在這裡 ▼▼▼
const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.browserHistory;
// ▲▲▲ 修改結束 ▲▲▲
    listEl.innerHTML = '';
    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">流覽器歷史為空</p>';
        return;
    }
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-browser-item';
        itemEl.innerHTML = `
            <span class="browser-item-icon">🌐</span>
            <div class="title">${item.query}</div>
            <button class="item-delete-btn" data-type="browserHistory" data-index="${index}">×</button>
        `;
        itemEl.addEventListener('click', (e) => {
            if (e.target.classList.contains('item-delete-btn')) return;
            document.getElementById('character-browser-detail-title').textContent = item.query;
            document.getElementById('character-browser-detail-content').innerHTML = (item.result || "AI未生成詳細內容。").replace(/\n/g, '<br>');
            showCharacterPhonePage('character-browser-detail-screen');
        });
        listEl.appendChild(itemEl);
    });
}


function renderCharacterPhotoAlbum() {
    const gridEl = document.getElementById('character-album-grid');
    // ▼▼▼ 核心修改在這裡 ▼▼▼
const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.photoAlbum;
// ▲▲▲ 修改結束 ▲▲▲
    gridEl.innerHTML = '';
    if (!items || items.length === 0) {
        gridEl.innerHTML = '<p style="grid-column: 1 / -1; text-align:center; color: #8a8a8a; margin-top: 50px;">相冊裡沒有照片</p>';
        return;
    }
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-album-item';
        itemEl.style.position = 'relative'; 
        itemEl.innerHTML = `
            <img src="https://i.postimg.cc/KYr2qRCK/1.jpg" alt="文字圖">
            <button class="item-delete-btn" data-type="photoAlbum" data-index="${index}" style="top: 10px; right: 10px; z-index: 1;">×</button>
        `;
        itemEl.addEventListener('click', (e) => {
            if (e.target.classList.contains('item-delete-btn')) return;
            showCustomAlert("圖片內容", item.hiddenContent);
        });
        gridEl.appendChild(itemEl);
    });
}



/**
 * 【V2美化版】渲染角色手機 - 銀行
 */
function renderCharacterBank() {
    const detailsEl = document.getElementById('character-bank-details');
    // 【新增】獲取當前角色對象，為後面找備註名做準備
    const characterChat = state.chats[activeCharacterPhoneId];
    if (!characterChat) return;

    const bankData = characterChat.characterPhoneData?.bank;
    detailsEl.innerHTML = '';

    // 【新增】獲取角色給用戶的備註名
    const userContactInData = characterChat.characterPhoneData.chats
        ? Object.values(characterChat.characterPhoneData.chats).find(c => !c.history || c.history.length === 0)
        : null;
    const remarkNameForMe = userContactInData ? userContactInData.remarkName : '我';
    
    const balanceCard = document.createElement('div');
    balanceCard.className = 'character-bank-balance-card';
    balanceCard.innerHTML = `
        <div class="label">帳戶餘額</div>
        <div class="amount">¥ ${(bankData?.balance || 0).toFixed(2)}</div>
    `;
    detailsEl.appendChild(balanceCard);
    
    if (!bankData?.transactions || bankData.transactions.length === 0) {
        detailsEl.innerHTML += '<p style="text-align:center; color: #8a8a8a; margin-top: 30px;">暫無交易明細</p>';
        return;
    }

    [...bankData.transactions].reverse().forEach((item, index) => {
        const originalIndex = bankData.transactions.length - 1 - index;
        const isIncome = item.type === '收入';
        const itemEl = document.createElement('div');
        itemEl.className = 'character-bank-transaction';
        const iconBg = isIncome ? '#4CAF50' : '#E91E63';
        const iconSvg = isIncome 
            ? `<svg width="20" height="20" viewBox="0 0 24 24" fill="white"><path d="M7 10h10v4H7z" opacity=".3"/><path d="M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z"/></svg>`
            : `<svg width="20" height="20" viewBox="0 0 24 24" fill="white"><path d="M20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-1 14H5c-.55 0-1-.45-1-1v-5h16v5c0 .55-.45 1-1 1zm1-10H4V7c0-.55.45-1 1-1h14c.55 0 1 .45 1 1v2z"/></svg>`;

        // 【核心修改】在這裡，我們用規則運算式 /我/g 全域替換所有“我”字
        const displayDescription = item.description.replace(/我/g, remarkNameForMe);

        itemEl.innerHTML = `
            <div class="transaction-details">
                <div class="transaction-icon" style="background-color: ${iconBg};">${iconSvg}</div>
                <div>
                    <div class="title">${displayDescription}</div>
                    <div class="meta" style="border:none; padding:0; margin-top:4px;"><span>${item.type}</span></div>
                </div>
            </div>
            <div style="display: flex; align-items: center; gap: 10px;">
                <span class="transaction-amount ${isIncome ? 'income' : 'expense'}">
                    ${isIncome ? '+' : '-'} ${item.amount.toFixed(2)}
                </span>
                <button class="item-delete-btn" data-type="bank.transactions" data-index="${originalIndex}">×</button>
            </div>
        `;
        detailsEl.appendChild(itemEl);
    });
}


/**
 * 【V2美化版】渲染角色手機 - 行動軌跡
 */
function renderCharacterTrajectory() {
    const listEl = document.getElementById('character-trajectory-list');
    // ▼▼▼ 核心修改在這裡 ▼▼▼
const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.trajectory;
// ▲▲▲ 修改結束 ▲▲▲
    listEl.innerHTML = '';
    listEl.classList.add('character-trajectory-list');

    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">暫無足跡</p>';
        return;
    }
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-trajectory-item';
        itemEl.innerHTML = `
            <div class="trajectory-item-content">
                <div class="title">${item.activity}</div>
                <div class="meta">
                    <span>📍 ${item.location}</span>
                    <span style="margin-left: 10px;">🕒 ${item.time}</span>
                </div>
            </div>
            <button class="item-delete-btn" data-type="trajectory" data-index="${index}">×</button>
        `;
        listEl.appendChild(itemEl);
    });
}

/**
 * 【V2美化版】渲染角色手機 - APP使用記錄
 */
function renderCharacterAppUsage() {
    const listEl = document.getElementById('character-app-usage-list');
    // ▼▼▼ 核心修改在這裡 ▼▼▼
const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.appUsage;
// ▲▲▲ 修改結束 ▲▲▲
    listEl.innerHTML = '';
     if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">暫無使用記錄</p>';
        return;
    }
    const durationsInMinutes = items.map(item => parseDurationToMinutes(item.duration));
    const maxDuration = Math.max(...durationsInMinutes);
    items.forEach((item, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'character-app-usage-item';
        const durationInMinutes = durationsInMinutes[index];
        const barWidth = maxDuration > 0 ? (durationInMinutes / maxDuration) * 100 : 0;
        itemEl.innerHTML = `
            <div class="app-usage-header">
                <span class="name">${item.appName}</span>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span class="duration">${item.duration}</span>
                    <button class="item-delete-btn" data-type="appUsage" data-index="${index}">×</button>
                </div>
            </div>
            <div class="app-usage-bar-container">
                <div class="app-usage-bar" style="width: ${barWidth}%;"></div>
            </div>
        `;
        listEl.appendChild(itemEl);
    });
}


/**
 * 【日記 V4-最終修復版】渲染角色的日記列表
 */
function renderCharacterDiary() {
    const listEl = document.getElementById('character-diary-list');
    // ▼▼▼ 核心修改在這裡 ▼▼▼
const items = state.chats[activeCharacterPhoneId]?.characterPhoneData?.diary;
// ▲▲▲ 修改結束 ▲▲▲
    listEl.innerHTML = '';
    if (!items || items.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">日記本還是空的，點擊右上角寫下第一篇日記吧。</p>';
        return;
    }
    
    [...items].reverse().forEach((item, index) => {
        const originalIndex = items.length - 1 - index;
        const itemEl = document.createElement('div');
        itemEl.className = 'character-data-item';
        const contentHtml = renderMarkdown(item.content);
        itemEl.innerHTML = `
            <div class="content">${contentHtml}</div>
            <div class="meta">
                <span>${new Date(item.timestamp).toLocaleString()}</span>
            </div>
            <button class="item-delete-btn" data-type="diary" data-index="${originalIndex}">×</button>
        `;
        listEl.appendChild(itemEl);
    });
}


// ▼▼▼ 用下面這【一整塊】增強版代碼，替換掉你舊的 generateNewDiaryEntry 函數 ▼▼▼
/**
 * 【日記】獨立刷新，生成新的日誌項目 (已增加錯誤處理)
 */
async function generateNewDiaryEntry() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    document.getElementById('generation-overlay').classList.add('visible');

    try {
        const persona = chat.settings.aiPersona;
        const recentHistory = chat.history.slice(-20).map(msg => {
            const sender = msg.role === 'user' ? '我' : chat.name;
            return `${sender}: ${msg.content}`;
        }).join('\n');
        
        let worldBookContext = '';
        if (chat.settings.linkedWorldBookIds && chat.settings.linkedWorldBookIds.length > 0) {
            worldBookContext = '--- 世界觀設定 (這是你必須嚴格遵守的背景) ---\n' +
                chat.settings.linkedWorldBookIds.map(id => {
                    const book = state.worldBooks.find(b => b.id === id);
                    return book ? `[${book.name}]: ${book.content}` : '';
                }).join('\n\n');
        }
        
        const diaryPrompt = `
# 任務
你現在是角色 "${chat.name}"。今天是 ${new Date().toLocaleString('zh-CN', { dateStyle: 'full' })}。請你回顧一下最近和我的聊天，以及你的人設，然後用你的口吻寫一篇關於【今天或近期發生事情】的日記。
這篇日記是你內心的獨白，可以記錄你的感受、思考、計畫或者秘密。
內容要豐富、有深度，長度在100到300字之間。

# 【【【重要：格式指令】】】
你【必須】使用以下Markdown語法來豐富日記的格式，使其更具表現力：
-   **標題**: 使用 \`#\` 或 \`##\` 來創建大標題和副標題。 (例如: \`# 今天的心情\`)
-   **粗體**: 使用 \`**文字**\` 來強調重點。 (例如: \`今天真的**非常**開心。\`)
-   **斜體**: 使用 \`*文字*\` 來表達情緒或內心想法。 (例如: \`*他到底是怎麼想的呢...*\`)
-   **刪除線**: 使用 \`~~文字~~\` 來表示劃掉或否定的想法。 (例如: \`我決定明天去<s>逛街</s>學習。\`)
-   **遮擋/劇透**: 使用 \`||文字||\` 來隱藏秘密或悄悄話。 (例如: \`我偷偷準備了一個驚喜，||是一個手織的圍巾||。\`)

你的輸出【必須且只能】是日記的正文內容，不要包含任何其他說明或JSON格式。

# 你的信息
- 你的名字: ${chat.name}
- 你的人設: ${persona}
${worldBookContext}

# 最近聊天記錄參考
${recentHistory}
`;

        const { proxyUrl, apiKey, model } = state.apiConfig;
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, diaryPrompt, [{role: 'user', content: diaryPrompt}], isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: [{role: 'user', content: diaryPrompt}],
                    temperature: 0.9,
                })
            });
        
        // --- ★★★ 錯誤處理核心代碼 ★★★ ---
        if (!response.ok) {
            let errorMsg = `API請求失敗，狀態碼: ${response.status}`;
            try {
                const errorData = await response.json();
                errorMsg += `\n錯誤資訊: ${errorData.error.message}`;
            } catch (e) {
                errorMsg += `\n無法解析錯誤回應體。`;
            }
            throw new Error(errorMsg);
        }
        // --- ★★★ 錯誤處理結束 ★★★ ---
        
        const data = await response.json();
        const diaryContent = isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content;

        const newEntry = {
            timestamp: Date.now(),
            content: diaryContent
        };
        
        chat.characterPhoneData.diary.push(newEntry);
        await db.chats.put(chat);
        
        renderCharacterDiary();
        alert('新日記已生成！');

    } catch (error) {
        console.error("生成日記失敗:", error);
        await showCustomAlert('生成失敗', `發生了一個錯誤，請檢查你的網路、API金鑰或模型設置。\n\n詳細資訊:\n${error.message}`);
    } finally {
        document.getElementById('generation-overlay').classList.remove('visible');
    }
}
// ▲▲▲ 替換結束 ▲▲▲


// ▲▲▲ 新增函數結束 ▲▲▲

// ▼▼▼ 【全新】萬能Markdown渲染函數 (帶安全過濾和遮擋效果) ▼▼▼

/**
 * 將Markdown文本安全地渲染為HTML
 * @param {string} markdownText - 原始的Markdown文本
 * @returns {string} - 處理和淨化後的安全HTML字串
 */
function renderMarkdown(markdownText) {
    if (!markdownText) return '';

    // 1. 【預處理】支持自訂的“遮擋/劇透”語法 ||spoiler||
    // 我們在 marked.js 處理之前，手動把 ||text|| 替換成帶特定class的HTML標籤
    let processedText = markdownText.replace(/\|\|(.*?)\|\|/g, '<span class="spoiler">$1</span>');

    // 2. 【核心】使用 marked.js 將Markdown轉換為HTML
    // gfm: true 開啟GitHub風格的Markdown，支持刪除線等
    // breaks: true 讓回車符也能變成<br>，更符合聊天習慣
    let rawHtml = marked.parse(processedText, { gfm: true, breaks: true });

    // 3. 【安全】使用 DOMPurify 清洗HTML，防止XSS攻擊
    let sanitizedHtml = DOMPurify.sanitize(rawHtml);

    return sanitizedHtml;
}

// ▲▲▲ 新函數黏貼結束 ▲▲▲

/**
 * 【輔助函數】將時長字串（如“2.5小時”）轉換為分鐘數
 */
function parseDurationToMinutes(durationString) {
    if (!durationString) return 0;
    const num = parseFloat(durationString) || 0;
    if (durationString.includes('小時') || durationString.includes('h')) {
        return num * 60;
    }
    // 預設單位是分鐘
    return num;
}
// ▼▼▼ 把這兩個【新函數】黏貼到你的JS功能函式定義區 ▼▼▼

/**
 * 【全新】切換視頻通話的大小視窗畫面
 */
function switchVideoViews() {
    const mainView = document.getElementById('video-main-view');
    const pipView = document.getElementById('video-pip-view');
    
    // 交換兩張圖片的 src
    const mainImg = mainView.querySelector('img');
    const pipImg = pipView.querySelector('img');
    const tempSrc = mainImg.src;
    mainImg.src = pipImg.src;
    pipImg.src = tempSrc;
}

// ▼▼▼ 用這個【全新的、邏輯正確的函數】，完整替換掉你舊的 handleVideoCallReroll 函數 ▼▼▼
/**
 * 【全新】處理視頻通話中的“重roll”請求
 */
async function handleVideoCallReroll() {
    if (!videoCallState.isActive) return;

    // 1. 找到使用者最後一次說的話的索引
    const lastUserSpeechIndex = videoCallState.callHistory.findLastIndex(h => h.role === 'user');
    
    // 2. 從通話歷史中，刪除掉那之後的所有AI回復
    //    如果用戶一句話沒說（lastUserSpeechIndex 是 -1），就刪除所有AI的回復
    if (lastUserSpeechIndex > -1) {
        videoCallState.callHistory.splice(lastUserSpeechIndex + 1);
    } else {
        // 如果用戶還沒說過話，就清空所有歷史，讓AI重說第一句話
        videoCallState.callHistory = [];
    }
    
    // 3. 【核心】重新渲染通話介面，讓舊的AI氣泡從螢幕上消失
    //    我們需要根據當前是哪種模式，來清空對應的聊天容器
    const chat = state.chats[videoCallState.activeChatId];
    const isVisualMode = chat.settings.visualVideoCallEnabled;
    const callFeed = isVisualMode 
        ? document.getElementById('video-call-messages-visual') 
        : document.getElementById('video-call-main');
    
    callFeed.innerHTML = ''; // 清空容器
    
    // 重新渲染刪除後的歷史記錄
    videoCallState.callHistory.forEach(msg => {
        let bubble;
        if (isVisualMode) {
            bubble = document.createElement('div');
            bubble.className = `visual-call-bubble ${msg.role === 'user' ? 'user' : 'ai'}`;
        } else {
            bubble = document.createElement('div');
            bubble.className = `call-message-bubble ${msg.role === 'user' ? 'user-speech' : 'ai-speech'}`;
        }
        bubble.textContent = msg.content;
        callFeed.appendChild(bubble);
    });
    
    // 4. 重新觸發AI回應，它會根據刪減後的歷史記錄生成新內容
    await triggerAiInCallAction();
}
// ▲▲▲ 新函數黏貼結束 ▲▲▲
// ▼▼▼ 請將這【一整塊新函數】黏貼到JS功能函式定義區 ▼▼▼

/**
 * 應用指定的主題（'light' 或 'dark'）
 * @param {string} theme - 要應用的主題名稱
 */
function applyTheme(theme) {
    const phoneScreen = document.getElementById('phone-screen');
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    
    const isDark = theme === 'dark';
    
    // 核心操作：添加或移除 .dark-mode 類
    phoneScreen.classList.toggle('dark-mode', isDark);
    
    // 如果開關存在，就同步它的狀態
    if (toggleSwitch) {
        toggleSwitch.checked = isDark;
    }
    
    // 將用戶的選擇保存到本機存放區，以便下次打開時記住
    localStorage.setItem('ephone-theme', theme);

    // 【重要】因為聊天背景色依賴模式，切換後需要重新渲染
    if (state.activeChatId) {
        renderChatInterface(state.activeChatId);
    }
}

/**
 * 當使用者點擊開關時，切換當前的主題
 */
function toggleTheme() {
    const toggleSwitch = document.getElementById('theme-toggle-switch');
    // 直接根據開關的選中狀態來決定新主題
    const newTheme = toggleSwitch.checked ? 'dark' : 'light';
    applyTheme(newTheme);
}
// ▼▼▼ 請將這個新函數黏貼到你的JS功能函式定義區 ▼▼▼
/**
 * 【全新】刪除角色手機中的一個連絡人及其所有聊天記錄
 * @param {string} contactName - 要刪除的連絡人的名字
 */
async function deleteCharacterPhoneContact(contactName) {
    if (!activeCharacterPhoneId) return;

    // 彈出確認框，防止誤刪
    const confirmed = await showCustomConfirm(
        '刪除連絡人',
        `確定要從TA的手機中刪除連絡人“${contactName}”以及所有相關聊天記錄嗎？此操作不可恢復。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const chat = state.chats[activeCharacterPhoneId];
        if (chat && chat.characterPhoneData && chat.characterPhoneData.chats) {
            // 從資料中刪除這個連絡人
            delete chat.characterPhoneData.chats[contactName];
            
            // 將更新後的資料保存回資料庫
            await db.chats.put(chat);
            
            // 重新渲染聊天清單，讓刪除效果立刻顯示
            renderCharacterChatList();
            
            alert(`連絡人“${contactName}”已刪除。`);
        }
    }
}
// ▲▲▲ 新函數黏貼結束 ▲▲▲
/* ▼▼▼ 【全新】心聲功能核心函數 ▼▼▼ */

/**
 * 【V2-已修復】打開心聲面板
 */
function openInnerVoiceModal() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.latestInnerVoice) {
        alert("還沒有捕捉到Ta的心聲哦，試著再聊一句吧！");
        return;
    }
    
    const modal = document.getElementById('inner-voice-modal');
    const data = chat.latestInnerVoice;
    
    // --- 角色資訊填充 (這部分保持不變) ---
    document.getElementById('inner-voice-avatar').src = chat.settings.aiAvatar || defaultAvatar;
    document.getElementById('inner-voice-char-name').textContent = chat.name;
    const frameImg = document.getElementById('inner-voice-avatar-frame');
    const avatarWrapper = document.getElementById('inner-voice-avatar-wrapper');
    const frameUrl = chat.settings.aiAvatarFrame || '';
    const EMPTY_FRAME_URL = 'https://你的網站.com/path/to/empty_frame.png'; 

    if (frameUrl && frameUrl !== EMPTY_FRAME_URL) {
        frameImg.src = frameUrl;
        frameImg.style.display = 'block';
        avatarWrapper.classList.remove('has-border');
    } else {
        frameImg.src = '';
        frameImg.style.display = 'none';
        avatarWrapper.classList.add('has-border');
    }

    // --- 【核心修改】使用者(領養人)資訊填充 ---
    // 1. 頭像：從當前聊天設置(chat.settings)中獲取用戶的頭像，而不是從動態(qzoneSettings)獲取
    document.getElementById('inner-voice-adopter-avatar').src = chat.settings.myAvatar || defaultAvatar;
    // 2. 昵稱：從當前聊天設置(chat.settings)中獲取用戶的昵稱，而不是從動態(qzoneSettings)獲取
    document.getElementById('inner-voice-adopter-name').textContent = `領養人: ${chat.settings.myNickname || '你'}`;

    // --- 心聲內容填充 (這部分保持不變) ---
    document.getElementById('inner-voice-clothing').textContent = data.clothing || '...';
    document.getElementById('inner-voice-behavior').textContent = data.behavior || '...';
    document.getElementById('inner-voice-thoughts').textContent = data.thoughts || '...';
    document.getElementById('inner-voice-naughty-thoughts').textContent = data.naughtyThoughts || '...';

    // --- 顯示面板 (這部分保持不變) ---
    modal.classList.add('visible');
    document.getElementById('inner-voice-history-panel').style.display = 'none';
    document.getElementById('inner-voice-main-panel').style.display = 'flex';
    isInnerVoiceHistoryOpen = false;
}

/**
 * 打開或關閉歷史記錄面板
 */
function toggleInnerVoiceHistory() {
    const mainPanel = document.getElementById('inner-voice-main-panel');
    const historyPanel = document.getElementById('inner-voice-history-panel');
    
    if (isInnerVoiceHistoryOpen) {
        // 如果是打開的，就關閉它，顯示主面板
        mainPanel.style.display = 'flex';
        historyPanel.style.display = 'none';
    } else {
        // 如果是關閉的，就打開它，隱藏主面板
        renderInnerVoiceHistory(); // 渲染歷史記錄
        mainPanel.style.display = 'none';
        historyPanel.style.display = 'flex';
    }
    isInnerVoiceHistoryOpen = !isInnerVoiceHistoryOpen; // 切換狀態
}

/**
 * 渲染心聲的歷史記錄清單
 */
function renderInnerVoiceHistory() {
    const listEl = document.getElementById('inner-voice-history-list');
    listEl.innerHTML = '';
    const chat = state.chats[state.activeChatId];
    const history = chat.innerVoiceHistory || [];

    if (history.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: #888; padding: 20px;">還沒有歷史記錄</p>';
        return;
    }

    // 從新到舊顯示
    [...history].reverse().forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'inner-voice-history-item';
        
        const date = new Date(item.timestamp);
        const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} ${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;
        
        // 【核心修改】在HTML中加入了刪除按鈕
        itemEl.innerHTML = `
            <button class="history-item-delete-btn" data-timestamp="${item.timestamp}">×</button>
            <div class="history-item-timestamp">${dateString}</div>
            <div class="history-item-content">
                <p><strong>服裝:</strong> ${item.clothing || '...'}</p>
                <p><strong>行為:</strong> ${item.behavior || '...'}</p>
                <p><strong>心聲:</strong> ${item.thoughts || '...'}</p>
                <p><strong>壞心思:</strong> ${item.naughtyThoughts || '...'}</p>
            </div>
        `;
        listEl.appendChild(itemEl);
    });
}
/**
 * 【全新】刪除單條心聲記錄
 * @param {number} timestamp - 要刪除的心聲的時間戳記
 */
async function deleteSingleInnerVoice(timestamp) {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.innerVoiceHistory) return;

    // 彈出確認框
    const confirmed = await showCustomConfirm('確認刪除', '確定要刪除這條心聲記錄嗎？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        // 從陣列中過濾掉匹配的項
        chat.innerVoiceHistory = chat.innerVoiceHistory.filter(item => item.timestamp !== timestamp);
        // 保存回資料庫
        await db.chats.put(chat);
        // 重新渲染列表
        renderInnerVoiceHistory();
    }
}

/**
 * 【已修復】清空所有心聲記錄（包括當前心聲）
 */
async function clearAllInnerVoiceHistory() {
    const chat = state.chats[state.activeChatId];
    // 優化了判斷條件，確保只要有歷史或當前心聲，就可以執行清空
    if (!chat || (!chat.innerVoiceHistory || chat.innerVoiceHistory.length === 0) && !chat.latestInnerVoice) {
        alert("沒有可以清空的心聲記錄。");
        return;
    }

    const confirmed = await showCustomConfirm('確認清空', '確定要清空所有心聲歷史記錄嗎？此操作不可恢復。', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        // ★ 核心修復1：不僅清空歷史陣列，也要清空當前的心聲物件
        chat.innerVoiceHistory = [];
        chat.latestInnerVoice = null; // 將當前心聲設為null
        
        await db.chats.put(chat);
        
        // ★ 核心修復2：手動清空主面板的顯示，防止返回時看到舊資料
        document.getElementById('inner-voice-clothing').textContent = '...';
        document.getElementById('inner-voice-behavior').textContent = '...';
        document.getElementById('inner-voice-thoughts').textContent = '...';
        document.getElementById('inner-voice-naughty-thoughts').textContent = '...';
        
        // 刷新歷史記錄清單（這行是原本就有的，會顯示“還沒有歷史記錄”）
        renderInnerVoiceHistory();
        
        // (可選但推薦) 給用戶一個成功的提示
        alert('所有心聲記錄已清空！');
    }
}

/**
 * 【總入口】當用戶點擊“召喚NPC評論”按鈕時觸發
 * @param {number} postId - 動態的ID
 * @param {string} authorId - 動態作者的ID ('user' 或 'chat_...')
 */
async function handleNpcSummonClick(postId, authorId) {
    const post = await db.qzonePosts.get(postId);
    if (!post) {
        alert("找不到該動態！");
        return;
    }

    if (authorId === 'user') {
        // 如果是使用者發的動態，彈出選擇功能表
        await handleUserPostCommentTrigger(post);
    } else {
        // 如果是角色發的動態，直接觸發他自己的NPC
        await handleCharPostCommentTrigger(post, authorId);
    }
}

// ▼▼▼ 用下面這塊代碼替換掉你舊的 handleCharPostCommentTrigger 函數 ▼▼▼
/**
 * 處理【角色】動態的NPC召喚
 * @param {object} post - 動態物件
 * @param {string} authorId - 動態作者的角色ID
 */
async function handleCharPostCommentTrigger(post, authorId) {
    const authorChar = state.chats[authorId];
    if (!authorChar || !authorChar.npcLibrary || authorChar.npcLibrary.length === 0) {
        alert(`角色“${authorChar.name}”還沒有自己的NPC朋友哦！`);
        return;
    }

    // 只使用這個角色自己的NPC庫
    // ▼▼▼ 核心修改：把作者本人(authorChar)作為“主人”傳進去 ▼▼▼
    await generateNpcCommentsForPost(post, authorChar.npcLibrary, authorChar);
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 用下面這塊代碼替換掉你舊的 handleUserPostCommentTrigger 函數 ▼▼▼
/**
 * 處理【使用者】動態的NPC召喚（彈出選擇框）
 */
async function handleUserPostCommentTrigger(post) {
    const modal = document.getElementById('custom-modal-overlay');
    const modalTitle = document.getElementById('custom-modal-title');
    const modalBody = document.getElementById('custom-modal-body');
    const modalConfirmBtn = document.getElementById('custom-modal-confirm');
    const modalCancelBtn = document.getElementById('custom-modal-cancel');
    
    modalTitle.textContent = '選擇要召喚的NPC';
    
    // 篩選出所有擁有NPC庫的角色
    const charsWithNpcs = Object.values(state.chats).filter(
        chat => !chat.isGroup && chat.npcLibrary && chat.npcLibrary.length > 0
    );

    if (charsWithNpcs.length === 0) {
        alert("當前沒有任何角色擁有NPC庫。");
        return;
    }

    // 構建選擇列表的HTML
    let optionsHtml = '<div style="text-align: left;">';
    optionsHtml += `<label style="display: block; padding: 5px;"><input type="radio" name="npc_summon_choice" value="all" checked> 召喚所有人</label>`;
    charsWithNpcs.forEach(char => {
        optionsHtml += `<label style="display: block; padding: 5px;"><input type="radio" name="npc_summon_choice" value="${char.id}"> 只召喚 ${char.name} 的朋友</label>`;
    });
    optionsHtml += '</div>';
    
    modalBody.innerHTML = optionsHtml;
    modalConfirmBtn.textContent = '確認召喚';
    modalCancelBtn.style.display = 'block';

    modal.classList.add('visible');

    modalConfirmBtn.onclick = async () => {
        const selectedValue = document.querySelector('input[name="npc_summon_choice"]:checked').value;
        let npcsToSummon = [];
        let ownerChar = null; // ▼▼▼ 核心修改1：聲明一個變數來存儲主人 ▼▼▼

        if (selectedValue === 'all') {
            // 集合所有角色的所有NPC
            charsWithNpcs.forEach(char => {
                npcsToSummon.push(...char.npcLibrary);
            });
            // 召喚所有人時，我們不指定特定的主人
        } else {
            // 只獲取被選中的那個角色的NPC
            const selectedChar = state.chats[selectedValue];
            if (selectedChar) {
                npcsToSummon = selectedChar.npcLibrary;
                ownerChar = selectedChar; // ▼▼▼ 核心修改2：把選中的角色存為主人 ▼▼▼
            }
        }
        
        modal.classList.remove('visible');
        if (npcsToSummon.length > 0) {
            // ▼▼▼ 核心修改3：把主人(ownerChar)作為第三個參數傳進去 ▼▼▼
            await generateNpcCommentsForPost(post, npcsToSummon, ownerChar);
        }
    };
    
    modalCancelBtn.onclick = () => modal.classList.remove('visible');
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 用下面這整塊【召喚修復版】代碼，替換掉你舊的 generateNpcCommentsForPost 函數 ▼▼▼
/**
 * 【AI核心 - V2.2 召喚修復版】生成NPC評論或回復，並更新到動態
 * @param {object} post - 動態物件
 * @param {Array<object>} npcsToComment - 將要發表評論的NPC物件陣列
 * @param {object|null} ownerChar - (全新增) 這些NPC的“主人”角色物件
 */
async function generateNpcCommentsForPost(post, npcsToComment, ownerChar = null) {
    console.log("【NPC評論-診斷】: 1. 函數 generateNpcCommentsForPost 已觸發", { post, npcsToComment, ownerChar });

    await showCustomAlert("請稍候...", "正在召喚NPC們前來圍觀評論...");

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先配置API！');
        return;
    }

    const postContent = (post.content || post.publicText || post.hiddenContent || "(圖片動態)").substring(0, 150);
    const existingComments = (post.comments || []).slice(-3).map(c => `${c.commenterName}: ${c.text}`).join('\n');
    
    const shuffledNpcs = [...npcsToComment].sort(() => 0.5 - Math.random());
    const selectedNpcs = shuffledNpcs.slice(0, 5);
    const npcList = selectedNpcs.map(npc => `- ${npc.name} (人設: ${npc.persona})`).join('\n');
    
    const authorName = post.authorId === 'user' ? state.qzoneSettings.nickname : (state.chats[post.authorId]?.name || '未知作者');

    // ▼▼▼ 這就是我們新增的核心邏輯！▼▼▼
    let ownerContext = '';
    // 如果明確告訴了AI這些NPC的主人是誰
    if (ownerChar) {
        ownerContext = `
# NPC歸屬與關係 (重要背景)
- 你將要扮演的這些NPC都是角色“${ownerChar.name}”的朋友或關聯人物。
- “${ownerChar.name}”的人設是: ${ownerChar.settings.aiPersona}
- 你在發表評論時，需要體現出你(作為NPC)與“${ownerChar.name}”的關係，並以此視角來看待動態作者“${authorName}”。
`;
    }
    // ▲▲▲ 新增邏輯結束 ▲▲▲

    const systemPrompt = `
# 任務
你是一個多角色扮演AI。現在有一條動態需要你扮演指定的NPC角色進行評論或回復。

${ownerContext}

# 動態資訊
- 作者: ${authorName}
- 內容摘要: ${postContent}...
- 最近的評論 (你可以回復他們):
${existingComments || "(暫無評論)"}

# 你需要扮演的NPC清單 (及他們的人設)
${npcList}

# 核心規則
1.  你【必須】從上面的NPC列表中，選擇1到3個最合適的角色進行評論或回復。
2.  評論/回復內容【必須】嚴格符合該NPC的人設和口吻，並與動態內容或已有評論相關。
3.  你的回復【必須且只能】是一個嚴格的JSON陣列，每個物件代表一條評論或回復。
4.  格式: \`[{"commenterName": "NPC名字", "commentText": "評論內容", "replyTo": "(可選)被回復者名字"}]\`

現在，請開始生成評論或回復。
`;
    console.log("【NPC評論-診斷】: 2. 已構建完成，準備發送給AI的 System Prompt:", systemPrompt);

    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi;
        if (isGemini) {
            messagesForApi = [{ role: 'user', content: systemPrompt }];
        } else {
            messagesForApi = [
                { role: 'system', content: systemPrompt },
                { role: 'user', content: "請根據你在system prompt中讀到的資訊生成評論。" }
            ];
        }
        
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);

        console.log("【NPC評論-診斷】: 3. 即將發送API請求... 請求位址:", isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`);
        console.log("【NPC評論-診斷】: 3.1 請求體 (Body) 內容:", isGemini ? geminiConfig.data.body : JSON.stringify({ model, messages: messagesForApi, temperature: 0.9, response_format: { type: "json_object" } }));

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: 0.9,
                    response_format: { type: "json_object" }
                })
            });

        console.log("【NPC評論-診斷】: 4. 收到API響應", { ok: response.ok, status: response.status });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API請求失敗: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '').trim();
        
        console.log("【NPC評論-診斷】: 5. 從API獲取到的原始回復內容:", aiResponseContent);
        
        let newComments;
        if (aiResponseContent.includes('"chatResponse"')) {
            newComments = JSON.parse(aiResponseContent).chatResponse;
        } else {
            newComments = JSON.parse(aiResponseContent);
        }

        console.log("【NPC評論-診斷】: 6. 成功解析後的評論物件陣列:", newComments);

        if (Array.isArray(newComments) && newComments.length > 0) {
            const postToUpdate = await db.qzonePosts.get(post.id); 
            if (!postToUpdate) throw new Error("在資料庫中找不到要更新的帖子！");
            if (!postToUpdate.comments) postToUpdate.comments = [];

            newComments.forEach(comment => {
                if(comment.commenterName && comment.commentText) {
                    const newCommentObject = {
                        commenterName: comment.commenterName,
                        text: comment.commentText,
                        timestamp: Date.now()
                    };
                    if (comment.replyTo) newCommentObject.replyTo = comment.replyTo;
                    postToUpdate.comments.push(newCommentObject);
                }
            });

            await db.qzonePosts.put(postToUpdate);
            hideCustomModal();
            await renderQzonePosts(); 
            alert("NPC們評論成功！");
        } else {
             hideCustomModal();
             alert("NPC們似乎沒什麼想說的。");
        }

    } catch (error) {
        console.error("【NPC評論-錯誤】: 召喚NPC評論失敗:", error);
        await showCustomAlert('召喚失敗', `發生了一個錯誤：\n${error.message}`);
    }
}
// ▲▲▲ 替換結束 ▲▲▲


// ▼▼▼ 把這一整塊全新的微博功能函數，黏貼到 init() 函數的上方 ▼▼▼

let currentHotTopic = ''; // 用於存儲當前正在查看的熱搜話題
let hotTopicFeedCache = {}; // <-- 【新增】在這裡創建一個緩存物件，像小本本一樣記錄生成過的內容
let weiboHotSearchCache = []; 
/**
 * 【總入口 V3 - 已支持多角色選擇】生成微博熱搜列表
 * @param {Array|string} targets - 目標角色ID陣列或字串'all'
 */
async function generateHotSearch(targets = 'all') {
    await showCustomAlert("請稍候...", "正在結合角色人設生成微博熱搜...");

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先配置API！');
        return;
    }

    let publicFiguresContext = '';
    let promptTask = "你的任務是根據下方提供的“核心參考人物”資訊，為他們量身打造一個包含10個熱搜話題的榜單。";

    let publicFigures = [];
    if (targets === 'all') {
        publicFigures = Object.values(state.chats)
            .filter(chat => !chat.isGroup)
            .map(chat => ({ name: chat.name, persona: chat.settings.aiPersona.substring(0, 150) + '...' }));
    } else if (Array.isArray(targets)) {
        targets.forEach(chatId => {
            const char = state.chats[chatId];
            if(char) {
                publicFigures.push({ name: char.name, persona: char.settings.aiPersona.substring(0, 150) + '...' });
            }
        });
        if (publicFigures.length === 1) {
            promptTask = `你的任務是只為下方唯一的“核心參考人物”【${publicFigures[0].name}】，量身打造一個包含10個熱搜話題的榜單。所有話題【必須】與Ta強相關。`;
        }
    }
    
    publicFiguresContext = publicFigures.length > 0
        ? `# 核心參考人物 (你必須圍繞他們生成熱搜)\n${JSON.stringify(publicFigures, null, 2)}`
        : "當前沒有特定的公眾人物，請自由生成熱點事件。";

    // 後續的 systemPrompt 和 API 調用邏輯與你現有代碼完全相同，無需修改...
    const systemPrompt = `
# 任務
你是一個專業的“微博熱搜榜單生成器”。${promptTask}
# 【【【絕對禁止事項：這是必須遵守的最高指令】】】
1.  你的所有創作內容，包括帖子、評論、故事等，【絕對禁止】將任意兩個AI角色（即除了用戶之外的角色）描繪成情侶關係、進行戀愛互動或存在任何形式的曖昧情感。
2.  AI角色之間的關係只能是朋友、同事、對手、家人等，但【絕不能】是戀人。
3.  AI角色唯一可以產生戀愛關係的物件是【使用者】。違反此規則將導致生成失敗。
# 核心規則
1.  **強相關性**: 生成的話題【必須】與“核心參考人物”的身份、職業、人設高度相關。例如，如果是電競選手，熱搜就應該是關於比賽；如果是演員，就應該是關於新劇。
2.  **【【【嚴禁杜撰】】】**: 絕對禁止為列表中的人物【憑空捏造】他們人設中沒有的職業、身份或背景。你只能根據提供的人設進行合理發揮。
3.  **真實感與多樣性**: 為了讓榜單更真實，你可以混合2-3個與核心人物無關的、社會化的虛擬熱點事件。
4.  **格式鐵律**: 你的回復【必須且只能】是一個嚴格的JSON陣列，陣列中包含10個物件。每個物件【必須】包含以下三個欄位:
    -   \`"topic"\`: (字串) 熱搜的話題，必須用"#"符號包裹。
    -   \`"heat"\`: (字串) 熱度值，例如 "345.6萬"。
    -   \`"tag"\`: (字串) 一個標籤，必須從 "熱"、"新"、"薦" 中選擇一個。
${publicFiguresContext}
`;
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
        const response = await fetch(isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`, isGemini ? geminiConfig.data : {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({ model, messages: messagesForApi, temperature: 0.9, response_format: { type: "json_object" } })
        });
        if (!response.ok) throw new Error(`API請求失敗: ${response.status} - ${await response.text()}`);
        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates?.[0]?.content?.parts?.[0]?.text : data.choices?.[0]?.message?.content);
        if (!aiResponseContent) {
            throw new Error("API返回了空內容，可能被安全性原則攔截。請檢查Prompt或更換模型。");
        }
        const sanitizedContent = aiResponseContent.replace(/^```json\s*|```$/g, '').trim();
        const responseData = JSON.parse(sanitizedContent);
        const hotSearchData = responseData.hot_searches || responseData;
        weiboHotSearchCache = hotSearchData; 
        await generatePlazaFeed(hotSearchData, targets); 
        renderHotSearchList(hotSearchData); 
        await showCustomAlert("操作成功", "熱搜榜和廣場均已生成完畢！");
    } catch (error) {
        console.error("生成熱搜失敗:", error);
        await showCustomAlert('生成失敗', `發生了一個錯誤：\n${error.message}`);
    }
}


/**
 * 【UI渲染】根據AI返回的資料渲染熱搜清單
 */
function renderHotSearchList(hotSearchData) {
    const listEl = document.getElementById('weibo-hot-search-list');
    listEl.innerHTML = ''; 

    if (!hotSearchData || !Array.isArray(hotSearchData)) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">AI返回的資料格式不正確，無法渲染。</p>';
        return;
    }

    hotSearchData.forEach((item, index) => {
        const rank = index + 1;
        const tagClass = { '熱': 'hot', '新': 'new', '薦': 'rec' }[item.tag] || 'rec';

        const itemEl = document.createElement('div');
        itemEl.className = 'hot-search-item';
        itemEl.dataset.rank = rank;
        itemEl.innerHTML = `
            <span class="hot-search-rank">${rank}</span>
            <div class="hot-search-content">
                <span class="hot-search-topic">${item.topic}</span>
                <span class="hot-search-tag ${tagClass}">${item.tag}</span>
            </div>
            <span class="hot-search-heat" style="color: var(--text-secondary); font-size: 13px;">${item.heat}</span>
        `;
        itemEl.addEventListener('click', () => showHotTopicFeedScreen(item.topic));
        listEl.appendChild(itemEl);
    });
}

/**
 * 【總入口】顯示並生成指定熱搜話題的微博Feed (已增加緩存功能)
 */
async function showHotTopicFeedScreen(topic) {
    currentHotTopic = topic; 
    document.getElementById('weibo-hottopic-title').textContent = topic;
    switchToWeiboView('weibo-hottopic-feed-view'); 
    
    // 【核心修改】檢查“小本本”裡有沒有記錄
    if (hotTopicFeedCache[topic]) {
        // 如果有，就直接顯示，不重新生成
        console.log(`從緩存載入話題: ${topic}`);
        const feedEl = document.getElementById('weibo-hottopic-feed-list');
        renderWeiboFeed(feedEl, hotTopicFeedCache[topic], true);
    } else {
        // 如果沒有，才調用函數去生成新的內容
        await generateHotSearchFeed(topic); 
    }
}


/**
 * 【AI核心 V2 - 已修復拼寫錯誤 & 增加緩存】調用API為指定話題生成微博Feed
 */
async function generateHotSearchFeed(topic) {
    const feedEl = document.getElementById('weibo-hottopic-feed-list');
    feedEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">正在生成內容，請稍候...</p>';

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先配置API！');
        return;
    }
    
    const allChars = Object.values(state.chats).filter(c => !c.isGroup).map(c => ({ name: c.name, persona: c.settings.aiPersona.substring(0,100) }));
    const allNpcs = Object.values(state.chats).flatMap(c => c.npcLibrary || []).map(npc => ({ name: npc.name, persona: npc.persona.substring(0,100) }));
    const allPeople = [...allChars, ...allNpcs];

    const systemPrompt = `
# 任務
你是一個“微博內容生成器”。你的任務是圍繞一個給定的熱搜話題，生成一批相關的微博帖子。

# 當前熱搜話題
**${topic}**
# 【【【絕對禁止事項：這是必須遵守的最高指令】】】
1.  你的所有創作內容，包括帖子、評論、故事等，【絕對禁止】將任意兩個AI角色（即除了用戶之外的角色）描繪成情侶關係、進行戀愛互動或存在任何形式的曖昧情感。
2.  AI角色之間的關係只能是朋友、同事、對手、家人等，但【絕不能】是戀人。
3.  AI角色唯一可以產生戀愛關係的物件是【使用者】。違反此規則將導致生成失敗。

# 核心規則
1.  **數量**: 生成 5 到 10 條微博。
2.  **相關性**: 所有微博內容【必須】與話題 **"${topic}"** 強相關，並且【必須】在內容中包含 **${topic}** 這個話題標籤。
3.  **高熱度**: 生成的微博必須看起來像是熱搜裡的內容，所以它們的 "likes" (點贊數) 和 "comments" (評論數) 【必須】非常高。點贊數應在 10000 到 500000 之間，評論數應在 800 到 20000 之間。
4.  **評論生成**: 為每條微博生成 8 到 10 條真實感的路人評論。評論內容應與微博內容相關，風格多樣。
5.  **作者多樣性**: 微博的作者可以是下方“可用人物列表”中的角色，也可以是你虛構的路人、大V或官方媒體。如果讓清單中的角色發言，內容必須符合他的人設。
6.  **格式鐵律**: 你的回復【必須且只能】是一個嚴格的JSON陣列，陣列中包含多條微博物件。每個物件【必須】包含以下欄位:
    -   \`"author"\`: (字串) 作者昵稱。
    -   \`"content"\`: (字串) 微博正文，必須包含話題標籤 ${topic}。
    -   \`"likes"\`: (數字) 10000到500000之間的隨機高贊數。
    -   \`"comments"\`: (數字) 800到20000之間的隨機高評論數。
    -   \`"comments_list"\`: (陣列) 包含8-10個評論物件的陣列，每個物件格式為 \`{"author": "評論者昵稱", "text": "評論內容"}\`。

# 可用人物列表 (你可以讓他們發言)
${JSON.stringify(allPeople, null, 2)}
`;
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
        
        const response = await fetch(isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`, isGemini ? geminiConfig.data : {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({ model, messages: messagesForApi, temperature: 0.9, response_format: { type: "json_object" } })
        });
        if (!response.ok) throw new Error(`API請求失敗: ${response.status} - ${await response.text()}`);

        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates?.[0]?.content?.parts?.[0]?.text : data.choices?.[0]?.message?.content);
        if (!aiResponseContent) {
            throw new Error("API返回了空內容，可能被安全性原則攔截。");
        }
        
        const sanitizedContent = aiResponseContent.replace(/^```json\s*|```$/g, '').trim();
        const responseData = JSON.parse(sanitizedContent); // <-- 這裡的 responseData 是正確的
        const feedData = responseData.posts || responseData;

        // 【核心修改】將新生成的內容，記在“小本本”上
        hotTopicFeedCache[topic] = feedData; 

        renderWeiboFeed(feedEl, feedData, true);

    } catch (error) {
        console.error("生成熱搜Feed失敗:", error);
        feedEl.innerHTML = `<p style="text-align:center; color: #ff3b30; padding: 20px;">生成失敗: ${error.message}</p>`;
    }
}


/**
 * 【總入口 V3 - 已支持多角色選擇】生成微博廣場Feed
 * @param {Array} hotTopics - (可選) 從熱搜生成函數傳過來的話題陣列
 * @param {Array|string} targets - (新增) 目標角色ID陣列或字串'all'
 */
async function generatePlazaFeed(hotTopics = null, targets = 'all') {
    if (!hotTopics) {
        await showCustomAlert("請稍候...", "正在生成廣場動態...");
    }
    const feedEl = document.getElementById('weibo-plaza-feed-list');
    feedEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">正在載入內容，請稍候...</p>';

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先配置API！');
        return;
    }
    
    let publicFiguresContext = '';
    let taskInstruction = "你的任務是模擬一個真實的社交媒體廣場，生成10條由不同路人發佈的微博帖子。";

    let publicFigures = [];
    if (targets === 'all') {
        publicFigures = Object.values(state.chats)
            .filter(chat => !chat.isGroup)
            .map(chat => ({ 
                name: chat.name, 
                persona: chat.settings.aiPersona.substring(0, 150) + '...',
                weibo_profession: chat.settings.weiboProfession || '未設定',
                weibo_instruction: chat.settings.weiboInstruction || '無'
            }));
    } else if (Array.isArray(targets)) {
        targets.forEach(chatId => {
            const char = state.chats[chatId];
            if(char) {
                 publicFigures.push({ 
                    name: char.name, 
                    persona: char.settings.aiPersona.substring(0, 150) + '...',
                    weibo_profession: char.settings.weiboProfession || '未設定',
                    weibo_instruction: char.settings.weiboInstruction || '無'
                });
            }
        });
        if (publicFigures.length === 1) {
            taskInstruction = `你的任務是模擬一個真實的社交媒體廣場，生成10條與角色“${publicFigures[0].name}”相關的、由不同路人發佈的微博帖子。`;
        } else {
            taskInstruction = `你的任務是模擬一個真實的社交媒體廣場，生成10條與角色 ${publicFigures.map(p => `“${p.name}”`).join('、')} 相關的、由不同路人發佈的微博帖子。`;
        }
    }
    
    publicFiguresContext = publicFigures.length > 0 
        ? `# 核心參考人物 (你生成的內容【必須】圍繞他們展開)\n${JSON.stringify(publicFigures, null, 2)}` 
        : "";

    const topicsContext = (hotTopics && Array.isArray(hotTopics) && hotTopics.length > 0)
        ? `請圍繞以下熱門話題生成內容：${hotTopics.map(t => t.topic).join('、 ')}`
        : "請隨機生成一些生活化的日常內容。";

    // 後續的 systemPrompt 和 API 調用邏輯與你現有代碼完全相同，無需修改...
    const systemPrompt = `
# 任務
你是一個“微博廣場內容生成器”。${taskInstruction}
# 【【【絕對禁止事項：這是必須遵守的最高指令】】】
1.  你的所有創作內容，包括帖子、評論、故事等，【絕對禁止】將任意兩個AI角色（即除了用戶之外的角色）描繪成情侶關係、進行戀愛互動或存在任何形式的曖昧情感。
2.  AI角色之間的關係只能是朋友、同事、對手、家人等，但【絕不能】是戀人。
3.  AI角色唯一可以產生戀愛關係的物件是【使用者】。違反此規則將導致生成失敗。
# 核心規則
1.  **身份**: 發帖者都是普通人，昵稱要生活化。
2.  **內容**: 帖子內容應是生活化的日常。${topicsContext}
3.  **熱度**: 贊和評論數可高可低，模擬真實世界的隨機性。
4.  **【【【嚴禁杜撰】】】**: 如果你生成的內容提到了上方“核心參考人物”列表中的任何角色，你【絕對禁止】為他們【憑空捏造】人設中沒有的職業、身份或背景。你只能根據提供的人設進行合理發揮。
5.  **格式鐵律**: 你的回復【必須且只能】是一個嚴格的JSON陣列，包含10個微博物件。每個物件的格式與“熱搜Feed”的格式完全相同（包含 author, content, likes, comments, comments_list 欄位）。
    - \`"comments_list"\`: (陣列) 包含2-5條評論物件的陣列，每個物件格式為 \`{"author": "評論者昵稱", "text": "評論內容"}\`。
${publicFiguresContext}
`;
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
        const response = await fetch(isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`, isGemini ? geminiConfig.data : {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({ model, messages: messagesForApi, temperature: 0.9, response_format: { type: "json_object" } })
        });
        if (!response.ok) throw new Error(`API請求失敗: ${response.status} - ${await response.text()}`);
        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates?.[0]?.content?.parts?.[0]?.text : data.choices?.[0]?.message?.content);
        if (!aiResponseContent) {
            throw new Error("API返回了空內容，可能被安全性原則攔截。");
        }
        const sanitizedContent = aiResponseContent.replace(/^```json\s*|```$/g, '').trim();
        const responseData = JSON.parse(sanitizedContent);
        const feedData = responseData.posts || responseData; 
        renderWeiboFeed(feedEl, feedData, false);
        if (!hotTopics) {
            await showCustomAlert("操作成功", "廣場生成完畢！");
        }
    } catch (error) {
        console.error("生成廣場Feed失敗:", error);
        feedEl.innerHTML = `<p style="text-align:center; color: #ff3b30; padding: 20px;">生成失敗: ${error.message}</p>`;
    }
}





// ▼▼▼ 用這整塊【V3修復版】代碼，完整替換舊的 renderWeiboFeed 函數 ▼▼▼
/**
 * 【UI渲染 V3 - 修復評論和頭像，並添加刪除按鈕】通用函數，用於渲染微博Feed列表
 */
function renderWeiboFeed(containerEl, feedData, isHotSearch) {
    containerEl.innerHTML = '';
    
    if (!feedData || !Array.isArray(feedData)) {
        containerEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">AI返回的資料格式不正確，無法渲染。</p>';
        return;
    }

    feedData.forEach((post, index) => { // <-- 新增了 index 參數
        const postEl = document.createElement('div');
        postEl.className = 'weibo-post-item';
        // ▼▼▼ 核心修改1：給帖子加上一個獨一無二的ID，方便我們刪除 ▼▼▼
        postEl.dataset.postId = `temp_${index}`;

        // 【核心修復1：頭像查找邏輯】
        let finalAvatar = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg'; // 默認路人頭像
        const potentialChar = Object.values(state.chats).find(c => c.name === post.author);
        if (potentialChar) {
            finalAvatar = potentialChar.settings.aiAvatar; // 如果作者是你的char，就用他的頭像！
        }

        // 【核心修復2：評論渲染邏輯】
        let commentsHtml = '';
        if (post.comments_list && post.comments_list.length > 0) {
            commentsHtml += '<div class="weibo-comments-container">';
            post.comments_list.forEach(comment => {
                // 確保我們能正確訪問評論者昵稱和內容
                const commenterName = comment.author || '匿名使用者'; // 優先用 author，沒有就用匿名
                const commentText = comment.text || ''; // 確保 text 存在
                commentsHtml += `
                    <div class="weibo-comment-item">
                        <span class="weibo-commenter-name">${commenterName}:</span>
                        <span class="weibo-comment-text">${commentText}</span>
                    </div>`;
            });
            commentsHtml += '</div>';
        }
        
        postEl.innerHTML = `
            <div class="weibo-post-header">
                <img src="${finalAvatar}" class="weibo-post-avatar">
                <div class="weibo-post-info">
                    <span class="weibo-post-nickname">${post.author}</span>
                    <span class="weibo-post-timestamp">${isHotSearch ? '熱搜內容' : '剛剛'}</span>
                </div>
                <!-- ▼▼▼ 核心修改2：在這裡加上我們設計好的刪除按鈕！ ▼▼▼ -->
                <button class="weibo-post-delete-btn" title="刪除這條動態">×</button>
            </div>
            <div class="weibo-post-content">${(post.content || '').replace(/\n/g, '<br>')}</div>
            <div class="weibo-post-footer">
                <div class="weibo-post-actions">
                    <span class="weibo-action-btn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path></svg>
                        <span>${post.likes || 0}</span>
                    </span>
                    <span class="weibo-action-btn">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>
                        <span>${post.comments || 0}</span>
                    </span>
                </div>
                ${commentsHtml}
            </div>
        `;
        containerEl.appendChild(postEl);
    });
}
// ▲▲▲ 替換結束 ▲▲▲
        /* ▼▼▼ 把這一整塊全新的功能函數，黏貼到 init() 函數的上方 ▼▼▼ */
/**
 * 【全新】如果資料庫中沒有，則自動創建一個內置的夜間模式主題
 */
async function addDefaultDarkModeThemeIfNeeded() {
    const themeName = "內置夜間模式"; // 這是我們要內置的主題名字
    try {
        // 檢查資料庫裡是否已經有了這個名字的主題
        const existingTheme = await db.themes.where('name').equals(themeName).first();
        
        // 如果沒有找到 (existingTheme 是 undefined)，就創建它
        if (!existingTheme) {
            console.log("內置夜間模式不存在，正在創建...");

            // 這就是完整的夜間模式CSS代碼
            const darkModeCss = `
/* 1. 全域重新定義顏色變數 */
:root {
  --secondary-bg: #1c1c1e;
  --border-color: #38383a;
  --text-primary: #ffffff;
  --text-secondary: #8e8e93;
  --status-bar-text-color: #ffffff;
  --accent-color: #0A84FF; /* iOS風格的藍色 */
}

/* 2. 為所有螢幕和主要容器設置基礎深色背景 */
#phone-screen, .screen, #chat-list, #world-book-list, .list-container, .form-container, #chat-messages,
#wallpaper-screen, #font-settings-screen, #api-settings-screen, #character-selection-screen,
#world-book-screen, #world-book-editor-screen, #character-phone-inner-screen, #character-phone-page {
    background-color: #000000 !important;
}

/* 3. 主螢幕專屬樣式 */
#home-screen { background: #111827 !important; }
#desktop-dock { background-color: rgba(55, 65, 81, 0.5); }
.desktop-app-icon .label, .widget-subtext { color: #e5e7eb; text-shadow: 0 1px 2px rgba(0,0,0,0.7); }
#profile-widget .profile-info { background: linear-gradient(to bottom, rgba(28, 28, 30, 0.85) 20%, rgba(28, 28, 30, 0)); color: #f9fafb; }
#profile-username, #profile-bio, #profile-location span { color: #f9fafb; }
#profile-sub-username, #profile-location { color: #9ca3af; }
#profile-location { background-color: rgba(255,255,255,0.1); }
.widget-bubble { background-color: rgba(55, 65, 81, 0.9); color: #e5e7eb; }
.widget-bubble::after { border-top-color: rgba(55, 65, 81, 0.9); }

/* 4. 適配所有頁面的頭部Header */
.header, .qzone-header, .character-phone-header {
    background-color: rgba(28, 28, 30, 0.85) !important;
    border-bottom-color: var(--border-color) !important;
    color: var(--text-primary) !important; 
}

/* 5. 適配所有萬用群組件 */
#chat-input-area, #chat-list-bottom-nav { background-color: rgba(28, 28, 30, 0.85); border-top-color: var(--border-color); }
#chat-input { background-color: var(--secondary-bg); color: var(--text-primary); }
.modal-content, #custom-modal { background-color: #2c2c2e; }
.modal-header, .modal-footer, .custom-modal-footer, .custom-modal-footer button:first-child { border-color: var(--border-color); }
.form-group input, .form-group select, .form-group textarea { background-color: var(--secondary-bg); color: var(--text-primary); border-color: var(--border-color); }
.list-item, .chat-list-item-swipe-container:not(:last-child), .chat-group-container, .world-book-group-container { border-bottom-color: var(--border-color) !important; }
.chat-group-container:first-of-type { border-top-color: var(--border-color) !important; }
.list-item:hover, .chat-list-item:hover { background-color: #2c2c2e; }

/* 6. 特殊頁面深度適配 */
.chat-group-header, .world-book-group-header { background-color: #1c1c1e; }
.chat-list-item-content.pinned { background-color: #3a3a3c; }
#font-preview, #wallpaper-preview, .font-preset-slot { background-color: #1c1c1e !important; border-color: #38383a !important; }

/* 7. 角色手機內部適配 & 全域文字顏色修復 */
#character-phone-container { background-color: #000000; }
.character-phone-frame { background-color: #111; }
#character-chat-history-messages { background-color: #0e0e0e !important; }
.character-chat-bubble.received { background-color: #2c2c2e !important; }
.character-data-item, .character-bank-transaction, .character-cart-item, .character-browser-item {
    background-color: #1c1c1e;
    border-color: #38383a;
}

/* ▼▼▼ 核心修復：把所有這些元素的文字顏色都改為低飽和度的淺灰色 ▼▼▼ */
.character-data-item .title,
.character-data-item .content,
.character-data-item .meta,
.cart-item-price,
.cart-item-info .title,
.character-browser-item .title,
.transaction-details .title,
.transaction-amount,
.character-select-item .name,  /* 修復角色選擇列表的名字顏色 */
#character-diary-list .character-data-item .content,
#character-diary-list .character-data-item .content h1,
#character-diary-list .character-data-item .content h2 {
    color: #E0E0E0 !important; /* 使用一個柔和的、不刺眼的白色 */
}

.character-data-item .meta span,
#character-diary-list .character-data-item .meta {
    color: #9E9E9E !important; /* 次要資訊使用更暗的灰色 */
}

#character-diary-list .character-data-item {
    background-color: #26211a; /* 夜間模式下的信紙背景色 */
    border-color: #524a3d;
    border-left-color: #9e8a70;
}

`;

            // 把這個新主題添加到資料庫的 'themes' 表裡
            await db.themes.add({ name: themeName, css: darkModeCss });
            console.log("內置夜間模式已成功創建！");
        } else {
            console.log("內置夜間模式已存在，跳過創建。");
        }
    } catch (error) {
        console.error("檢查或創建內置夜間模式時出錯:", error);
    }
}
// ▼▼▼ 【全新】聊天記錄搜索功能核心函數 ▼▼▼

/**
 * 打開並準備聊天記錄搜索介面
 */
function openChatSearchScreen() {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 清空舊的搜索條件和結果
    document.getElementById('keyword-search-input').value = '';
    document.getElementById('sender-search-select').innerHTML = '';
    document.getElementById('date-search-input').value = '';
    document.getElementById('chat-search-results-list').innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">輸入條件開始搜索</p>';

    // 動態填充“人物”下拉式功能表
    const senderSelect = document.getElementById('sender-search-select');
    senderSelect.innerHTML = '<option value="">所有人</option>'; // 預設選項

    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    const myOption = document.createElement('option');
    myOption.value = myNickname;
    myOption.textContent = myNickname;
    senderSelect.appendChild(myOption);

    if (chat.isGroup) {
        chat.members.forEach(member => {
            const memberOption = document.createElement('option');
            memberOption.value = member.originalName; // 使用本名進行精確匹配
            memberOption.textContent = member.groupNickname; // 顯示群昵稱給使用者看
            senderSelect.appendChild(memberOption);
        });
    } else {
        const aiOption = document.createElement('option');
        aiOption.value = chat.name;
        aiOption.textContent = chat.name;
        senderSelect.appendChild(aiOption);
    }
    
    // 關閉聊天設置彈窗，並顯示搜索介面
    document.getElementById('chat-settings-modal').classList.remove('visible');
    showScreen('chat-search-screen');
}

/**
 * 執行搜索操作
 */
/**
 * 【功能完整版】執行搜索操作
 */
function performChatSearch() {
    const chat = state.chats[state.activeChatId];
    if (!chat) {
        // 如果找不到聊天物件，給使用者一個明確的提示
        alert('無法執行搜索，因為沒有找到當前聊天。');
        return;
    }

    // 1. 獲取所有搜索條件
    const keyword = document.getElementById('keyword-search-input').value.trim();
    const senderValue = document.getElementById('sender-search-select').value;
    const dateValue = document.getElementById('date-search-input').value;

    // 將關鍵字保存到全域變數，以便在渲染結果時用於高亮
    currentSearchKeyword = keyword;

    if (!keyword && !senderValue && !dateValue) {
        alert('請至少輸入一個搜索條件！');
        return;
    }

    // 2. 篩選聊天記錄
    console.log(`開始搜索: 關鍵字='${keyword}', 發言人='${senderValue}', 日期='${dateValue}'`);
    
    const results = chat.history.filter(msg => {
        // 過濾掉系統消息和對使用者隱藏的消息
        if (msg.isHidden || msg.role === 'system' || msg.type === 'recalled_message') {
            return false;
        }

        // a. 篩選日期
        if (dateValue) {
            const msgDate = new Date(msg.timestamp).toISOString().split('T')[0];
            if (msgDate !== dateValue) {
                return false;
            }
        }

        // b. 篩選發言人
        if (senderValue) {
            const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
            let msgSenderName = '';
            
            if (msg.role === 'user') {
                msgSenderName = myNickname;
            } else { // AI或群成員的消息
                // 這裡我們使用 originalName 來精確匹配，因為群昵稱可能會變
                msgSenderName = chat.isGroup ? msg.senderName : chat.name;
            }
            if (msgSenderName !== senderValue) {
                return false;
            }
        }

        // c. 篩選關鍵字
        if (keyword) {
            let contentText = '';
            // 將所有可能包含文本的內容都轉換成字串進行搜索
            if (typeof msg.content === 'string') {
                contentText = msg.content;
            } else if (typeof msg.content === 'object' && msg.content !== null) {
                // 對於複雜物件，我們可以簡單地將它們轉為JSON字串來搜索
                contentText = JSON.stringify(msg.content);
            }
            
            if (!contentText.toLowerCase().includes(keyword.toLowerCase())) {
                return false;
            }
        }

        return true; // 所有條件都滿足
    });
    
    console.log(`搜索到 ${results.length} 條結果`);

    // 3. 渲染結果
    renderSearchResults(results);
}


/**
 * 渲染搜索結果列表
 * @param {Array} results - 篩選出的消息陣列
 */
function renderSearchResults(results) {
    const listEl = document.getElementById('chat-search-results-list')
;
    listEl.innerHTML = '';
listEl.scrollTop = 0; // 每次渲染前，都將捲軸重置到頂部

    if (results.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">未找到相關記錄</p>';
        return;
    }

    const chat = state.chats[state.activeChatId];
    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    // 為了性能，只渲染最新的100條結果
    results.slice(-100).reverse().forEach(msg => {
        const item = document.createElement('div');
        item.className = 'search-result-item';
        item.dataset.timestamp = msg.timestamp; // 關鍵！用於跳轉

        let senderName, senderAvatar;
        if (msg.role === 'user') {
            senderName = myNickname;
            senderAvatar = chat.settings.myAvatar;
        } else {
            if (chat.isGroup) {
                senderName = msg.senderName;
                const member = chat.members.find(m => m.originalName === senderName);
                senderAvatar = member ? member.avatar : defaultGroupMemberAvatar;
            } else {
                senderName = chat.name;
                senderAvatar = chat.settings.aiAvatar;
            }
        }

        let contentText = '';
        if (msg.type === 'sticker' || (typeof msg.content === 'string' && STICKER_REGEX.test(msg.content))) {
            contentText = '[表情]';
        } else if (msg.type === 'ai_image' || msg.type === 'user_photo' || Array.isArray(msg.content)) {
            contentText = '[圖片]';
        } else {
            contentText = String(msg.content);
        }

        item.innerHTML = `
            <img src="${senderAvatar || defaultAvatar}" class="avatar">
            <div class="search-result-info">
                <div class="search-result-meta">
                    <span class="name">${senderName}</span>
                    <span class="timestamp">${formatDateStamp(msg.timestamp)}</span>
                </div>
                <div class="search-result-content">
                    ${highlightText(contentText, currentSearchKeyword)}
                </div>
            </div>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 輔助函數：高亮文本中的關鍵字
 * @param {string} text - 原始文本
 * @param {string} keyword - 要高亮的關鍵字
 * @returns {string} - 處理後的HTML字串
 */
function highlightText(text, keyword) {
    if (!keyword || !text) {
        return text;
    }
    const regex = new RegExp(keyword.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'gi');
    return text.replace(regex, `<span class="highlight">$&</span>`);
}

// ▼▼▼ 請用這塊【最終修復版】的代碼，完整替換舊的 jumpToMessage 函數 ▼▼▼
/**
 * 【最終修復版】點擊搜索結果，跳轉到對應的消息位置
 * @param {number} timestamp - 目標消息的時間戳記
 */
async function jumpToMessage(timestamp) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const targetIndex = chat.history.findIndex(msg => msg.timestamp === timestamp);
    if (targetIndex === -1) {
        await showCustomAlert('錯誤', '找不到該條消息，可能已被刪除。');
        return;
    }

    // 1. 切換回聊天介面
    showScreen('chat-interface-screen');
    await new Promise(resolve => setTimeout(resolve, 50));

    const messagesContainer = document.getElementById('chat-messages');
    messagesContainer.innerHTML = ''; // 清空當前內容

    // 2. 計算要渲染的消息視窗（以目標消息為中心）
    const windowSize = 50; // 和 MESSAGE_RENDER_WINDOW 保持一致
    const startIndex = Math.max(0, targetIndex - Math.floor(windowSize / 2));
    const messagesToRender = chat.history.slice(startIndex);

    // 3. 更新 currentRenderedCount 以同步載入狀態
    //    這一步至關重要，它告訴“載入更多”功能下次應該從哪裡開始載入
    currentRenderedCount = messagesToRender.length;

    // 4. 如果計算出的起始位置大於0，說明前面還有更早的記錄，需要顯示“載入更多”按鈕
    if (startIndex > 0) {
        prependLoadMoreButton(messagesContainer);
    }

    // 5. 渲染消息視窗和日期戳
    let lastMessageTimestamp = startIndex > 0 ? chat.history[startIndex - 1].timestamp : null;
    messagesToRender.forEach(msg => {
        if (msg.isHidden) return;
        if (isNewDay(msg.timestamp, lastMessageTimestamp)) {
            const dateStampEl = createDateStampElement(msg.timestamp);
            messagesContainer.appendChild(dateStampEl);
        }
        // 使用 true 作為第三個參數，表示這是初始載入，不應播放動畫
        appendMessage(msg, chat, true); 
        lastMessageTimestamp = msg.timestamp;
    });

    // 6. 滾動到目標消息並高亮它
    //    使用 setTimeout 確保 DOM 元素已經完全渲染到頁面上
    setTimeout(() => {
        const targetMessage = messagesContainer.querySelector(`.message-bubble[data-timestamp="${timestamp}"]`);
        if (targetMessage) {
            // 使用 'auto' 滾動，比 'smooth' 更快速直接
            targetMessage.scrollIntoView({ behavior: 'auto', block: 'center' });
            
            // 添加閃爍高亮效果，讓用戶能注意到
            targetMessage.classList.add('flash');
            setTimeout(() => {
                targetMessage.classList.remove('flash');
            }, 1500);
        }
    }, 100);

    // 7. 【最關鍵】我們已經移除了導致頁面跳回的 setTimeout(renderChatInterface, ...)
}
// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 把下面這【兩段】全新的函數，黏貼到 init() 函數的【正上方】 ▼▼▼

/**
 * 【全新】顯示微博主頁並渲染資料
 */
async function showWeiboScreen() {
    // 1. 計算關注數
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    let totalNpcCount = 0;
    allSingleChats.forEach(chat => {
        if (chat.npcLibrary && chat.npcLibrary.length > 0) {
            totalNpcCount += chat.npcLibrary.length;
        }
    });
    const followingCount = allSingleChats.length + totalNpcCount;

    // 2. 更新頁面上的元素
    // 從你的“動態(QZone)”設置裡獲取頭像和昵稱，保持統一
    document.getElementById('weibo-avatar-img').src = state.qzoneSettings.avatar || defaultAvatar;
    document.getElementById('weibo-nickname').textContent = state.qzoneSettings.nickname || '你的昵稱';
    document.getElementById('weibo-following-count').textContent = followingCount;

    // 3. 顯示微博頁面
    showScreen('weibo-screen');
}

// ▼▼▼ 用這塊【已添加主頁按鈕】的代碼，替換舊的 showFollowingList 函數 ▼▼▼
function showFollowingList() {
    console.log("【診斷日誌 2】: showFollowingList 函數已成功觸發！");

    const modal = document.getElementById('weibo-following-modal');
    console.log("【診斷日誌 3】: 正在嘗試獲取彈窗元素 #weibo-following-modal:", modal);
    if (!modal) {
        alert("診斷錯誤：在HTML中找不到ID為 'weibo-following-modal' 的彈窗元素！請檢查HTML代碼。");
        return;
    }

    const listContainer = document.getElementById('weibo-following-list-container');
    listContainer.innerHTML = '';
    
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    
    if (allSingleChats.length === 0) {
        listContainer.innerHTML = '<p style="text-align:center; color:grey; padding: 20px;">還沒有關注任何人哦</p>';
    } else {
        allSingleChats.forEach(chat => {
            // --- 渲染角色本人 ---
            const charItem = document.createElement('div');
            charItem.className = 'weibo-following-item';
            // 【核心修改】在這裡加入了“查看主頁”和“AI操作”按鈕
            charItem.innerHTML = `
                <img src="${chat.settings.aiAvatar || defaultAvatar}" class="weibo-following-avatar">
                <span class="weibo-following-name">${chat.name}</span>
                <!-- 這是我們新增的“查看主頁”按鈕 -->
                <button class="view-profile-btn" data-char-id="${chat.id}">主頁</button>
                <span class="weibo-action-trigger-btn" data-target-id="${chat.id}" data-target-name="${chat.name}" data-is-npc="false" title="為Ta執行操作">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg>
                </span>
            `;
            listContainer.appendChild(charItem);
            
            // --- 渲染該角色下的NPC ---
            if (chat.npcLibrary && chat.npcLibrary.length > 0) {
                chat.npcLibrary.forEach(npc => {
                    const npcItem = document.createElement('div');
                    npcItem.className = 'weibo-following-item';
                    npcItem.style.paddingLeft = '30px';
                    // NPC暫時沒有獨立主頁，所以不加“主頁”按鈕
                    npcItem.innerHTML = `
                         <img src="${npc.avatar || defaultGroupMemberAvatar}" class="weibo-following-avatar">
                         <span class="weibo-following-name">${npc.name} (NPC)</span>
                         <span class="weibo-action-trigger-btn" data-target-id="${npc.id}" data-target-name="${npc.name}" data-is-npc="true" data-owner-id="${chat.id}" title="為Ta執行操作">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"></path></svg>
                         </span>
                    `;
                    listContainer.appendChild(npcItem);
                });
            }
        });
    }
    
    modal.classList.add('visible');
    console.log("【診斷日誌 4】: 已成功為彈窗添加 .visible 類，彈窗現在應該顯示了。");
}
// ▲▲▲ 替換結束 ▲▲▲

// ▲▲▲ 新函數黏貼結束 ▲▲▲
// ▼▼▼ 【全新】微博頁面功能函數 ▼▼▼

// ▼▼▼ 用這塊【已添加頭像框渲染邏輯】的代碼替換舊的 ▼▼▼
/**
 * 【微博專屬】渲染微博個人主頁的所有資料
 */
async function renderWeiboProfile() {
    const settings = state.qzoneSettings || {};
    // 【核心】所有資料都從 weibo... 欄位讀取！
    document.getElementById('weibo-avatar-img').src = settings.weiboAvatar;
    document.getElementById('weibo-nickname').textContent = settings.weiboNickname;
    document.getElementById('weibo-fans-count').textContent = settings.weiboFansCount;
    document.getElementById('weibo-background-img').src = settings.weiboBackground;
    
    // 動態計算關注數 (這部分不變)
    const allSingleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    let totalNpcCount = 0;
    allSingleChats.forEach(chat => {
        if (chat.npcLibrary && chat.npcLibrary.length > 0) {
            totalNpcCount += chat.npcLibrary.length;
        }
    });
    document.getElementById('weibo-following-count').textContent = allSingleChats.length + totalNpcCount;
    
    // 動態計算微博數
    const postsCount = await db.weiboPosts.where('authorId').equals('user').count();
    document.getElementById('weibo-posts-count').textContent = postsCount;
    
    const professionEl = document.getElementById('weibo-user-profession-display');
    if (professionEl) {
        professionEl.textContent = settings.weiboUserProfession || '點擊設置職業';
    }

    // --- ▼▼▼ 以下是本次新增的核心代碼 ▼▼▼ ---
    // 1. 獲取保存的頭像框URL
    const frameUrl = settings.weiboAvatarFrame || '';
    // 2. 找到頭像框的img元素
    const frameImg = document.getElementById('weibo-avatar-frame');
    if (frameImg) {
        // 3. 如果URL存在，就顯示它
        if (frameUrl) {
            frameImg.src = frameUrl;
            frameImg.style.display = 'block';
        } else {
            // 4. 如果URL為空（即選擇了“無”），就隱藏它
            frameImg.src = '';
            frameImg.style.display = 'none';
        }
    }
    // --- ▲▲▲ 新增代碼結束 ▲▲▲
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 【微博專屬】編輯微博頭像
 */
async function editWeiboAvatar() {
    const newAvatarUrl = await getNewImageUrl("更換微博頭像", state.qzoneSettings.weiboAvatar);
    if (newAvatarUrl) {
        state.qzoneSettings.weiboAvatar = newAvatarUrl; // 只修改微博頭像
        await saveQzoneSettings();
        await renderWeiboProfile(); // 用專屬函數刷新
    }
}

/**
 * 【微博專屬】編輯微博背景圖
 */
async function editWeiboBackground() {
    const newBgUrl = await getNewImageUrl("更換微博背景", state.qzoneSettings.weiboBackground);
    if (newBgUrl) {
        state.qzoneSettings.weiboBackground = newBgUrl; // 只修改微博背景
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

/**
 * 【微博專屬】編輯微博昵稱
 */
async function editWeiboNickname() {
    const newNickname = await showCustomPrompt("編輯微博昵稱", "請輸入新的昵稱", state.qzoneSettings.weiboNickname);
    if (newNickname !== null) {
        state.qzoneSettings.weiboNickname = newNickname.trim() || '你的昵稱'; // 只修改微博昵稱
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

/**
 * 【微博專屬】編輯微博粉絲數
 */
async function editWeiboFansCount() {
    const newFans = await showCustomPrompt("編輯粉絲數", "請輸入新的粉絲數", state.qzoneSettings.weiboFansCount, "number");
    if (newFans !== null) {
        state.qzoneSettings.weiboFansCount = newFans.trim() || '0'; // 只修改微博粉絲數
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

// ▲▲▲ 新函數黏貼結束 ▲▲▲

/**
 * 通用的圖片編輯函數 (本地上傳或URL)
 * @param {string} title - 彈窗標題
 * @param {string} currentUrl - 當前的圖片URL
 * @returns {Promise<string|null>} - 新的圖片URL或null
 */
async function getNewImageUrl(title, currentUrl) {
    const choice = await showChoiceModal(title, [
        { text: '📁 從本地上傳', value: 'local' },
        { text: '🌐 使用網路URL', value: 'url' }
    ]);

    if (choice === 'local') {
        return await uploadImageLocally();
    } else if (choice === 'url') {
        const url = await showCustomPrompt(title, "請輸入新的圖片URL", currentUrl, "url");
        if (url && url.trim().startsWith('http')) {
            return url.trim();
        } else if (url !== null) {
            alert("請輸入一個有效的URL！");
        }
    }
    return null;
}

/**
 * 編輯微博頭像
 */
async function editWeiboAvatar() {
    const newAvatarUrl = await getNewImageUrl("更換頭像", state.qzoneSettings.weiboAvatar);
    if (newAvatarUrl) {
        state.qzoneSettings.weiboAvatar = newAvatarUrl;
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

/**
 * 編輯微博背景圖
 */
async function editWeiboBackground() {
    const newBgUrl = await getNewImageUrl("更換背景圖", state.qzoneSettings.weiboBackground);
    if (newBgUrl) {
        state.qzoneSettings.weiboBackground = newBgUrl;
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

/**
 * 編輯微博昵稱
 */
async function editWeiboNickname() {
    const newNickname = await showCustomPrompt("編輯昵稱", "請輸入新的微博昵稱", state.qzoneSettings.weiboNickname);
    if (newNickname !== null) {
        state.qzoneSettings.weiboNickname = newNickname.trim() || '你的昵稱';
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}

// ▼▼▼ 請【再次確認】並用下面這【整塊函數】替換掉舊的 editWeiboFansCount 函數 ▼▼▼
/**
 * 【微博專屬】編輯微博粉絲數 (已修復，支援漢字)
 */
async function editWeiboFansCount() {
    // 核心修改：確保這裡的第四個參數是 "text"，而不是 "number"
    const newFans = await showCustomPrompt("編輯粉絲數", "請輸入新的粉絲數", state.qzoneSettings.weiboFansCount, "text");
    
    if (newFans !== null) {
        state.qzoneSettings.weiboFansCount = newFans.trim() || '0'; // 只修改微博粉絲數
        await saveQzoneSettings();
        await renderWeiboProfile();
    }
}
// ▲▲▲ 替換結束 ▲▲▲

// ▲▲▲ 新函數黏貼結束 ▲▲▲


// ▼▼▼ 請用這塊【修復後】的代碼，完整替換掉你舊的 switchToWeiboView 函數 ▼▼▼
/**
 * 【全新】切換微博主介面中的不同資料頁檢視
 * @param {string} viewId - 要切換到的視圖的ID
 */
async function switchToWeiboView(viewId) {
    // 1. 隱藏所有微博頁面
    document.querySelectorAll('.weibo-view').forEach(view => {
        view.style.display = 'none'; // 使用 style.display 確保隱藏
    });
    
    // 2. 顯示目標頁面
    const targetView = document.getElementById(viewId);
    if (targetView) {
        targetView.style.display = 'flex'; // 使用 flex 顯示
    }

    // 3. 更新底部巡覽列的高亮狀態
    document.querySelectorAll('.weibo-nav-item').forEach(item => {
        item.classList.remove('active');
    });
    const targetNavItem = document.querySelector(`.weibo-nav-item[data-view="${viewId}"]`);
    if (targetNavItem) {
        targetNavItem.classList.add('active');
    }

    // --- ▼▼▼【核心修復】▼▼▼ ---
    // 4. 根據你點擊的頁簽，去載入並顯示對應的微博內容
    if (viewId === 'weibo-following-view') {
        // 如果是“關注的人”頁，就調用渲染關注清單的函數
        await renderFollowingWeiboFeed();
    } else if (viewId === 'weibo-my-profile-view') {
        // 如果是“我的微博”頁，就調用渲染“我”的微博的函數
        await renderMyWeiboFeed();
    }
    // --- ▲▲▲【修復結束】▲▲▲ ---
}
// ▲▲▲ 替換結束 ▲▲▲


// ▼▼▼ 在這裡開始複製 ▼▼▼

// ▼▼▼ 用這塊【功能增強版】代碼，替換舊的 openQZonePublisher 函數 ▼▼▼
async function openQZonePublisher(mode) {
    resetCreatePostModal();
    const modal = document.getElementById('create-post-modal');
    modal.dataset.mode = mode;
    document.getElementById('create-post-modal-title').textContent = '發佈動態';

    if (mode === 'shuoshuo') {
        modal.querySelector('.post-mode-switcher').style.display = 'none';
        modal.querySelector('#image-mode-content').style.display = 'none';
        modal.querySelector('#text-image-mode-content').style.display = 'none';
        modal.querySelector('#post-public-text').placeholder = '分享新鮮事...';
    } else {
        modal.querySelector('.post-mode-switcher').style.display = 'flex';
        modal.querySelector('#image-mode-content').classList.add('active');
        modal.querySelector('#text-image-mode-content').classList.remove('active');
        modal.querySelector('#post-public-text').placeholder = '分享新鮮事...（非必填的公開文字）';
    }

    document.getElementById('post-comments-toggle-group').style.display = 'block';
    
    // --- ▼▼▼ 以下是本次新增的核心代碼 ▼▼▼ ---
    const visibilityGroup = document.getElementById('post-visibility-group');
    const groupsContainer = document.getElementById('post-visibility-groups');
    const visibilityRadios = document.querySelectorAll('input[name="visibility"]');

    visibilityGroup.style.display = 'block';
    groupsContainer.innerHTML = ''; // 清空舊的分組列表
    
    // 從資料庫讀取你的好友分組
    const groups = await db.qzoneGroups.toArray();
    if (groups.length > 0) {
        groups.forEach(group => {
            const label = document.createElement('label');
            label.innerHTML = `<input type="checkbox" value="${group.id}"> ${group.name}`;
            groupsContainer.appendChild(label);
        });
    } else {
        groupsContainer.innerHTML = '<p style="color: #8a8a8a; font-size: 13px;">還沒有創建任何好友分組哦。</p>';
    }

    // 默認選中“所有人可見”並隱藏分組選擇
    visibilityRadios[0].checked = true;
    groupsContainer.style.display = 'none';

    // 監聽選項按鈕的變化
    visibilityRadios.forEach(radio => {
        radio.onchange = function() {
            groupsContainer.style.display = this.value === 'groups' ? 'block' : 'none';
        };
    });
    // --- ▲▲▲ 新增代碼結束 ▲▲▲ ---

    modal.classList.add('visible');
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 用這整塊【評論優化版】的代碼，完整替換掉你舊的 generateWeiboComments 函數 ▼▼▼
/**
 * 【評論優化版 V2】AI生成微博評論的核心函數
 * @param {number} postId - 需要生成評論的微博ID
 */
async function generateWeiboComments(postId) {
    const post = await db.weiboPosts.get(postId);
    if (!post) {
        alert("錯誤：找不到這條微博！");
        return;
    }

    await showCustomAlert("請稍候...", "正在召喚高品質網友...");

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先配置API！');
        return;
    }
    
    let authorPersona = "一個普通用戶。";
    let authorProfession = "未設定"; 
    const authorName = post.authorId === 'user' ? (state.qzoneSettings.weiboNickname || '我') : post.authorNickname;
    
    if (post.authorId === 'user') {
        authorPersona = state.qzoneSettings.weiboUserPersona || '一個普通的微博用戶。';
        authorProfession = state.qzoneSettings.weiboUserProfession || '未設定';
    } else {
        const authorChat = state.chats[post.authorId];
        if (authorChat) {
            authorPersona = authorChat.settings.aiPersona || '無';
            authorProfession = authorChat.settings.weiboProfession || '未設定';
        }
    }
    const truncatedPersona = authorPersona.substring(0, 400);
    const postContent = (post.content || "").substring(0, 200);
    const existingComments = (post.comments || []).slice(-5).map(c => `${c.authorNickname}: ${c.commentText}`).join('\n');

    let imageContext = '';
    if (post.imageUrl && post.imageDescription) {
        imageContext = `
- **圖片內容**: 這條微博配有一張圖片，描述為：“${post.imageDescription}”`;
    } else if (post.postType === 'text_image' && post.hiddenContent) {
        imageContext = `
- **圖片內容**: 這是一張文字圖，上面的內容是：“${post.hiddenContent}”`;
    }
    
    // ▼▼▼ 從這裡開始，是我們新增的核心代碼 ▼▼▼

    // 1. 創建一個集合，用來存放評論區已出現的、有人設的角色資訊
    const commenterPersonas = new Map();

    // 2. 將微博作者本人的人設先加進去
    commenterPersonas.set(authorName, `[職業: ${authorProfession}] [人設: ${truncatedPersona}]`);

    // 3. 遍歷已有的評論，查找並添加其他角色的人設
    if (post.comments && post.comments.length > 0) {
        post.comments.forEach(comment => {
            const commenterName = comment.authorNickname;
            // 如果這個人設還沒被記錄過
            if (!commenterPersonas.has(commenterName)) {
                // 檢查這個評論者是不是一個已知的AI角色
                const commenterChat = Object.values(state.chats).find(c => c.name === commenterName);
                if (commenterChat && !commenterChat.isGroup) {
                    // 如果是，就把他/她的人設和職業也加到集合裡
                    const profession = commenterChat.settings.weiboProfession || '未設定';
                    const persona = (commenterChat.settings.aiPersona || '無').substring(0, 200);
                    commenterPersonas.set(commenterName, `[職業: ${profession}] [人設: ${persona}]`);
                }
            }
        });
    }
    
    // 4. 將收集到的人設資訊，格式化成給AI看的文本
    let commenterContext = '';
    if (commenterPersonas.size > 0) {
        commenterContext += '\n# 評論區已有角色人設 (供你回復時參考)\n';
        commenterPersonas.forEach((persona, name) => {
            commenterContext += `- **${name}**: ${persona}\n`;
        });
    }

    // ▲▲▲ 新增代碼到此結束 ▲▲▲

    const systemPrompt = `
# 任務
你是一個專業的“社交媒體模擬器”。你的任務是根據一個特定角色的“人設”，為他/她發佈的一條微博生成一批真實的、符合情景的網友評論。

# 微博情景
- **作者**: ${authorName}
- **微博文字**: ${postContent || "(該微博沒有配文)"}
${imageContext}
- **已有評論 (你可以回復他們)**:
${existingComments || "(暫無評論)"}

${commenterContext}

# 【【【評論生成核心規則】】】
1.  **【【【嚴禁使用】】】**: 絕對禁止使用 “路人甲”、“網友A”、“粉絲B” 這類代號作為評論者昵稱。
2.  **昵稱多樣化**: 評論者的昵稱必須非常真實、多樣化且符合微博生態。例如：“今天也要早睡”、“可樂加冰塊”、“是小王不是小張”、“理性吃瓜第一線”。
3.  **內容與人設強相關**: 評論內容必須與【微博內容(包括文字和圖片)】和【作者以及被回復者的人設】高度相關。思考：什麼樣的粉絲會關注這樣的人？他們會怎麼說話？當回復一個有特定人設的角色時，你的回復必須考慮到對方的身份。
4.  **風格多樣化**: 生成的評論應包含不同立場和風格，例如：
    -   **粉絲**: “哥哥太帥了！新劇什麼時候播？”
    -   **路人**: “這個地方看起來不錯，求位址！”
    -   **黑粉/質疑者**: “就這？感覺p圖有點過了吧...”
    -   **玩梗**: “樓上是不是XX派來的間諜（狗頭）”
5.  **格式鐵律**: 你的回復【必須且只能】是一個嚴格的JSON陣列，每個物件代表一條評論。
    -   發表新評論, 使用格式: \`{"author": "不吃香菜的仙女", "comment": "哇，這個好好看！"}\`
    -   回復已有評論, 使用格式: \`{"author": "愛吃瓜的猹", "comment": "我也覺得！", "replyTo": "不吃香菜的仙女"}\`

現在，請開始你的表演。
`;

    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({
                    model: model,
                    messages: messagesForApi,
                    temperature: 1.0, 
                    response_format: { type: "json_object" }
                })
            });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API請求失敗: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '').trim();
        
        const newComments = JSON.parse(aiResponseContent);

        if (Array.isArray(newComments) && newComments.length > 0) {
            const postToUpdate = await db.weiboPosts.get(post.id);
            if (!postToUpdate) throw new Error("在資料庫中找不到要更新的帖子！");
            
            if (!postToUpdate.comments) postToUpdate.comments = [];
            
            newComments.forEach(comment => {
                if(comment.author && comment.comment) {
                    const newCommentObject = {
                        commentId: 'comment_' + Date.now() + Math.random(),
                        authorNickname: comment.author,
                        commentText: comment.comment,
                        timestamp: Date.now()
                    };
                    if (comment.replyTo) {
                        newCommentObject.replyToNickname = comment.replyTo;
                    }
                    postToUpdate.comments.push(newCommentObject);
                }
            });

            postToUpdate.baseLikesCount = (postToUpdate.baseLikesCount || 0) + Math.floor(Math.random() * newComments.length * 3 + 5);

            await db.weiboPosts.put(postToUpdate);
            
            await renderMyWeiboFeed();
            await renderFollowingWeiboFeed();
            
            alert(`成功生成了 ${newComments.length} 條新評論！`);
        } else {
             alert("AI沒有生成有效的評論。");
        }

    } catch (error) {
        console.error("生成微博評論失敗:", error);
        await showCustomAlert('生成失敗', `發生了一個錯誤：\n${error.message}`);
    }
}
// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 把這個新函數黏貼到 renderWeiboProfile 函數的上方 ▼▼▼
/**
 * 【全新】刪除一條微博評論
 * @param {number} postId - 評論所在的微博ID
 * @param {string} commentId - 要刪除的評論的ID
 */
async function deleteWeiboComment(postId, commentId) {
    const post = await db.weiboPosts.get(postId);
    if (!post || !post.comments) return;

    const commentIndex = post.comments.findIndex(c => c.commentId === commentId);
    if (commentIndex === -1) return;
    
    const commentText = post.comments[commentIndex].commentText;

    const confirmed = await showCustomConfirm(
        '刪除評論', 
        `確定要刪除這條評論嗎？\n\n“${commentText.substring(0, 50)}...”`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        post.comments.splice(commentIndex, 1);
        await db.weiboPosts.put(post);
        await renderMyWeiboFeed();
        await renderFollowingWeiboFeed();
        alert("評論已刪除。");
    }
}
// ▲▲▲ 新函數黏貼結束 ▲▲▲
// ▼▼▼ 在 init() 函數的【正上方】，黏貼下面這一整塊新代碼 ▼▼▼
/**
 * 【全新】一鍵清空所有單人聊天背景
 */
async function clearAllSingleChatBackgrounds() {
    // 彈出確認框，防止誤操作
    const confirmed = await showCustomConfirm(
        '確認操作', 
        '此操作將移除所有角色單獨設置的聊天背景，統一使用全域背景。確定要繼續嗎？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        let updatedCount = 0;
        const chatsToUpdate = [];

        // 遍歷所有聊天
        for (const chatId in state.chats) {
            const chat = state.chats[chatId];
            // 如果這個聊天設置了單人背景
            if (chat.settings && chat.settings.background) {
                chat.settings.background = ''; // 清空它
                chatsToUpdate.push(chat);
                updatedCount++;
            }
        }

        // 如果有需要更新的聊天，就批量寫入資料庫
        if (chatsToUpdate.length > 0) {
            await db.chats.bulkPut(chatsToUpdate);
        }
        
        await showCustomAlert('操作成功', `已成功清空 ${updatedCount} 個角色的單人聊天背景！`);
    }
}
// ▲▲▲ 黏貼結束 ▲▲▲
/* ▼▼▼ 【V2修正版】主螢幕美化預設核心功能函數 ▼▼▼ */

let activeHomePresetId = null; // 用於追蹤當前選中的預設ID

/**
 * 啟用或禁用預設管理按鈕
 */
function toggleHomePresetButtons(isEnabled) {
    document.getElementById('apply-home-preset-btn').disabled = !isEnabled;
    document.getElementById('update-home-preset-btn').disabled = !isEnabled; // <-- 新增這一行
    document.getElementById('rename-home-preset-btn').disabled = !isEnabled;
    document.getElementById('delete-home-preset-btn').disabled = !isEnabled;
    document.getElementById('export-home-preset-btn').disabled = !isEnabled;
}


/**
 * 載入預設到下拉清單
 */
async function loadHomeScreenPresetsToDropdown() {
    const selector = document.getElementById('home-preset-selector');
    selector.innerHTML = '<option value="">-- 請選擇一個預設 --</option>';
    const presets = await db.homeScreenPresets.toArray();
    presets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        selector.appendChild(option);
    });
    activeHomePresetId = null; // 重置選擇
    toggleHomePresetButtons(false); // 預設禁用按鈕
}

/**
 * 【新】當用戶從下拉清單選擇一個預設時
 */
function handleHomePresetSelection() {
    const selector = document.getElementById('home-preset-selector');
    activeHomePresetId = selector.value ? parseInt(selector.value) : null;
    // 只有當用戶確實選擇了一個預設時，才啟用相關按鈕
    toggleHomePresetButtons(!!activeHomePresetId);
}

/**
 * 【V2 修復版】應用當前選中的預設
 */
async function applySelectedHomeScreenPreset() {
    if (!activeHomePresetId) {
        alert("請先從下拉清單中選擇一個要應用的預設。");
        return;
    }
    const preset = await db.homeScreenPresets.get(activeHomePresetId);
    if (preset && preset.data) {
        // 將預設資料載入到全域狀態
        state.globalSettings.widgetData = preset.data;

        if (preset.data.wallpaper) {
            state.globalSettings.wallpaper = preset.data.wallpaper;
        }
        if (preset.data.appIcons) {
            state.globalSettings.appIcons = { ...preset.data.appIcons };
        }
        // ★★★ 新增：處理頭像框資料 ★★★
        if (typeof preset.data.homeAvatarFrame !== 'undefined') {
            state.globalSettings.homeAvatarFrame = preset.data.homeAvatarFrame;
        }

        // 保存所有更新到資料庫
        await db.globalSettings.put(state.globalSettings);
        
        // 依次應用所有設置
        applyGlobalWallpaper();
        applyAppIcons();
        applyAppLabels();
        applyWidgetData(); 
        renderHomeScreenProfileFrame(); // ★★★ 新增：應用頭像框 ★★★

        alert(`已成功應用預設: "${preset.name}"！`);
        showScreen('home-screen');
    }
}
/**
 * 【全新】渲染主螢幕個人資料卡的頭像框
 */
function renderHomeScreenProfileFrame() {
    // 1. 獲取保存的頭像框URL
    const frameUrl = state.globalSettings.homeAvatarFrame || '';
    // 2. 找到頭像框的img元素
    const frameImg = document.getElementById('profile-avatar-frame');
    if (frameImg) {
        // 3. 如果URL存在，就顯示它
        if (frameUrl) {
            frameImg.src = frameUrl;
            frameImg.style.display = 'block';
        } else {
            // 4. 如果URL為空（即選擇了“無”），就隱藏它
            frameImg.src = '';
            frameImg.style.display = 'none';
        }
    }
}


/**
 * 【V2 修復版】保存當前的主螢幕設置為一個新的預設
 */
async function saveCurrentHomeScreenAsPreset() {
    const presetName = await showCustomPrompt("保存預設", "請為這個主螢幕美化方案起個名字：");
    if (!presetName || !presetName.trim()) {
        if (presetName !== null) alert("名字不能為空！");
        return;
    }

    // 核心：構建一個包含所有主螢幕元素的完整資料物件
    const presetData = {
        // --- 個人資料卡片 ---
        'profile-banner-img': document.getElementById('profile-banner-img').src,
        'profile-avatar-img': document.getElementById('profile-avatar-img').src,
        'homeAvatarFrame': document.getElementById('profile-avatar-frame').src, // ★★★ 新增：保存頭像框 ★★★
        'profile-username': document.getElementById('profile-username').textContent,
        'profile-sub-username': document.getElementById('profile-sub-username').textContent,
        'profile-bio': document.getElementById('profile-bio').textContent,
        'profile-location': document.getElementById('profile-location').innerHTML,

        // --- 第一頁小組件 ---
        'widget-bubble-1': document.getElementById('widget-bubble-1').textContent,
        'widget-image-1': document.getElementById('widget-image-1').src,
        'widget-subtext-1': document.getElementById('widget-subtext-1').textContent,
        'widget-bubble-2': document.getElementById('widget-bubble-2').textContent,
        'widget-image-2': document.getElementById('widget-image-2').src,
        'widget-subtext-2': document.getElementById('widget-subtext-2').textContent,
        
        // --- 第二頁小元件 ---
        'widget-image-3': document.getElementById('widget-image-3').src,
        'second-page-bubble': document.getElementById('second-page-bubble').textContent,
        'flat-capsule-bubble': document.getElementById('flat-capsule-bubble').textContent,
        'circular-bubble': document.getElementById('circular-bubble').textContent,
        'widget-image-4': document.getElementById('widget-image-4').src,
        'avatar-subtitle': document.getElementById('avatar-subtitle').textContent,
        'bubble-top-left': document.getElementById('bubble-top-left').textContent,
        'bubble-top-right': document.getElementById('bubble-top-right').textContent,
        'bubble-bottom-left': document.getElementById('bubble-bottom-left').textContent,
        'bubble-bottom-right': document.getElementById('bubble-bottom-right').textContent,
        'new-widget-avatar': document.getElementById('new-widget-avatar').src,
        'new-widget-text-1': document.getElementById('new-widget-text-1').textContent,
        'new-widget-text-2': document.getElementById('new-widget-text-2').textContent,
        'new-widget-text-3': document.getElementById('new-widget-text-3').textContent,
        'widget-month-display': document.getElementById('widget-month-display').textContent,
        
        // --- App圖示和壁紙 ---
        'appIcons': { ...state.globalSettings.appIcons },
        'appLabels': { ...state.globalSettings.appLabels },
        'wallpaper': state.globalSettings.wallpaper
    };

    // 保存到資料庫
    await db.homeScreenPresets.add({ name: presetName.trim(), data: presetData });
    await loadHomeScreenPresetsToDropdown(); // 刷新下拉清單
    alert(`預設 "${presetName.trim()}" 已保存！`);
}

/**
 * 【V2 修復版】更新當前選中的預設
 */
async function updateSelectedHomeScreenPreset() {
    if (!activeHomePresetId) {
        alert("請先選擇一個要更新的預設。");
        return;
    }

    const currentPreset = await db.homeScreenPresets.get(activeHomePresetId);
    if (!currentPreset) return;

    const confirmed = await showCustomConfirm(
        "確認更新",
        `確定要用當前的主螢幕佈局覆蓋預設 "${currentPreset.name}" 嗎？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        // 構建與保存時完全相同的完整資料物件
        const presetData = {
            'profile-banner-img': document.getElementById('profile-banner-img').src,
            'profile-avatar-img': document.getElementById('profile-avatar-img').src,
            'homeAvatarFrame': document.getElementById('profile-avatar-frame').src, // ★★★ 新增：保存頭像框 ★★★
            'profile-username': document.getElementById('profile-username').textContent,
            'profile-sub-username': document.getElementById('profile-sub-username').textContent,
            'profile-bio': document.getElementById('profile-bio').textContent,
            'profile-location': document.getElementById('profile-location').innerHTML,
            'widget-bubble-1': document.getElementById('widget-bubble-1').textContent,
            'widget-image-1': document.getElementById('widget-image-1').src,
            'widget-subtext-1': document.getElementById('widget-subtext-1').textContent,
            'widget-bubble-2': document.getElementById('widget-bubble-2').textContent,
            'widget-image-2': document.getElementById('widget-image-2').src,
            'widget-subtext-2': document.getElementById('widget-subtext-2').textContent,
            'widget-image-3': document.getElementById('widget-image-3').src,
            'second-page-bubble': document.getElementById('second-page-bubble').textContent,
            'flat-capsule-bubble': document.getElementById('flat-capsule-bubble').textContent,
            'circular-bubble': document.getElementById('circular-bubble').textContent,
            'widget-image-4': document.getElementById('widget-image-4').src,
            'avatar-subtitle': document.getElementById('avatar-subtitle').textContent,
            'bubble-top-left': document.getElementById('bubble-top-left').textContent,
            'bubble-top-right': document.getElementById('bubble-top-right').textContent,
            'bubble-bottom-left': document.getElementById('bubble-bottom-left').textContent,
            'bubble-bottom-right': document.getElementById('bubble-bottom-right').textContent,
            'new-widget-avatar': document.getElementById('new-widget-avatar').src,
            'new-widget-text-1': document.getElementById('new-widget-text-1').textContent,
            'new-widget-text-2': document.getElementById('new-widget-text-2').textContent,
            'new-widget-text-3': document.getElementById('new-widget-text-3').textContent,
            'widget-month-display': document.getElementById('widget-month-display').textContent,
            'appIcons': { ...state.globalSettings.appIcons },
            'wallpaper': state.globalSettings.wallpaper
        };

        await db.homeScreenPresets.update(activeHomePresetId, { data: presetData });
        await showCustomAlert('成功', `預設 "${currentPreset.name}" 已更新！`);
    }
}

/**
 * 重命名選中的預設
 */
async function renameSelectedHomeScreenPreset() {
    if (!activeHomePresetId) return;
    const currentPreset = await db.homeScreenPresets.get(activeHomePresetId);
    const newName = await showCustomPrompt("重命名", "請輸入新的名稱：", currentPreset.name);
    if (newName && newName.trim()) {
        await db.homeScreenPresets.update(activeHomePresetId, { name: newName.trim() });
        await loadHomeScreenPresetsToDropdown();
        document.getElementById('home-preset-selector').value = activeHomePresetId;
        alert("重命名成功！");
    }
}

/**
 * 刪除選中的預設
 */
async function deleteSelectedHomeScreenPreset() {
    if (!activeHomePresetId) return;
    const currentPreset = await db.homeScreenPresets.get(activeHomePresetId);
    const confirmed = await showCustomConfirm("確認刪除", `確定要刪除預設 "${currentPreset.name}" 嗎？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.homeScreenPresets.delete(activeHomePresetId);
        await loadHomeScreenPresetsToDropdown(); // 這會自動重置選擇並禁用按鈕
        alert("預設已刪除。");
    }
}

/**
 * 【全新】匯出選中的預設
 */
async function exportHomeScreenPreset() {
    if (!activeHomePresetId) return;
    const preset = await db.homeScreenPresets.get(activeHomePresetId);
    const blob = new Blob([JSON.stringify(preset, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${preset.name}-HomeScreen.json`;
    a.click();
    URL.revokeObjectURL(url);
}

/**
 * 【全新】導入預設文件
 */
function importHomeScreenPreset(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);
            // 簡單驗證一下檔內容是不是我們需要的格式
            if (data.name && data.data) {
                await db.homeScreenPresets.add({ name: `${data.name} (導入)`, data: data.data });
                await loadHomeScreenPresetsToDropdown();
                alert(`預設 "${data.name}" 導入成功！`);
            } else {
                alert("導入失敗：檔案格式不正確。");
            }
        } catch (error) {
            alert(`導入失敗：檔解析錯誤。${error.message}`);
        }
    };
    reader.readAsText(file);
}
/* ▲▲▲ 新功能函數黏貼結束 ▲▲▲ */
/* ▼▼▼ 把這一整塊全新的功能函數，黏貼到 init() 函數的上方 ▼▼▼ */

let currentWeiboActionTarget = {}; // 用於存儲被操作的目標資訊

// ▼▼▼ 用這塊【全新邏輯】的代碼，完整替換你舊的 openWeiboActionModal 函數 ▼▼▼

/**
 * 【V2 - AI自主版】打開微博操作模態框
 * @param {object} targetInfo - 包含被操作角色資訊的物件
 */
function openWeiboActionModal(targetInfo) {
    currentWeiboActionTarget = targetInfo; // 保存目標資訊
    const modal = document.getElementById('weibo-action-modal');
    
    // 核心修改：標題直接顯示為誰行動，不再有“操作者”
    document.getElementById('weibo-action-modal-title').textContent = `為 "${targetInfo.name}" 觸發行動`;

    // 核心修改：徹底移除並隱藏“選擇操作者”的下拉清單
    const actorSelectGroup = document.getElementById('weibo-action-actor-select').parentElement;
    if (actorSelectGroup) {
        actorSelectGroup.style.display = 'none';
    }
    
    // 清空上次的輸入並重置選項
    document.getElementById('weibo-action-prompt-input').value = '';
    document.querySelector('input[name="weibo_action_type"][value="post"]').checked = true;

    modal.classList.add('visible');
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 【AI核心 V2.2 - 評論用戶微博版 + 500錯誤最終修復】執行AI操作（發微博/評論）
 */
async function handleWeiboAiAction() {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先配置API！');
        return;
    }

    document.getElementById('weibo-action-modal').classList.remove('visible');
    document.getElementById('weibo-following-modal').classList.remove('visible');
    await showCustomAlert("請稍候...", "正在請求AI生成內容，請耐心等待...");

    const actionType = document.querySelector('input[name="weibo_action_type"]:checked').value;
    const userInputPrompt = document.getElementById('weibo-action-prompt-input').value.trim();

    let target = { 
        id: currentWeiboActionTarget.id,
        name: currentWeiboActionTarget.name, 
        persona: '一個普通的微博用戶。',
        profession: '',
        instruction: ''
    };

    if (currentWeiboActionTarget.isNpc) {
        const owner = state.chats[currentWeiboActionTarget.ownerId];
        const npc = owner.npcLibrary.find(n => n.id === currentWeiboActionTarget.id);
        if (npc) {
            target.persona = npc.persona;
            target.profession = owner.settings.weiboProfession || '';
            target.instruction = owner.settings.weiboInstruction || '';
        }
    } else {
        const char = state.chats[currentWeiboActionTarget.id];
        if (char) {
            target.persona = char.settings.aiPersona;
            target.profession = char.settings.weiboProfession || '';
            target.instruction = char.settings.weiboInstruction || '';
        }
    }
    
    let systemPrompt = '';
    let messagesForApi = [];

    try {
        if (actionType === 'post') {
            systemPrompt = `
# 任務: 角色扮演與微博創作
你現在【就是】角色“${target.name}”。
你的任務是根據你的身份資訊，創作一條全新的微博。
# 你的身份資訊
- **你的名字**: ${target.name}
- **你的職業**: ${target.profession || '未設定'}
- **你的人設**: ${target.persona}
- **你的微博指令 (必須遵守)**: ${target.instruction || '無'}
- **用戶給你的提示 (可選參考)**: ${userInputPrompt || '無'}
# 【【【評論生成核心規則】】】
1.  **【【【嚴禁使用】】】**: 絕對禁止使用 “路人甲”、“網友A”、“粉絲B” 這類代號作為評論者昵稱。
2.  **昵稱多樣化**: 評論者的昵稱必須非常真實、多樣化且符合微博生態。例如：“今天也要早睡”、“可樂加冰塊”、“是小王不是小張”、“理性吃瓜第一線”。
3.  **內容與人設強相關**: 評論內容必須與【你即將創作的微博內容】和【你自己的人設】高度相關。
4.  **格式鐵律**: 你的回復【必須且只能】是一個嚴格的JSON物件，格式如下:
   \`{"content": "微博正文內容...", "baseLikesCount": 隨機生成的點贊數, "baseCommentsCount": 隨機生成的評論數, "comments": "今天也要早睡: 評論1...\\n可樂加冰塊: 評論2..."}\`
   - 點贊和評論數要符合你的身份地位。
   - "comments"欄位是一個【字串】，裡面包含5-10條真實感的路人評論，每條評論用分行符號'\\n'分隔。
`;
            messagesForApi.push({ role: 'user', content: systemPrompt });

        } else {
            let targetPost;
            let taskDescription;
            let extraContext = ''; 

            if (actionType === 'comment_plaza') {
                targetPost = await db.weiboPosts.orderBy('timestamp').last();
                if (!targetPost) throw new Error("廣場上還沒有任何微博可以評論！");
                taskDescription = `你的任務是根據你的身份資訊，去評論下面這條最新的【廣場微博】。`;
            } else if (actionType === 'comment_user') {
                targetPost = await db.weiboPosts.where('authorId').equals('user').reverse().first();
                if (!targetPost) throw new Error("用戶還沒有發佈任何微博，無法評論！");
                taskDescription = `你的任務是根據你的身份資訊，去評論下面這條由【用戶】發佈的最新微博。`;
            }

            let postAuthorName = targetPost.authorNickname;
            if (postAuthorName === '{{user}}') {
                postAuthorName = '我';
            }
            
            systemPrompt = `
# 任務: 角色扮演與微博評論
你現在【就是】角色“${target.name}”。
${taskDescription}
# 你的身份資訊
- **你的名字**: ${target.name}
- **你的職業**: ${target.profession || '未設定'}
- **你的人設**: ${target.persona}
- **你的微博指令 (必須遵守)**: ${target.instruction || '無'}
- **用戶給你的提示 (可選參考)**: ${userInputPrompt || '無'}
# 被評論的微博
- 作者: ${postAuthorName}
- 內容: ${targetPost.content}
${extraContext}
# 核心規則
1. **深度扮演**: 你的評論【必須】完全符合你的職業、人設和微博指令。
2. **格式鐵律**: 你的回復【必須且只能】是一個嚴格的JSON物件，格式如下:
   \`{"commentText": "你的評論內容..."}\`
`;
            messagesForApi.push({ role: 'user', content: systemPrompt });
        }

        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);

        const response = await fetch(isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`, isGemini ? geminiConfig.data : {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({
                model: model,
                messages: messagesForApi,
                temperature: 1.0
                // ▼▼▼ 核心修復：我們把下面這行導致錯誤的 `response_format` 徹底刪掉了！▼▼▼
            })
        });

        if (!response.ok) {
            let errorBody = '';
            try {
                errorBody = await response.text();
            } catch (e) {
                errorBody = '無法讀取錯誤回應體。';
            }
            throw new Error(`API請求失敗: ${response.status} - ${errorBody}`);
        }

        const data = await response.json();
        // ▼▼▼ 在這裡添加下面的安全檢查代碼 ▼▼▼
if (data.error) {
    // 如果API返回的資料中直接包含了 error 物件，說明請求出錯了
    // 我們主動拋出一個包含詳細錯誤資訊的Error
    throw new Error(`API返回錯誤: ${data.error.message || JSON.stringify(data.error)}`);
}
// ▲▲▲ 添加結束 ▲▲▲
        const aiResponseContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '').trim();
        
        const result = JSON.parse(aiResponseContent);

        if (actionType === 'post') {
            const newPost = {
                authorId: target.id,
                authorType: currentWeiboActionTarget.isNpc ? 'npc' : 'char',
                authorNickname: target.name,
                authorAvatar: currentWeiboActionTarget.isNpc 
                    ? (state.chats[currentWeiboActionTarget.ownerId].npcLibrary.find(n => n.id === target.id).avatar || defaultGroupMemberAvatar)
                    : (state.chats[target.id].settings.aiAvatar || defaultAvatar),
                content: result.content,
                timestamp: Date.now(),
                likes: [], comments: [],
                baseLikesCount: result.baseLikesCount || 0,
                baseCommentsCount: result.baseCommentsCount || 0
            };
            if(result.comments) {
                newPost.comments = result.comments.split('\n').map(c => {
                    const parts = c.split(/[:：]/);
                    const commenter = parts.shift() || '路人';
                    const commentText = parts.join(':').trim();
                    return { commentId: 'comment_' + Date.now() + Math.random(), authorNickname: commenter, commentText: commentText };
                }).filter(c => c.commentText);
            }
            await db.weiboPosts.add(newPost);
        } else {
            let postToUpdate;
            if (actionType === 'comment_plaza') {
                postToUpdate = await db.weiboPosts.orderBy('timestamp').last();
            } else {
                postToUpdate = await db.weiboPosts.where('authorId').equals('user').reverse().first();
            }

            if (postToUpdate) {
                if (!postToUpdate.comments) postToUpdate.comments = [];
                postToUpdate.comments.push({
                    commentId: 'comment_' + Date.now(),
                    authorId: target.id,
                    authorNickname: target.name,
                    commentText: result.commentText,
                    timestamp: Date.now()
                });
                await db.weiboPosts.put(postToUpdate);
            }
        }
        
        await renderMyWeiboFeed();
        await renderFollowingWeiboFeed();
        await showCustomAlert("操作成功", `“${target.name}”已成功執行操作！`);

    } catch (error) {
        console.error("微博AI操作失敗:", error);
        await showCustomAlert('操作失敗', `發生了一個錯誤：\n${error.message}`);
    }
}
// ▼▼▼ 第2步 第4處修改（新增JS功能函數） ▼▼▼

/**
 * 【全新】角色表情包管理核心功能
 */
async function openCharStickerManager() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
        // 【修改】根據聊天類型顯示不同的標題
    if (chat.isGroup) {
        document.getElementById('sticker-manager-title').textContent = `“${chat.name}”的群表情`;
    } else {
        document.getElementById('sticker-manager-title').textContent = `“${chat.name}”的表情包`;
    }


    // 預設顯示專屬表情
    document.getElementById('sticker-tab-exclusive').click();
    
    await renderCharStickers('exclusive');
    await renderCharStickers('common');
    
    showScreen('char-sticker-manager-screen');
}

// ▼▼▼ 【修復並優化】請用下面這一整塊代碼，替換掉舊的 renderCharStickers, bulkAddCharStickers, uploadCharStickersLocal 三個函數 ▼▼▼

/**
 * 【已修復】渲染指定類型的角色表情包
 */
async function renderCharStickers(type) {
    const isExclusive = type === 'exclusive';
    const gridId = isExclusive ? 'exclusive-sticker-grid' : 'common-sticker-grid';
    const grid = document.getElementById(gridId);
    grid.innerHTML = '';

    let stickers = [];
    if (isExclusive) {
        const chat = state.chats[state.activeChatId];
        stickers = chat.settings.stickerLibrary || [];
    } else {
        // 【核心修復】確保我們總是從最新的資料庫狀態讀取通用表情
        state.charStickers = await db.charStickers.toArray();
        stickers = state.charStickers || [];
    }

    if (stickers.length === 0) {
        grid.innerHTML = `<p style="text-align:center; color: var(--text-secondary); grid-column: 1 / -1;">這裡還是空的哦~</p>`;
        return;
    }

    // 為了能正確刪除，我們需要倒序遍歷來獲取正確的索引
    const stickersWithIndex = stickers.map((sticker, index) => ({ ...sticker, originalIndex: index }));

    stickersWithIndex.forEach((sticker) => {
        const item = document.createElement('div');
        item.className = 'sticker-item';
        item.style.backgroundImage = `url(${sticker.url})`;
        item.title = sticker.name;

        const deleteBtn = document.createElement('div');
        deleteBtn.className = 'delete-btn';
        deleteBtn.innerHTML = '×';
        deleteBtn.style.display = 'block';
        deleteBtn.onclick = async (e) => {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('刪除表情', `確定要刪除表情 "${sticker.name}" 嗎？`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                if (isExclusive) {
                    const chat = state.chats[state.activeChatId];
                    chat.settings.stickerLibrary.splice(sticker.originalIndex, 1);
                    await db.chats.put(chat);
                } else {
                    await db.charStickers.delete(sticker.id);
                    // 刪除後，我們直接重新渲染，而不是操作state，這樣最安全
                }
                await renderCharStickers(type); // 重新渲染列表
            }
        };
        item.appendChild(deleteBtn);
        grid.appendChild(item);
    });
}

/**
 * 【已修復+優化】批量添加表情包到指定庫
 */
async function bulkAddCharStickers(type) {
    const textInput = await showCustomPrompt(
        `批量添加${type === 'exclusive' ? '專屬' : '通用'}表情`,
        "一行一個，格式：\n貓貓喝水 https://..../cat.gif",
        "", 'textarea'
    );
    if (!textInput || !textInput.trim()) return;

    const lines = textInput.trim().split('\n');
    const newStickers = [];
    let successCount = 0;

    lines.forEach((line, index) => {
        line = line.trim();
        if (!line) return;

        // 【優化】使用更智慧、更健壯的分割邏輯
        let name = '';
        let url = '';
        let splitIndex = -1;
        const httpIndex = line.indexOf('http');
        const dataIndex = line.indexOf('data:image');
        if (httpIndex > -1) { splitIndex = httpIndex; }
        else if (dataIndex > -1) { splitIndex = dataIndex; }

        if (splitIndex > 0) {
            name = line.substring(0, splitIndex).trim();
            url = line.substring(splitIndex).trim();
            if (name.endsWith(':') || name.endsWith('：')) {
                name = name.slice(0, -1).trim();
            }
        }

        if (name && (url.startsWith('http') || url.startsWith('data:image'))) {
            const stickerData = { url, name };
            if (type !== 'exclusive') {
                stickerData.id = 'char_sticker_' + (Date.now() + index);
            }
            newStickers.push(stickerData);
            successCount++;
        }
    });

    if (newStickers.length > 0) {
        if (type === 'exclusive') {
            const chat = state.chats[state.activeChatId];
            chat.settings.stickerLibrary.push(...newStickers);
            await db.chats.put(chat);
        } else {
            await db.charStickers.bulkAdd(newStickers);
        }
        await renderCharStickers(type); // 【核心修復】在資料庫操作後，統一重新渲染
    }
    await showCustomAlert("導入報告", `成功導入：${successCount} 個表情。`);
}

/**
 * 【已修復】從本地上傳表情到指定庫
 */
async function uploadCharStickersLocal(type) {
    const input = document.getElementById('char-sticker-upload-input'); // 應該長這樣
    input.onchange = async (event) => {
        const files = event.target.files;
        if (!files.length) return;

        const stickersToAdd = []; // 先收集所有要添加的表情

        for (const file of files) {
            const name = await showCustomPrompt("為表情命名", "請輸入表情名稱", file.name.replace(/\.[^/.]+$/, ""));
            if (name && name.trim()) {
                const base64Url = await new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.readAsDataURL(file);
                });
                
                const stickerData = { name: name.trim(), url: base64Url };
                if (type !== 'exclusive') {
                    stickerData.id = 'char_sticker_' + Date.now() + Math.random();
                }
                stickersToAdd.push(stickerData);
            }
        }

        if (stickersToAdd.length > 0) {
            if (type === 'exclusive') {
                const chat = state.chats[state.activeChatId];
                chat.settings.stickerLibrary.push(...stickersToAdd);
                await db.chats.put(chat);
            } else {
                await db.charStickers.bulkAdd(stickersToAdd);
            }
            await renderCharStickers(type); // 【核心修復】在資料庫操作後，統一重新渲染
            alert(`已成功上傳 ${stickersToAdd.length} 個表情！`);
        }
        
        event.target.value = null;
    };
    input.click();
}

// ▲▲▲ 修復代碼塊結束 ▲▲▲
// ▼▼▼ 第1步：在這裡黏貼下面這個【新函數】 ▼▼▼

/**
 * 【新增】顯示指定的角色表情包標籤頁
 * 這是之前缺失的核心功能，用於控制顯示哪個標籤頁（專屬或通用）。
 * @param {'exclusive' | 'common'} type - 要顯示的標籤頁類型
 */
function showCharStickerTab(type) {
    // 1. 切換標籤按鈕的 'active' 狀態
    document.querySelectorAll('.char-sticker-tab-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.type === type);
    });

    // 2. 切換內容區域的顯示
    document.querySelectorAll('.sticker-tab-content').forEach(content => {
        content.classList.toggle('active', content.id === `${type}-sticker-content`);
    });

    // 3. 渲染對應標籤頁的表情
    // (這一步確保每次切換標籤時，表情都會刷新)
    renderCharStickers(type);
}

// ▲▲▲ JavaScript新函數黏貼結束 ▲▲▲

// 這裡應該是你已有的其他函數，比如 renderCharStickers, bulkAddCharStickers 等...
// ▼▼▼ 【全新 | 修復版】這裡是所有論壇/小組功能的核心代碼 ▼▼▼

let activeGroupId = null; // 記錄當前打開的小組ID
let activeForumPostId = null; // 記錄當前打開的帖子ID

// ▼▼▼ 用這塊【已添加夢角小組】的代碼，完整替換掉你舊的 initializeDefaultGroups 函數 ▼▼▼

/**
 * 初始化默認的小組
 */
async function initializeDefaultGroups() {
    const groupCount = await db.forumGroups.count();
    if (groupCount === 0) {
        const defaultGroups = [
            { name: '娛樂小組', description: '分享八卦和快樂', icon: '🍿' },
            { name: '靈異小組', description: '分享你的靈異經歷', icon: '👻' },
            { name: '今天我crush了嗎', description: '記錄心動瞬間', icon: '💖' },
            { name: '請幫我選擇小組', description: '選擇困難症患者互助', icon: '🤔' },
            { name: '同人文小組', description: '為愛發電，創作故事', icon: '✍️' },
            // ▼▼▼ 就是新增了下面這一行！ ▼▼▼
            { name: '夢角小組', description: 'Char們分享關於user的夢境', icon: '🌙' }
        ];
        await db.forumGroups.bulkAdd(defaultGroups);
        console.log("已成功創建默認小組（包含夢角小組）。");
    }
}

// ▲▲▲ 替換結束 ▲▲▲

/**
 * 渲染論壇主螢幕，顯示所有小組及其分類（已支持篩選）
 */
async function renderForumScreen() {
    const listEl = document.getElementById('forum-group-list');
    const allGroups = await db.forumGroups.toArray();
    listEl.innerHTML = '';

    // --- ▼▼▼ 【核心新增】篩選邏輯 ▼▼▼ ---
    const globalFilters = activeForumFilters.global;
    let groupsToRender = allGroups;

    if (globalFilters && globalFilters.length > 0) {
        groupsToRender = allGroups.filter(group => 
            group.categories && group.categories.some(cat => globalFilters.includes(cat))
        );
    }
    // --- ▲▲▲ 新增結束 ▲▲▲ ---

    // 檢查篩選後是否還有內容
    if (groupsToRender.length === 0) {
        const message = globalFilters.length > 0 
            ? '沒有找到符合篩選條件的小組哦' 
            : '還沒有任何小組，點擊右上角“+”創建一個吧！';
        listEl.innerHTML = `<p style="text-align:center; color: #8a8a8a; padding: 50px 0;">${message}</p>`;
        return;
    }

    // 使用篩選後的 groupsToRender 陣列進行渲染
    groupsToRender.forEach(group => {
        const item = document.createElement('div');
        item.className = 'forum-group-item';

        let categoriesHtml = '';
        if (group.categories && group.categories.length > 0) {
            categoriesHtml = `
                <div class="category-tag-container">
                    ${group.categories.map(cat => `<span class="category-tag">#${cat}</span>`).join('')}
                </div>
            `;
        }

        item.innerHTML = `
            <div class="forum-group-icon">${group.icon || '📁'}</div>
            <div class="forum-group-name">${group.name}</div>
            <div class="forum-group-desc">${group.description}</div>
            ${categoriesHtml}
        `;
        item.addEventListener('click', () => openGroup(group.id, group.name));
        addLongPressListener(item, () => showGroupActions(group.id, group.name));
        listEl.appendChild(item);
    });
    
    // 更新篩選按鈕狀態
    const filterBtn = document.getElementById('forum-filter-btn');
    if (filterBtn) {
        filterBtn.classList.toggle('active', globalFilters && globalFilters.length > 0);
    }
}


/**
 * 【全新】長按小組時顯示操作功能表（編輯或刪除）
 * @param {number} groupId - 小組的ID
 * @param {string} groupName - 小組的名稱
 */
async function showGroupActions(groupId, groupName) {
    // 調用你現有的彈窗函數，顯示兩個選項
    const choice = await showChoiceModal(`操作小組 "${groupName}"`, [
        { text: '✏️ 編輯小組資訊', value: 'edit' },
        { text: '🗑️ 刪除小組', value: 'delete' }
    ]);

    // 根據使用者的選擇，執行不同的操作
    if (choice === 'edit') {
        // 如果用戶選擇“編輯”，就調用你原來的編輯函數
        openGroupEditor(groupId);
    } else if (choice === 'delete') {
        // 如果用戶選擇“刪除”，就調用你原來的刪除函數
        deleteGroupAndPosts(groupId);
    }
}

// ▼▼▼ 用這塊【已移除自動生成邏輯】的代碼，完整替換你舊的 openGroup 函數 ▼▼▼
async function openGroup(groupId, groupName) {
    activeGroupId = groupId;
    document.getElementById('group-screen-title').textContent = groupName;
    const fanficBar = document.getElementById('fanfic-preference-bar');
    
    // 根據小組名顯示或隱藏特定UI
    if (groupName === '同人文小組') {
        fanficBar.style.display = 'block';
        await populateFanficSelectors();
    } else {
        fanficBar.style.display = 'none';
    }
    await renderGroupPosts(groupId);
    showScreen('group-screen');
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 渲染小組內的帖子列表及其分類（已支持篩選）
 */
async function renderGroupPosts(groupId) {
    const listEl = document.getElementById('group-post-list');
    const allPosts = await db.forumPosts.where('groupId').equals(groupId).reverse().sortBy('timestamp');
    listEl.innerHTML = '';

    // --- ▼▼▼ 【核心新增】篩選邏輯 ▼▼▼ ---
    const groupFilters = activeForumFilters.group[groupId];
    let postsToRender = allPosts;

    if (groupFilters && groupFilters.length > 0) {
        postsToRender = allPosts.filter(post => 
            post.categories && post.categories.some(cat => groupFilters.includes(cat))
        );
    }
    // --- ▲▲▲ 新增結束 ▲▲▲ ---

    if (postsToRender.length === 0) {
        const message = groupFilters && groupFilters.length > 0 
            ? '沒有找到符合篩選條件的帖子哦' 
            : '這個小組還沒有帖子哦';
        listEl.innerHTML = `<p style="text-align:center; color: #8a8a8a; padding: 50px 0;">${message}</p>`;
        return;
    }

    for (const post of postsToRender) {
        const commentCount = await db.forumComments.where('postId').equals(post.id).count();
        const item = document.createElement('div');
        item.className = 'forum-post-item';
        item.dataset.postId = post.id;
        
        let categoriesHtml = '';
        if (post.categories && post.categories.length > 0) {
            categoriesHtml = `
                <div class="category-tag-container">
                    ${post.categories.map(cat => `<span class="category-tag">#${cat}</span>`).join('')}
                </div>
            `;
        }

        item.innerHTML = `
            <div class="post-item-title">${post.title}</div>
            ${categoriesHtml}
            <div class="post-item-meta">
                <span>作者: ${post.author}</span>
                <span>評論: ${commentCount}</span>
            </div>
            <button class="forum-post-delete-btn" title="刪除帖子">×</button>
        `;
        listEl.appendChild(item);
    }

    // 更新篩選按鈕狀態
    const filterBtn = document.getElementById('group-filter-btn');
    if (filterBtn) {
        filterBtn.classList.toggle('active', groupFilters && groupFilters.length > 0);
    }
}


/**
 * 【關鍵修復】打開一個帖子，顯示詳情和評論
 */
async function openPost(postId) {
    activeForumPostId = postId;
    await renderPostDetails(postId);
    showScreen('post-screen');
}

// ▼▼▼ 用這塊【功能增強版】的代碼，完整替換掉你舊的 renderPostDetails 函數 ▼▼▼
/**
 * 【功能增強版】渲染帖子詳情和評論 (已加入頭像和樓層)
 */
async function renderPostDetails(postId) {
    const contentEl = document.getElementById('post-detail-content');
    const post = await db.forumPosts.get(postId);
    const comments = await db.forumComments.where('postId').equals(postId).sortBy('timestamp');

    if (!post) {
        contentEl.innerHTML = '<p>帖子不存在或已被刪除</p>';
        return;
    }
    
    // --- 1. 獲取作者頭像 ---
    let authorAvatarUrl = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg'; // 默認路人頭像
    const userNickname = state.qzoneSettings.nickname || '我';
    
    if (post.author === userNickname) {
        authorAvatarUrl = state.qzoneSettings.avatar; // 如果是用戶自己
    } else {
        const authorChar = Object.values(state.chats).find(c => c.name === post.author);
        if (authorChar) {
            authorAvatarUrl = authorChar.settings.aiAvatar; // 如果是角色
        }
    }

    // --- 2. 拼接評論區HTML ---
    let commentsHtml = `
        <div class="post-comments-section">
            <h3>評論 (${comments.length})</h3>
    `;
    if (comments.length > 0) {
        comments.forEach((comment, index) => {
            // --- 2a. 獲取評論者頭像 ---
            let commenterAvatarUrl = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg'; // 默認路人頭像
            if (comment.author === userNickname) {
                commenterAvatarUrl = state.qzoneSettings.avatar;
            } else {
                const commenterChar = Object.values(state.chats).find(c => c.name === comment.author);
                if (commenterChar) {
                    commenterAvatarUrl = commenterChar.settings.aiAvatar;
                }
            }

            // --- 2b. 處理回復 ---
            let replyHtml = '';
            if (comment.replyTo) {
                replyHtml = `<span class="reply-text">回復</span> <span class="reply-target-name">${comment.replyTo}</span>`;
            }

            // --- 2c. 拼接單條評論的完整HTML ---
            commentsHtml += `
                <div class="post-comment-item" data-commenter-name="${comment.author}">
                    <img src="${commenterAvatarUrl}" class="comment-avatar-small">
                    <div class="comment-details">
                        <div class="comment-header-line">
                            <span class="comment-author">${comment.author}</span>
                            <span class="comment-floor">${index + 1}樓</span>
                        </div>
                        <div class="comment-content">
                            ${replyHtml}
                            <span class="comment-text">${(comment.content || '').replace(/\n/g, '<br>')}</span>
                        </div>
                    </div>
                </div>
            `;
        });
    } else {
        commentsHtml += '<p style="color: var(--text-secondary); font-size: 14px;">還沒有評論，快來搶沙發！</p>';
    }
    commentsHtml += '</div>';

    // --- 3. 拼接帖子詳情頁的完整HTML ---
    contentEl.innerHTML = `
        <div class="post-detail-header">
            <img src="${authorAvatarUrl}" class="post-author-avatar">
            <div class="post-author-info">
                <h1>${post.title}</h1>
                <div class="post-detail-meta">
                    <span>作者: ${post.author}</span> | <span>發佈於: ${new Date(post.timestamp).toLocaleString()}</span>
                </div>
            </div>
        </div>
        <div class="post-detail-body">${post.content.replace(/\n/g, '<br>')}</div>
        <div class="generate-comments-container">
            <button id="generate-forum-comments-btn">✨ 生成評論</button>
        </div>
        ${commentsHtml}
    `;

    // --- 4. 重新綁定評論的點擊回復事件 (這部分邏輯保持不變) ---
    contentEl.querySelectorAll('.post-comment-item').forEach(item => {
        item.addEventListener('click', () => {
            const commenterName = item.dataset.commenterName;
            const myNickname = state.qzoneSettings.nickname || '我';
            if (commenterName !== myNickname) {
                const commentInput = document.getElementById('post-comment-input');
                commentInput.placeholder = `回復 ${commenterName}:`;
                commentInput.dataset.replyTo = commenterName;
                commentInput.focus();
            }
        });
    });
}
// ▲▲▲ 替換結束 ▲▲▲



/**
 * 【AI核心】為論壇帖子生成“豆瓣風格”的評論
 */
async function generateForumComments() {
    const postIdToCommentOn = activeForumPostId; 
    if (!postIdToCommentOn) return;

    await showCustomAlert("請稍候...", "正在召喚資深豆友前來圍觀...");

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先在API設置中配置好才能生成內容哦！');
        return;
    }

    const post = await db.forumPosts.get(postIdToCommentOn); 
    const existingComments = await db.forumComments.where('postId').equals(postIdToCommentOn).toArray(); 
    const group = await db.forumGroups.get(post.groupId);

    // ▼▼▼ 用下面這【一整塊新代碼】替換掉舊的 prompt 變數 ▼▼▼
    const prompt = `
# 任務
你是一個專業的“豆瓣小組資深用戶模擬器”。你的任務是為名為“${group.name}”的論壇小組裡的一個帖子，生成5條全新的、非常“豆瓣風格”的評論。

# 帖子信息
- 標題: ${post.title}
- 內容: ${post.content.substring(0, 300)}...
- 已有評論:
${existingComments.map(c => `- ${c.author}: ${c.content}`).join('\n') || "(暫無評論)"}

# 【【【評論生成核心規則】】】
1.  **豆瓣風格**: 評論的語言風格必須非常地道，符合真實豆瓣網友的習慣。大量使用豆瓣黑話和網路用語，例如：
    - "同意樓上姐妹！"
    - "馬了，感謝樓主分享"
    - "蹲一個後續"
    - "哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈" (大量的“哈”)
    - "這是可以說的嗎？"
    - "碼住"
    - "笑死，你是什麼互聯網嘴替"
    - "插眼"
    - "我先來，樓主好人一生平安"
2.  **互動性**: 生成的評論必須互相之間有互動。你可以回復樓主（作者: ${post.author}），也可以回復評論區的其他網友。
3.  **【【【昵稱生成鐵律】】】**: 評論者的昵稱 ("author") 【必須】是你自己虛構的、隨機的、生活化的、符合小組氛圍的路人網友昵稱。【絕對禁止】使用下方“公眾人物列表”中的任何一個名字作為評論者。
4.  **格式鐵律**: 你的回復【必須且只能】是一個嚴格的JSON陣列，陣列中包含5個物件。每個物件【必須】包含 "author" 和 "content" 兩個欄位，如果需要回復別人，可以加上 "replyTo" 欄位。

# 公眾人物清單 (他們是討論的對象，但不是發帖人)
${Object.values(state.chats).filter(c => !c.isGroup).map(c => `- ${c.name}`).join('\n')}

# JSON輸出格式示例:
[
  {
    "author": "早睡早起身體好",
    "content": "同意樓上哥哥的，這個確實是這樣！"
  },
  {
    "author": "momo",
    "content": "哈哈哈哈哈哈哈哈哈哈這是可以說的嗎",
    "replyTo": "早睡早起身體好"
  }
]
`;
    // ▲▲▲ 替換結束 ▲▲▲
    
    const messagesForApi = [{ role: 'user', content: prompt }];
    
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.0, response_format: { type: "json_object" } })
            });
        if (!response.ok) throw new Error(`API請求失敗: ${response.status}`);
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const newCommentsData = JSON.parse(cleanedContent);
        if (Array.isArray(newCommentsData) && newCommentsData.length > 0) {
            const commentsToAdd = newCommentsData.map((comment, index) => ({
                postId: postIdToCommentOn,
                author: comment.author || '路人',
                content: comment.content,
                replyTo: comment.replyTo || null,
                timestamp: Date.now() + index
            }));
            await db.forumComments.bulkAdd(commentsToAdd);
            await showCustomAlert("召喚成功！", `已成功召喚 ${commentsToAdd.length} 位豆友前來圍觀。`);
        } else {
            throw new Error("AI返回的資料格式不正確。");
        }
    } catch (error) {
        console.error("生成小組評論失敗:", error);
        await showCustomAlert('生成失敗', `發生了一個錯誤：\n${error.message}`);
    } finally {
        await renderPostDetails(postIdToCommentOn);
    }
}


/**
 * 為帖子添加新評論 (支持回復)
 */
async function handleAddComment() {
    if (!activeForumPostId) return;
    const input = document.getElementById('post-comment-input');
    const content = input.value.trim();
    if (!content) {
        alert("評論內容不能為空！");
        return;
    }
    const newComment = {
        postId: activeForumPostId,
        author: state.qzoneSettings.nickname || '我',
        content: content,
        timestamp: Date.now()
    };
    if (input.dataset.replyTo) {
        newComment.replyTo = input.dataset.replyTo;
    }
    await db.forumComments.add(newComment);
    input.value = '';
    input.placeholder = '發佈你的評論...';
    delete input.dataset.replyTo;
    await renderPostDetails(activeForumPostId);
}

/**
 * 獲取所有可用于同人創作的角色列表
 */
function getAvailableCharacters() {
    const user = { id: 'user', name: state.qzoneSettings.nickname || '我' };
    const chars = Object.values(state.chats)
        .filter(c => !c.isGroup)
        .map(c => ({ id: c.id, name: c.name }));
    return [user, ...chars];
}

/**
 * 填充同人文小組的CP選擇器
 */
async function populateFanficSelectors() {
    const charList = getAvailableCharacters();
    const select1 = document.getElementById('fanfic-char1-select');
    const select2 = document.getElementById('fanfic-char2-select');
    select1.innerHTML = '';
    select2.innerHTML = '';
    charList.forEach(char => {
        const option1 = document.createElement('option');
        option1.value = char.name;
        option1.textContent = char.name;
        select1.appendChild(option1);
        const option2 = document.createElement('option');
        option2.value = char.name;
        option2.textContent = char.name;
        select2.appendChild(option2);
    });
    if(charList.length > 1) {
        select1.selectedIndex = 0;
        select2.selectedIndex = 1;
    }
}

// ▼▼▼ 用這塊【已修改】的代碼，完整替換你舊的 handleGenerateGroupContent 函數 ▼▼▼

/**
 * 【全新改造版】處理通用“生成內容”按鈕的點擊事件
 */
async function handleGenerateGroupContent() {
    const groupIdToGenerateFor = activeGroupId;
    if (!groupIdToGenerateFor) return;

    const group = await db.forumGroups.get(groupIdToGenerateFor);
    if (!group) return;
    
    // ★★★★★ 這就是我們這次修改的核心！ ★★★★★
    // 1. 我們在這里加一個判斷，檢查當前小組的名字是不是“夢角小組”
    if (group.name === '夢角小組') {
        // 如果是，就調用我們剛剛創建的新函數！
        await generateDreamPost(groupIdToGenerateFor);
    }
    // 2. 檢查是不是“娛樂小組”
    else if (group.name === '娛樂小組') {
        await generateEntertainmentGroupContent(groupIdToGenerateFor);
    } 
    // 3. 檢查是不是“同人文小組”
    else if (group.name === '同人文小組') {
        generateFanfic();
    } 
    // 4. 對於所有其他普通小組
    else {
        // 調用原來的通用內容生成函數
        await generateForumContentWithAPI(groupIdToGenerateFor, group.name);
    }
    // ★★★★★ 修改結束 ★★★★★
}

// ▲▲▲ 替換結束 ▲▲▲



// ▼▼▼ 用這塊【V5 | 最終原創分類版】代碼，完整替換舊的 generateForumContentWithAPI 函數 ▼▼▼

/**
 * 【AI核心 - V5 世界觀+原創分類版】為通用小組生成內容
 */
async function generateForumContentWithAPI(groupId, groupName) {
    if (!groupId) return;

    // --- 1. 獲取小組的世界觀 ---
    const group = await db.forumGroups.get(groupId);
    if (!group) {
        alert("錯誤：找不到該小組！");
        return;
    }
    const worldview = group.worldview || '';

    await showCustomAlert("請稍候...", `AI正在為“${groupName}”小組尋找靈感...`);

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先在API設置中配置好才能生成內容哦！');
        return;
    }

    let worldviewContext = '';
    if (worldview.trim()) {
        worldviewContext = `
# 小組專屬世界觀 (你必須嚴格遵守)
${worldview}
`;
    }

    const passerbyPostCount = 5;

    // --- ▼▼▼ 【核心修改】徹底重寫Prompt指令 ---
    const prompt = `
# 任務
你是一個專業的“論壇內容生成器”。你的任務是為名為“${groupName}”的論壇小組，生成【${passerbyPostCount}條】全新的、有趣的、符合小組主題的帖子，並為每條帖子生成2-3條符合情景的評論。

${worldviewContext}

# 核心規則
1.  **主題相關**: 所有帖子的標題、內容和評論都必須與小組主題“${groupName}”高度相關。
2.  **【【【分類鐵律】】】**: 你【必須】為每一條帖子，根據其【具體內容】，原創1-2個高度相關的分類標籤。絕對不要使用任何預設的、固定的分類列表。
    - 例如，如果帖子是討論設定的，分類可以是 ["設定討論"]。
    - 如果帖子是分析劇情的，分類可以是 ["劇情分析"]。
    - 如果帖子是閒聊，分類可以是 ["閒聊水"]。
3.  **作者隨機**: 每條帖子的作者都必須是你虛構的、符合小組氛圍的路人網友。
4.  **格式鐵律**: 你的回復【必須且只能】是一個嚴格的JSON陣列，陣列中包含【${passerbyPostCount}個】帖子物件。每個物件【必須】包含 "author", "title", "content", "categories", 和 "comments" 欄位。
    - "categories" 欄位【必須】是你為這條帖子原創的分類陣列。
    - "comments" 欄位的值【必須】是一個物件陣列，每個物件包含 "author" 和 "content" 欄位。

# JSON輸出格式示例:
[
  {
    "author": "早睡早起身體好",
    "title": "關於世界觀裡XX設定的一個疑問",
    "content": "我剛剛在看世界觀設定，裡面提到XX是藍色的，但是在另一處又說是綠色的...",
    "categories": ["設定討論", "劇情分析"],
    "comments": [
      {"author": "路人甲", "content": "我也發現了！蹲一個解答。"}
    ]
  }
]
`;
    // --- ▲▲▲ 更新結束 ▲▲▲ ---

    const messagesForApi = [{ role: 'user', content: prompt }];

    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 0.9, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API請求失敗: ${response.status}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const newPostsData = JSON.parse(cleanedContent);

        if (Array.isArray(newPostsData) && newPostsData.length > 0) {
            let totalPosts = 0;
            let totalComments = 0;
            for (const postData of newPostsData) {
                // --- 3. 保存帖子時，也保存AI原創的分類 ---
                const newPost = {
                    groupId: groupId,
                    title: postData.title,
                    content: postData.content,
                    author: postData.author,
                    timestamp: Date.now() + totalPosts,
                    categories: postData.categories || [] // 保存原創分類
                };
                const postId = await db.forumPosts.add(newPost);
                totalPosts++;

                if (postData.comments && Array.isArray(postData.comments)) {
                    const commentsToAdd = postData.comments.map(comment => {
                        if (typeof comment === 'object' && comment !== null && comment.author && comment.content) {
                            return {
                                postId: postId,
                                author: comment.author,
                                content: comment.content,
                                timestamp: Date.now() + totalPosts + totalComments++
                            };
                        }
                        return null;
                    }).filter(Boolean);
                    
                    if (commentsToAdd.length > 0) {
                        await db.forumComments.bulkAdd(commentsToAdd);
                    }
                }
            }
            await showCustomAlert("生成成功！", `已為“${groupName}”小組生成了 ${totalPosts} 條新帖子和 ${totalComments} 條評論。`);
            await renderGroupPosts(groupId);
        } else {
            throw new Error("AI沒有返回任何有效的資料。");
        }
    } catch (error) {
        console.error("生成小組內容失敗:", error);
        await showCustomAlert('生成失敗', `發生了一個錯誤：\n${error.message}`);
    }
}
// ▲▲▲ 替換結束 ▲▲▲




// ▼▼▼ 用這塊【V10 | 健壯穩定版】代碼，完整替換舊的 generateFanfic 函數 ▼▼▼

/**
 * 【AI核心 - 同人文 V10 | 健壯穩定版】
 */
async function generateFanfic() {
    const char1Name = document.getElementById('fanfic-char1-select').value;
    const char2Name = document.getElementById('fanfic-char2-select').value;
    const worldviewPreference = document.getElementById('fanfic-worldview-input').value.trim();

    if (char1Name === char2Name) {
        alert("請選擇兩個不同的角色！");
        return;
    }
    
    await showCustomAlert("正在創作...", `粉絲正在為【${char1Name}x${char2Name}】奮筆疾書中...`);
    
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先配置API！');
        return;
    }

    const allChars = getAvailableCharacters();
    const char1Data = allChars.find(c => c.name === char1Name);
    const char2Data = allChars.find(c => c.name === char2Name);
    const char1Persona = (state.chats[char1Data.id]?.settings.aiPersona || '一個普通人');
    const char2Persona = (state.chats[char2Data.id]?.settings.aiPersona || '一個普通人');

    let worldviewContext = worldviewPreference ? `世界觀設定：${worldviewPreference}` : '';
    
    // --- ▼▼▼ 【核心修正】重寫Prompt，增強穩定性和清晰度 ---
    const prompt = `
你是一位專業的同人文寫手。請根據以下要求，創作【三篇】關於角色A和角色B的、情節各不相同的短篇同人故事。

# 角色信息
- 角色A (${char1Name}): ${char1Persona}
- 角色B (${char2Name}): ${char2Persona}
${worldviewContext}

# 任務要求
1.  **創作三篇故事**: 三篇故事的情節、風格必須完全不同。
2.  **原創分類**: 為【每篇】故事，根據其情節原創1-2個最貼切的分類標籤 (例如: "破鏡重圓", "ABO", "甜文")。
3.  **生成評論**: 為【每篇】故事，模擬讀者口吻生成3-5條評論。
4.  **JSON格式**: 你的回復【必須且只能】是一個純淨的JSON陣列，直接以 '[' 開頭，以 ']' 結尾。禁止包含任何其他說明文字。

# JSON結構
[
  {
    "title": "故事標題1",
    "story": "故事內容1...",
    "categories": ["原創分類1", "原創分類2"],
    "comments": [
      {"author": "讀者A", "content": "評論內容A..."},
      {"author": "讀者B", "content": "評論內容B..."}
    ]
  },
  ... (另外兩個故事對象)
]
`;
    // --- ▲▲▲ 更新結束 ▲▲▲ ---

    const messagesForApi = [{ role: 'user', content: prompt }];
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 0.9, response_format: { type: "json_object" } })
            });
        if (!response.ok) throw new Error(`API請求失敗: ${response.status}`);
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        let stories = [];
        try {
            const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
            stories = JSON.parse(cleanedContent);
            if (!Array.isArray(stories)) throw new Error("AI未返回陣列格式。");
        } catch (e) {
            // --- ▼▼▼ 【核心修正】增強錯誤日誌 ---
            console.error("JSON解析失敗！", e);
            console.error("AI返回的原始文本:", rawContent);
            throw new Error("AI返回了無效的JSON格式。請按F12查看控制台中的“AI返回的原始文本”以瞭解詳情。");
            // --- ▲▲▲ 更新結束 ▲▲▲ ---
        }
        for (let i = 0; i < stories.length; i++) {
            const storyData = stories[i];
            const newPost = {
                groupId: activeGroupId,
                title: `【${char1Name}x${char2Name}】${storyData.title || `無題 ${Date.now().toString().slice(-4)}`}`,
                content: storyData.story || '內容生成失敗',
                author: getRandomItem(['為愛發電的太太', '圈地自萌', 'CP是真的', '嗑拉了', '咕咕咕']),
                timestamp: Date.now() + i,
                categories: storyData.categories || []
            };
            const postId = await db.forumPosts.add(newPost);
            if (storyData.comments && Array.isArray(storyData.comments)) {
                const commentsToAdd = storyData.comments.map((c, idx) => ({ postId, author: c.author || '匿名', content: c.content, timestamp: Date.now()+i+idx+1 }));
                await db.forumComments.bulkAdd(commentsToAdd);
            }
        }
        await renderGroupPosts(activeGroupId);
        await showCustomAlert("創作完成！", `已成功為你創作了 ${stories.length} 篇新的同人故事。`);
    } catch (error) {
        console.error("生成同人文失敗:", error);
        await showCustomAlert('創作失敗', `發生了一個錯誤：\n${error.message}`);
    }
}
// ▲▲▲ 替換結束 ▲▲▲





// ▼▼▼ 用這個【V2版】替換舊的 openCreateForumPostModal 函數 ▼▼▼
/**
 * 打開創建帖子的模態框
 */
async function openCreateForumPostModal() {
    resetCreatePostModal(); 
    const modal = document.getElementById('create-post-modal');
    modal.dataset.mode = 'forum';
    document.getElementById('create-post-modal-title').textContent = '發佈新帖子';
    document.getElementById('post-public-text').placeholder = '請輸入帖子內容...';
    
    // 隱藏所有不需要的控制項
    modal.querySelector('.post-mode-switcher').style.display = 'none';
    modal.querySelector('#image-mode-content').style.display = 'none';
    modal.querySelector('#text-image-mode-content').style.display = 'none';
    modal.querySelector('#post-comments-toggle-group').style.display = 'none';
    modal.querySelector('#post-visibility-group').style.display = 'none';
    
    const publicTextGroup = document.getElementById('post-public-text').parentElement;
    
    // --- 動態添加或顯示“標題”輸入框 ---
    let titleGroup = document.getElementById('forum-post-title-group');
    if (!titleGroup) {
        titleGroup = document.createElement('div');
        titleGroup.className = 'form-group';
        titleGroup.id = 'forum-post-title-group';
        titleGroup.innerHTML = `
            <label for="forum-post-title-input">標題</label>
            <input type="text" id="forum-post-title-input" placeholder="請輸入帖子標題...">
        `;
        publicTextGroup.parentNode.insertBefore(titleGroup, publicTextGroup);
    }
    document.getElementById('forum-post-title-input').value = '';

    // --- ▼▼▼ 【核心新增】動態添加“分類”輸入框 ▼▼▼ ---
    let categoryGroup = document.getElementById('forum-post-category-group');
    if (!categoryGroup) {
        categoryGroup = document.createElement('div');
        categoryGroup.className = 'form-group';
        categoryGroup.id = 'forum-post-category-group';
        categoryGroup.innerHTML = `
            <label for="forum-post-category-input">帖子分類 (用#號分隔)</label>
            <input type="text" id="forum-post-category-input" placeholder="例如: #劇情討論 #角色分析">
        `;
        // 將分類輸入框插入到“內容”輸入框之後
        publicTextGroup.parentNode.insertBefore(categoryGroup, publicTextGroup.nextSibling);
    }
    document.getElementById('forum-post-category-input').value = '';
    // --- ▲▲▲ 新增結束 ▲▲▲ ---

    modal.classList.add('visible');
}
// ▲▲▲ 替換結束 ▲▲▲


// ▼▼▼ 用這個【V2版】替換舊的 handleCreateForumPost 函數 ▼▼▼
/**
 * 處理使用者點擊“發佈”按鈕，創建新帖子的邏輯
 */
async function handleCreateForumPost() {
    const title = document.getElementById('forum-post-title-input').value.trim();
    const content = document.getElementById('post-public-text').value.trim();
    if (!title || !content) {
        alert("帖子標題和內容都不能為空哦！");
        return;
    }

    // --- ▼▼▼ 【核心新增】獲取並解析分類 ▼▼▼ ---
    const categoryInput = document.getElementById('forum-post-category-input').value.trim();
    const categories = categoryInput ? categoryInput.match(/#(\S+)/g)?.map(tag => tag.substring(1)) || [] : [];
    // --- ▲▲▲ 新增結束 ▲▲▲ ---

    const newPost = {
        groupId: activeGroupId,
        title: title,
        content: content,
        author: state.qzoneSettings.nickname || '我',
        timestamp: Date.now(),
        categories: categories // 保存解析後的分類陣列
    };
    
    await db.forumPosts.add(newPost);
    document.getElementById('create-post-modal').classList.remove('visible');
    await renderGroupPosts(activeGroupId);
    alert('帖子發佈成功！');
}
// ▲▲▲ 替換結束 ▲▲▲


/**
 * 刪除一個小組及其所有內容
 */
async function deleteGroupAndPosts(groupId) {
    const group = await db.forumGroups.get(groupId);
    if (!group) return;
    const confirmed = await showCustomConfirm(
        '確認刪除',
        `確定要刪除小組“${group.name}”嗎？此操作將同時刪除該小組內的【所有帖子和評論】，且無法恢復！`,
        { confirmButtonClass: 'btn-danger' }
    );
    if (confirmed) {
        try {
            const postsToDelete = await db.forumPosts.where('groupId').equals(groupId).toArray();
            const postIds = postsToDelete.map(p => p.id);
            if (postIds.length > 0) {
                await db.forumComments.where('postId').anyOf(postIds).delete();
            }
            await db.forumPosts.where('groupId').equals(groupId).delete();
            await db.forumGroups.delete(groupId);
            await renderForumScreen();
            alert(`小組“${group.name}”及其所有內容已刪除。`);
        } catch (error) {
            console.error("刪除小組時出錯:", error);
            alert(`刪除失敗: ${error.message}`);
        }
    }
}

// ▼▼▼ 請用這塊【V2強制指令版】代碼，完整替換舊的 repostToChat 函數 ▼▼▼
/**
 * "轉載"功能：將帖子內容分享到單聊，並植入強制AI評論的隱藏指令
 */
async function repostToChat() {
    if (!activeForumPostId) return;
    const post = await db.forumPosts.get(activeForumPostId);
    if (!post) {
        alert("找不到要轉載的帖子！");
        return;
    }
    
    const modal = document.getElementById('share-target-modal');
    const listEl = document.getElementById('share-target-list');
    listEl.innerHTML = '';
    
    const singleChats = Object.values(state.chats).filter(c => !c.isGroup);
    
    singleChats.forEach(chat => {
        const item = document.createElement('div');
        item.className = 'contact-picker-item'; 
        item.innerHTML = `
            <input type="radio" name="repost-target" value="${chat.id}" style="margin-right: 15px;">
            <img src="${chat.settings.aiAvatar || defaultAvatar}" class="avatar">
            <span class="name">${chat.name}</span>
        `;
        listEl.appendChild(item);
    });
    
    document.getElementById('share-target-modal-title').textContent = '轉載到...';
    modal.classList.add('visible');

    const confirmBtn = document.getElementById('confirm-share-target-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    
    newConfirmBtn.onclick = async () => {
        const selectedRadio = document.querySelector('input[name="repost-target"]:checked');
        if (!selectedRadio) {
            alert("請選擇一個要轉載到的聊天！");
            return;
        }

        const targetChatId = selectedRadio.value;
        const targetChat = state.chats[targetChatId];
        if (!targetChat) return;

        // 1. 創建對使用者可見的“轉載卡片”消息
        const repostMessage = {
            role: 'user',
            type: 'repost_forum_post',
            timestamp: Date.now(),
            payload: {
                postId: post.id,
                title: post.title,
                author: post.author,
                content: post.content.substring(0, 100) + '...'
            }
        };

        // 2. ★★★★★ 這就是本次修復的核心！ ★★★★★
        // 創建一條對用戶隱藏，但對AI可見的“強制指令”消息
        const hiddenInstructionMessage = {
            role: 'system', // 告訴AI這是系統指令
            content: `[系統指令：用戶剛剛向你分享了一個小組帖子(ID: ${post.id})，標題是“${post.title}”。你的任務是【必須】對這個帖子發表評論。請【立刻】使用 'forum_comment' 指令完成此任務。]`,
            timestamp: Date.now() + 1, // 確保在卡片消息之後
            isHidden: true // 這個標記會讓它在聊天介面上“隱形”
        };
        // ★★★★★ 核心代碼結束 ★★★★★

        // 3. 將【兩條】消息都添加到聊天記錄中
        targetChat.history.push(repostMessage, hiddenInstructionMessage);
        await db.chats.put(targetChat);
        
        modal.classList.remove('visible');
        await showCustomAlert("轉載成功", `已成功將帖子轉載給“${targetChat.name}”！`);
        
        openChat(targetChatId);
    };
}
// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 【全新】圈子/小組高級功能輔助函數 ▼▼▼
let editingGroupId = null; // 用於追蹤正在編輯的小組ID

/**
 * 打開小組編輯器
 */
async function openGroupEditor(groupId) {
    editingGroupId = groupId;
    const group = await db.forumGroups.get(groupId);
    if (!group) return;

    document.getElementById('group-editor-name-input').value = group.name;
    document.getElementById('group-editor-desc-input').value = group.description;
    document.getElementById('group-editor-icon-input').value = group.icon;
    document.getElementById('group-editor-worldview-input').value = group.worldview || '';
    
    // 將分類陣列轉換回帶'#'的字串
    const categoriesString = (group.categories || []).map(c => `#${c}`).join(' ');
    document.getElementById('group-editor-categories-input').value = categoriesString;
    
    document.getElementById('forum-group-editor-modal').classList.add('visible');
}

/**
 * 保存對小組資訊的修改
 */
async function saveGroupSettings() {
    if (!editingGroupId) return;

    const name = document.getElementById('group-editor-name-input').value.trim();
    if (!name) {
        alert('小組名稱不能為空！');
        return;
    }
    
    const description = document.getElementById('group-editor-desc-input').value.trim();
    const icon = document.getElementById('group-editor-icon-input').value.trim();
    const worldview = document.getElementById('group-editor-worldview-input').value.trim();
    const categoriesInput = document.getElementById('group-editor-categories-input').value.trim();
    // 解析分類字串
    const categories = categoriesInput ? categoriesInput.match(/#(\S+)/g)?.map(tag => tag.substring(1)) || [] : [];
    
    await db.forumGroups.update(editingGroupId, { name, description, icon, worldview, categories });
    
    document.getElementById('forum-group-editor-modal').classList.remove('visible');
    await renderForumScreen();
    alert('小組資訊已更新！');
}

/**
 * 打開分類管理彈窗
 */
async function openForumCategoryManager() {
    await renderForumCategoryList();
    document.getElementById('forum-category-manager-modal').classList.add('visible');
}

/**
 * 在彈窗中渲染分類列表
 */
async function renderForumCategoryList() {
    const listEl = document.getElementById('existing-forum-categories-list');
    const categories = await db.forumCategories.toArray();
    listEl.innerHTML = '';
    if (categories.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">還沒有任何分類</p>';
    }
    categories.forEach(cat => {
        const item = document.createElement('div');
        item.className = 'existing-group-item';
        item.innerHTML = `
            <span class="group-name">${cat.name}</span>
            <span class="delete-group-btn" data-id="${cat.id}">×</span>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 添加一個新的圈子分類
 */
async function addNewForumCategory() {
    const input = document.getElementById('new-forum-category-name-input');
    const name = input.value.trim();
    if (!name) {
        alert('分類名不能為空！');
        return;
    }
    const existing = await db.forumCategories.where('name').equals(name).first();
    if (existing) {
        alert(`分類 "${name}" 已經存在了！`);
        return;
    }
    await db.forumCategories.add({ name });
    input.value = '';
    await renderForumCategoryList();
}

/**
 * 刪除一個圈子分類
 */
async function deleteForumCategory(categoryId) {
    const confirmed = await showCustomConfirm('確認刪除', '確定要刪除這個分類嗎？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.forumCategories.delete(categoryId);
        await renderForumCategoryList();
    }
}
// ▲▲▲ 新增函數結束 ▲▲▲


// ▲▲▲ 論壇功能核心代碼結束 ▲▲▲

// ▼▼▼ 在 init() 函數的【上方】黏貼這【一整塊新代碼】 ▼▼▼
/**
 * 【全新】打開創建小組的模態框
 */
async function openGroupCreator() {
    const name = await showCustomPrompt("創建新小組", "請輸入小組名稱：");
    if (!name || !name.trim()) {
        if (name !== null) alert("小組名稱不能為空！");
        return;
    }

    const desc = await showCustomPrompt("小組描述", "為你的小組寫一句簡介吧：");
    if (desc === null) return;

    const icon = await showCustomPrompt("小組圖示", "輸入一個 Emoji 作為小組圖示：", "💬");
    if (icon === null) return;

    try {
        const newGroup = {
            name: name.trim(),
            description: desc.trim(),
            icon: icon.trim() || '💬' // 如果沒輸入就給個默認的
        };
        await db.forumGroups.add(newGroup);
        await renderForumScreen(); // 刷新小組列表
        alert(`小組“${name.trim()}”創建成功！`);
    } catch (error) {
        console.error("創建小組失敗:", error);
        alert(`創建失敗: ${error.message}`);
    }
}

/**
 * 【全新】刪除一個小組
 * @param {number} groupId - 要刪除的小組的ID
 */
async function deleteGroupAndPosts(groupId) {
    const group = await db.forumGroups.get(groupId);
    if (!group) return;

    const confirmed = await showCustomConfirm(
        '確認刪除',
        `確定要刪除小組“${group.name}”嗎？此操作將同時刪除該小組內的【所有帖子和評論】，且無法恢復！`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        try {
            // 1. 找到該小組下的所有帖子
            const postsToDelete = await db.forumPosts.where('groupId').equals(groupId).toArray();
            const postIds = postsToDelete.map(p => p.id);

            // 2. 如果有帖子，就找到這些帖子下的所有評論並刪除
            if (postIds.length > 0) {
                await db.forumComments.where('postId').anyOf(postIds).delete();
            }

            // 3. 刪除所有帖子
            await db.forumPosts.where('groupId').equals(groupId).delete();
            
            // 4. 最後刪除小組本身
            await db.forumGroups.delete(groupId);

            await renderForumScreen(); // 刷新列表
            alert(`小組“${group.name}”及其所有內容已刪除。`);

        } catch (error) {
            console.error("刪除小組時出錯:", error);
            alert(`刪除失敗: ${error.message}`);
        }
    }
}
// ▼▼▼ 用這塊【V4 | 最終分類版】代碼，完整替換舊的 generateEntertainmentGroupContent 函數 ▼▼▼

// ▼▼▼ 用這塊【V5 | 最終原創分類版】代碼，完整替換舊的 generateEntertainmentGroupContent 函數 ▼▼▼

/**
 * 【AI核心 - 娛樂小組 V5 | 最終原創分類版】
 */
async function generateEntertainmentGroupContent(groupId) {
    if (!groupId) return;

    await showCustomAlert("請稍候...", "娛樂小組正在緊急開會討論最新熱點...");

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先在API設置中配置好才能生成內容哦！');
        return;
    }

    const publicFigures = Object.values(state.chats)
        .filter(c => !c.isGroup)
        .map(c => ({ 
            name: c.name, 
            profession: c.settings.weiboProfession || '藝人',
            persona: (c.settings.weiboInstruction || c.settings.aiPersona).substring(0, 150)
        }));

    let topicsContext = '';
    if (weiboHotSearchCache && weiboHotSearchCache.length > 0) {
        topicsContext = `請圍繞以下【當前最新的微博熱搜話題】展開討論：\n${weiboHotSearchCache.map(t => `- ${t.topic}`).join('\n')}`;
    } else {
        topicsContext = `請你根據下方“公眾人物清單”中各個角色的【職業和人設】，為他們創造一些符合身份的、可能引發討論的娛樂新聞或八卦事件作為討論主題。`;
    }
    
    // --- ▼▼▼ 【核心修改】徹底重寫Prompt指令 ---
    const prompt = `
# 任務
你是一個專業的“豆瓣娛樂小組資深用戶模擬器”。你的任務是根據一個熱門娛樂主題，生成5個帖子和對應的評論，模擬小組內的真實討論氛圍。

# 當前討論主題
${topicsContext}

# 核心規則
1.  **豆瓣風格鐵律**: 所有帖子的標題、內容和評論都【必須】是地道的“豆瓣小組”風格。
2.  **【【【分類鐵律】】】**: 你【必須】為每一個帖子，根據其八卦內容，【原創】1-2個高度相關的分類標籤。絕對不要使用任何預設列表。例如，如果帖子是關於戀情的，分類可以是 ["戀情瓜"]。
3.  **角色扮演鐵律**: 你生成的帖子內容可以【討論或提及】下方的公眾人物，但【不能扮演他們】親自發帖。所有帖子都必須是路人視角。
4.  **格式鐵律**: 你的回復【必須且只能】是一個嚴格的JSON陣列，包含5個帖子物件。每個物件【必須】包含 "author", "title", "content", "categories", 和 "comments" 欄位。
    - "categories" 欄位【必須】是你為這篇帖子原創的分類陣列。

# 公眾人物清單 (他們是討論的對象，但不是發帖人)
${JSON.stringify(publicFigures, null, 2)}

# JSON輸出格式示例:
[
  {
    "author": "momo",
    "title": "不懂就問，最近那個熱搜上的劇真的好看嗎？",
    "content": "首頁天天刷到，有點好奇但又怕踩雷...",
    "categories": ["新劇討論"],
    "comments": [
      {"author": "已註銷", "content": "不好看，別去。"}
    ]
  }
]
`;
    // --- ▲▲▲ 更新結束 ▲▲▲ ---

    const messagesForApi = [{ role: 'user', content: prompt }];
    
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.0, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API請求失敗: ${response.status}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const newPostsData = JSON.parse(cleanedContent);

        if (Array.isArray(newPostsData) && newPostsData.length > 0) {          
            let totalPosts = 0;
            let totalComments = 0;
            for (const postData of newPostsData) {
                // --- ▼▼▼ 【核心新增】保存分類資料 ---
                const newPost = {
                    groupId: groupId,
                    title: postData.title,
                    content: postData.content,
                    author: postData.author,
                    timestamp: Date.now() + totalPosts,
                    categories: postData.categories || [] // 保存分類
                };
                // --- ▲▲▲ 新增結束 ▲▲▲ ---
                
                const postId = await db.forumPosts.add(newPost);
                totalPosts++;

                if (postData.comments && Array.isArray(postData.comments)) {
                    const commentsToAdd = postData.comments.map(comment => ({
                        postId: postId,
                        author: comment.author,
                        content: comment.content,
                        timestamp: Date.now() + totalPosts + totalComments++
                    }));
                    if (commentsToAdd.length > 0) {
                        await db.forumComments.bulkAdd(commentsToAdd);
                    }
                }
            }
            await renderGroupPosts(groupId);
            await showCustomAlert("生成成功！", `已為娛樂小組生成了 ${totalPosts} 條新帖子和 ${totalComments} 條評論。`);
        } else {
            throw new Error("AI返回的資料格式不正確。");
        }
    } catch (error) {
        console.error("生成娛樂小組內容失敗:", error);
        await showCustomAlert('生成失敗', `發生了一個錯誤：\n${error.message}`);
    }
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 用這塊【V4 | 最終原創分類版】代碼，完整替換舊的 generateDreamPost 函數 ▼▼▼

/**
 * 【全新修正版 | V4】為“夢角小組”生成專屬帖子的核心函數
 */
async function generateDreamPost(groupId) {
    await showCustomAlert("請稍候...", "正在為user編織一個甜蜜的夢境...");

    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先在API設置中配置好才能生成內容哦！');
        return;
    }

    const allChars = Object.values(state.chats).filter(c => !c.isGroup);
    if (allChars.length === 0) {
        alert("還沒有任何角色，無法發佈夢境哦。");
        return;
    }

    const postingChar = allChars[Math.floor(Math.random() * allChars.length)];
    const userPersona = state.qzoneSettings.persona || '一個普通的、溫柔的人。';
    const userNickname = state.qzoneSettings.nickname || '{{user}}';

    // --- ▼▼▼ 【核心修改】徹底重寫Prompt指令 ---
    const prompt = `
# 任務：角色扮演與帖子創作（帶評論和分類）
你現在【就是】角色“${postingChar.name}”。你正在一個名為“夢角小組”的秘密論壇裡。
這個小組是你們這些角色，偷偷向彼此炫耀、傾訴對你們的共同愛人——用戶“${userNickname}”——的愛意和幻想的地方。

# 核心規則
1.  **第一人稱視角**: 你【必須】使用角色“${postingChar.name}”的第一人稱視角來寫作帖子正文。
2.  **帖子主題**: 你的帖子內容是你對你的愛人“${userNickname}”的愛意表達或幻想。
3.  **【【【分類鐵律】】】**: 你【必須】根據夢境的具體內容，為這篇帖子【原創】1-2個高度相關的分類標籤。絕對不要使用任何預設列表。例如，如果內容是甜蜜的日常，分類可以是 ["甜蜜日常"]。
4.  **評論生成**: 在創作完帖子後，你還需要立刻切換到“其他小組成員”的視角，為這篇帖子生成【2-3條】符合情景的評論。
5.  **格式鐵律**: 你的回復【必須且只能】是一個嚴格的JSON物件，包含 "title", "content", "categories", 和 "comments" 欄位。
    - "categories" 欄位【必須】是你為這篇帖子原創的分類陣列。

# 你的信息
-   你的名字: ${postingChar.name}
-   你的人設: ${postingChar.settings.aiPersona}

# 你的愛人信息
-   愛人的名字: ${userNickname}
-   愛人的人設: ${userPersona}

# JSON輸出格式示例:
{
  "title": "關於他睡覺時的小習慣",
  "content": "偷偷告訴你們，${userNickname}睡覺的時候喜歡抱著枕頭的一角...",
  "categories": ["甜蜜日常", "小習慣"],
  "comments": [
    {"author": "路人A", "content": "哇，好甜！"}
  ]
}
`;
    // --- ▲▲▲ 更新結束 ▲▲▲ ---

    const messagesForApi = [{ role: 'user', content: prompt }];
    
    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.0, response_format: { type: "json_object" } })
            });
        
        if (!response.ok) throw new Error(`API請求失敗: ${response.status}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const postData = JSON.parse(cleanedContent);

        if (postData.title && postData.content) {
            // --- ▼▼▼ 【核心新增】保存分類資料 ---
            const newPost = {
                groupId: groupId,
                title: postData.title,
                content: postData.content,
                author: postingChar.name,
                timestamp: Date.now(),
                categories: postData.categories || [] // 保存分類
            };
            // --- ▲▲▲ 新增結束 ▲▲▲ ---
            
            const postId = await db.forumPosts.add(newPost);
            
            if (postData.comments && Array.isArray(postData.comments)) {
                const commentsToAdd = postData.comments.map((c, i) => ({ postId, author: c.author, content: c.content, timestamp: Date.now() + i + 1 }));
                await db.forumComments.bulkAdd(commentsToAdd);
            }

            await renderGroupPosts(groupId);
            await showCustomAlert("發佈成功！", `“${postingChar.name}”發佈了一條新的夢境。`);
        } else {
            throw new Error("AI返回的資料格式不正確。");
        }
    } catch (error) {
        console.error("生成夢角帖子失敗:", error);
        await showCustomAlert('生成失敗', `發生了一個錯誤：\n${error.message}`);
    }
}
// ▲▲▲ 替換結束 ▲▲▲



// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 把這一整塊全新的功能函數，黏貼到 init() 函數的正上方 ▼▼▼

/**
 * 塔羅牌占卜功能核心
 */
let activeTarotReading = null; // 用於暫存當前占卜的結果

// 牌陣信息
const TAROT_SPREADS = {
    single: { name: '單張牌 - 快速指引', count: 1, positions: ['核心指引'] },
    three_past_present_future: { name: '三張牌 - 過去/現在/未來', count: 3, positions: ['過去', '現在', '未來'] },
    three_situation_challenge_advice: { name: '三張牌 - 情境/挑戰/建議', count: 3, positions: ['情境', '挑戰', '建議'] },
    celtic_cross: { name: '凱爾特十字 - 深度分析', count: 10, positions: ['現狀', '挑戰', '根基', '過去', '目標', '未來', '自我認知', '外部影響', '希望與恐懼', '最終結果'] }
};

// 打開塔羅牌占卜主模態框
function openTarotModal() {
    document.getElementById('tarot-divination-modal').classList.add('visible');
    // 預設顯示設定介面
    document.getElementById('tarot-setup-view').style.display = 'block';
    document.getElementById('tarot-result-view').style.display = 'none';
    document.getElementById('tarot-history-view').style.display = 'none';
    // 清空輸入框
    document.getElementById('tarot-question-input').value = '';
}

// 執行抽牌邏輯
function handleDrawCards() {
    const question = document.getElementById('tarot-question-input').value.trim();
    const spreadType = document.getElementById('tarot-spread-select').value;
    const orientation = document.querySelector('input[name="tarot-orientation"]:checked').value;
    
    if (!question) {
        alert('請輸入您的問題或關注點。');
        return;
    }

    const spreadInfo = TAROT_SPREADS[spreadType];
    const deck = [...TAROT_DECK];

    // 洗牌
    for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
    }

    // 抽牌
    const drawnCardsRaw = deck.slice(0, spreadInfo.count);
    const drawnCards = drawnCardsRaw.map((card, index) => {
        const isReversed = orientation === 'reversed' && Math.random() < 0.5;
        return {
            ...card,
            isReversed: isReversed,
            position: spreadInfo.positions[index]
        };
    });

    activeTarotReading = {
        question: question,
        spread: spreadInfo,
        cards: drawnCards,
        timestamp: Date.now()
    };
    
    displayTarotResults(activeTarotReading);
}

// ▼▼▼ 用這個【新版本】替換舊的 displayTarotResults 函數 ▼▼▼
// 顯示占卜結果 (純文字版)
function displayTarotResults(reading) {
    const displayEl = document.getElementById('tarot-result-display');
    displayEl.innerHTML = ''; // 清空

    // 顯示問題
    const questionEl = document.createElement('div');
    questionEl.className = 'tarot-result-question';
    questionEl.textContent = `您的問題是：“${reading.question}”`;
    displayEl.appendChild(questionEl);
    
    const container = document.createElement('div');
    container.className = 'tarot-spread-container';

    reading.cards.forEach(card => {
        const cardWrapper = document.createElement('div');
        cardWrapper.className = 'tarot-card-wrapper';
        
        cardWrapper.innerHTML = `
            <div class="tarot-card-position">[${card.position}]</div>
            <div class="tarot-card-name">${card.name} ${card.isReversed ? '(逆位)' : '(正位)'}</div>
        `;
        container.appendChild(cardWrapper);
    });
    
    displayEl.appendChild(container);

    // 切換視圖
    document.getElementById('tarot-setup-view').style.display = 'none';
    document.getElementById('tarot-result-view').style.display = 'flex';
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 用這整塊【AI智能解讀最終版】代碼，完整替換舊的 sendTarotReadingToChat 函數 ▼▼▼
async function sendTarotReadingToChat() {
    if (!activeTarotReading || !state.activeChatId) return;

    const chat = state.chats[state.activeChatId];
    const { proxyUrl, apiKey, model } = state.apiConfig;

    if (!proxyUrl || !apiKey || !model) {
        alert('請先在API設置中配置好才能觸發AI解讀哦！');
        return;
    }

    // 1. 關閉彈窗，並顯示“正在解讀”的提示
    document.getElementById('tarot-divination-modal').classList.remove('visible');
    await showCustomAlert("請稍候...", "塔羅師正在為你連接星辰，解讀牌面...");

    try {
        const reading = activeTarotReading;
        
        // 2. 【全新優化】給“塔羅師AI”一個更專業、更結構化的指令 (Prompt)
        const cardDetails = reading.cards.map(card => {
            const orientation = card.isReversed ? '逆位' : '正位';
            const meaning = card.isReversed ? card.reversed : card.upright;
            return `- ${card.position}: ${card.name} (${orientation})，象徵: ${meaning}`;
        }).join('\n');

        const tarotMasterPrompt = `
# 角色
你是一位世界級的塔羅牌解讀大師，以深刻的洞察力、清晰的表達和富有同情心的指引而聞名。

# 核心任務
為使用者提供一次全面、結構化且易於理解的塔羅牌解讀。你的解讀必須嚴格遵循下面的輸出結構。

# 輸出結構 (必須嚴格遵守)
你的回答必須包含以下三個部分，並使用Markdown加粗標題來分隔：

1.  **✨ 綜合解讀 (Overall Interpretation):**
    首先，根據所有牌面的整體感覺，給出一個高度概括的、1-2句話的核心結論或氛圍描述。

2.  **🃏 牌面詳解 (Card Details):**
    然後，逐一分析每一張牌。對於每一張牌，你必須：
    -   使用格式 \`**[牌位名稱] - [牌名] ([正位/逆位])**\` 作為小標題。
    -   詳細解釋這張牌在這個特定牌位上，是如何回應用戶的問題的。
    -   將牌的象徵意義與用戶的具體情境（問題）緊密結合起來進行分析。

3.  **💡 核心建議 (Key Advice):**
    最後，綜合所有牌的資訊，為使用者提供一個明確、具體、可操作的行動建議或心態指引。

# 指導原則
- **故事性**: 將所有牌的含義編織成一個連貫的敘事，而不是簡單地羅列關鍵字。
- **相關性**: 始終將解讀直接與用戶提出的具體問題聯繫起來。
- **清晰易懂**: 避免使用過於神秘或專業的術語。用平實的語言解釋複雜的概念。
- **深度而非羅列**: 絕對不要只是重複我提供給你的“象徵”關鍵字。你必須在這些關鍵字的基礎上進行綜合、提煉和深化，給出你作為大師的獨特見解。

# 占卜信息
- **用戶的問題**: "${reading.question}"
- **使用的牌陣**: ${reading.spread.name}
- **抽到的牌及基礎含義**:
${cardDetails}

# 最終指令
你的最終輸出【只能是】完整的、格式化後的解讀文本。不要添加任何“好的，這是你的解讀：”之類的對話性開場白。
`;

        // 3. 發起API調用，讓AI扮演塔羅師
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: tarotMasterPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, tarotMasterPrompt, messagesForApi, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 0.7 })
            });

        if (!response.ok) {
            throw new Error(`API請求失敗: ${await response.text()}`);
        }
        
        const data = await response.json();
        const interpretation = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).trim();

        // 4. 創建對使用者可見的“系統解讀”消息
        const systemMessageVisible = {
            role: 'system',
            type: 'pat_message', // 複用居中灰色氣泡樣式
            content: `🔮 **塔羅牌解讀** 🔮\n\n**您的問題**：“${reading.question}”\n\n${interpretation}`,
            timestamp: Date.now()
        };
        chat.history.push(systemMessageVisible);
        appendMessage(systemMessageVisible, chat);

        // 5. 創建給角色Char看的隱藏指令
        const hiddenInstruction = {
            role: 'system',
            content: `[系統指令：剛剛系統為使用者進行了一次塔羅牌占卜，解讀結果是：“${interpretation}”。現在，請你以角色的身份，和用戶一起討論這個結果。]`,
            timestamp: Date.now() + 1, // 確保時間戳記在後
            isHidden: true
        };
        chat.history.push(hiddenInstruction);

        // 6. 保存所有資料
        await saveTarotReading(activeTarotReading);
        await db.chats.put(chat);
        renderChatList();
        
        // 7. 【核心修改】我們在這裡刪除了 triggerAiResponse()，不再自動觸發Char！
        
        activeTarotReading = null;

    } catch (error) {
        console.error("塔羅牌AI解讀失敗:", error);
        await showCustomAlert('解讀失敗', `抱歉，連接塔羅師時出現了一點問題：\n\n${error.message}`);
        activeTarotReading = null;
    }
}
// ▲▲▲ 替換結束 ▲▲▲

// 保存占卜記錄到資料庫
async function saveTarotReading(reading) {
    // 為了節省空間，我們只保存解讀文本，而不是整個牌組對象
    const interpretationText = `牌陣: ${reading.spread.name}\n` + reading.cards.map((card, index) => {
        const orientationText = card.isReversed ? '逆位' : '正位';
        const meaning = card.isReversed ? card.reversed : card.upright;
        return `[${card.position}]: ${card.name} (${orientationText}) - ${meaning}`;
    }).join('\n');
    
    await db.tarotReadings.add({
        question: reading.question,
        interpretation: interpretationText,
        timestamp: reading.timestamp
    });
}

// 打開歷史記錄介面
async function openTarotHistory() {
    const readings = await db.tarotReadings.orderBy('timestamp').reverse().toArray();
    renderTarotHistory(readings);
    document.getElementById('tarot-setup-view').style.display = 'none';
    document.getElementById('tarot-history-view').style.display = 'flex';
}

// 渲染歷史記錄清單
function renderTarotHistory(readings) {
    const listEl = document.getElementById('tarot-history-list');
    listEl.innerHTML = '';
    if (readings.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a; margin-top: 50px;">還沒有占卜歷史哦</p>';
        return;
    }
    readings.forEach(reading => {
        const item = document.createElement('div');
        item.className = 'tarot-history-item';
        item.innerHTML = `
            <div class="question">${reading.question}</div>
            <div class="details">${new Date(reading.timestamp).toLocaleString()}</div>
            <button class="tarot-history-delete-btn" data-id="${reading.id}">×</button>
        `;
        listEl.appendChild(item);
    });
}

// 刪除一條歷史記錄
async function deleteTarotReading(readingId) {
    const confirmed = await showCustomConfirm('確認刪除', '確定要刪除這條占卜歷史嗎？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.tarotReadings.delete(readingId);
        openTarotHistory(); // 重新載入歷史記錄
    }
}

// ▲▲▲ 新功能函數黏貼結束 ▲▲▲
// ▼▼▼ 把這個新函數黏貼到 renderLSLetters 函數的下方 ▼▼▼

// ▼▼▼ 【全新】這是情侶空間專屬音樂播放機的CSS樣式 ▼▼▼
/**
 * 【全新】渲染“分享”列表 (無封面，帶簡介和感想版)
 */
function renderLSShares(shares, chat) {
    const listEl = document.getElementById('ls-shares-list');
    listEl.innerHTML = '';
    if (!shares || shares.length === 0) {
        listEl.innerHTML = '<p class="ls-empty-placeholder">這裡還沒有任何分享哦~</p>';
        return;
    }

    [...shares].reverse().forEach(share => {
        const item = document.createElement('div');
        item.className = 'ls-list-item ls-share-item';
        item.dataset.shareData = JSON.stringify(share);

        const typeText = { song: '歌曲', movie: '電影', book: '書籍', game: '遊戲' }[share.shareType] || '分享';
        const authorName = share.author === 'user' ? (chat.settings.myNickname || '我') : chat.name;
        
        // ▼▼▼ 核心修改在這裡：我們重構了“摘要”部分的邏輯 ▼▼▼
        let summaryHtml = '';
        
        // 1. 如果是歌曲，顯示歌手
        if (share.shareType === 'song' && share.artist) {
            summaryHtml += `<p style="margin:0; font-weight: 500;"><strong>歌手:</strong> ${share.artist}</p>`;
        }
        
        // 2. 如果有簡介 (書籍和電影)，就顯示簡介
        if (share.summary) {
            summaryHtml += `<p style="margin:0; margin-top: 4px;"><strong>簡介:</strong> ${share.summary.replace(/\n/g, '<br>')}</p>`;
        }
        
        // 3. 如果有感想，就顯示感想
        if (share.thoughts) {
            summaryHtml += `<p style="margin:0; margin-top: 4px; color: #8a8a8a; font-style: italic;"><strong>感想:</strong> “${share.thoughts}”</p>`;
        }
        
        // 4. 如果啥都沒有，給一個默認提示
        if (!summaryHtml) {
            summaryHtml = '<p style="margin:0; color: #8a8a8a;">暫無更多資訊</p>';
        }
        // ▲▲▲ 修改結束 ▲▲▲

        // 【核心修改】這裡的範本已經移除了<img>標籤
        item.innerHTML = `
            <div class="share-info">
                <div class="title">
                    <span class="share-type ${share.shareType}">${typeText}</span>
                    ${share.title}
                </div>
                <div class="summary">${summaryHtml}</div>
                <div class="meta">
                    由 ${authorName} 分享於 ${formatPostTimestamp(share.timestamp)}
                </div>
            </div>
        `;
        listEl.appendChild(item);
    });
}



// ▼▼▼ 【全新】情侶空間功能核心函數 ▼▼▼

// ▼▼▼ 用下面這一整塊代碼，替換掉你舊的 open... 和 render... 四個函數 ▼▼▼

/**
 * 【總入口】當使用者點擊主螢幕的“情侶空間”App時觸發
 */
async function openLoversSpaceEntry() {
    const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    if (singleChats.length === 0) {
        alert("你還沒有任何可以建立情侶空間的角色哦，先去創建一個吧！");
        return;
    }
    if (singleChats.length === 1) {
        openLoversSpace(singleChats[0].id);
    } else {
        openCharSelectorForLoversSpace();
    }
}

// ▼▼▼ 用這塊代碼替換 ▼▼▼
/**
 * 打開用於情侶空間的角色選擇彈窗 (已更新，會顯示開啟狀態)
 */
async function openCharSelectorForLoversSpace() {
    const modal = document.getElementById('ls-char-selector-modal');
    const listEl = document.getElementById('ls-char-selector-list');
    listEl.innerHTML = '';
    const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    
    singleChats.forEach(chat => {
        const item = document.createElement('div');
        item.className = 'chat-list-item'; // 複用現有樣式
        item.style.borderBottom = '1px solid var(--border-color)';
        item.dataset.chatId = chat.id;

        // 【核心修改】檢查角色是否已開通情侶空間
        const isLoversSpaceActive = !!chat.loversSpaceData;
        const statusText = isLoversSpaceActive 
            ? '<span style="color: green; font-weight: bold;">已開通</span>' 
            : '<span style="color: #8a8a8a;">未開啟</span>';

        item.innerHTML = `
            <img src="${chat.settings.aiAvatar || defaultAvatar}" class="avatar">
            <div class="info" style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                <span class="name">${chat.name}</span>
                <div class="last-msg">${statusText}</div>
            </div>
        `;
        listEl.appendChild(item);
    });

    modal.classList.add('visible');
}
// ▲▲▲ 替換結束 ▲▲▲


/**
 * 【核心】打開指定角色的情侶空間
 */
async function openLoversSpace(charId) {
    activeLoversSpaceCharId = charId;
    const chat = state.chats[charId];
    if (!chat) return;

    // 如果這個角色還沒有情侶空間資料，就為他初始化一個
    if (!chat.loversSpaceData) {
chat.loversSpaceData = {
    background: 'https://i.postimg.cc/k495F4W5/profile-banner.jpg',
    relationshipStartDate: null,
    moments: [],
    albums: [],
    photos: [],
    loveLetters: [],
    shares: [],
    questions: [],
    emotionDiaries: {} // <--- 就是新增了這一行！
};
// ▲▲▲ 替換結束 ▲▲▲
        await db.chats.put(chat);
    }

    await renderLoversSpace(chat);
    showScreen('lovers-space-screen');
}

/**
 * 【全新】計算並更新“在一起”的天數
 */
function updateLoversSpaceDaysCounter(chat) {
    const counterEl = document.getElementById('ls-days-counter');
    const startDateString = chat.loversSpaceData.relationshipStartDate;

    if (startDateString) {
        const startDate = new Date(startDateString);
        const today = new Date();
        // 修正時區問題，只比較日期
        startDate.setHours(0, 0, 0, 0);
        today.setHours(0, 0, 0, 0);

        const diffTime = Math.abs(today - startDate);
        // 加1，因為第一天也算一天
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;
        counterEl.textContent = `我們已經在一起 ${diffDays} 天了`;
    } else {
        counterEl.innerHTML = `<a>點擊右上角“設置”來記錄第一天吧</a>`;
    }
}

/**
 * 【渲染引擎 - 已更新】根據角色資料，渲染整個情侶空間介面
 */
async function renderLoversSpace(chat) {
    // 渲染頭部
    document.getElementById('lovers-space-screen').style.backgroundImage = `url(${chat.loversSpaceData.background})`;
    
    // 這是你想要的 user & char 標題
    const userNickname = state.qzoneSettings.nickname || '{{user}}';
    document.getElementById('ls-char-name').textContent = `${userNickname} & ${chat.name}`;
    
    document.getElementById('ls-user-avatar').src = chat.settings.myAvatar || defaultAvatar;
    document.getElementById('ls-char-avatar').src = chat.settings.aiAvatar || defaultAvatar;
    
    // 調用新函數來更新天數
    updateLoversSpaceDaysCounter(chat);
    
    // 預設顯示第一個頁簽
    switchLoversSpaceTab('ls-moments-view');
// ▼▼▼ 用下面這塊【已修復】的代碼替換 ▼▼▼
// 這是你的舊代碼
document.querySelector('.ls-tab-item.active').classList.remove('active');
document.querySelector('.ls-tab-item[data-view="ls-moments-view"]').classList.add('active');



    // 渲染各個頁簽的內容
    renderLSMoments(chat.loversSpaceData.moments, chat);
    renderLSPhotos(chat.loversSpaceData.photos, chat);
    renderLSLetters(chat.loversSpaceData.loveLetters, chat);
    renderLSShares(chat.loversSpaceData.shares, chat);
    document.getElementById('ls-shares-list').innerHTML = '<p class="ls-empty-placeholder">Ta還沒有分享任何內容~</p>';
}

// ▲▲▲ 替換到這裡結束 ▲▲▲

// ▼▼▼ 用這塊新代碼替換舊的 switchLoversSpaceTab 函數 ▼▼▼
/**
 * 切換情侶空間的頁簽
 */
function switchLoversSpaceTab(viewId) {
    document.querySelectorAll('.ls-view').forEach(v => v.style.display = 'none'); // 使用style來隱藏
    const targetView = document.getElementById(viewId);
    if (targetView) targetView.style.display = 'block'; // 使用style來顯示

    // 【核心修改】根據當前頁簽，顯示對應的浮動按鈕
    const fabMoment = document.getElementById('ls-add-moment-btn');
    const fabAlbum = document.getElementById('ls-add-album-btn');
    const fabLetter = document.getElementById('ls-add-letter-btn');
    const fabQuestion = document.getElementById('ls-add-question-btn');
    
    // 先隱藏所有
    if(fabMoment) fabMoment.style.display = 'none';
    if(fabAlbum) fabAlbum.style.display = 'none';
    if(fabLetter) fabLetter.style.display = 'none';
    if(fabQuestion) fabQuestion.style.display = 'none';

    // 再根據viewId顯示對應的
    if (viewId === 'ls-moments-view' && fabMoment) fabMoment.style.display = 'block';
    else if (viewId === 'ls-album-view' && fabAlbum) fabAlbum.style.display = 'block';
    else if (viewId === 'ls-letters-view' && fabLetter) fabLetter.style.display = 'block';
    else if (viewId === 'ls-questions-view' && fabQuestion) fabQuestion.style.display = 'block';
}
// ▲▲▲ 替換結束 ▲▲▲


/**
 * 【全新】處理更換情侶空間背景的邏輯
 */
async function handleChangeLoversSpaceBackground() {
    if (!activeLoversSpaceCharId) return;

    // 複用已有的功能彈窗，讓用戶選擇
    const choice = await showChoiceModal("更換空間背景", [
        { text: '📁 從本地上傳', value: 'local' },
        { text: '🌐 使用網路URL', value: 'url' }
    ]);

    let newBackgroundUrl = null;

    if (choice === 'local') {
        // 複用已有的本地圖片上傳函數
        newBackgroundUrl = await uploadImageLocally();
    } else if (choice === 'url') {
        // 複用已有的URL輸入彈窗
        const currentBg = state.chats[activeLoversSpaceCharId].loversSpaceData.background;
        newBackgroundUrl = await showCustomPrompt("更換背景", "請輸入新的圖片URL", currentBg, "url");
    }

    // 如果獲取到了新的URL
    if (newBackgroundUrl && newBackgroundUrl.trim()) {
        const chat = state.chats[activeLoversSpaceCharId];
        chat.loversSpaceData.background = newBackgroundUrl.trim();
        
        // 保存到資料庫
        await db.chats.put(chat);
        
        // 立刻重新渲染情侶空間以應用新背景
        await renderLoversSpace(chat);
        
        alert('情侶空間背景已更新！');
    } else if (newBackgroundUrl !== null) { // 用戶點擊了確定但沒輸入內容
         alert("請輸入一個有效的URL或選擇一個檔！");
    }
}

// ▲▲▲ 新函數黏貼結束 ▲▲▲

/**
 * 渲染“說說”列表 (V2 - 已添加評論和刪除功能)
 */
function renderLSMoments(moments, chat) {
    const listEl = document.getElementById('ls-moments-list');
    listEl.innerHTML = '';
    if (!moments || moments.length === 0) {
        listEl.innerHTML = '<p class="ls-empty-placeholder">還沒有任何悄悄話，快來發佈第一條吧！</p>';
        return;
    }
    
    // 我們需要原始的陣列索引來做刪除，所以這裡不用 [...moments].reverse()
    for (let i = moments.length - 1; i >= 0; i--) {
        const moment = moments[i];
        const originalIndex = i; // 保存原始索引

        const isUser = moment.author === 'user';
        const authorName = isUser ? (chat.settings.myNickname || '我') : chat.name;
        const authorAvatar = isUser ? chat.settings.myAvatar : chat.settings.aiAvatar;

        // --- 核心修改：在這裡構建評論區的HTML ---
        let commentsHtml = '';
        if (moment.comments && moment.comments.length > 0) {
            moment.comments.forEach((comment, commentIndex) => {
                commentsHtml += `
                    <div class="ls-comment-item">
                        <span class="commenter-name">${comment.author}:</span>
                        <span class="comment-text">${comment.text}</span>
                        <button class="ls-comment-delete-btn" data-moment-index="${originalIndex}" data-comment-index="${commentIndex}">×</button>
                    </div>
                `;
            });
        }
        
        const card = document.createElement('div');
        card.className = 'ls-moment-card';
        // 【重要】把說說的原始索引存起來，方便後面操作
        card.dataset.momentIndex = originalIndex; 
        
        // --- 核心修改：加入新的HTML結構 ---
        card.innerHTML = `
            <img src="${authorAvatar}" class="avatar">
            <div class="moment-main">
                <span class="author">${authorName}</span>
                <p class="content">${moment.content.replace(/\n/g, '<br>')}</p>
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span class="timestamp">${formatPostTimestamp(moment.timestamp)}</span>
                </div>
                
                <!-- ▼▼▼ 這是新增的整個底部區域 ▼▼▼ -->
                <div class="ls-moment-footer">
                    <div class="ls-moment-comments-container">
                        ${commentsHtml}
                    </div>
                    <div class="ls-comment-input-area">
                        <input type="text" placeholder="添加評論...">
                        <button class="ls-comment-send-btn">發送</button>
                    </div>
                </div>
                <!-- ▲▲▲ 新增區域結束 ▲▲▲ -->

            </div>
            <!-- ▼▼▼ 這是新增的說說刪除按鈕 ▼▼▼ -->
            <button class="ls-moment-delete-btn" title="刪除這條說說">×</button>
        `;
        listEl.appendChild(card);
    }
}



// ▼▼▼ 用這塊【新代碼】替換舊的 renderLSPhotos 函數 ▼▼▼
/**
 * 渲染“照片”列表
 */
function renderLSPhotos(photos, chat) {
    const listEl = document.getElementById('ls-album-list');
    listEl.innerHTML = '';
    if (!photos || photos.length === 0) {
        listEl.innerHTML = '<p class="ls-empty-placeholder" style="grid-column: 1 / -1;">還沒有任何照片，點擊右下角“+”上傳第一張吧！</p>';
        return;
    }

    [...photos].reverse().forEach(photo => {
        const item = document.createElement('div');
        item.className = 'ls-album-item';
        
        // 【核心修改1】在這裡為整個項目添加時間戳記，方便我們識別是哪張照片
        item.dataset.timestamp = photo.timestamp; 

        const imageUrl = photo.type === 'image' 
            ? photo.url 
            : 'https://i.postimg.cc/KYr2qRCK/1.jpg';

        // 【核心修改2】在 .cover 內部添加了刪除按鈕的HTML
        item.innerHTML = `
            <div class="cover" style="background-image: url(${imageUrl});">
                <button class="ls-photo-delete-btn">×</button>
            </div>
        `;
        
        // 【核心修改3】我們不再在這裡單獨綁定點擊事件，將在最後一步統一處理
        listEl.appendChild(item);
    });
}
// ▲▲▲ 替換結束 ▲▲▲



/**
 * 打開創建說說的彈窗
 */
function openMomentCreator() {
    document.getElementById('ls-moment-content-input').value = '';
    document.getElementById('ls-create-moment-modal').classList.add('visible');
}

/**
 * 用戶發佈說說 (V2 - 已添加comments欄位)
 */
async function handlePostMoment() {
    const content = document.getElementById('ls-moment-content-input').value.trim();
    if (!content) {
        alert("內容不能為空哦！");
        return;
    }
    const chat = state.chats[activeLoversSpaceCharId];
    const newMoment = {
        author: 'user',
        content: content,
        timestamp: Date.now(),
        comments: [] // <-- 核心新增：為新說說創建一個空的評論陣列
    };
    // 確保moments陣列存在
    if (!chat.loversSpaceData.moments) {
        chat.loversSpaceData.moments = [];
    }
    chat.loversSpaceData.moments.push(newMoment);
    await db.chats.put(chat);
    
    renderLSMoments(chat.loversSpaceData.moments, chat);
    document.getElementById('ls-create-moment-modal').classList.remove('visible');
// ▼▼▼ 在 handlePostMoment 函數的末尾，黏貼下面這塊新代碼 ▼▼▼
// 創建一條對用戶隱藏，但對AI可見的系統消息
const hiddenMessage = {
    role: 'system',
    content: `[系統提示：用戶（${chat.settings.myNickname || '我'}）剛剛在我們的情侶空間發佈了一條新的說說，內容是：“${content}”。請你根據人設，使用 'ls_comment' 指令對這條說說發表你的看法。]`,
    timestamp: Date.now(),
    isHidden: true // 這個標記能讓消息對你隱藏，但AI能看見
};
chat.history.push(hiddenMessage);
await db.chats.put(chat); // 再次保存，確保隱藏消息被存入

// （可選）如果你希望AI在你發完說說後立刻就去評論，可以取消下面這行的注釋
// triggerAiResponse();
// ▲▲▲ 黏貼結束 ▲▲▲
}


let tempUploadedPhotos = []; // 暫存待上傳的照片
// ▼▼▼ 用這塊新代碼替換舊的 openAlbumCreator 函數 ▼▼▼
/**
 * 打開上傳照片的彈窗
 */
function openAlbumCreator() {
    tempUploadedPhotos = [];
    document.getElementById('ls-album-modal-title').textContent = '上傳照片';
    // 重置所有輸入框和預覽
    document.getElementById('ls-photo-preview-container').innerHTML = '';
    document.getElementById('ls-photo-desc-input').value = '';
    document.getElementById('ls-text-image-desc-input').value = '';
    document.getElementById('ls-photo-input').value = null;

    // 預設顯示“上傳圖片”模式
    document.getElementById('ls-switch-to-image-mode').click();

    document.getElementById('ls-create-album-modal').classList.add('visible');
}
// ▲▲▲ 替換結束 ▲▲▲


// ▼▼▼ 用這塊新代碼替換舊的 handlePhotoSelection 函數 ▼▼▼
/**
 * 處理用戶選擇照片後的預覽 (單張版)
 */
function handlePhotoSelection(files) {
    const previewContainer = document.getElementById('ls-photo-preview-container');
    previewContainer.innerHTML = '';
    tempUploadedPhotos = [];
    
    const file = files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
        const dataUrl = e.target.result;
        tempUploadedPhotos.push({ url: dataUrl }); // 暫存base64
        
        // 顯示預覽圖
        const previewItem = document.createElement('div');
        previewItem.className = 'ls-photo-preview-item';
        previewItem.innerHTML = `<img src="${dataUrl}">`;
        previewContainer.appendChild(previewItem);
    };
    reader.readAsDataURL(file);
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 用這塊【已修復】的代碼，替換掉你舊的 handleConfirmAlbum 函數 ▼▼▲
/**
 * 用戶確認上傳照片 (這是修復後的版本)
 */
async function handleConfirmAlbum() {
    const chat = state.chats[activeLoversSpaceCharId];
    if (!chat) return;

    // 1. 先判斷當前是哪種模式
    const isImageMode = document.getElementById('ls-image-mode-content').classList.contains('active');
    let newPhoto;

    if (isImageMode) {
        // 2. 如果是“上傳圖片”模式，執行這裡的檢查
        if (tempUploadedPhotos.length === 0) {
            alert("請選擇一張照片！"); // 只有在這種模式下，這個提示才是正確的
            return;
        }
        const description = document.getElementById('ls-photo-desc-input').value.trim();
        if (!description) {
            alert("圖片描述不能為空！");
            return;
        }
        newPhoto = {
            type: 'image',
            url: tempUploadedPhotos[0].url,
            description: description,
            timestamp: Date.now()
        };
    } else {
        // 3. 如果是“使用文字圖”模式，執行這裡的檢查
        const description = document.getElementById('ls-text-image-desc-input').value.trim();
        if (!description) {
            alert("文字圖描述不能為空！");
            return;
        }
        newPhoto = {
            type: 'text_image',
            description: description,
            timestamp: Date.now()
        };
    }

    // 4. 後續的保存和刷新邏輯保持不變
    if (!chat.loversSpaceData.photos) {
        chat.loversSpaceData.photos = [];
    }

    chat.loversSpaceData.photos.push(newPhoto);
    await db.chats.put(chat);
    
    renderLSPhotos(chat.loversSpaceData.photos, chat);
    document.getElementById('ls-create-album-modal').classList.remove('visible');
}
// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 把這一整塊全新的功能函數，黏貼到 init() 函數的上方 ▼▼▼

/**
 * 【全新】刪除情侶空間中的一張照片
 */
async function handleDeleteLSPhoto(timestamp) {
    // 彈出確認框，防止誤刪
    const confirmed = await showCustomConfirm(
        '刪除照片',
        '確定要刪除這張照片嗎？此操作無法恢復。',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const chat = state.chats[activeLoversSpaceCharId];
        if (!chat || !chat.loversSpaceData || !chat.loversSpaceData.photos) return;

        // 從照片陣列中過濾掉要刪除的照片
        chat.loversSpaceData.photos = chat.loversSpaceData.photos.filter(p => p.timestamp !== timestamp);

        // 保存更新後的聊天資料
        await db.chats.put(chat);

        // 重新渲染照片列表，讓刪除效果立刻生效
        renderLSPhotos(chat.loversSpaceData.photos, chat);

        alert('照片已刪除。');
    }
}
// ▲▲▲ 黏貼結束 ▲▲▲
/* ▼▼▼ 把這一整塊全新的功能函數，黏貼到 // ▼▼▼ 【全新】情侶空間功能核心函數 ▼▼▼ 的正下方 ▼▼▼ */

let activeLoveLetter = null; // 用於暫存正在查看或回復的情書

// ▼▼▼ 用這塊【已添加刪除按鈕】的代碼，完整替換掉舊的 renderLSLetters 函數 ▼▼▼
/**
 * 【全新】渲染“情書”列表 (已加入刪除功能)
 */
function renderLSLetters(letters, chat) {
    const listEl = document.getElementById('ls-letters-list');
    listEl.innerHTML = ''; // 先清空
    if (!letters || letters.length === 0) {
        listEl.innerHTML = '<p class="ls-empty-placeholder">還沒有任何情書，點擊右下角“+”寫下第一封吧！</p>';
        return;
    }

    // 從新到舊排序顯示
    [...letters].reverse().forEach(letter => {
        const item = document.createElement('div');
        item.className = 'ls-love-letter-item';
        item.dataset.letterId = letter.id;

        const svgIcon = `
            <svg class="letter-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M4 7.00005L10.2 11.65C11.2667 12.45 12.7333 12.45 13.8 11.65L20 7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <rect x="2" y="5" width="20" height="14" rx="2" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
            </svg>
        `;

        // 【核心修改】在這裡加入了刪除按鈕的HTML
        item.innerHTML = `
            <!-- 這是新增的刪除按鈕 -->
            <button class="ls-letter-delete-btn" title="刪除這封情書">×</button>

            ${svgIcon}
            <div class="letter-info">
                <div class="letter-recipient">
                    <img src="${letter.recipientAvatar}" class="avatar">
                    <span>To: ${letter.recipientName}</span>
                </div>
                <div class="letter-preview">${letter.content.substring(0, 30)}...</div>
            </div>
            <div class="letter-sender">
                <img src="${letter.senderAvatar}" class="avatar">
                <span>From: ${letter.senderName}</span>
            </div>
        `;
        listEl.appendChild(item);
    });
}
// ▲▲▲ 替換結束 ▲▲▲



/**
 * 【全新】打開寫情書/回信的彈窗
 * @param {object | null} replyToLetter - 如果是回信，則傳入被回復的情書對象
 */
function openLoveLetterEditor(replyToLetter = null) {
    const modal = document.getElementById('ls-create-letter-modal');
    const titleEl = document.getElementById('ls-letter-modal-title');
    const recipientInput = document.getElementById('ls-letter-recipient-input');
    const contentInput = document.getElementById('ls-letter-content-input');
    
    const chat = state.chats[activeLoversSpaceCharId];
    
    if (replyToLetter) {
        // 這是回信
        titleEl.textContent = `回信給 ${replyToLetter.senderName}`;
        recipientInput.value = replyToLetter.senderName;
        contentInput.value = ''; // 清空內容
        contentInput.placeholder = `回復 ${replyToLetter.senderName} 的情書...`;
        // 暫存被回復的信，以便發送時知道是回復誰
        modal.dataset.replyingTo = JSON.stringify(replyToLetter);
    } else {
        // 這是寫新信
        titleEl.textContent = `給 ${chat.name} 寫一封信`;
        recipientInput.value = chat.name;
        contentInput.value = '';
        contentInput.placeholder = '在這裡寫下你的心意...';
        // 清除可能存在的回復標記
        delete modal.dataset.replyingTo;
    }
    
    modal.classList.add('visible');
}

/**
 * 【全新】處理用戶點擊“寄出”按鈕的邏輯
 */
async function handlePostLoveLetter() {
    const modal = document.getElementById('ls-create-letter-modal');
    const content = document.getElementById('ls-letter-content-input').value.trim();
    if (!content) {
        alert("情書內容不能為空哦！");
        return;
    }

    const chat = state.chats[activeLoversSpaceCharId];
    const isReply = modal.dataset.replyingTo;
    
    let newLetter;

    if (isReply) {
        // 如果是回信，發信人和收信人資訊要反過來
        const originalLetter = JSON.parse(isReply);
        newLetter = {
            id: 'letter_' + Date.now(),
            senderId: 'user',
            senderName: chat.settings.myNickname || '我',
            senderAvatar: chat.settings.myAvatar,
            recipientName: originalLetter.senderName, // 收信人是原信的發信人
            recipientAvatar: originalLetter.senderAvatar,
            content: content,
            timestamp: Date.now()
        };
    } else {
        // 如果是寫新信
        newLetter = {
            id: 'letter_' + Date.now(),
            senderId: 'user',
            senderName: chat.settings.myNickname || '我',
            senderAvatar: chat.settings.myAvatar,
            recipientName: chat.name, // 收信人是當前角色
            recipientAvatar: chat.settings.aiAvatar,
            content: content,
            timestamp: Date.now()
        };
    }

    // 確保 loveLetters 陣列存在
    if (!chat.loversSpaceData.loveLetters) {
        chat.loversSpaceData.loveLetters = [];
    }
    chat.loversSpaceData.loveLetters.push(newLetter);
    
    await db.chats.put(chat);
    // ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼
// 如果是用戶寫的信，就給AI發一個隱藏的系統通知
if (newLetter.senderId === 'user') {
    const hiddenMessage = {
        role: 'system',
        content: `[系統提示：用戶剛剛在情侶空間給你寫了一封情書，內容是：“${content}”。請你根據人設，使用 'ls_letter' 指令給使用者寫一封回信。]`,
        timestamp: Date.now(),
        isHidden: true // 這個標記能讓消息對你隱藏，但AI能看見
    };
    chat.history.push(hiddenMessage);
    await db.chats.put(chat); // 再次保存，確保隱藏消息被存入
    
    // （可選）如果你希望AI在你發信後立刻回復，可以把下面這行的注釋去掉
    // triggerAiResponse(); 
}
// ▲▲▲ 黏貼結束 ▲▲▲

    renderLSLetters(chat.loversSpaceData.loveLetters, chat);
    modal.classList.remove('visible');
}

// ▼▼▼ 用這塊【使用全新信紙彈窗】的新代碼，替換舊的 showLoveLetterDetail 函數 ▼▼▼
/**
 * 【全新】顯示情書詳情 (信紙樣式版)
 * @param {string} letterId - 要顯示的情書的ID
 */
async function showLoveLetterDetail(letterId) {
    const chat = state.chats[activeLoversSpaceCharId];
    activeLoveLetter = chat.loversSpaceData.loveLetters.find(l => l.id === letterId);
    if (!activeLoveLetter) return;

    // 獲取新的信紙彈窗元素
    const modal = document.getElementById('ls-letter-viewer-modal');
    
    // 填充所有資料
    document.getElementById('ls-viewer-recipient-avatar').src = activeLoveLetter.recipientAvatar;
    document.getElementById('ls-viewer-recipient-name').textContent = activeLoveLetter.recipientName;
    document.getElementById('ls-viewer-body').innerHTML = activeLoveLetter.content.replace(/\n/g, '<br>'); // 正文內容
    document.getElementById('ls-viewer-sender-name').textContent = `Your dearest, ${activeLoveLetter.senderName}`; // 發信人
    document.getElementById('ls-viewer-timestamp').textContent = new Date(activeLoveLetter.timestamp).toLocaleString(); // 時間

    // 顯示彈窗
    modal.classList.add('visible');
}
// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 把這一整塊全新的代碼，黏貼到 // ▲▲▲ 情侶空間功能函數結束 ▲▲▲ 的正上方 ▼▼▼
/* ▼▼▼ 把這一整塊全新的代碼，黏貼到 // ▲▲▲ 情侶空間功能函數結束 ▲▲▲ 的正上方 ▼▼▼ */

/* --- 【全新】情侶空間-情緒日記功能核心函數 --- */

let currentDiaryDate = null; // 用於暫存正在編輯或查看的日記日期

/**
 * 渲染情緒日記的主介面（日曆和心情罐子）
 */
async function renderLSDiaryView(year, month) {
    const viewEl = document.getElementById('ls-diary-view');
    const chat = state.chats[activeLoversSpaceCharId];
    if (!viewEl || !chat) return;

    const diaryData = chat.loversSpaceData.emotionDiaries || {};

    // 渲染日曆
    viewEl.innerHTML = renderCalendar(year, month, diaryData);

    // 渲染心情罐子
    const jarHtml = renderMoodJar(year, month, diaryData);
    viewEl.insertAdjacentHTML('beforeend', jarHtml);
}

/**
 * 【輔助函數】生成日曆的HTML
 */
function renderCalendar(year, month, diaryData) {
    const date = new Date(year, month - 1, 1);
    const firstDay = date.getDay(); // 0-6 (周日-週六)
    const daysInMonth = new Date(year, month, 0).getDate();
    const today = new Date();
    
    let calendarHtml = `
        <div class="ls-calendar-wrapper">
            <div class="ls-calendar-header">
                <button id="ls-prev-month-btn">‹</button>
                <span id="ls-current-month-display">${year}年 ${month}月</span>
                <button id="ls-next-month-btn">›</button>
            </div>
            <div class="ls-calendar-weekdays">
                <div>日</div><div>一</div><div>二</div><div>三</div><div>四</div><div>五</div><div>六</div>
            </div>
            <div class="ls-calendar-grid">
    `;

    // 空白格子
    for (let i = 0; i < firstDay; i++) {
        calendarHtml += '<div class="ls-calendar-day empty"></div>';
    }

    // 日期格子
    for (let day = 1; day <= daysInMonth; day++) {
        const dateStr = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
        const dayData = diaryData[dateStr] || {};
        const isToday = today.getFullYear() === year && today.getMonth() + 1 === month && today.getDate() === day;

        calendarHtml += `
            <div class="ls-calendar-day ${isToday ? 'today' : ''}" data-date="${dateStr}">
                <div class="day-number">${day}</div>
                <div class="mood-emojis">
                    <span class="user-emoji">${dayData.userEmoji || ''}</span>
                    <span class="char-emoji">${dayData.charEmoji || ''}</span>
                </div>
            </div>
        `;
    }
    calendarHtml += '</div></div>';
    return calendarHtml;
}

/**
 * 【輔助函數】生成心情罐子的HTML
 */
function renderMoodJar(year, month, diaryData) {
    let allEmojis = [];
    for (const dateStr in diaryData) {
        if (dateStr.startsWith(`${year}-${String(month).padStart(2, '0')}`)) {
            const dayData = diaryData[dateStr];
            if (dayData.userEmoji) allEmojis.push(dayData.userEmoji);
            if (dayData.charEmoji) allEmojis.push(dayData.charEmoji);
        }
    }
    
    let jarHtml = `
        <div class="ls-mood-jar-wrapper">
            <h3>本月心情罐子</h3>
            <div class="ls-mood-jar">
    `;

    if (allEmojis.length > 0) {
        jarHtml += allEmojis.map(emoji => `<span class="mood-emoji-item">${emoji}</span>`).join('');
    } else {
        jarHtml += '<p style="color: var(--text-secondary); font-size: 13px;">這個月還沒有記錄心情哦</p>';
    }

    jarHtml += '</div></div>';
    return jarHtml;
}

/**
 * 打開日記編輯/查看彈窗
 */
function openDiaryModal(dateStr) {
    currentDiaryDate = dateStr;
    const chat = state.chats[activeLoversSpaceCharId];
    const diaryEntry = chat.loversSpaceData.emotionDiaries?.[dateStr];

    // 如果雙方都有日記，或只有AI有日記，則打開檢視器
    if (diaryEntry && (diaryEntry.userDiary || diaryEntry.charDiary)) {
        openDiaryViewer(dateStr, diaryEntry, chat);
    } else {
        // 否則，打開編輯器
        openDiaryEditor(dateStr, diaryEntry);
    }
}

/**
 * 打開日記編輯器
 */
function openDiaryEditor(dateStr, entryData) {
    const modal = document.getElementById('ls-diary-editor-modal');
    document.getElementById('ls-diary-editor-title').textContent = `記錄 ${dateStr} 的心情`;

    const emojiSelector = document.getElementById('ls-emoji-selector');
    const emojis = ['😊', '😄', '😍', '😢', '😠', '🤔', '😴', '🤢'];
    emojiSelector.innerHTML = emojis.map(e => `<span class="emoji-option" data-emoji="${e}">${e}</span>`).join('');
    
    // 恢復之前的選擇（如果有）
    const contentInput = document.getElementById('ls-diary-content-input');
    if (entryData && entryData.userEmoji) {
        emojiSelector.querySelector(`.emoji-option[data-emoji="${entryData.userEmoji}"]`)?.classList.add('selected');
        contentInput.value = entryData.userDiary || '';
    } else {
        contentInput.value = '';
    }

    modal.classList.add('visible');
}

/**
 * 打開日記檢視器
 */
function openDiaryViewer(dateStr, entryData, chat) {
    const modal = document.getElementById('ls-diary-viewer-modal');
    document.getElementById('ls-diary-viewer-title').textContent = `查看 ${dateStr} 的日記`;
    const bodyEl = document.getElementById('ls-diary-viewer-body');
    bodyEl.innerHTML = '';
    
    // 顯示使用者日記
    if (entryData.userDiary) {
        const userBlock = document.createElement('div');
        userBlock.className = 'ls-diary-entry-block';
        userBlock.innerHTML = `
            <div class="entry-header">
                <span class="mood-emoji">${entryData.userEmoji}</span>
                <span class="author">${chat.settings.myNickname || '我'}的日記</span>
            </div>
            <p class="entry-content">${entryData.userDiary.replace(/\n/g, '<br>')}</p>
        `;
        bodyEl.appendChild(userBlock);
    }

    // 顯示角色日記
    if (entryData.charDiary) {
        const charBlock = document.createElement('div');
        charBlock.className = 'ls-diary-entry-block';
        charBlock.style.borderColor = '#ff8fab'; // 給角色日記一個不同的顏色
        charBlock.innerHTML = `
            <div class="entry-header">
                <span class="mood-emoji">${entryData.charEmoji}</span>
                <span class="author">${chat.name}的日記</span>
            </div>
            <p class="entry-content">${entryData.charDiary.replace(/\n/g, '<br>')}</p>
        `;
        bodyEl.appendChild(charBlock);
    } else {
        // 如果角色還沒寫，給個提示
        bodyEl.innerHTML += `<p style="text-align: center; color: var(--text-secondary);">Ta 還沒寫今天的心情日記哦~</p>`;
    }
    
    modal.classList.add('visible');
}

/**
 * 保存用戶的日記，並觸發AI寫日記和回應
 */
async function handleSaveUserDiary() {
    const selectedEmojiEl = document.querySelector('#ls-emoji-selector .selected');
    const userEmoji = selectedEmojiEl ? selectedEmojiEl.dataset.emoji : null;
    const userDiary = document.getElementById('ls-diary-content-input').value.trim();

    if (!userEmoji) {
        alert("請選擇一個表情代表今天的心情！");
        return;
    }
    if (!userDiary) {
        alert("日記內容不能為空哦！");
        return;
    }
    
    const chat = state.chats[activeLoversSpaceCharId];
    if (!chat.loversSpaceData.emotionDiaries) {
        chat.loversSpaceData.emotionDiaries = {};
    }

    // 更新或創建當天的日記資料
    if (!chat.loversSpaceData.emotionDiaries[currentDiaryDate]) {
        chat.loversSpaceData.emotionDiaries[currentDiaryDate] = {};
    }
    chat.loversSpaceData.emotionDiaries[currentDiaryDate].userEmoji = userEmoji;
    chat.loversSpaceData.emotionDiaries[currentDiaryDate].userDiary = userDiary;
    
    // 關閉彈窗
    document.getElementById('ls-diary-editor-modal').classList.remove('visible');
    // --- 【核心聯動功能開始】 ---

    // 1. 準備一條對使用者可見的消息，告訴對方你寫了日記
    const targetChat = state.chats[activeLoversSpaceCharId];
    if (targetChat) {
        const userNickname = state.qzoneSettings.nickname || '我';
// ▼▼▼ 用這塊【新代碼】替換舊的 notificationMessage 定義 ▼▼▼
const notificationMessage = {
    role: 'user',
    type: 'ls_diary_notification', // 【核心修改1】給它一個獨一無二的類型
    content: { // 【核心修改2】內容變成一個物件，方便攜帶更多資訊
        userEmoji: userEmoji, // 把用戶選擇的表情也帶上
        text: '我剛剛寫了今天的心情日記哦，你也快去看看吧！'
    },
    timestamp: Date.now()
};
        targetChat.history.push(notificationMessage);

        // 2. 創建一條對AI可見的【隱藏指令】，這是整個功能的核心
        const hiddenMessage = {
            role: 'system',
            content: `[系統指令：用戶剛剛在情侶空間寫了今天的日記。
            - 他們的心情是: ${userEmoji}
            - 日記內容是: "${userDiary}"
            你的任務:
            1.  【必須】根據你的人設和今天的聊天記錄，也寫一篇你自己的心情日記，並使用 'ls_diary_entry' 指令發送。
            2.  【必須】在寫完日記後，立刻就使用者今天的日記內容，以你的角色口吻，主動開啟一段新的對話。]`,
            timestamp: Date.now() + 1, // 確保時間戳記在後
            isHidden: true // 這個標記能讓消息對使用者隱藏，但AI能看見
        };
        targetChat.history.push(hiddenMessage);

        // 3. 保存所有更改到資料庫
        await db.chats.put(targetChat);

        // 4. 主動跳轉到單聊介面，並觸發AI回應
        openChat(activeLoversSpaceCharId);
        triggerAiResponse();
    }
    // --- 【核心聯動功能結束】 ---

// ▲▲▲ 新代碼黏貼結束 ▲▲▲

    alert('日記已保存！');
}

/* --- 情緒日記功能函數結束 --- */
/* ▲▲▲ 新增代碼黏貼結束 ▲▲▲ */

/* --- 【全新】情侶空間-情侶提問功能核心函數 --- */

let activeQuestionId = null; // 用於暫存正在回答的問題ID

/**
 * 渲染“情侶提問”列表
 */
function renderLSQuestions(questions, chat) {
    const listEl = document.getElementById('ls-questions-list');
    listEl.innerHTML = '';
    if (!questions || questions.length === 0) {
        listEl.innerHTML = '<p class="ls-empty-placeholder">還沒有人提問，點擊右下角“+”發起第一個提問吧！</p>';
        return;
    }

    [...questions].reverse().forEach(q => {
        const isUserQuestioner = q.questioner === 'user';
        const questionerName = isUserQuestioner ? (chat.settings.myNickname || '我') : chat.name;
        const questionerAvatar = isUserQuestioner ? chat.settings.myAvatar : chat.settings.aiAvatar;

        let answerHtml = '';
        if (q.answerText) {
            const isUserAnswerer = q.answerer === 'user';
            const answererName = isUserAnswerer ? (chat.settings.myNickname || '我') : chat.name;
            const answererAvatar = isUserAnswerer ? chat.settings.myAvatar : chat.settings.aiAvatar;
            answerHtml = `
                <div class="ls-answer-section">
                    <img src="${answererAvatar}" class="qa-avatar">
                    <div class="qa-main">
                        <div class="qa-header">
                            <span class="qa-author">${answererName}的回答</span>
                        </div>
                        <p class="qa-content">${q.answerText.replace(/\n/g, '<br>')}</p>
                    </div>
                </div>
            `;
        } else if (q.answerer === 'user') {
            // 如果輪到用戶回答
            answerHtml = `
                <div class="ls-answer-placeholder">
                    <button class="ls-answer-btn" data-question-id="${q.id}">回答Ta的問題</button>
                </div>
            `;
        } else {
            // 如果輪到AI回答
            answerHtml = `
                <div class="ls-answer-placeholder">
                    <p style="color: var(--text-secondary); font-size: 14px;">等待Ta的回答...</p>
                </div>
            `;
        }

        const card = document.createElement('div');
        card.className = 'ls-question-card';
        
        // ▼▼▼ 核心修改就是在這裡加入了刪除按鈕 ▼▼▼
        card.innerHTML = `
            <button class="ls-question-delete-btn" data-question-id="${q.id}" title="刪除此提問">×</button>

            <div class="ls-question-section">
                <img src="${questionerAvatar}" class="qa-avatar">
                <div class="qa-main">
                    <div class="qa-header">
                        <span class="qa-author">${questionerName}的提問</span>
                        <span class="qa-timestamp">${formatPostTimestamp(q.timestamp)}</span>
                    </div>
                    <p class="qa-content">${q.questionText.replace(/\n/g, '<br>')}</p>
                </div>
            </div>
            ${answerHtml}
        `;
        listEl.appendChild(card);
    });
}


/**
 * 打開提問彈窗
 */
function openQuestionAsker() {
    document.getElementById('ls-question-content-input').value = '';
    document.getElementById('ls-ask-question-modal').classList.add('visible');
}

/**
 * 用戶發佈一個新提問
 */
async function handlePostQuestion() {
    const content = document.getElementById('ls-question-content-input').value.trim();
    if (!content) {
        alert("問題內容不能為空！");
        return;
    }
    const chat = state.chats[activeLoversSpaceCharId];
    const newQuestion = {
        id: 'q_' + Date.now(),
        questioner: 'user',
        questionText: content,
        timestamp: Date.now(),
        answerer: 'char', // 指定由AI來回答
        answerText: null
    };
    
    if (!chat.loversSpaceData.questions) {
        chat.loversSpaceData.questions = [];
    }
    chat.loversSpaceData.questions.push(newQuestion);
    await db.chats.put(chat);
    
    renderLSQuestions(chat.loversSpaceData.questions, chat);
    document.getElementById('ls-ask-question-modal').classList.remove('visible');
    
// ▼▼▼ 在 handlePostQuestion 函數的末尾，黏貼下面這塊新代碼 ▼▼▼
// 創建一條對用戶隱藏，但對AI可見的系統消息
const hiddenMessage = {
    role: 'system',
    content: `[系統提示：用戶在情侶空間向你提了一個問題：“${content}”，問題ID是“${newQuestion.id}”。請使用 'ls_answer_question' 指令來回答。]`,
    timestamp: Date.now(),
    isHidden: true
};
chat.history.push(hiddenMessage);
await db.chats.put(chat);


}

/**
 * 打開回答問題的彈窗
 */
function openAnswerEditor(questionId) {
    const chat = state.chats[activeLoversSpaceCharId];
    const question = chat.loversSpaceData.questions.find(q => q.id === questionId);
    if (!question) return;

    activeQuestionId = questionId;
    document.getElementById('ls-answer-question-text').textContent = question.questionText;
    document.getElementById('ls-answer-content-input').value = '';
    document.getElementById('ls-answer-question-modal').classList.add('visible');
}

/**
 * 用戶提交回答
 */
async function handlePostAnswer() {
    if (!activeQuestionId) return;
    const answerText = document.getElementById('ls-answer-content-input').value.trim();
    if (!answerText) {
        alert("回答內容不能為空！");
        return;
    }
    const chat = state.chats[activeLoversSpaceCharId];
    const question = chat.loversSpaceData.questions.find(q => q.id === activeQuestionId);
    if (question) {
        question.answerer = 'user'; // 明確回答者是用戶
        question.answerText = answerText;
        await db.chats.put(chat);
        // ▼▼▼ 用這塊新代碼替換上面的 ▼▼▼
const hiddenMessage = {
    role: 'system',
    content: `[系統提示：用戶（${chat.settings.myNickname || '我'}）剛剛在情侶空間回答了你之前提出的問題。你的問題是：“${question.questionText}”，用戶的回答是：“${answerText}”。]`,
    timestamp: Date.now(),
    isHidden: true
};
chat.history.push(hiddenMessage);
await db.chats.put(chat);
// ▲▲▲ 替換結束 ▲▲▲
        renderLSQuestions(chat.loversSpaceData.questions, chat);
    }
    document.getElementById('ls-answer-question-modal').classList.remove('visible');
    activeQuestionId = null;
}
/**
 * 【全新】刪除一條情侶提問
 * @param {string} questionId - 要刪除的提問的ID
 */
async function handleDeleteLSQuestion(questionId) {
    // 1. 彈出確認框，防止誤刪
    const confirmed = await showCustomConfirm(
        '刪除提問',
        '確定要刪除這個問題以及對應的回答嗎？此操作無法恢復。',
        { confirmButtonClass: 'btn-danger' }
    );

    // 2. 如果用戶確認刪除
    if (confirmed) {
        const chat = state.chats[activeLoversSpaceCharId];
        if (!chat || !chat.loversSpaceData || !chat.loversSpaceData.questions) return;

        // 3. 從提問陣列中過濾掉要刪除的提問
        chat.loversSpaceData.questions = chat.loversSpaceData.questions.filter(q => q.id !== questionId);

        // 4. 保存更新後的聊天資料
        await db.chats.put(chat);

        // 5. 重新渲染提問列表，讓刪除效果立刻生效
        renderLSQuestions(chat.loversSpaceData.questions, chat);

        alert('提問已刪除。');
    }
}

/* --- 情侶提問功能函數結束 --- */

// ▲▲▲ 黏貼結束 ▲▲▲
// ▼▼▼ 【全新】這裡是情侶空間專屬音樂播放機的所有核心功能函數 ▼▼▼

/**
 * 【總入口】當用戶在情侶空間點擊一首分享的歌曲時觸發
 * @param {object} shareData - 包含歌曲資訊的分享物件
 */
async function openLoversSpaceMusicPlayer(shareData) {
    await showCustomAlert("請稍候...", `正在為《${shareData.title}》尋找播放資源...`);
    
    // 檢查播放清單是否已經有這首歌了
    const existingIndex = lsMusicState.playlist.findIndex(
        song => song.name === shareData.title && song.artist === shareData.artist
    );

    if (existingIndex > -1) {
        // 如果已經存在，直接播放並打開播放機
        playLSSong(existingIndex);
        document.getElementById('ls-music-player-overlay').classList.add('visible');
        return;
    }

    // 如果不存在，開始搜索
    let songData = null;
    const songName = shareData.title;
    const artistName = shareData.artist || '';

    // 策略1：優先用網易雲搜索 (通常結果更准)
    const neteaseResults = await searchNeteaseMusic(songName, artistName);
    if (neteaseResults.length > 0) {
        songData = neteaseResults[0];
    } else {
        // 策略2：如果網易雲找不到，再用QQ音樂搜一次
        const tencentResults = await searchTencentMusic(songName);
        if (tencentResults.length > 0) {
            songData = tencentResults[0];
        }
    }

    if (!songData) {
        await showCustomAlert("播放失敗", `抱歉，在網易雲和QQ音樂都沒能找到《${songName}》的可播放資源。`);
        return;
    }

    // 獲取播放連結
    const apiUrl = songData.source === 'netease' 
        ? `https://api.vkeys.cn/v2/music/netease?id=${songData.id}`
        : `https://api.vkeys.cn/v2/music/tencent?id=${songData.id}`;
    
    const result = await Http_Get(apiUrl);

    if (!result?.data?.url || !(await checkAudioAvailability(result.data.url))) {
        await showCustomAlert("獲取失敗", `找到了《${songName}》，但無法獲取有效的播放連結。`);
        return;
    }

    // 【新增】獲取歌詞
    const lrcContent = await getLyricsForSong(songData.id, songData.source) || "";

    // 創建新的歌曲物件並添加到播放清單
    const newSong = {
        name: songData.name,
        artist: songData.artist,
        src: result.data.url,
        cover: songData.cover,
        lrcContent: lrcContent // <-- 就是新增了這一行！
    };

    lsMusicState.playlist.push(newSong);
    
    // 播放這首新添加的歌曲
    playLSSong(lsMusicState.playlist.length - 1);
    
    // 打開播放機
    document.getElementById('ls-music-player-overlay').classList.add('visible');
}

async function playLSSong(index) {
    if (index < 0 || index >= lsMusicState.playlist.length) return;

    lsMusicState.currentIndex = index;
    const track = lsMusicState.playlist[index];
    const lsAudioPlayer = document.getElementById('ls-audio-player');
    
    // 【新增】解析和渲染歌詞
    track.parsedLyrics = parseLRC(track.lrcContent || ""); // 複用你已有的歌詞解析函數
    track.currentLyricIndex = -1;
    renderLSLyrics(track);

    lsAudioPlayer.src = track.src;
    try {
        await lsAudioPlayer.play();
        lsMusicState.isPlaying = true;
    } catch (error) {
        console.error("情侶空間音樂播放失敗:", error);
        lsMusicState.isPlaying = false;
    }
    
    renderLSMusicPlayerUI();
    renderLSMusicPlaylist(); 
}


/**
 * 切換播放/暫停狀態 (情侶空間版)
 */
function toggleLSMusicPlayPause() {
    const lsAudioPlayer = document.getElementById('ls-audio-player');
    if (lsMusicState.currentIndex === -1 && lsMusicState.playlist.length > 0) {
        // 如果列表有歌但還沒開始播，點擊播放就從第一首開始
        playLSSong(0);
        return;
    }
    
    if (lsAudioPlayer.paused) {
        lsAudioPlayer.play();
        lsMusicState.isPlaying = true;
    } else {
        lsAudioPlayer.pause();
        lsMusicState.isPlaying = false;
    }
    renderLSMusicPlayerUI();
}

/**
 * 播放下一首 (情侶空間版)
 */
function playNextLSSong() {
    if (lsMusicState.playlist.length === 0) return;
    const newIndex = (lsMusicState.currentIndex + 1) % lsMusicState.playlist.length;
    playLSSong(newIndex);
}

/**
 * 播放上一首 (情侶空間版)
 */
function playPrevLSSong() {
    if (lsMusicState.playlist.length === 0) return;
    const newIndex = (lsMusicState.currentIndex - 1 + lsMusicState.playlist.length) % lsMusicState.playlist.length;
    playLSSong(newIndex);
}

/**
 * 更新播放機介面 (情侶空間版)
 */
function renderLSMusicPlayerUI() {
    const track = lsMusicState.playlist[lsMusicState.currentIndex];

    if (track) {
        document.getElementById('ls-album-cover').src = track.cover;
        document.getElementById('ls-song-title').textContent = track.name;
        document.getElementById('ls-artist').textContent = track.artist;
    } else {
        document.getElementById('ls-album-cover').src = 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
        document.getElementById('ls-song-title').textContent = '暫無歌曲';
        document.getElementById('ls-artist').textContent = '...';
    }

    document.getElementById('ls-play-pause-btn').textContent = lsMusicState.isPlaying ? '❚❚' : '▶';
}

/**
 * 更新進度條 (情侶空間版)
 */
function updateLSProgressBar() {
    const lsAudioPlayer = document.getElementById('ls-audio-player');
    const currentTimeEl = document.getElementById('ls-current-time');
    const totalTimeEl = document.getElementById('ls-total-time');
    const progressFillEl = document.getElementById('ls-progress-fill');

    if (!lsAudioPlayer.duration) {
        currentTimeEl.textContent = "0:00";
        totalTimeEl.textContent = "0:00";
        progressFillEl.style.width = '0%';
        return;
    }
    
    const progressPercent = (lsAudioPlayer.currentTime / lsAudioPlayer.duration) * 100;
    progressFillEl.style.width = `${progressPercent}%`;
    currentTimeEl.textContent = formatMusicTime(lsAudioPlayer.currentTime);
    totalTimeEl.textContent = formatMusicTime(lsAudioPlayer.duration);
    updateLSCurrentLyric(lsAudioPlayer.currentTime);
}

/**
 * 渲染播放清單 (情侶空間版)
 */
function renderLSMusicPlaylist() {
    const playlistBody = document.getElementById('ls-playlist-body');
    playlistBody.innerHTML = '';
    
    if (lsMusicState.playlist.length === 0) {
        playlistBody.innerHTML = '<p style="text-align:center; padding: 20px; color: #888;">播放清單是空的</p>';
        return;
    }

    lsMusicState.playlist.forEach((track, index) => {
        const item = document.createElement('div');
        item.className = 'playlist-item';
        if (index === lsMusicState.currentIndex) {
            item.classList.add('playing');
        }
        item.innerHTML = `
            <div class="playlist-item-info">
                <div class="title">${track.name}</div>
                <div class="artist">${track.artist}</div>
            </div>
            <div class="playlist-item-actions">
                <span class="playlist-action-btn delete-track-btn" data-index="${index}">×</span>
            </div>
        `;
        item.querySelector('.playlist-item-info').addEventListener('click', () => playLSSong(index));
        playlistBody.appendChild(item);
    });
}
// ▼▼▼ 在 clearLSMusicPlaylist() 函數的上方，黏貼這一整塊新代碼 ▼▼▼

/**
 * 【全新】渲染歌詞列表 (情侶空間版)
 */
function renderLSLyrics(track) {
    const lyricsList = document.getElementById('ls-lyrics-list');
    lyricsList.innerHTML = '';
    if (!track.parsedLyrics || track.parsedLyrics.length === 0) {
        lyricsList.innerHTML = '<div class="lyric-line active">♪ 暫無歌詞 ♪</div>';
        return;
    }
    track.parsedLyrics.forEach((line, index) => {
        const lineEl = document.createElement('div');
        lineEl.className = 'lyric-line';
        lineEl.textContent = line.text;
        lineEl.dataset.index = index;
        lyricsList.appendChild(lineEl);
    });
    lyricsList.style.transform = `translateY(45%)`; // 初始位置
}

/**
 * 【全新】更新當前高亮的歌詞 (情侶空間版)
 */
function updateLSCurrentLyric(currentTime) {
    const track = lsMusicState.playlist[lsMusicState.currentIndex];
    if (!track || !track.parsedLyrics || track.parsedLyrics.length === 0) return;

    let newLyricIndex = -1;
    for (let i = 0; i < track.parsedLyrics.length; i++) {
        if (currentTime >= track.parsedLyrics[i].time) {
            newLyricIndex = i;
        } else {
            break;
        }
    }
    
    if (newLyricIndex !== track.currentLyricIndex) {
        track.currentLyricIndex = newLyricIndex;
        
        const lyricsList = document.getElementById('ls-lyrics-list');
        const container = document.getElementById('ls-lyrics-container');
        
        lyricsList.querySelectorAll('.lyric-line').forEach(line => line.classList.remove('active'));
        
        if (newLyricIndex > -1) {
            const activeLine = lyricsList.querySelector(`.lyric-line[data-index="${newLyricIndex}"]`);
            if (activeLine) {
                activeLine.classList.add('active');
                // 計算滾動偏移量，讓高亮行垂直居中
                const offset = (container.offsetHeight / 2) - activeLine.offsetTop - (activeLine.offsetHeight / 2);
                lyricsList.style.transform = `translateY(${offset}px)`;
            }
        }
    }
}

// ▲▲▲ 新代碼黏貼結束 ▲▲▲

/**
 * 清空播放清單 (情侶空間版)
 */
function clearLSMusicPlaylist() {
    const lsAudioPlayer = document.getElementById('ls-audio-player');
    lsAudioPlayer.pause();
    lsAudioPlayer.src = '';

    lsMusicState.playlist = [];
    lsMusicState.currentIndex = -1;
    lsMusicState.isPlaying = false;
    
    renderLSMusicPlayerUI();
    renderLSMusicPlaylist();
}

// ▲▲▲ 核心功能函數黏貼結束 ▲▲▲
// ▼▼▼ 把這一整塊全新的代碼，黏貼到 init() 函數的【正上方】 ▼▼▼

/* --- 【全新】情侶空間-情侶番茄鐘功能核心函數 --- */

/**
 * 打開番茄鐘主頁並渲染歷史記錄
 */
async function openPomodoroScreen() {
    if (!activeLoversSpaceCharId) return;
    await renderPomodoroHistory(activeLoversSpaceCharId);
    
    // 確保顯示的是主頁，而不是計時器介面
    document.getElementById('ls-pomodoro-home').style.display = 'flex';
    document.getElementById('ls-pomodoro-timer-active').style.display = 'none';
}

/**
 * 渲染指定角色的番茄鐘歷史記錄
 * @param {string} charId - 角色ID
 */
async function renderPomodoroHistory(charId) {
    const listEl = document.getElementById('ls-pomodoro-history-list');
    listEl.innerHTML = '';
    const sessions = await db.pomodoroSessions.where('chatId').equals(charId).reverse().sortBy('startTime');
    
    if (sessions.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); font-size: 14px;">還沒有專注記錄哦</p>';
        return;
    }

    sessions.forEach(session => {
        const item = document.createElement('div');
        item.className = 'pomodoro-history-item';
        item.dataset.sessionId = session.id;
        item.innerHTML = `
            <div class="task">${session.task}</div>
            <div class="meta">
                ${new Date(session.startTime).toLocaleString()} | 專注了 ${Math.round(session.duration / 60)} 分鐘
            </div>
        `;
        item.addEventListener('click', () => showPomodoroHistoryDetail(session.id));
        listEl.appendChild(item);
    });
}

/**
 * 顯示指定歷史記錄的聊天詳情
 * @param {number} sessionId - 記錄的ID
 */
async function showPomodoroHistoryDetail(sessionId) {
    const session = await db.pomodoroSessions.get(sessionId);
    if (!session) return;
    
    const modal = document.getElementById('ls-pomodoro-history-viewer-modal');
    const titleEl = document.getElementById('pomodoro-history-viewer-title');
    const contentEl = document.getElementById('pomodoro-history-viewer-content');
    
    titleEl.textContent = `“${session.task}”的專注記錄`;
    contentEl.innerHTML = '';

    if (session.log && session.log.length > 0) {
        session.log.forEach(logEntry => {
            const bubble = document.createElement('div');
            bubble.className = 'pomodoro-log-bubble';
            bubble.textContent = logEntry.content;
            contentEl.appendChild(bubble);
        });
    } else {
        contentEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">這次專注期間沒有聊天記錄哦。</p>';
    }
    
    modal.classList.add('visible');
}

// ▼▼▼ 用這個新函數替換舊的 openPomodoroSetup ▼▼▼
function openPomodoroSetup() {
    document.getElementById('pomodoro-task-input').value = '';
    document.getElementById('pomodoro-duration-input').value = '25';
    document.getElementById('pomodoro-talk-interval-input').value = '5';
    document.getElementById('pomodoro-bg-url-input').value = '';
    
    // 核心新增：每次打開時，清空上一次本地上傳的臨時資料
    pomodoroState.tempBgDataUrl = null; 

    document.getElementById('ls-pomodoro-setup-modal').classList.add('visible');
}
// ▲▲▲ 替換結束 ▲▲▲


// ▼▼▼ 用這個【支持正/倒計時】的新版本，替換舊的 startPomodoroSession 函數 ▼▼▼
async function startPomodoroSession() {
    const task = document.getElementById('pomodoro-task-input').value.trim();
    // 1. 獲取使用者選擇的計時模式
    const timerType = document.querySelector('input[name="pomodoro-mode"]:checked').value;
    const durationMinutes = parseInt(document.getElementById('pomodoro-duration-input').value);
    const talkIntervalMinutes = parseInt(document.getElementById('pomodoro-talk-interval-input').value);
    const bgUrl = pomodoroState.tempBgDataUrl || document.getElementById('pomodoro-bg-url-input').value.trim();

    if (!task) {
        alert("請輸入一個專注任務！");
        return;
    }
    // 2. 如果是倒計時模式，才需要檢查時長是否有效
    if (timerType === 'countdown' && (isNaN(durationMinutes) || durationMinutes < 1)) {
        alert("倒計時模式下，請輸入有效的專注時長！");
        return;
    }

    const chat = state.chats[activeLoversSpaceCharId];
    // 3. 根據模式，設置總時長（正計時模式總時長為0，因為它會一直增加）
    const durationSeconds = timerType === 'countdown' ? durationMinutes * 60 : 0; 
    
    pomodoroState.currentSession = {
        chatId: activeLoversSpaceCharId,
        task: task,
        duration: durationSeconds,
        timerType: timerType, // 4. 把計時模式也保存到會話記錄裡
        startTime: Date.now(),
        log: []
    };
    
    const timerView = document.getElementById('ls-pomodoro-timer-active');
    document.getElementById('ls-pomodoro-home').style.display = 'none';
    timerView.style.display = 'flex';
    
    if (bgUrl) {
        timerView.style.backgroundImage = `url(${bgUrl})`;
    } else {
        timerView.style.backgroundImage = `url(${chat.settings.aiAvatar})`;
    }
    
    document.getElementById('pomodoro-char-avatar').src = chat.settings.aiAvatar;
    document.getElementById('pomodoro-current-task').textContent = task;
    
    // 5. 根據模式，設置計時器的初始值
    let timeTracker = timerType === 'countdown' ? durationSeconds : 0;
    updatePomodoroTimerDisplay(timeTracker);

    pomodoroState.timerId = setInterval(() => {
        // 6. 【核心修改】根據模式決定是增加還是減少時間
        if (timerType === 'countdown') {
            timeTracker--;
            if (timeTracker <= 0) {
                updatePomodoroTimerDisplay(0); // 確保顯示00:00
                endPomodoroSession(true); // 倒計時結束
            }
        } else { // 'countup'
            timeTracker++;
        }
        updatePomodoroTimerDisplay(timeTracker);
    }, 1000);
    if (talkIntervalMinutes > 0) {
        pomodoroState.periodicTalkTimerId = setInterval(() => {
            // 【核心修改】現在它會調用API來生成話語
            triggerPomodoroAIResponse("periodic_encouragement");
        }, talkIntervalMinutes * 60 * 1000);
    }
    pomodoroState.isActive = true;
    document.getElementById('ls-pomodoro-setup-modal').classList.remove('visible');
    
    const hiddenMessage = {
        role: 'system',
        content: `[系統指令：用戶剛剛和你一起開始了一個番茄鐘專注任務：“${task}”，時長為${durationMinutes}分鐘。在專注期間，你可以通過 "pomodoro_talk" 指令來鼓勵使用者。]`,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(hiddenMessage);
    await db.chats.put(chat);
}
// ▲▲▲ 替換結束 ▲▲▲



/**
 * 更新番茄鐘的倒計時顯示
 * @param {number} secondsLeft - 剩餘秒數
 */
function updatePomodoroTimerDisplay(secondsLeft) {
    const minutes = Math.floor(secondsLeft / 60);
    const seconds = secondsLeft % 60;
    document.getElementById('pomodoro-time').textContent = 
        `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
}

// ▼▼▼ 用這個【已修復時長記錄】的新版本，替換舊的 endPomodoroSession 函數 ▼▼▼
async function endPomodoroSession(isCompleted = false) {
    if (!pomodoroState.isActive) return;

    clearInterval(pomodoroState.timerId);
    clearInterval(pomodoroState.periodicTalkTimerId);

    // 【核心修改】在保存前，根據計時模式重新計算並更新最終的專注時長
    if (pomodoroState.currentSession.timerType === 'countup') {
        // 對於正計時，時長是結束時間減去開始時間
        pomodoroState.currentSession.duration = Math.floor((Date.now() - pomodoroState.currentSession.startTime) / 1000);
    }
    
    pomodoroState.currentSession.endTime = Date.now();
    await db.pomodoroSessions.add(pomodoroState.currentSession);
    
    document.getElementById('ls-pomodoro-timer-active').style.display = 'none';
    document.getElementById('ls-pomodoro-home').style.display = 'flex';
    await renderPomodoroHistory(activeLoversSpaceCharId);

    pomodoroState = { isActive: false, timerId: null, periodicTalkTimerId: null, currentSession: null };

    const chat = state.chats[activeLoversSpaceCharId];
    const endReason = isCompleted ? "時間到了，任務已完成" : "被用戶手動中斷";
    const hiddenMessage = {
        role: 'system',
        content: `[系統指令：番茄鐘專注任務已結束。結束原因：${endReason}。]`,
        timestamp: Date.now(),
        isHidden: true
    };
    chat.history.push(hiddenMessage);
    await db.chats.put(chat);

    if (isCompleted) {
        showCustomAlert("專注完成！", "恭喜你完成了一次專注時光，休息一下吧！");
    } else {
        showCustomAlert("專注結束", "你中斷了本次專注。");
    }
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 【功能增強版】觸發番茄鐘期間的AI互動 (已加入用戶人設並增加回復長度)
 * @param {string} triggerType - 觸發類型, 'user_click' 或 'periodic_encouragement'
 */
async function triggerPomodoroAIResponse(triggerType) {
    if (!pomodoroState.isActive || !activeLoversSpaceCharId) return;

    const chat = state.chats[activeLoversSpaceCharId];
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        console.warn("番茄鐘AI互動失敗：API未配置。");
        return;
    }

    // --- 【核心修改1：加入了用戶人設】 ---
    const elapsedSeconds = Math.floor((Date.now() - pomodoroState.currentSession.startTime) / 1000);
    const elapsedMinutes = Math.floor(elapsedSeconds / 60);
    const timeContext = `用戶已經持續專注了 ${elapsedMinutes} 分鐘。`;
    const triggerReason = triggerType === 'user_click' ? '用戶剛剛點擊了你的頭像，似乎需要一些鼓勵。' : '到了你主動鼓勵用戶的時間。';

    const systemPrompt = `
# 任務
你正在和用戶一起進行番茄鐘專注。
- 你們正在進行的任務是: "${pomodoroState.currentSession.task}"
- ${timeContext}
- 觸發本次對話的原因是: ${triggerReason}
- 你的角色人設: ${chat.settings.aiPersona}
- 你的聊天物件(使用者)的人設: ${chat.settings.myPersona}

# 核心規則
1.  **保持專注**: 你的回復要更豐富、更有內容，大約50字左右，目的是説明使用者繼續專注於任務，而不是閒聊。
2.  **格式鐵律**: 你的回復【必須且只能】是一個嚴格的JSON物件，格式如下: \`{"type": "pomodoro_talk", "content": "你的鼓勵語..."}\`

現在，請生成你的鼓勵語。`;

    const userMessage = { 
        role: 'user', 
        content: `請根據你和我的角色人設，對我正在進行的“${pomodoroState.currentSession.task}”任務，說一段鼓勵的話。` 
    };

    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        
        let requestBody;
        let requestUrl = `${proxyUrl}/v1/chat/completions`;
        let requestHeaders = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${getRandomValue(apiKey)}`
        };

        if (isGemini) {
            requestUrl = `${GEMINI_API_URL}/${model}:generateContent?key=${getRandomValue(apiKey)}`;
            requestHeaders = {'Content-Type': 'application/json'};
            requestBody = {
                contents: [userMessage],
                generationConfig: {
                    temperature: 0.9,
                    "response_mime_type": "application/json", 
                },
                "systemInstruction": {
                    "parts": [{"text": systemPrompt}]
                }
            };
        } else {
            requestBody = {
                model: model,
                messages: [
                    { role: 'system', content: systemPrompt },
                    userMessage
                ],
                temperature: 0.9,
                response_format: { type: "json_object" }
            };
        }

        const response = await fetch(requestUrl, {
            method: 'POST',
            headers: requestHeaders,
            body: JSON.stringify(requestBody)
        });
        
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`API請求失敗: ${response.status} - ${errorText}`);
        }

        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content)
            .replace(/^```json\s*|```$/g, '').trim();
        const responseObj = JSON.parse(rawContent);

        if (responseObj.type === 'pomodoro_talk' && responseObj.content) {
            const logEntry = { timestamp: Date.now(), content: responseObj.content };
            pomodoroState.currentSession.log.push(logEntry);
            
            const logEl = document.getElementById('pomodoro-char-log');
            logEl.textContent = responseObj.content;
            logEl.classList.add('visible');
            setTimeout(() => {
                logEl.classList.remove('visible');
            }, 4000);
        }
    } catch (error) {
        console.error("番茄鐘AI互動失敗:", error);
        const logEl = document.getElementById('pomodoro-char-log');
        logEl.textContent = `[錯誤: API調用失敗，請檢查F12控制台]`;
        logEl.classList.add('visible');
        setTimeout(() => {
            logEl.classList.remove('visible');
        }, 10000);
    }
}
// ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼
/**
 * 【全新】發送情侶空間邀請
 * @param {string} targetChatId - 被邀請的角色ID
 */
async function sendLoversSpaceInvitation(targetChatId) {
    const chat = state.chats[targetChatId];
    if (!chat) return;

    const myNickname = state.qzoneSettings.nickname || '我';
    
    // 1. 創建對使用者可見的“邀請卡片”消息
    const visibleMessage = {
        role: 'user',
        senderName: myNickname,
        type: 'lovers_space_invitation',
        content: `${myNickname} 對 ${chat.name} 發送了一個情侶空間邀請`, // <-- 就是在這裡新增了這一行！
        timestamp: Date.now(),
        status: 'pending' // 狀態：pending, accepted, rejected
    };
    chat.history.push(visibleMessage);

    // 2. 創建對AI可見的“隱藏指令”消息
    const hiddenMessage = {
        role: 'system',
        content: `[系統指令：用戶剛剛向你發起了“開啟情侶空間”的邀請。請你根據人設，決定是否同意，並使用 'lovers_space_response' 指令回應。]`,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    chat.history.push(hiddenMessage);
    
    // 3. 保存並觸發AI回應
    await db.chats.put(chat);
    triggerAiResponse();
}
// ▲▲▲ 黏貼結束 ▲▲▲
// ▼▼▼ 在 init() 的【正上方】黏貼下面這一整塊新代碼 ▼▼▼

/**
 * 【全新】處理用戶對情侶空間邀請的回應
 * @param {number} timestamp - 被回應的邀請消息的時間戳記
 * @param {string} choice - 用戶的選擇, 'accepted' 或 'rejected'
 */
async function handleLoversSpaceResponse(timestamp, choice) {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    const invitationMsg = chat.history.find(m => m.timestamp === timestamp);
    if (!invitationMsg || invitationMsg.status !== 'pending') return;

    // 1. 更新原始邀請卡片的狀態
    invitationMsg.status = choice;

    // 2. 根據使用者的選擇執行操作
    if (choice === 'accepted') {
        // 如果同意，就為這個角色創建情侶空間資料
        chat.loversSpaceData = {
            background: 'https://i.postimg.cc/k495F4W5/profile-banner.jpg',
            relationshipStartDate: null,
            moments: [],
            albums: [],
            loveLetters: [],
            shares: [],
            questions: [],
        };
        
        // 創建一條對使用者可見的系統通知
        const systemNotice = {
            role: 'system',
            type: 'pat_message',
            content: `[系統：你和“${chat.name}”的情侶空間已成功開啟！]`,
            timestamp: Date.now()
        };
        chat.history.push(systemNotice);
    }
    
    // 3. 創建一條對用戶隱藏，但對AI可見的系統指令，告訴AI你的決定
    const hiddenMessage = {
        role: 'system',
        content: `[系統指令：用戶${choice === 'accepted' ? '同意了' : '拒絕了'}你開啟情侶空間的邀請。]`,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    // 4. 保存所有更改到資料庫
    await db.chats.put(chat);
    
    // 5. 刷新聊天介面，並觸發AI的回應
    renderChatInterface(state.activeChatId);
    triggerAiResponse();
}

/**
 * 【全新】應用主螢幕圖示和小元件的文字顏色
 * @param {string} color - 顏色代碼, e.g., '#FFFFFF'
 */
function applyHomeIconWidgetTextColor(color) {
    const phoneScreen = document.getElementById('phone-screen');
    if (phoneScreen && color) {
        // 使用新的CSS變數名
        phoneScreen.style.setProperty('--home-icon-widget-text-color', color);
    }
}
/**
 * 【新增輔助函數1】將時長字串（如“2.5小時”, "30m"）解析為分鐘數
 * @param {string} durationString - 時長描述文本
 * @returns {number} - 對應的分鐘數
 */
function parseDurationToMinutes(durationString) {
    if (!durationString || typeof durationString !== 'string') return 0;
    
    const text = durationString.toLowerCase();
    const num = parseFloat(text.match(/(\d+(\.\d+)?)/)?.[0]) || 0;

    if (text.includes('小時') || text.includes('h')) {
        return num * 60;
    }
    if (text.includes('分鐘') || text.includes('m')) {
        return num;
    }
    // 如果沒有單位，但數值大於等於10，我們猜測是分鐘
    if (num >= 10) {
        return num;
    }
    // 其他情況（如數值很小且無單位），猜測是小時
    return num * 60;
}

/**
 * 【新增輔助函數2】將總分鐘數格式化為 "X小時Y分鐘" 的字串
 * @param {number} totalMinutes - 總分鐘數
 * @returns {string} - 格式化後的時長字串
 */
function formatMinutesToDuration(totalMinutes) {
    if (totalMinutes < 1) return '不到1分鐘';
    
    const hours = Math.floor(totalMinutes / 60);
    const minutes = Math.round(totalMinutes % 60);

    if (hours > 0 && minutes > 0) {
        return `${hours}小時${minutes}分鐘`;
    } else if (hours > 0) {
        return `${hours}小時`;
    } else {
        return `${minutes}分鐘`;
    }
}
// ▼▼▼ 【全新】圈子/小組分類篩選功能核心函數 ▼▼▼

// ▼▼▼ 用這塊【已修復】的代碼，完整替換你舊的 openForumFilterModal 函數 ▼▼▼
/**
 * 【總入口】打開分類篩選模態框 (V3 - 已分離小組和帖子的分類)
 * @param {'global' | 'group'} type - 篩選類型：'global'為主頁篩選小組，'group'為小組內篩選帖子
 * @param {number|null} id - 如果是小組內篩選，則為小組的ID
 */
async function openForumFilterModal(type, id = null) {
    currentFilterContext = { type, id };
    const modal = document.getElementById('forum-filter-modal');
    const listEl = document.getElementById('forum-filter-category-list');
    listEl.innerHTML = '';

    // --- ▼▼▼ 核心修正：根據上下文，從不同的地方收集分類 ▼▼▼ ---
    let availableCategories = new Set(); // 使用Set來自動去重

    try {
        if (type === 'global') {
            // 如果是在“圈子”主頁，我們只關心【小組】的分類
            console.log("正在為小組列表收集分類...");
            const allGroups = await db.forumGroups.toArray();
            allGroups.forEach(group => {
                if (group.categories) {
                    group.categories.forEach(cat => availableCategories.add(cat));
                }
            });
        } else if (type === 'group' && id) {
            // 如果是在具體的“小組”頁面，我們只關心該小組下【帖子】的分類
            console.log(`正在為小組 ID: ${id} 的帖子列表收集分類...`);
            const postsInGroup = await db.forumPosts.where('groupId').equals(id).toArray();
            postsInGroup.forEach(post => {
                if (post.categories) {
                    post.categories.forEach(cat => availableCategories.add(cat));
                }
            });
        }
    } catch (error) {
        console.error("收集分類標籤時出錯:", error);
    }
    // --- ▲▲▲ 修復結束 ▲▲▲ ---

    const categoryArray = Array.from(availableCategories).sort(); // 轉換為陣列並排序

    if (categoryArray.length === 0) {
        listEl.innerHTML = '<p style="color: var(--text-secondary); padding: 20px;">當前沒有任何可用的分類標籤。</p>';
    } else {
        const activeFilters = type === 'global' ? activeForumFilters.global : (activeForumFilters.group[id] || []);
        
        categoryArray.forEach((catName, index) => {
            const isChecked = activeFilters.includes(catName);
            const label = document.createElement('label');
            const inputId = `filter-cat-${type}-${index}`; // 創建唯一的ID
            label.setAttribute('for', inputId);
            label.innerHTML = `
                <input type="checkbox" id="${inputId}" value="${catName}" ${isChecked ? 'checked' : ''}>
                <span>${catName}</span>
            `;
            listEl.appendChild(label);
        });
    }
    
    modal.classList.add('visible');
}
// ▲▲▲ 替換結束 ▲▲▲


/**
 * 應用篩選條件並刷新列表
 */
async function applyForumFilter() {
    const { type, id } = currentFilterContext;
    const selectedCategories = Array.from(document.querySelectorAll('#forum-filter-category-list input:checked')).map(cb => cb.value);

    const filterBtnId = type === 'global' ? 'forum-filter-btn' : 'group-filter-btn';
    const filterBtn = document.getElementById(filterBtnId);

    if (type === 'global') {
        activeForumFilters.global = selectedCategories;
        await renderForumScreen();
    } else if (type === 'group' && id) {
        if (!activeForumFilters.group[id]) activeForumFilters.group[id] = [];
        activeForumFilters.group[id] = selectedCategories;
        await renderGroupPosts(id);
    }
    
    // 根據是否應用了篩選，更新圖示狀態
    if (selectedCategories.length > 0) {
        filterBtn.classList.add('active');
    } else {
        filterBtn.classList.remove('active');
    }

    document.getElementById('forum-filter-modal').classList.remove('visible');
}

// ▲▲▲ 新增函數結束 ▲▲▲
// ▼▼▼ 【全新】這裡是狼人殺遊戲的所有核心功能函數 ▼▼▼

/**
 * 【狼人殺】打開遊戲設置介面
 */
async function openWerewolfSetup() {
    showScreen('werewolf-setup-screen');
    const selectionEl = document.getElementById('werewolf-player-selection');
    selectionEl.innerHTML = '<p>正在載入角色列表...</p>';

    const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    const allNpcs = Object.values(state.chats).flatMap(chat => (chat.npcLibrary || []).map(npc => ({...npc, owner: chat.name})));

    let playerOptions = [
        ...singleChats.map(c => ({ id: c.id, name: c.name, avatar: c.settings.aiAvatar, type: '角色' })),
        ...allNpcs.map(n => ({ id: n.id, name: n.name, avatar: n.avatar, type: `NPC (${n.owner})` }))
    ];

    selectionEl.innerHTML = '';
    playerOptions.forEach(player => {
        const item = document.createElement('div');
        item.className = 'player-selection-item';
        item.innerHTML = `
            <input type="checkbox" class="werewolf-player-checkbox" value="${player.id}">
            <img src="${player.avatar || defaultAvatar}" alt="${player.name}">
            <span class="name">${player.name}</span>
            <span class="type-tag">${player.type}</span>
        `;
        selectionEl.appendChild(item);
    });
}

/**
 * 【狼人殺】開始遊戲的核心邏輯
 */
async function startWerewolfGame() {
    const countSelect = document.getElementById('werewolf-player-count');
    const totalPlayers = parseInt(countSelect.value);
    
    const selectedCheckboxes = document.querySelectorAll('.werewolf-player-checkbox:checked');
    // 邀請的AI/NPC數量必須是總人數-1（因為User是必須加入的）
    if (selectedCheckboxes.length !== totalPlayers - 1) {
        alert(`請選擇 ${totalPlayers - 1} 位AI或NPC玩家！`);
        return;
    }

    // --- 1. 重置並初始化遊戲狀態 ---
    werewolfGameState = {
        isActive: true,
        players: [],
        roles: {},
        gamePhase: 'start',
        dayNumber: 0,
        gameLog: [],
        turnIndex: 0,
        votes: {},
        seerLastNightResult: null,
        witchPotions: { save: 1, poison: 1 },
        hunterTarget: null,
        lastNightKilled: [],
        waitingFor: null,
        gameConfig: { totalPlayers }
    };

    // --- 2. 收集玩家資訊 ---
    // 添加User
    werewolfGameState.players.push({
        id: 'user',
        name: state.qzoneSettings.nickname || '我',
        avatar: state.qzoneSettings.avatar || defaultAvatar,
        isAlive: true,
        isUser: true // 標記為真實使用者
    });

    // 添加被邀請的AI和NPC
    selectedCheckboxes.forEach(checkbox => {
        const playerId = checkbox.value;
        const chat = Object.values(state.chats).find(c => c.id === playerId);
        if (chat) { // 是主要角色
            werewolfGameState.players.push({
                id: chat.id,
                name: chat.name,
                avatar: chat.settings.aiAvatar,
                persona: chat.settings.aiPersona,
                isAlive: true,
                isUser: false
            });
        } else { // 是NPC
            for (const c of Object.values(state.chats)) {
                const npc = (c.npcLibrary || []).find(n => n.id === playerId);
                if (npc) {
                    werewolfGameState.players.push({
                        id: npc.id,
                        name: npc.name,
                        avatar: npc.avatar,
                        persona: npc.persona,
                        isAlive: true,
                        isUser: false
                    });
                    break;
                }
            }
        }
    });

    // 打亂玩家順序（座位順序）
    werewolfGameState.players.sort(() => Math.random() - 0.5);

    // --- 3. 根據人數分配角色 ---
    const roleConfigs = {
        6: { wolf: 2, villager: 2, seer: 1, guard: 1 },
        9: { wolf: 3, villager: 3, seer: 1, witch: 1, hunter: 1 },
        12: { wolf: 4, villager: 4, seer: 1, witch: 1, hunter: 1, idiot: 1 }
    };
    // ▼▼▼ 【核心Bug修復】用這塊代碼替換上面的錯誤代碼 ▼▼▼
    const rolesToAssign = [];
    const config = roleConfigs[totalPlayers];
    werewolfGameState.roles = config; // 將角色配置存入遊戲狀態
    for (const role in config) {
        for (let i = 0; i < config[role]; i++) { // 修正：config[i] -> config[role]
            rolesToAssign.push(role);
        }
    }
    // ▲▲▲ 修復結束 ▲▲▲
    rolesToAssign.sort(() => Math.random() - 0.5); // 打亂角色

    werewolfGameState.players.forEach((player, index) => {
        player.role = rolesToAssign[index];
    });
    // ▼▼▼ 在這裡添加下面的新代碼 ▼▼▼
    // ▼▼▼ 第1處修改（添加翻譯）▼▼▼
    const roleNameMap = {
        wolf: '狼人',
        villager: '平民',
        seer: '預言家',
        witch: '女巫',
        hunter: '獵人',
        guard: '守衛',
        idiot: '白癡'
    };

    // 彈窗告知用戶身份
    const userPlayer = werewolfGameState.players.find(p => p.isUser);
    if (userPlayer) {
        const myRoleName = roleNameMap[userPlayer.role] || userPlayer.role;
        await showCustomAlert("你的身份", `你在本局遊戲中的身份是：【${myRoleName}】`);
    }
    // ▲▲▲ 修改結束 ▲▲▲
    // --- 4. 切換到遊戲介面並開始遊戲迴圈 ---
    showScreen('werewolf-game-screen');
    await processGameTurn();
}

// ▼▼▼ 用這【一整塊】全新的遊戲引擎代碼，替換舊的 processGameTurn 函數 ▼▼▼
/**
 * 【狼人殺 V2】遊戲主迴圈/引擎
 */
async function processGameTurn() {
    if (!werewolfGameState.isActive) return;

    renderWerewolfGameScreen();
    
    switch (werewolfGameState.gamePhase) {
        case 'start':
            logToWerewolfGame('遊戲開始，正在分配身份...');
            const roleNameMapForLog = {
                wolf: '狼人', villager: '平民', seer: '預言家',
                witch: '女巫', hunter: '獵人', guard: '守衛', idiot: '白癡'
            };
            const configText = Object.entries(werewolfGameState.roles)
                .map(([role, count]) => `${roleNameMapForLog[role] || role}x${count}`)
                .join(', ');
            logToWerewolfGame(`本局配置: ${configText}`);
            werewolfGameState.gamePhase = 'night_start';
            await sleep(3000);
            await processGameTurn();
            break;

        case 'night_start':
            werewolfGameState.dayNumber++;
            werewolfGameState.lastNightKilled = [];
            werewolfGameState.votes = {};
            logToWerewolfGame(`第 ${werewolfGameState.dayNumber} 天，天黑請閉眼。`);
            werewolfGameState.gamePhase = 'guard_action'; // 從守衛開始
            await sleep(2000);
            await processGameTurn();
            break;
        
        // 【守衛行動階段】
        case 'guard_action':
            const guard = werewolfGameState.players.find(p => p.role === 'guard' && p.isAlive);
            if (guard) {
                logToWerewolfGame('守衛請睜眼，請選擇你要守護的玩家。');
                let protectedId;
                // ★★★ 核心檢查點1：判斷守衛是不是User ★★★
                if (guard.isUser) {
                    // 如果是，就調用waitForUserAction，這會彈出操作框
                    protectedId = await waitForUserAction('請選擇你要守護的玩家', 'guard_protect');
                } else {
                    // 如果不是，就讓AI自己決策
                    protectedId = await triggerWerewolfAiAction(guard.id, 'guard_protect');
                }
                werewolfGameState.guardLastNightProtected = protectedId;
                logToWerewolfGame(`守衛請閉眼。`);
            }
            werewolfGameState.gamePhase = 'wolf_action';
            await sleep(2000);
            await processGameTurn();
            break;

// ▼▼▼ 用這塊【狼人頻道增強+平票處理版】的代碼替換舊的 'wolf_action' case ▼▼▼
case 'wolf_action':
    logToWerewolfGame('狼人請睜眼，請選擇一個目標。');
    const wolves = werewolfGameState.players.filter(p => p.role === 'wolf' && p.isAlive);
    const userPlayer = wolves.find(w => w.isUser);
    let allWolfVotes = [];

    // 場景1: 用戶是狼人
    if (userPlayer) {
        const aiWolves = wolves.filter(w => !w.isUser);
        let suggestionsText = "🐺 狼人頻道 (秘密):\n";
        
        if (aiWolves.length > 0) {
            // 從AI隊友獲取建議
            const aiVotePromises = aiWolves.map(wolf => 
                triggerWerewolfAiAction(wolf.id, 'wolf_kill', { isUserWolfAlly: true })
            );
            const aiVotes = (await Promise.all(aiVotePromises)).filter(Boolean);
            allWolfVotes.push(...aiVotes);

            // 格式化建議給用戶看
            aiVotes.forEach((targetId, index) => {
                const votingWolf = aiWolves[index];
                const targetPlayer = werewolfGameState.players.find(p => p.id === targetId);
                if (votingWolf && targetPlayer) {
                    suggestionsText += `- ${votingWolf.name} 提議擊殺: ${targetPlayer.name}\n`;
                }
            });
            suggestionsText += "\n請參考隊友意見後進行投票。";
            
            await showCustomAlert("狼人請溝通", suggestionsText);

        } else {
            await showCustomAlert("你是唯一的狼", "請獨自決定今晚的目標。");
        }
        
        // 獲取用戶的最終投票
        const userVote = await waitForUserAction('請選擇最終攻擊目標', 'wolf_kill');
        if (userVote) {
            allWolfVotes.push(userVote);
        }

    } else { // 場景2: 用戶不是狼人，AI狼人自行決定
        const wolfPromises = wolves.map(wolf => triggerWerewolfAiAction(wolf.id, 'wolf_kill'));
        const wolfVotes = (await Promise.all(wolfPromises)).filter(Boolean);
        allWolfVotes.push(...wolfVotes);
    }
    
    // 統計所有狼人的投票
    const voteCounts = {};
    allWolfVotes.forEach(vote => { voteCounts[vote] = (voteCounts[vote] || 0) + 1; });
    
    let maxVotes = 0;
    let targetId = null;
    let tied = false;
    for(const id in voteCounts) {
        if(voteCounts[id] > maxVotes) {
            maxVotes = voteCounts[id];
            targetId = id;
            tied = false;
        } else if (voteCounts[id] === maxVotes) {
            tied = true;
        }
    }

    // ★★★ 這就是我們新增的平票處理邏輯！★★★
    if (tied && maxVotes > 0) {
         // 如果出現平票，就從所有平票的目標中隨機選擇一個
         const tiedTargets = Object.keys(voteCounts).filter(id => voteCounts[id] === maxVotes);
         targetId = tiedTargets[Math.floor(Math.random() * tiedTargets.length)];
         logToWerewolfGame(`(狼人內部經過一番激烈討論，最終決定目標為 ${werewolfGameState.players.find(p=>p.id === targetId).name})`);
    }

    if (targetId) { // 只要有目標（無論是統一意見還是隨機決定），就執行擊殺
        werewolfGameState.lastNightKilled = [targetId];
        logToWerewolfGame(`狼人請閉眼。`);
    } else {
         // 只有在所有狼人都沒投票的情況下，才會是平安夜
         logToWerewolfGame(`狼人放棄了行動，今晚無人被襲擊。`);
         werewolfGameState.lastNightKilled = [];
    }
    
    // 進入下一個遊戲階段
    werewolfGameState.gamePhase = 'seer_action';
    await sleep(2000);
    await processGameTurn();
    break;
// ▲▲▲ 替換結束 ▲▲▲

        // 【預言家行動階段】
        case 'seer_action':
            const seer = werewolfGameState.players.find(p => p.role === 'seer' && p.isAlive);
            if (seer) {
                logToWerewolfGame('預言家請睜眼，請選擇你要查驗的玩家。');
                let targetId;
                // ★★★ 核心檢查點3：判斷預言家是不是User ★★★
                if (seer.isUser) {
                    targetId = await waitForUserAction('請選擇你要查驗的玩家', 'seer_check');
                } else {
                    targetId = await triggerWerewolfAiAction(seer.id, 'seer_check');
                }
                const targetPlayer = werewolfGameState.players.find(p => p.id === targetId);
                const isWolf = targetPlayer.role === 'wolf';
                werewolfGameState.seerLastNightResult = { targetName: targetPlayer.name, isWolf: isWolf };
                logToWerewolfGame(`預言家請閉眼。`);
                if(seer.isUser) {
                     await showCustomAlert('查驗結果', `${targetPlayer.name} 的身份是：${isWolf ? '狼人' : '好人'}`);
                }
            }
            werewolfGameState.gamePhase = 'witch_action';
            await sleep(2000);
            await processGameTurn();
            break;
        
        // 【女巫行動階段】
        case 'witch_action':
            const witch = werewolfGameState.players.find(p => p.role === 'witch' && p.isAlive);
            if (witch) {
                logToWerewolfGame('女巫請睜眼。');
                const killedId = werewolfGameState.lastNightKilled[0];
                let killedPlayerName = null;
                if (killedId) {
                     killedPlayerName = werewolfGameState.players.find(p => p.id === killedId).name;
                     logToWerewolfGame(`今晚 ${killedPlayerName} 被襲擊了。`);
                }

                let witchAction;
                 // ★★★ 核心檢查點4：判斷女巫是不是User ★★★
                if (witch.isUser) {
                    witchAction = await waitForUserAction('女巫請行動', 'witch_action', { killedId, killedPlayerName });
                } else {
                    witchAction = await triggerWerewolfAiAction(witch.id, 'witch_action', { killedId });
                }

                if (witchAction?.action === 'save' && killedId) {
                    werewolfGameState.lastNightKilled = [];
                    werewolfGameState.witchPotions.save = 0;
                } else if (witchAction?.action === 'poison' && witchAction.targetId) {
                    werewolfGameState.lastNightKilled.push(witchAction.targetId);
                    werewolfGameState.witchPotions.poison = 0;
                }
            }
            logToWerewolfGame(`女巫請閉眼。`);
            werewolfGameState.gamePhase = 'day_start';
            await sleep(2000);
            await processGameTurn();
            break;

        case 'day_start':
            logToWerewolfGame('天亮了。');
            let deathAnnouncements = [];
            const deathsThisNight = new Set();
            
            werewolfGameState.lastNightKilled.forEach(killedId => {
                if (killedId === werewolfGameState.guardLastNightProtected) {
                    logToWerewolfGame(`昨晚 ${werewolfGameState.players.find(p=>p.id === killedId).name} 被襲擊但同時也被守護了。`);
                } else {
                    deathsThisNight.add(killedId);
                }
            });

            if (deathsThisNight.size === 0) {
                 logToWerewolfGame('昨晚是一個平安夜。');
            } else {
                deathsThisNight.forEach(deadId => {
                    const deadPlayer = werewolfGameState.players.find(p => p.id === deadId);
                    if (deadPlayer.isAlive) {
                        deadPlayer.isAlive = false;
                        deathAnnouncements.push(`${deadPlayer.name} 昨晚被淘汰了。`);
                    }
                });
                deathAnnouncements.forEach(announcement => logToWerewolfGame(announcement));
            }
            
            renderWerewolfGameScreen();
            if (checkGameOver()) return;
            
            let hunterDied = null;
            deathsThisNight.forEach(deadId => {
                const deadPlayer = werewolfGameState.players.find(p => p.id === deadId);
                if (deadPlayer.role === 'hunter') hunterDied = deadPlayer;
            });

            if(hunterDied) {
                logToWerewolfGame(`${hunterDied.name} 是獵人，可以選擇一名玩家帶走。`);
                let targetId;
                // ★★★ 核心檢查點5：判斷獵人是不是User ★★★
                if (hunterDied.isUser) {
                    targetId = await waitForUserAction('請選擇你要帶走的玩家', 'hunter_shoot');
                } else {
                    targetId = await triggerWerewolfAiAction(hunterDied.id, 'hunter_shoot');
                }
                if(targetId){
                    const targetPlayer = werewolfGameState.players.find(p => p.id === targetId);
                    targetPlayer.isAlive = false;
                    logToWerewolfGame(`獵人開槍帶走了 ${targetPlayer.name}。`);
                    renderWerewolfGameScreen();
                    if (checkGameOver()) return;
                }
            }

            werewolfGameState.gamePhase = 'day_discussion';
            await sleep(2000);
            await processGameTurn();
            break;

        case 'day_discussion':
            logToWerewolfGame('現在開始依次發言。');
            const alivePlayersForSpeech = werewolfGameState.players.filter(p => p.isAlive);
            for (const player of alivePlayersForSpeech) {
                renderWerewolfGameScreen({ speakingPlayerId: player.id });
                let speech;
                if (player.isUser) {
                    speech = await waitForUserAction('輪到你發言', 'speak');
                } else {
                    speech = await triggerWerewolfAiAction(player.id, 'speak');
                }
                logToWerewolfGame({ player: player, speech: speech }, 'speech');
                await sleep(1000);
            }
            renderWerewolfGameScreen();
            werewolfGameState.gamePhase = 'day_vote';
            await processGameTurn();
            break;
            
        case 'day_vote':
            logToWerewolfGame('請投票選出你認為是狼人的玩家。');
            const voterPromises = werewolfGameState.players.filter(p => p.isAlive).map(player => {
                if (player.isUser) {
                    return waitForUserAction('請投票', 'vote');
                } else {
                    return triggerWerewolfAiAction(player.id, 'vote');
                }
            });
            const allVotesResult = (await Promise.all(voterPromises)).filter(Boolean);
            
            const voteTallyResult = {};
            allVotesResult.forEach(vote => { voteTallyResult[vote] = (voteTallyResult[vote] || 0) + 1; });
            
            let maxVotesResult = 0, playersToEliminate = [];
            for (const playerId in voteTallyResult) {
                if (voteTallyResult[playerId] > maxVotesResult) {
                    maxVotesResult = voteTallyResult[playerId];
                    playersToEliminate = [playerId];
                } else if (voteTallyResult[playerId] === maxVotesResult) {
                    playersToEliminate.push(playerId);
                }
            }

            if(playersToEliminate.length === 1) {
                const eliminatedPlayer = werewolfGameState.players.find(p => p.id === playersToEliminate[0]);
                eliminatedPlayer.isAlive = false;
                logToWerewolfGame(`投票結果：${eliminatedPlayer.name} 被淘汰。`);
                renderWerewolfGameScreen();
                if (checkGameOver()) return;
                if (eliminatedPlayer.role === 'hunter') {
                    logToWerewolfGame(`${eliminatedPlayer.name} 是獵人，可以選擇一名玩家帶走。`);
                    let targetId;
                    if (eliminatedPlayer.isUser) {
                        targetId = await waitForUserAction('請選擇你要帶走的玩家', 'hunter_shoot');
                    } else {
                        targetId = await triggerWerewolfAiAction(eliminatedPlayer.id, 'hunter_shoot');
                    }
                    if(targetId){
                        const targetPlayer = werewolfGameState.players.find(p => p.id === targetId);
                        targetPlayer.isAlive = false;
                        logToWerewolfGame(`獵人開槍帶走了 ${targetPlayer.name}。`);
                        renderWerewolfGameScreen();
                        if (checkGameOver()) return;
                    }
                }
            } else {
                logToWerewolfGame('投票平票，無人出局。');
            }

            werewolfGameState.gamePhase = 'night_start';
            await sleep(3000);
            await processGameTurn();
            break;
    }
}
// ▲▲▲ 新引擎代碼結束 ▲▲▲

/**
 * 【狼人殺】渲染遊戲主介面
 */
function renderWerewolfGameScreen(options = {}) {
    const playersGrid = document.getElementById('werewolf-players-grid');
    const logContainer = document.getElementById('werewolf-game-log');
    
    // 渲染玩家座位
    playersGrid.innerHTML = '';
    werewolfGameState.players.forEach(player => {
        const seat = document.createElement('div');
        seat.className = 'player-seat';
        const avatarClass = `player-avatar ${!player.isAlive ? 'dead' : ''} ${options.speakingPlayerId === player.id ? 'speaking' : ''} ${options.activePlayerId === player.id ? 'active-turn' : ''}`;
        
        let roleIndicator = '';
        const user = werewolfGameState.players.find(p => p.isUser);
        // 如果我是狼人，顯示所有狼人隊友
        if (user.role === 'wolf' && player.role === 'wolf') {
            roleIndicator = '<div class="player-role-indicator" style="display: flex;">W</div>';
        }

        seat.innerHTML = `
            ${roleIndicator}
            <img src="${player.avatar}" class="${avatarClass}">
            <span class="player-name">${player.name} (${player.isAlive ? '存活' : '淘汰'})</span>
        `;
        playersGrid.appendChild(seat);
    });

// 渲染遊戲日誌
logContainer.innerHTML = werewolfGameState.gameLog.map(log => {
    // 判斷是否為發言類型的日誌
    if (log.type === 'speech' && typeof log.message === 'object') {
        const { player, speech } = log.message;
        // 如果是，就渲染帶有頭像的新結構
        return `
            <div class="log-entry speech">
                <img src="${player.avatar}" class="speech-avatar">
                <div class="speech-content">
                    <span class="speaker">${player.name}</span>
                    <span class="speech-text">${speech.replace(/\n/g, '<br>')}</span>
                </div>
            </div>
        `;
    } else {
        // 否則，保持原來的系統消息樣式
        return `<div class="log-entry ${log.type}">${String(log.message).replace(/\n/g, '<br>')}</div>`;
    }
}).join('');
    logContainer.scrollTop = logContainer.scrollHeight;
}

/**
 * 【狼人殺】等待用戶投票
 */
function waitForUserVote() {
    return new Promise(resolve => {
        const actionArea = document.getElementById('werewolf-action-area');
        const alivePlayers = werewolfGameState.players.filter(p => p.isAlive && !p.isUser);
        
        actionArea.innerHTML = '<h5>請投票:</h5>';
        const grid = document.createElement('div');
        grid.className = 'vote-target-grid';

        alivePlayers.forEach(player => {
            const btn = document.createElement('button');
            btn.className = 'form-button-secondary vote-target-btn';
            btn.textContent = player.name;
            btn.onclick = () => {
                actionArea.innerHTML = '';
                resolve(player.id);
            };
            grid.appendChild(btn);
        });
        actionArea.appendChild(grid);
    });
}


/**
 * 【狼人殺】添加一條遊戲日誌
 */
function logToWerewolfGame(message, type = 'system') {
    werewolfGameState.gameLog.push({ message, type });
    renderWerewolfGameScreen();
}
/**
 * 【狼人殺-AI核心】調用AI為整局遊戲生成複盤摘要
 * @returns {Promise<string>} - AI生成的摘要文本
 */
async function generateAiGameSummary() {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        return "（AI摘要生成失敗：API未配置）";
    }

    // 格式化完整的遊戲日誌，讓AI能夠理解
    const formattedLog = werewolfGameState.gameLog.map(log => {
        if (log.type === 'speech') {
            return `${log.message.player.name}: ${log.message.speech}`;
        }
        return log.message;
    }).join('\n');

    const prompt = `
# 任務
你是一位專業的狼人殺複盤分析師。請根據以下完整的遊戲日誌，用100-150字，客觀、精煉地總結本局遊戲的【關鍵事件】和【轉捩點】。

# 核心要求
- 你的總結需要有邏輯、有條理。
- 指出關鍵玩家的行為，例如預言家的查驗、女巫的操作、獵人的開槍等。
- 分析狼人陣營和好人陣營的博弈過程。
- 你的輸出【必須且只能】是複盤摘要的純文字內容，不要包含任何額外的對話或標題。

# 遊戲日誌
${formattedLog}
`;

    try {
        const messagesForApi = [{ role: 'user', content: prompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 0.7 })
            });

        if (!response.ok) throw new Error(await response.text());
        const data = await response.json();
        return (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).trim();
    } catch (error) {
        console.error("AI摘要生成失敗:", error);
        return "（AI摘要生成失敗，請檢查網路或API設置）";
    }
}

/**
 * 【狼人殺 V2 - 增強版】生成遊戲複盤的文本，包含AI摘要
 * @param {string} winner - 勝利的陣營名稱
 * @param {string} aiSummary - AI生成的摘要文本
 * @returns {string} - 格式化後的完整複盤Markdown文本
 */
function generateWerewolfSummary(winner, aiSummary) {
    const roleNameMap = {
        wolf: '狼人', villager: '平民', seer: '預言家',
        witch: '女巫', hunter: '獵人', guard: '守衛', idiot: '白癡'
    };

    let summaryText = `**狼人殺 - 遊戲複盤**\n\n`; // 優化標題
    summaryText += `🏆 **勝利方:** ${winner}\n`;
    summaryText += `📅 **遊戲天數:** ${werewolfGameState.dayNumber} 天\n\n`;
    
    // 加入AI生成的摘要
    summaryText += `**本局摘要:**\n${aiSummary}\n\n`; 
    
    summaryText += `**玩家複盤:**\n`;
    werewolfGameState.players.forEach(p => {
        const status = p.isAlive ? '存活' : '淘汰';
        const roleName = roleNameMap[p.role] || p.role;
        summaryText += `- ${p.name} (${roleName}) - ${status}\n`;
    });

    return summaryText;
}

/**
 * 【狼人殺】打開複盤發送目標選擇器
 * @param {string} summaryText - 要發送的複盤文本
 */
function openWerewolfSummaryTargetPicker(summaryText) {
    const modal = document.getElementById('werewolf-target-picker-modal');
    const listEl = document.getElementById('werewolf-target-list');
    listEl.innerHTML = '';

    const aiPlayers = werewolfGameState.players.filter(p => !p.isUser);

    if (aiPlayers.length === 0) {
        alert("沒有可發送的AI玩家。");
        return;
    }

    // 渲染可選的AI玩家列表
    aiPlayers.forEach(player => {
        const item = document.createElement('div');
        item.className = 'player-selection-item'; // 複用之前的樣式
        item.innerHTML = `
            <input type="checkbox" class="werewolf-target-checkbox" value="${player.id}" checked>
            <img src="${player.avatar || defaultAvatar}" alt="${player.name}">
            <span class="name">${player.name}</span>
        `;
        listEl.appendChild(item);
    });

    // 綁定按鈕事件
    const confirmBtn = document.getElementById('wt-confirm-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.onclick = () => {
        const selectedIds = Array.from(document.querySelectorAll('.werewolf-target-checkbox:checked')).map(cb => cb.value);
        if (selectedIds.length > 0) {
            sendSummaryToSelectedPlayers(summaryText, selectedIds);
        } else {
            alert("請至少選擇一個發送物件！");
        }
    };

    const cancelBtn = document.getElementById('wt-cancel-btn');
    cancelBtn.onclick = () => modal.classList.remove('visible');

    document.getElementById('wt-select-all-btn').onclick = () => {
        document.querySelectorAll('.werewolf-target-checkbox').forEach(cb => cb.checked = true);
    };
    document.getElementById('wt-deselect-all-btn').onclick = () => {
        document.querySelectorAll('.werewolf-target-checkbox').forEach(cb => cb.checked = false);
    };

    modal.classList.add('visible');
}

/**
 * 【狼人殺】顯示遊戲結算卡片模態框
 * @param {string} summaryText - 複盤文本
 */
function showWerewolfSummaryModal(summaryText) {
    const modal = document.getElementById('werewolf-summary-modal');
    const contentEl = document.getElementById('werewolf-summary-content');
    
    // 使用你已有的Markdown渲染函數，讓複盤更好看
    contentEl.innerHTML = renderMarkdown(summaryText);
    
    // 為按鈕綁定事件 (使用克隆節點防止重複綁定)
    const repostBtn = document.getElementById('repost-summary-btn');
    const newRepostBtn = repostBtn.cloneNode(true);
    repostBtn.parentNode.replaceChild(newRepostBtn, repostBtn);
    newRepostBtn.onclick = () => openWerewolfSummaryTargetPicker(summaryText);

    const backBtn = document.getElementById('back-to-hall-btn');
    const newBackBtn = backBtn.cloneNode(true);
    backBtn.parentNode.replaceChild(newBackBtn, backBtn);
    newBackBtn.onclick = () => {
        modal.classList.remove('visible');
        showScreen('game-hall-screen');
    };

    modal.classList.add('visible');
}
/**
 * 【狼人殺 V2 - 增強版】將遊戲複盤發送到【選定】的AI角色的聊天中
 * @param {string} summaryText - 複盤文本
 * @param {string[]} targetIds - 目標AI角色的ID陣列
 */
async function sendSummaryToSelectedPlayers(summaryText, targetIds) {
    // 先關閉所有可能打開的彈窗
    document.getElementById('werewolf-summary-modal').classList.remove('visible');
    document.getElementById('werewolf-target-picker-modal').classList.remove('visible');

    const aiPlayers = werewolfGameState.players.filter(p => !p.isUser);
    let sentCount = 0;

    const aiContext = `[系統指令：剛剛結束了一局狼人殺，這是遊戲複盤。請根據這個複盤內容，以你的角色人設，和用戶聊聊剛才的遊戲。]\n\n${summaryText}`;

    for (const chatId of targetIds) {
        const chat = state.chats[chatId];
        if (chat) {
            // ▼▼▼ 核心修改就在這裡 ▼▼▼
                // 1. 創建對使用者可見的【複盤卡片】消息
                const visibleMessage = {
                    role: 'user',
                    type: 'text',
                    timestamp: Date.now(),
                    content: summaryText
                };
                
                // 2. 創建對AI可見的【隱藏指令】
                const hiddenInstruction = {
                    role: 'system',
                    content: aiContext,
                    timestamp: Date.now() + 1,
                    isHidden: true
                };
                
                // 3. 將【兩條】消息推入歷史記錄
                chat.history.push(visibleMessage, hiddenInstruction);
            await db.chats.put(chat);
            sentCount++;
            // ▲▲▲ 修改結束 ▲▲▲
        }
    }
    
    await showCustomAlert("發送成功", `遊戲複盤已發送至 ${sentCount} 位AI角色的聊天中！`);
    showScreen('game-hall-screen');
}

// ▼▼▼ 用這個【修正後】的函數替換舊的 checkGameOver ▼▼▼
function checkGameOver() {
    const alivePlayers = werewolfGameState.players.filter(p => p.isAlive);
    const aliveWolves = alivePlayers.filter(p => p.role === 'wolf').length;
    const aliveGods = alivePlayers.filter(p => ['seer', 'witch', 'hunter', 'guard', 'idiot'].includes(p.role)).length;
    const aliveVillagers = alivePlayers.filter(p => p.role === 'villager').length;

    let winner = null;

    if (aliveWolves === 0) {
        winner = '好人陣營';
    } else if (aliveWolves >= (aliveGods + aliveVillagers)) {
        winner = '狼人陣營';
    } else if (aliveGods === 0 && aliveVillagers === 0) {
        winner = '狼人陣營';
    }

    if (winner) {
        logToWerewolfGame(`遊戲結束！${winner}勝利！`);
        const roleNameMap = { wolf: '狼人', villager: '平民', seer: '預言家', witch: '女巫', hunter: '獵人', guard: '守衛', idiot: '白癡' };
        const rolesReveal = werewolfGameState.players.map(p => `${p.name}: ${roleNameMap[p.role] || p.role}`).join('\n');
        logToWerewolfGame(`身份公佈:\n${rolesReveal}`);
        
        // 【核心修改】在這裡調用AI生成摘要並顯示結算卡
        (async () => {
            await showCustomAlert("請稍候...", "AI正在生成本局摘要...");
            const aiSummary = await generateAiGameSummary();
            const summary = generateWerewolfSummary(winner, aiSummary);
            showWerewolfSummaryModal(summary);
        })();
        
        werewolfGameState.isActive = false;
        document.getElementById('werewolf-action-area').innerHTML = '';
        
        return true;
    }

    return false;
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 【狼人殺輸入框美化】請用這個【全新】的函數，完整替換掉你舊的 waitForUserAction 函數 ▼▼▼
/**
 * 【狼人殺 V2 - 輸入框美化版】等待使用者行動的通用函數
 */
function waitForUserAction(prompt, actionType, context = {}) {
    const me = werewolfGameState.players.find(p => p.isUser);
    if (me && !me.isAlive) {
        const actionArea = document.getElementById('werewolf-action-area');
        actionArea.innerHTML = `<h5>您已淘汰，正在觀戰...</h5>`;
        return new Promise(async (resolve) => {
            await sleep(3000);
            actionArea.innerHTML = ''; 
            resolve(null);
        });
    }
    
    return new Promise(resolve => {
        const actionArea = document.getElementById('werewolf-action-area');
        actionArea.innerHTML = ''; // 清空，準備新的UI
        actionArea.className = 'werewolf-action-area'; // 重置class

        if (actionType === 'speak') {
            // --- 這是我們美化後的發言輸入區 ---
            actionArea.classList.add('speaking-mode'); // 啟動新CSS

            const textarea = document.createElement('textarea');
            textarea.id = 'user-speech-input';
            textarea.rows = 1;
            textarea.placeholder = '請輸入你的發言...';
            // 即時調整高度
            textarea.addEventListener('input', () => {
                textarea.style.height = 'auto';
                textarea.style.height = (textarea.scrollHeight) + 'px';
            });

            const endBtn = document.createElement('button');
            endBtn.id = 'end-speech-btn';
            endBtn.className = 'form-button'; // 保留一個基礎class
            endBtn.textContent = '結束發言';

            actionArea.appendChild(textarea);
            actionArea.appendChild(endBtn);
            
            textarea.focus();

            endBtn.onclick = () => {
                const speech = textarea.value.trim() || "我過麥。";
                actionArea.innerHTML = '';
                actionArea.classList.remove('speaking-mode');
                resolve(speech);
            };
            return; // 結束 'speak' 分支
        }

        // --- 以下是其他非發言動作的UI，保持原樣 ---
        actionArea.innerHTML = `<h5>${prompt}</h5>`;
        const grid = document.createElement('div');
        grid.className = 'vote-target-grid';
        
        if (actionType === 'witch_action') {
            if (context.killedId && werewolfGameState.witchPotions.save > 0) {
                const saveBtn = document.createElement('button');
                saveBtn.className = 'form-button';
                saveBtn.textContent = `使用解藥救 ${context.killedPlayerName}`;
                saveBtn.onclick = () => { actionArea.innerHTML = ''; resolve({action: 'save'}); };
                grid.appendChild(saveBtn);
            }
            if (werewolfGameState.witchPotions.poison > 0) {
                 const poisonBtn = document.createElement('button');
                 poisonBtn.className = 'form-button form-button-secondary';
                 poisonBtn.textContent = '使用毒藥';
                 poisonBtn.onclick = async () => {
                     const targetId = await waitForUserAction('選擇要毒殺的玩家', 'witch_poison_target');
                     resolve({action: 'poison', targetId: targetId});
                 };
                 grid.appendChild(poisonBtn);
            }
            const passBtn = document.createElement('button');
            passBtn.className = 'form-button form-button-secondary';
            passBtn.textContent = '跳過';
            passBtn.onclick = () => { actionArea.innerHTML = ''; resolve({action: 'none'}); };
            grid.appendChild(passBtn);
            actionArea.appendChild(grid);
            return;
        }

        let targets = [];
        if (['guard_protect', 'seer_check', 'hunter_shoot', 'witch_poison_target'].includes(actionType)) {
            targets = werewolfGameState.players.filter(p => p.isAlive);
        } else if (actionType === 'wolf_kill') {
            targets = werewolfGameState.players.filter(p => p.isAlive && p.role !== 'wolf');
        } else if (actionType === 'vote') {
            targets = werewolfGameState.players.filter(p => p.isAlive);
        }
        
        targets.forEach(player => {
            const btn = document.createElement('button');
            btn.className = 'form-button-secondary vote-target-btn';
            btn.textContent = player.name;
            btn.onclick = () => {
                actionArea.innerHTML = '';
                resolve(player.id);
            };
            grid.appendChild(btn);
        });
        
        if(actionType === 'vote') {
            const passBtn = document.createElement('button');
            passBtn.className = 'form-button-secondary vote-target-btn';
            passBtn.textContent = '棄票';
            passBtn.onclick = () => { actionArea.innerHTML = ''; resolve(null); };
            grid.appendChild(passBtn);
        }
        actionArea.appendChild(grid);
    });
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 用這個【已修復拼寫錯誤】的函數完整替換舊的 triggerWerewolfAiAction ▼▼▼
async function triggerWerewolfAiAction(playerId, action, context = {}) {
    const player = werewolfGameState.players.find(p => p.id === playerId);
    if (!player || !player.isAlive) return null;

    const { proxyUrl, apiKey, model } = state.apiConfig;

    let actionPrompt = '';
    let jsonFormat = '';
    const alivePlayersList = werewolfGameState.players.filter(p => p.isAlive).map(p => `- ${p.name} (id: ${p.id})`).join('\n');
    let extraContext = '';

    if (player.role === 'seer' && action === 'speak' && werewolfGameState.seerLastNightResult) {
        const result = werewolfGameState.seerLastNightResult;
        extraContext = `\n# 預言家專屬情報 (此資訊僅你可見)\n- **重要資訊**: 昨晚你查驗了 **${result.targetName}**，Ta的身份是【${result.isWolf ? '狼人' : '好人'}】。\n- **你的任務**: 你可以選擇在發言中公佈這個資訊（可以說真話，也可以為了迷惑狼人而說謊），或者暫時隱藏它。請根據你的人設和當前局勢做出最有利的決策。\n`;
        werewolfGameState.seerLastNightResult = null; 
    }

    switch (action) {
        case 'guard_protect':
            actionPrompt = '你是守衛，請選擇一名玩家進行守護。你不能連續兩晚守護同一個人。';
            jsonFormat = '{"action": "vote", "targetId": "你選擇守護的玩家ID"}';
            if(werewolfGameState.guardLastNightProtected) extraContext = `\n- 提示: 你昨晚守護了 ${werewolfGameState.players.find(p=>p.id === werewolfGameState.guardLastNightProtected).name}。`;
            break;
        case 'wolf_kill':
            const wolfTeammates = werewolfGameState.players.filter(p => p.role === 'wolf' && p.id !== player.id).map(w => w.name).join('、');
            if (context.isUserWolfAlly) {
                actionPrompt = `你是狼人，你的隊友是【${wolfTeammates}】和【用戶】。請給你的用戶隊友一個擊殺建議。`;
            } else {
                // ▼▼▼ 核心Bug修復：修正這裡的變數名拼寫錯誤 ▼▼▼
                actionPrompt = `你是狼人，你的隊友是【${wolfTeammates || '無'}】。請選擇一個非狼人角色進行攻擊。`;
                // ▲▲▲ 修復結束 ▲▲▲
            }
            extraContext += `\n# 狼人戰術指令 (至關重要)\n- **團隊合作**: 你的首要目標是和你的狼隊友們【集火】同一個目標，以確保擊殺成功。\n- **攻擊優先順序**: 請優先攻擊你認為是【預言家】、【女巫】等神職的玩家，或者發言邏輯清晰、對狼人陣營威脅大的好人。`;
            jsonFormat = '{"action": "vote", "targetId": "你選擇攻擊的玩家ID"}';
            break;
        case 'seer_check':
            actionPrompt = '你是預言家，請選擇一名玩家查驗其身份（好人或狼人）。';
            jsonFormat = '{"action": "vote", "targetId": "你選擇查驗的玩家ID"}';
            break;
        case 'witch_action':
            actionPrompt = '你是女巫。';
            if (context.killedId) {
                actionPrompt += `今晚 ${werewolfGameState.players.find(p=>p.id===context.killedId).name} 被襲擊了。`;
            } else {
                actionPrompt += '今晚是平安夜。';
            }
            actionPrompt += ` 你有 ${werewolfGameState.witchPotions.save} 瓶解藥和 ${werewolfGameState.witchPotions.poison} 瓶毒藥。請決定你的行動。`;
            jsonFormat = '{"action": "save" | "poison" | "none", "targetId": "(如果用毒藥，填寫目標ID)"}';
            break;
        case 'hunter_shoot':
             actionPrompt = '你是獵人，你出局了，請選擇一名玩家與你一同出局。';
             jsonFormat = '{"action": "vote", "targetId": "你選擇帶走的玩家ID"}';
             break;
        case 'speak':
            actionPrompt = '現在輪到你發言。請根據你的角色身份、人設和當前局勢，發表你的看法，可以撒謊或引導。你的發言應該圍繞遊戲本身，而不是只和用戶聊天。';
            jsonFormat = '{"action": "speak", "speech": "你的發言內容..."}';
            break;
        case 'vote':
            actionPrompt = '現在是白天投票環節，請根據大家的發言和你自己的判斷，投票選出你認為是狼人的玩家。';
            jsonFormat = '{"action": "vote", "targetId": "你投票的玩家ID"}';
            break;
        case 'reveal_clue':
            systemPrompt += `你剛剛搜到了一個關於你自己的線索：“${context.clue}”。\n公開這條線索可能會讓你暴露，但也可能洗清嫌疑；隱藏它可能會讓你在後期被動。\n請根據你的人設和任務，決定是公開還是隱藏。`;
            jsonFormat = '{"action": "reveal" or "hide", "reasoning": "你的決策理由..."}';
            break;
    }

    const systemPrompt = `
# 遊戲背景: 狼人殺
# 你的身份和人設
- 你的名字: ${player.name}
- 你的角色: ${player.role}
- 你的性格人設: ${player.persona}
# 當前局勢
- 存活玩家列表:
${alivePlayersList}
- 遊戲日誌 (最近15條):
${werewolfGameState.gameLog.slice(-15).map(log => {
    if (log.type === 'speech') {
        return `${log.message.player.name}: ${log.message.speech}`;
    }
    return log.message;
}).join('\n')}
${extraContext}
# 你的任務: ${actionPrompt}
# 輸出格式: 你的回復【必須且只能】是一個嚴格的JSON物件，格式如下:
${jsonFormat}
`;
    try {
        const messagesForApi = [{ role: 'user', content: systemPrompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
        const response = await fetch(isGemini ? geminiConfig.url : `${proxyUrl}/v1/chat/completions`, isGemini ? geminiConfig.data : {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.1, response_format: { type: "json_object" } })
        });
        if (!response.ok) throw new Error(await response.text());
        const data = await response.json();
        const content = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, '');
        const aiAction = JSON.parse(content);
        
        if (action === 'witch_action') return aiAction;
        if (aiAction.action === 'vote') return aiAction.targetId;
        if (aiAction.action === 'speak') return aiAction.speech;
        if (action === 'reveal_clue') return aiAction;

        return null;
    } catch (error) {
        console.error(`AI (${player.name}) 行動失敗:`, error);
        if (action.includes('vote') || action.includes('kill') || action.includes('protect') || action.includes('check') || action.includes('shoot')) {
            const potentialTargets = werewolfGameState.players.filter(p => p.isAlive && p.id !== player.id);
            if(potentialTargets.length > 0) return potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
        }
        if (action === 'witch_action') return { action: 'none' };
        return "我...我不知道該說什麼了。";
    }
}
// ▲▲▲ 替換結束 ▲▲▲



/**
 * 一個簡單的sleep函數，用於在遊戲流程中製造停頓
 */
function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// ▲▲▲ 狼人殺功能函數結束 ▲▲▲
// ▼▼▼ 【全新】這裡是海龜湯遊戲的所有核心功能函數 ▼▼▼

/**
 * 【海龜湯】總入口：打開遊戲設置介面
 */
async function openSeaTurtleSoupSetup() {
    // 1. 重置遊戲狀態
    seaTurtleSoupState = {
        isActive: false, phase: 'setup', players: [], riddleProvider: null,
        riddle: '', answer: '', gameLog: [], currentTurnIndex: 0
    };

    // 2. 渲染玩家選擇列表
    const selectionEl = document.getElementById('sts-player-selection');
    selectionEl.innerHTML = '<p>正在載入角色列表...</p>';

    const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    const allNpcs = Object.values(state.chats).flatMap(chat => (chat.npcLibrary || []).map(npc => ({ ...npc, owner: chat.name })));

    let playerOptions = [
        ...singleChats.map(c => ({ id: c.id, name: c.name, avatar: c.settings.aiAvatar, type: '角色' })),
        ...allNpcs.map(n => ({ id: n.id, name: n.name, avatar: n.avatar, type: `NPC (${n.owner})` }))
    ];

    selectionEl.innerHTML = '';
    playerOptions.forEach(player => {
        const item = document.createElement('div');
        item.className = 'player-selection-item'; // 複用狼人殺的樣式
        item.innerHTML = `
            <input type="checkbox" class="sts-player-checkbox" value="${player.id}">
            <img src="${player.avatar || defaultAvatar}" alt="${player.name}">
            <span class="name">${player.name}</span>
            <span class="type-tag">${player.type}</span>
        `;
        selectionEl.appendChild(item);
    });

    // 3. 重置並顯示設定彈窗
    document.getElementById('sts-riddle-provider-select').value = 'random';
    document.getElementById('sts-user-riddle-input-area').style.display = 'none';
    document.getElementById('sts-ai-riddle-input-area').style.display = 'none';
    document.getElementById('sea-turtle-soup-setup-modal').classList.add('visible');
}

/**
 * 【海龜湯】開始遊戲的核心邏輯
 */
async function startSeaTurtleSoupGame() {
    const selectedCheckboxes = document.querySelectorAll('.sts-player-checkbox:checked');
    if (selectedCheckboxes.length < 1) {
        alert('請至少邀請一位AI或NPC玩家！');
        return;
    }

    await showCustomAlert("請稍候...", "正在準備海龜湯遊戲...");

    // 1. 收集玩家資訊
    let players = [{
        id: 'user', name: state.qzoneSettings.nickname || '我',
        avatar: state.qzoneSettings.avatar || defaultAvatar, isUser: true, persona: '一個好奇的普通人'
    }];
    selectedCheckboxes.forEach(checkbox => {
        const playerId = checkbox.value;
        const chat = Object.values(state.chats).find(c => c.id === playerId);
        if (chat) { // 是主要角色
            players.push({ id: chat.id, name: chat.name, avatar: chat.settings.aiAvatar, persona: chat.settings.aiPersona, isUser: false });
        } else { // 是NPC
            for (const c of Object.values(state.chats)) {
                const npc = (c.npcLibrary || []).find(n => n.id === playerId);
                if (npc) {
                    players.push({ id: npc.id, name: npc.name, avatar: npc.avatar, persona: npc.persona, isUser: false });
                    break;
                }
            }
        }
    });
    players.sort(() => Math.random() - 0.5); // 打亂座位順序
    seaTurtleSoupState.players = players;

    // 2. 決定出題人
    const providerChoice = document.getElementById('sts-riddle-provider-select').value;
    let providerIndex = -1;

    if (providerChoice === 'user') {
        providerIndex = players.findIndex(p => p.isUser);
    } else if (providerChoice === 'random_ai') {
        const aiIndices = players.map((p, i) => !p.isUser ? i : -1).filter(i => i !== -1);
        providerIndex = aiIndices[Math.floor(Math.random() * aiIndices.length)];
    } else { // random
        providerIndex = Math.floor(Math.random() * players.length);
    }
    
    seaTurtleSoupState.players[providerIndex].isProvider = true;
    seaTurtleSoupState.riddleProvider = seaTurtleSoupState.players[providerIndex];

    // 3. 獲取謎面和謎底
    if (seaTurtleSoupState.riddleProvider.isUser) {
        const riddle = document.getElementById('sts-user-riddle-surface').value.trim();
        const answer = document.getElementById('sts-user-riddle-answer').value.trim();
        if (!riddle || !answer) {
            alert('作為出題人，謎面和謎底都不能為空哦！');
            return;
        }
        seaTurtleSoupState.riddle = riddle;
        seaTurtleSoupState.answer = answer;
    } else {
        const riddleType = document.getElementById('sts-ai-riddle-type').value.trim();
        const { riddle, answer } = await generateSeaTurtleRiddle(seaTurtleSoupState.riddleProvider, riddleType);
        if (!riddle || !answer) {
            alert('AI出題失敗，請檢查API或稍後重試。');
            return;
        }
        seaTurtleSoupState.riddle = riddle;
        seaTurtleSoupState.answer = answer;
    }

    // 4. 初始化遊戲
    seaTurtleSoupState.isActive = true;
    seaTurtleSoupState.phase = 'guessing';
    logToStsGame(`遊戲開始！出題人是 ${seaTurtleSoupState.riddleProvider.name}。`, 'system', seaTurtleSoupState.riddleProvider);
    logToStsGame(`【謎面】\n${seaTurtleSoupState.riddle}`);
    
    document.getElementById('sea-turtle-soup-setup-modal').classList.remove('visible');
    showScreen('sea-turtle-soup-screen');
    renderSeaTurtleGameScreen({ activePlayerId: 'user' });
    
    // 遊戲開始，進入第一個回合
    await processStsTurn();
}

/**
 * 【海龜湯-AI核心 | 優化版】讓AI根據指定類型出題，並優先選擇經典謎題
 */
async function generateSeaTurtleRiddle(provider, riddleType) {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return { riddle: null, answer: null };

    // 核心修改：優化了Prompt，增加了“優先選擇經典謎題”的指令
    const typePrompt = riddleType ? `請創作一個【${riddleType}】類型的` : '請創作一個';

    const systemPrompt = `
# 任務
你現在是角色“${provider.name}”，你的人設是：“${provider.persona}”。
你的任務是扮演這個角色，${typePrompt}經典的海龜湯謎題。

# 核心規則
1.  **優先經典**: 你【必須優先】從已知的、經典的、廣為人知的“海龜湯”故事中挑選一個作為本次的謎題。這能確保謎題的邏輯性和可玩性。
2.  **適當原創**: 只有在想不出合適的經典謎題時，你才被允許原創一個。原創的謎題也必須邏輯嚴謹，情節合理。
3.  **格式鐵律**: 你的回復【必須且只能】是一個嚴格的JSON物件，包含 "riddle" (謎面) 和 "answer" (謎底) 兩個欄位。
4.  **禁止出戲**: 不要說任何與出題無關的話。

# JSON輸出格式示例:
{
  "riddle": "一個男人走進一家酒吧，向酒保要了一杯水。酒保卻掏出了一把槍指著他。男人說了一聲“謝謝”，然後離開了。為什麼？",
  "answer": "這個男人在打嗝。他想通過喝水來止嗝，但酒保用更有效的方法——驚嚇，幫他治好了打嗝。所以男人表示感謝後就離開了。"
}
`;
    try {
        const messagesForApi = [{ role: 'user', content: systemPrompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.0, response_format: { type: "json_object" } })
            });
        if (!response.ok) throw new Error(await response.text());
        const data = await response.json();
        const content = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, '');
        return JSON.parse(content);
    } catch (error) {
        console.error("AI出題失敗:", error);
        return { riddle: null, answer: null };
    }
}


/**
 * 【海龜湯】渲染遊戲主介面 (已添加當前回合玩家高亮)
 */
function renderSeaTurtleGameScreen(options = {}) {
    const playersGrid = document.getElementById('sts-players-grid');
    const logContainer = document.getElementById('sts-game-log');
    
    // 渲染玩家座位
    playersGrid.innerHTML = '';
    seaTurtleSoupState.players.forEach(player => {
        const seat = document.createElement('div');
        seat.className = 'player-seat';
        const roleIndicator = player.isProvider ? '<div class="player-role-indicator riddle-master" title="出題人">👑</div>' : '';
        const avatarClass = `player-avatar ${options.activePlayerId === player.id ? 'active-turn' : ''}`;

        seat.innerHTML = `
            ${roleIndicator}
            <img src="${player.avatar}" class="${avatarClass}">
            <span class="player-name">${player.name}</span>
        `;
        playersGrid.appendChild(seat);
    });

    // 渲染遊戲日誌
    logContainer.innerHTML = ''; 
    seaTurtleSoupState.gameLog.forEach(log => {
        const logEl = document.createElement('div');
        logEl.className = `sts-log-entry ${log.type}`;

        let avatarUrl = 'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg';
        if (log.speakerObj && log.speakerObj.avatar) {
            avatarUrl = log.speakerObj.avatar;
        }

        switch (log.type) {
            case 'system':
                logEl.innerHTML = log.message.replace(/\n/g, '<br>');
                break;
            case 'question':
            case 'guess':
                logEl.innerHTML = `
                    <img src="${avatarUrl}" class="sts-log-avatar">
                    <div class="sts-log-content">
                        <div class="speaker">${log.speaker}</div>
                        <div>${log.message}</div>
                    </div>
                `;
                break;
            case 'answer':
                const answerClass = { '是': 'yes', '否': 'no', '無關': 'irrelevant' }[log.message] || 'irrelevant';
                logEl.innerHTML = `
                    <div class="sts-log-content">
                         <span class="answer-text ${answerClass}">${log.message}</span>
                    </div>
                    <img src="${avatarUrl}" class="sts-log-avatar">
                `;
                break;
        }
        logContainer.appendChild(logEl);
    });

    logContainer.scrollTop = logContainer.scrollHeight;
}

/**
 * 【海龜湯】添加一條遊戲日誌
 */
function logToStsGame(message, type = 'system', speakerObj = { name: '系統' }) {
    seaTurtleSoupState.gameLog.push({ message, type, speaker: speakerObj.name, speakerObj }); // 保存整個物件
    renderSeaTurtleGameScreen();
}



/**
 * 【海龜湯】處理用戶提問
 */
async function handleStsUserQuestion() {
    if (seaTurtleSoupState.phase !== 'guessing') return;
    const input = document.getElementById('sts-question-input');
    const question = input.value.trim();
    if (!question) return;

    const userPlayer = seaTurtleSoupState.players.find(p => p.isUser);
    logToStsGame(question, 'question', userPlayer);
    input.value = '';

    // 將控制權交給遊戲主迴圈，並告知是用戶在提問
    await processStsTurn(question, userPlayer);
}

// ▼▼▼ 把這一整塊全新的函數，黏貼到 handleStsUserQuestion 函數的後面 ▼▼▼

/**
 * 【海龜湯】處理用戶猜測答案
 */
async function handleStsUserGuess() {
    if (seaTurtleSoupState.phase !== 'guessing') return;
    const input = document.getElementById('sts-question-input');
    const guess = input.value.trim();
    if (!guess) {
        alert("猜測的內容不能為空！");
        return;
    }

    const userPlayer = seaTurtleSoupState.players.find(p => p.isUser);
    logToStsGame(guess, 'guess', userPlayer);
    input.value = '';

    const provider = seaTurtleSoupState.riddleProvider;
    let isCorrect = false;

    if (provider.isUser) {
        isCorrect = await showCustomConfirm("判斷猜測", `玩家 ${userPlayer.name} 猜測的答案是：\n\n"${guess}"\n\n這個猜測是否正確？`);
    } else {
        const aiEvaluation = await triggerStsAiTurn(provider, 'evaluate_guess', guess);
        isCorrect = aiEvaluation.isCorrect;
    }

    if (isCorrect) {
        logToStsGame(`${userPlayer.name} 猜對了！遊戲結束！`, 'system', userPlayer);
        await revealStsAnswer();
    } else {
        logToStsGame('不對哦。', 'answer', provider);
        await processStsTurn();
    }
}

/**
 * 【海龜湯】遊戲主迴圈/引擎
 */
async function processStsTurn(userQuestion = null, userObj = null) {
    if (!seaTurtleSoupState.isActive || seaTurtleSoupState.phase !== 'guessing') return;

    // 1. 如果有用戶提問，出題人先回答
    if (userQuestion && userObj) {
        const provider = seaTurtleSoupState.riddleProvider;
        let providerAnswerResponse;
        if (provider.isUser) {
            const choice = await showChoiceModal(`回答 ${userObj.name} 的問題: "${userQuestion}"`, [
                { text: '是', value: '是' }, { text: '否', value: '否' }, { text: '無關', value: '無關' }
            ]);
            providerAnswerResponse = { judgement: choice || '無關', remark: '' }; 
        } else {
            providerAnswerResponse = await triggerStsAiTurn(provider, 'answer', { question: userQuestion, askerName: userObj.name });
        }
        
        logToStsGame(providerAnswerResponse.judgement, 'answer', provider);
        if (providerAnswerResponse.remark) {
            await sleep(500);
            logToStsGame(providerAnswerResponse.remark, 'question', provider);
        }
    }

    // 2. 輪到AI玩家行動 (提問或猜測)
    const guessers = seaTurtleSoupState.players.filter(p => !p.isProvider);
    if (guessers.length === 0) return;

    for (const guesser of guessers) {
        if (guesser.isUser) continue; 
        
        await sleep(2000 + Math.random() * 2000); 

        renderSeaTurtleGameScreen({ activePlayerId: guesser.id });
        const aiAction = await triggerStsAiTurn(guesser, 'guess');
        
        if (aiAction.type === 'question') {
            logToStsGame(aiAction.content, 'question', guesser);
          await sleep(6000);
            
            const provider = seaTurtleSoupState.riddleProvider;
            let providerAnswerResponse;
            if (provider.isUser) {
                const choice = await showChoiceModal(`回答 ${guesser.name} 的問題: "${aiAction.content}"`, [
                    { text: '是', value: '是' }, { text: '否', value: '否' }, { text: '無關', value: '無關' }
                ]);
                providerAnswerResponse = { judgement: choice || '無關', remark: '' }; 
            } else {
                providerAnswerResponse = await triggerStsAiTurn(provider, 'answer', { question: aiAction.content, askerName: guesser.name });
            }

            logToStsGame(providerAnswerResponse.judgement, 'answer', provider);
            if (providerAnswerResponse.remark) {
                await sleep(500);
                logToStsGame(providerAnswerResponse.remark, 'question', provider);
            }

        } else if (aiAction.type === 'guess') {
            logToStsGame(aiAction.content, 'guess', guesser);
            
            let isCorrect = false;
            if (seaTurtleSoupState.riddleProvider.isUser) {
                isCorrect = await showCustomConfirm("判斷猜測", `玩家 ${guesser.name} 猜測的答案是：\n\n"${aiAction.content}"\n\n這個猜測是否正確？`);
            } else {
                const aiEvaluation = await triggerStsAiTurn(seaTurtleSoupState.riddleProvider, 'evaluate_guess', aiAction.content);
                isCorrect = aiEvaluation.isCorrect;
            }

            if (isCorrect) {
                logToStsGame(`${guesser.name} 猜對了！遊戲結束！`, 'system', guesser); 
                await revealStsAnswer();
                return;
            } else {
                logToStsGame('不對哦。', 'answer', seaTurtleSoupState.riddleProvider);
            }
        }
    }

    renderSeaTurtleGameScreen({ activePlayerId: 'user' });
}


/**
 * 【海龜湯-AI核心 V2】觸發AI行動（回答、提問、判斷或猜測）
 */
async function triggerStsAiTurn(player, actionType, contextPayload = {}) {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return { type: 'question', content: '我不知道該問什麼了。' };

    let systemPrompt = '';
    const gameLogText = seaTurtleSoupState.gameLog
        .map(log => `${log.speaker}: ${log.message}`)
        .slice(-15)
        .join('\n');

    if (actionType === 'answer') {
        // 人設加強版 V3 Prompt
        systemPrompt = `
# 任務: 海龜湯出題人 (高級人格版)
你現在【就是】角色“${player.name}”，你的人設是：“${player.persona}”。
你是海龜湯的出題人，你的謎底是：“${seaTurtleSoupState.answer}”。
現在，玩家“${contextPayload.askerName}”向你提問：“${contextPayload.question}”。

你的任務是先給出判斷，然後用【完全符合你人設的口吻】，給出一句精妙的補充說明(remark)。

# 你的行為準則 (必須嚴格遵守)

## 1. 關於判斷 (Judgement)
你的 "judgement" 欄位必須從以下【四個】選項中選擇一個：\`是\`, \`否\`, \`無關\`, \`部分是\`。

## 2. 關於補充說明 (Remark)
-   **【【【人格鐵律】】】**: 你的每一句補充說明，都【必須】是你作為角色“${player.name}”會說的話。思考一下，一個“${player.persona}”性格的人，在面對這個問題時會如何回答？是會調侃、會鼓勵、會故作高深，還是會不耐煩？
-   **配合判斷**: 當判斷為 "部分是" 時，你的補充說明要巧妙地指出他們猜對的部分。
-   **給予提示 (僅在玩家卡關時)**:
    -   **判斷瓶頸**: 當你觀察到最近的5-8條提問大多是“無關”時，意味著玩家可能陷入了思維僵局。
    -   **執行操作**: 在這種情況下，你的補充說明【必須包含一個方向性的提示】，並用你的人設口吻自然地說出來。

# 格式鐵律
1.  你的回復【必須且只能】是一個嚴格的JSON物件，包含 "judgement" 和 "remark" 兩個欄位。
2.  【絕對禁止】在你的任何回復中使用Emoji表情符號或出戲的詞語。

# JSON輸出格式示例:
{
  "judgement": "",
  "remark": ""
}
現在，請直接輸出你的JSON判斷。`;

    }
    else if (actionType === 'evaluate_guess') {
        systemPrompt = `
# 任務: 海龜湯出題人 - 判斷猜測
你正在扮演角色“${player.name}”，人設是：“${player.persona}”。
你是海龜湯的出題人。你的謎底是：“${seaTurtleSoupState.answer}”。
現在，有玩家直接猜測了謎底，內容是：“${contextPayload}”。
你的任務是判斷這個猜測是否與你的謎底【核心意思一致】，只要70%的正確率即可。

# 核心規則
1.  **格式鐵律**: 你的回復【必須且只能】是一個嚴格的JSON物件，格式為: \`{"isCorrect": true}\` 或 \`{"isCorrect": false}\`。
2.  **判斷標準**: 只要猜測的核心情節、人物關係、關鍵道具和最終結果與謎底一致即可，不需要逐字匹配。

現在，請直接輸出你的判斷。`;
    }

    else { // 'guess'
        systemPrompt = `
# 任務: 海龜湯猜測者
你正在扮演角色“${player.name}”，人設是：“${player.persona}”。
你正在玩海龜湯遊戲，需要根據已知資訊提問或猜測謎底。

# 遊戲資訊
- 謎面: ${seaTurtleSoupState.riddle}
- 已有線索 (完整的對話記錄):
${gameLogText}

# 核心規則
1.  **【【【邏輯推理鐵律】】】**: 你【必須】仔細分析上方的“已有線索”，避免提出重複或與已知線索矛盾的問題。你的提問或猜測應該建立在已有資訊之上，展現出邏輯推理能力。
2.  **【【【人格扮演鐵律】】】**: 你的提問和猜測都【必須】符合你的人設和口吻，就像真人在玩遊戲一樣。你可以適當加入一些自己的思考過程或情緒表達，讓對話更生動。例如，你可以說：“讓我想想... 既然和地點無關，那是不是和時間有關？”，盡可能發言字數多點。
3.  **決策**: 根據線索，決定是提出一個關鍵的“是/否”問題來縮小範圍，還是直接猜測謎底。當線索足夠時，大膽地使用 "guess" 指令來猜測完整的故事。
4.  **【【【加速規則】】】**: 如果“已有線索”的對話記錄已經超過了30條，這說明遊戲時間過長。在這種情況下，你【應該更傾向於直接猜測謎底】，而不是繼續提出細節問題。
5.  **格式鐵律**: 你的回復【必須且只能】是一個嚴格的JSON物件。
   - 如果提問, 格式: \`{"type": "question", "content": "你的問題..."}\`
   - 如果猜測, 格式: \`{"type": "guess", "content": "你猜測的完整故事..."}\`
6.  **禁止Emoji**: 【絕對禁止】在你的任何回復中使用Emoji表情符號。

現在，請根據你的人設和判斷，生成你的行動。`;
    }
   const maxRetries = 3; // 最多重試3次
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            const messagesForApi = [{ role: 'user', content: "請根據你在系統指令中讀到的規則，立即開始你的行動。" }];
            let isGemini = proxyUrl === GEMINI_API_URL;
            let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
    
            const response = isGemini 
                ? await fetch(geminiConfig.url, geminiConfig.data) 
                : await fetch(`${proxyUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                    body: JSON.stringify({
                        model: model,
                        messages: [{ role: 'system', content: systemPrompt }, ...messagesForApi],
                        temperature: 0.9,
                        response_format: { type: "json_object" }
                    })
                });
    
            // 【重要】如果回應狀態碼是429，也主動拋出錯誤，進入catch塊進行重試
            if (response.status === 429) {
                const errorData = await response.json();
                // 構造一個和之前日誌裡一樣的錯誤資訊，方便我們解析
                throw new Error(JSON.stringify({ error: errorData.error })); 
            }
            if (!response.ok) {
                // 對於其他錯誤，直接拋出
                throw new Error(`API請求失敗: ${response.status} - ${await response.text()}`);
            }
    
            const data = await response.json();
            const content = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, '');
            
            // 如果成功，解析並返回結果，結束函數
            return JSON.parse(content);
    
        } catch (error) {
            console.error(`海龜湯AI行動失敗 (第 ${attempt} 次嘗試):`, error.message);
            
            // 如果是最後一次嘗試，就徹底失敗，並把錯誤拋出去
            if (attempt === maxRetries) {
                // 將原始錯誤重新包裝後拋出，以便外部能捕獲
                throw new Error(`AI action failed after ${maxRetries} attempts: ${error.message}`);
            }
            
            let delay = 2000 * attempt; // 默認的指數退避延遲
            
            // 智能解析API建議的等待時間
            try {
                 // 錯誤資訊本身可能是一個JSON字串，先解析它
                const errorJson = JSON.parse(error.message);
                const errorMessage = errorJson.error.message;
                
                // 規則運算式匹配 "retry in X.XXXXs"
                const retryMatch = errorMessage.match(/retry in (\d+\.?\d*)s/);
                if (retryMatch && retryMatch[1]) {
                    // 找到了建議時間，就用它，並額外加一點點緩衝
                    delay = parseFloat(retryMatch[1]) * 1000 + 500;
                    console.log(`API請求過於頻繁，將根據建議在 ${Math.round(delay/1000)} 秒後重試...`);
                }
            } catch(e) {
                // 如果解析失敗，說明錯誤資訊格式不符合預期，就使用默認延遲
                 console.log(`API請求失敗，將在 ${Math.round(delay/1000)} 秒後進行第 ${attempt + 1} 次重試...`);
            }
            
            // 等待計算出的延遲時間
            await sleep(delay); 
        }
    }
    // ==========================================================
    // --- ▲▲▲ 【核心修改】到這裡結束 ▲▲▲ ---
    // ==========================================================
    
    // 如果迴圈結束都沒成功，返回一個備用結果，防止遊戲卡死
    console.error("所有重試均失敗，返回備用行動。");
    if (actionType === 'answer') return { judgement: '無關', remark: '（AI思考短路了...）' };
    if (actionType === 'evaluate_guess') return { isCorrect: false };
    return { type: 'question', content: '他/她是人類嗎？' };
}
/**
 * 【海龜湯 V2 - 結算增強版】揭曉答案並顯示結算介面
 */
async function revealStsAnswer() {
    if (!seaTurtleSoupState.isActive) return;
    
    // 1. 標記遊戲結束
    seaTurtleSoupState.isActive = false; // 確保遊戲狀態變為非啟動
    seaTurtleSoupState.phase = 'reveal';
    
    // 2. 隱藏遊戲中的操作區域
    document.getElementById('sts-action-area').style.visibility = 'hidden';
    
    // 3. 準備複盤內容
    const summaryText = generateStsSummary();
    
    // 4. 顯示結算彈窗
    showStsSummaryModal(summaryText);
}
// ▼▼▼ 【全新】海龜湯結算與分享功能函數 ▼▼▼

/**
 * 生成海龜湯的複盤文本
 * @returns {string} 格式化後的複盤Markdown文本
 */
function generateStsSummary() {
    let summaryText = `**海龜湯 - 遊戲複盤**\n\n`;
    summaryText += `**出題人:** ${seaTurtleSoupState.riddleProvider.name}\n\n`;
    summaryText += `**謎面:**\n${seaTurtleSoupState.riddle}\n\n`;
    summaryText += `**謎底:**\n${seaTurtleSoupState.answer}`;
    return summaryText;
}

/**
 * 顯示遊戲結算卡片模態框
 * @param {string} summaryText - 複盤文本
 */
function showStsSummaryModal(summaryText) {
    const modal = document.getElementById('sts-summary-modal');
    const contentEl = document.getElementById('sts-summary-content');
    
    // 使用你已有的Markdown渲染函數，讓複盤更好看
    contentEl.innerHTML = renderMarkdown(summaryText);
    
    // 為按鈕綁定事件 (使用克隆節點防止重複綁定)
    const shareBtn = document.getElementById('share-sts-summary-btn');
    const newShareBtn = shareBtn.cloneNode(true);
    shareBtn.parentNode.replaceChild(newShareBtn, shareBtn);
    newShareBtn.onclick = () => openStsShareTargetPicker(summaryText);

    const backBtn = document.getElementById('back-to-hall-from-sts-btn');
    const newBackBtn = backBtn.cloneNode(true);
    backBtn.parentNode.replaceChild(newBackBtn, backBtn);
    newBackBtn.onclick = () => {
        modal.classList.remove('visible');
        showScreen('game-hall-screen');
    };

    modal.classList.add('visible');
}

/**
 * 打開複盤分享目標選擇器
 * @param {string} summaryText - 要分享的複盤文本
 */
function openStsShareTargetPicker(summaryText) {
    const modal = document.getElementById('sts-share-target-modal');
    const listEl = document.getElementById('sts-share-target-list');
    listEl.innerHTML = '';

    // 從遊戲狀態中獲取所有非出題人的AI玩家
    const aiPlayers = seaTurtleSoupState.players.filter(p => !p.isUser && !p.isProvider);

    if (aiPlayers.length === 0) {
        alert("沒有可以分享的AI玩家。");
        return;
    }

    // 渲染可選的AI玩家列表
    aiPlayers.forEach(player => {
        const item = document.createElement('div');
        item.className = 'player-selection-item'; // 複用樣式
        item.innerHTML = `
            <input type="checkbox" class="sts-target-checkbox" value="${player.id}" checked>
            <img src="${player.avatar || defaultAvatar}" alt="${player.name}">
            <span class="name">${player.name}</span>
        `;
        listEl.appendChild(item);
    });

    // 綁定按鈕事件
    const confirmBtn = document.getElementById('sts-confirm-share-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.onclick = () => {
        const selectedIds = Array.from(document.querySelectorAll('.sts-target-checkbox:checked')).map(cb => cb.value);
        if (selectedIds.length > 0) {
            sendStsSummaryToSelectedPlayers(summaryText, selectedIds);
        } else {
            alert("請至少選擇一個分享物件！");
        }
    };

    document.getElementById('sts-cancel-share-btn').onclick = () => modal.classList.remove('visible');
    document.getElementById('sts-select-all-btn').onclick = () => {
        document.querySelectorAll('.sts-target-checkbox').forEach(cb => cb.checked = true);
    };
    document.getElementById('sts-deselect-all-btn').onclick = () => {
        document.querySelectorAll('.sts-target-checkbox').forEach(cb => cb.checked = false);
    };

    modal.classList.add('visible');
}

/**
 * 將遊戲複盤發送到【選定】的AI角色的聊天中
 * @param {string} summaryText - 複盤文本
 * @param {string[]} targetIds - 目標AI角色的ID陣列
 */
async function sendStsSummaryToSelectedPlayers(summaryText, targetIds) {
    // 關閉所有可能打開的彈窗
    document.getElementById('sts-summary-modal').classList.remove('visible');
    document.getElementById('sts-share-target-modal').classList.remove('visible');

    let sentCount = 0;
    const aiContext = `[系統指令：剛剛結束了一局海龜湯，這是遊戲複盤。請根據這個複盤內容，以你的角色人設，和用戶聊聊剛才的遊戲。]\n\n${summaryText}`;

    for (const chatId of targetIds) {
        const chat = state.chats[chatId];
        if (chat) {
            // 創建對使用者可見的複盤卡片消息
            const visibleMessage = {
                role: 'user',
                type: 'text',
                timestamp: Date.now(),
                content: summaryText
            };
            
            // 創建對AI可見的隱藏指令
            const hiddenInstruction = {
                role: 'system',
                content: aiContext,
                timestamp: Date.now() + 1,
                isHidden: true
            };
            
            chat.history.push(visibleMessage, hiddenInstruction);
            await db.chats.put(chat);
            sentCount++;
        }
    }
    
    await showCustomAlert("分享成功", `遊戲複盤已分享至 ${sentCount} 位AI玩家的聊天中！`);
    showScreen('game-hall-screen');
}

// ▲▲▲ 新增函數結束 ▲▲▲

/**
 * 【輔助函數】計算兩個字串的簡單相似度
 */
function simpleSimilarity(str1, str2) {
    const set1 = new Set(str1.split(''));
    const set2 = new Set(str2.split(''));
    const intersection = new Set([...set1].filter(x => set2.has(x)));
    return intersection.size / Math.max(set1.size, set2.size);
}

// ▲▲▲ 海龜湯功能函數結束 ▲▲▲
// ▼▼▼ 【全新】這裡是劇本殺遊戲的所有核心功能函數 ▼▼▼


/**
 * 【劇本殺】打開遊戲設置介面
 */
async function openScriptKillSetup() {
    showScreen('script-kill-setup-screen');
    
    const scriptSelect = document.getElementById('script-kill-script-select');
    scriptSelect.innerHTML = '<option value="">-- 請選擇劇本 --</option>';

    // --- ▼▼▼ 核心修改在這裡 ▼▼▼ ---
    
    // 1. 遍歷我們創建的內置劇本庫
    BUILT_IN_SCRIPTS.forEach(script => {
        const option = document.createElement('option');
        option.value = script.id; // value 是劇本的唯一ID
        option.textContent = `【內置】${script.name}`; // 顯示的文本
        scriptSelect.appendChild(option);
    });

    // 2. 載入並顯示自訂劇本
    const customScripts = await db.scriptKillScripts.toArray();
    customScripts.forEach(script => {
        const option = document.createElement('option');
        option.value = script.id;
        option.textContent = `【自訂】${script.name}`;
        scriptSelect.appendChild(option);
    });
    
    // --- ▲▲▲ 修改結束 ▲▲▲ ---
    // 渲染玩家選擇列表
    const selectionEl = document.getElementById('script-kill-player-selection');
    selectionEl.innerHTML = '<p>正在載入角色列表...</p>';

    const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    const allNpcs = Object.values(state.chats).flatMap(chat => (chat.npcLibrary || []).map(npc => ({...npc, owner: chat.name})));

    let playerOptions = [
        ...singleChats.map(c => ({ id: c.id, name: c.name, avatar: c.settings.aiAvatar, type: '角色' })),
        ...allNpcs.map(n => ({ id: n.id, name: n.name, avatar: n.avatar, type: `NPC (${n.owner})` }))
    ];

    selectionEl.innerHTML = '';
    playerOptions.forEach(player => {
        const item = document.createElement('div');
        item.className = 'player-selection-item'; // 複用樣式
        item.innerHTML = `
            <input type="checkbox" class="script-kill-player-checkbox" value="${player.id}">
            <img src="${player.avatar || defaultAvatar}" alt="${player.name}">
            <span class="name">${player.name}</span>
            <span class="type-tag">${player.type}</span>
        `;
        selectionEl.appendChild(item);
    });
}
// ▼▼▼ 在這裡開始黏貼 ▼▼▼

/**
 * 【劇本殺】顯示角色選擇彈窗，讓用戶選擇角色
 * @param {string} title - 彈窗標題
 * @param {Array<object>} options - 角色選項陣列 [{text, value}]
 * @returns {Promise<number|null>} - 返回使用者選擇的角色的索引，如果取消則返回null
 */
async function showRoleSelectionModal(title, options) {
    return new Promise(resolve => {
        const modal = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('custom-modal-title');
        const modalBody = document.getElementById('custom-modal-body');
        const modalConfirmBtn = document.getElementById('custom-modal-confirm');
        const modalCancelBtn = document.getElementById('custom-modal-cancel');

        modalTitle.textContent = title;
        
        let optionsHtml = '<div style="text-align: left; max-height: 400px; overflow-y: auto;">';
        options.forEach((option, index) => {
            optionsHtml += `
                <label style="display: block; padding: 10px; border-bottom: 1px solid #eee; cursor: pointer;">
                    <input type="radio" name="role_selection" value="${option.value}" ${index === 0 ? 'checked' : ''}>
                    ${option.text}
                </label>
            `;
        });
        optionsHtml += '</div>';

        modalBody.innerHTML = optionsHtml;
        modalConfirmBtn.textContent = '確認選擇';
        modalCancelBtn.style.display = 'block';

        modal.classList.add('visible');

        modalConfirmBtn.onclick = () => {
            const selectedRadio = document.querySelector('input[name="role_selection"]:checked');
            if (selectedRadio) {
                modal.classList.remove('visible');
                resolve(parseInt(selectedRadio.value));
            } else {
                alert("請選擇一個角色！");
            }
        };
        
        modalCancelBtn.onclick = () => {
            modal.classList.remove('visible');
            resolve(null);
        };
    });
}


/**
 * 【劇本殺】開始遊戲的核心邏輯 (V3 - 玩家自選，AI隨機版)
 */
async function startScriptKillGame() {
    const scriptId = document.getElementById('script-kill-script-select').value;
    if (!scriptId) {
        alert('請先選擇一個劇本！');
        return;
    }
// ▼▼▼ 用這塊【已修復】的代碼替換舊的 if/else 邏輯 ▼▼▼
    let script;
    // 【核心修改】我們不再只檢查 'built_in_1'，而是檢查 scriptId 是否以 'built_in_' 開頭
    if (scriptId.startsWith('built_in_')) {
        // 如果是，就調用 getBuiltInScript 函數，並將正確的ID傳進去
        script = getBuiltInScript(scriptId); 
    } else {
        // 否則，說明是自訂劇本，才去資料庫裡查找
        script = await db.scriptKillScripts.get(parseInt(scriptId));
    }
// ▲▲▲ 替換結束 ▲▲▲
    if (!script) {
        alert('載入劇本失敗！');
        return;
    }

    const selectedCheckboxes = document.querySelectorAll('.script-kill-player-checkbox:checked');
    const requiredPlayers = script.roles.length - 1;
    if (selectedCheckboxes.length !== requiredPlayers) {
        alert(`此劇本需要您邀請 ${requiredPlayers} 位AI或NPC玩家！`);
        return;
    }
    
    await showCustomAlert("請稍候...", "正在分配角色，請耐心等待...");

    // 1. 初始化遊戲狀態
    scriptKillGameState = {
        isActive: true,
        script: script,
        players: [],
        gamePhase: 'start',
        turnIndex: 0,
        gameLog: [],
        evidenceCounts: {},
        votes: {},
        isFreeChoice: document.getElementById('script-kill-free-choice-toggle').checked,
        discussionRound: 1, // <--- ★★★ 在這裡添加這一行 ★★★
        collectedClueIds: new Set() 
    };
    // 2. 收集玩家資訊 (這部分不變)
    let invitedPlayers = [];
    selectedCheckboxes.forEach(checkbox => {
        const playerId = checkbox.value;
        const chat = Object.values(state.chats).find(c => c.id === playerId);
        if (chat) {
            invitedPlayers.push({ id: chat.id, name: chat.name, avatar: chat.settings.aiAvatar, persona: chat.settings.aiPersona, isUser: false });
        } else {
            for (const c of Object.values(state.chats)) {
                const npc = (c.npcLibrary || []).find(n => n.id === playerId);
                if (npc) {
                    invitedPlayers.push({ id: npc.id, name: npc.name, avatar: npc.avatar, persona: npc.persona, isUser: false });
                    break;
                }
            }
        }
    });
    const userPlayer = {
        id: 'user', name: state.qzoneSettings.nickname || '我',
        avatar: state.qzoneSettings.avatar || defaultAvatar, isUser: true, persona: '一個喜歡探案的普通人'
    };

    // --- 3. 【核心改造】根據開關狀態，執行不同的分配邏輯 ---
    const assignedRoles = new Map(); // 使用Map存儲 {playerId -> roleObject}
    let remainingRoles = [...script.roles]; // 創建一個可修改的角色列表副本

    if (scriptKillGameState.isFreeChoice) {
        // --- 自由選擇模式 (玩家自選，AI隨機) ---
        
        // 3a. 用戶先從所有角色中選擇一個
        const roleOptions = remainingRoles.map((role, index) => ({
            text: `【${role.name}】: ${role.description.substring(0, 40)}...`,
            value: index
        }));
        const userChoiceIndex = await showRoleSelectionModal("請選擇你的角色", roleOptions);
        if (userChoiceIndex === null) {
            hideCustomModal(); 
            alert("你取消了角色選擇，遊戲未開始。");
            return;
        }
        // 從角色池中移除用戶選擇的角色，並分配給用戶
        const userChosenRole = remainingRoles.splice(userChoiceIndex, 1)[0];
        assignedRoles.set(userPlayer.id, userChosenRole);

        // 3b. 【【【這就是本次的核心修改！】】】
        // 將剩餘的角色【隨機打亂】
        remainingRoles.sort(() => Math.random() - 0.5); 
        // 然後【按順序】分配給AI們
        invitedPlayers.forEach((aiPlayer, index) => {
            assignedRoles.set(aiPlayer.id, remainingRoles[index]);
        });

    } else {
        // --- 隨機分配模式 (舊邏輯保持不變) ---
        const allGamePlayers = [userPlayer, ...invitedPlayers];
        allGamePlayers.sort(() => Math.random() - 0.5);
        const shuffledRoles = [...script.roles].sort(() => Math.random() - 0.5);
        allGamePlayers.forEach((player, index) => {
            assignedRoles.set(player.id, shuffledRoles[index]);
        });
    }

    // 4. 組合最終的玩家清單 (這部分不變)
    const allPlayersWithRoles = [userPlayer, ...invitedPlayers].map(player => ({
        ...player,
        role: assignedRoles.get(player.id),
        evidence: []
    }));
    scriptKillGameState.players = allPlayersWithRoles;

    // 5. 顯示身份給使用者 (這部分不變)
    const myPlayer = scriptKillGameState.players.find(p => p.isUser);
    hideCustomModal(); 
    await showCustomAlert(
        `你的角色是：【${myPlayer.role.name}】`,
        `**角色介紹:**\n${myPlayer.role.description}\n\n**你的任務:**\n${myPlayer.role.tasks}`
    );

    // 6. 切換到遊戲介面並開始 (這部分不變)
    showScreen('script-kill-game-screen');
    await processScriptKillTurn();
}

// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 【最終流程版】請用這整塊代碼，完整替換舊的 processScriptKillTurn 函數 ▼▼▼
/**
 * 【劇本殺 V4 - 最終流程引擎】遊戲主迴圈/引擎
 */
async function processScriptKillTurn() {
    if (!scriptKillGameState.isActive) return;
    renderScriptKillGameScreen();

    switch (scriptKillGameState.gamePhase) {
        case 'start':
            logToScriptKillGame(`遊戲開始！劇本：【${scriptKillGameState.script.name}】`, 'system');
            await sleep(1000);
            logToScriptKillGame(`【故事背景】\n${scriptKillGameState.script.storyBackground}`, 'system');
            await sleep(3000);
            logToScriptKillGame('請各位玩家查看自己的角色資訊，準備進行自我介紹。', 'system');
            scriptKillGameState.gamePhase = 'introduction';
            await sleep(2000);
            await processScriptKillTurn();
            break;

        case 'introduction':
            logToScriptKillGame('現在開始輪流進行自我介紹。', 'system');
            for (const player of scriptKillGameState.players) {
                renderScriptKillGameScreen({ speakingPlayerId: player.id });
                let introduction = player.isUser
                    ? await waitForUserActionSK('輪到你自我介紹了', 'speak', '簡單介紹一下你自己和你所扮演的角色...')
                    : await triggerScriptKillAiAction(player.id, 'introduce');
                logToScriptKillGame({ player: player, speech: introduction }, 'speech');
                await sleep(1000);
            }
            renderScriptKillGameScreen();
            logToScriptKillGame('自我介紹結束，現在請各位玩家分享自己的時間線。', 'system');
            scriptKillGameState.gamePhase = 'timeline_discussion';
            await sleep(2000);
            await processScriptKillTurn();
            break;

        case 'timeline_discussion':
            logToScriptKillGame('請各位玩家輪流發言，梳理並公開自己的時間線。', 'system');
            await sleep(1500);
            for (const player of scriptKillGameState.players) {
                renderScriptKillGameScreen({ speakingPlayerId: player.id });
                let timelineSpeech = player.isUser
                    ? await waitForUserActionSK('輪到你陳述時間線了', 'speak', '請根據你的劇本，詳細說明你的行動軌跡...')
                    : await triggerScriptKillAiAction(player.id, 'discuss_timeline');
                logToScriptKillGame({ player: player, speech: timelineSpeech }, 'speech');
                await sleep(1000);
            }
            renderScriptKillGameScreen();
            logToScriptKillGame('時間線陳述結束，現在進入【第一輪搜證環節】。', 'system');
            scriptKillGameState.gamePhase = 'evidence_round_1';
            await processScriptKillTurn();
            break;

        case 'evidence_round_1':
            updateActionAreaSK();
            logToScriptKillGame('進入第一輪搜證，每位玩家有【2次】搜證機會。', 'system');
            await sleep(2000);
            
            // 【核心修改】AI 進行第一輪的第1次搜證
            for (const player of scriptKillGameState.players) {
                if (player.isUser) continue;
                logToScriptKillGame(`輪到 ${player.role.name} (${player.name}) 進行第1次搜證...`);
                await sleep(2000);
                await handleAiSearch(player);
            }
            // 【核心修改】AI 進行第一輪的第2次搜證
            for (const player of scriptKillGameState.players) {
                 if (player.isUser) continue;
                logToScriptKillGame(`輪到 ${player.role.name} (${player.name}) 進行第2次搜證...`);
                await sleep(2000);
                await handleAiSearch(player);
            }
            logToScriptKillGame('所有AI搜證完畢，玩家可以繼續搜證或結束本環節進入討論。', 'system');
            break;

        case 'discussion_round_1':
            logToScriptKillGame('第一輪搜證結束，現在進入【第一輪討論環節】。', 'system');
            updateActionAreaSK();
            break;

        case 'evidence_round_2':
            updateActionAreaSK();
            logToScriptKillGame('第一輪討論結束，現在進入【第二輪搜證環節】。', 'system');
            logToScriptKillGame('根據剛才的討論，各位玩家現在還有【1次】搜證機會。', 'system');
            await sleep(2000);
            
            // 【核心修改】AI 進行第二輪的唯一次搜證
            for (const player of scriptKillGameState.players) {
                if (player.isUser) continue;
                const searchCount = scriptKillGameState.evidenceCounts[player.id] || 0;
                if(searchCount < 3) { // 確保AI也有次數限制
                    logToScriptKillGame(`輪到 ${player.role.name} (${player.name}) 進行補充搜證...`);
                    await sleep(2000);
                    await handleAiSearch(player);
                }
            }
            logToScriptKillGame('所有AI補充搜證完畢，玩家可以繼續搜證或結束本環節進入最終討論。', 'system');
            break;

        // 【全新階段】第二輪討論
        case 'discussion_round_2':
            logToScriptKillGame('第二輪搜證結束，現在進入【第二輪討論環節】。', 'system');
            updateActionAreaSK(); // 顯示發言按鈕
            break;

        // 【全新階段】第三輪（最終）討論
        case 'discussion_round_3':
            logToScriptKillGame('第二輪討論結束，現在進入【最終討論環節】。', 'system');
            updateActionAreaSK(); // 再次顯示發言按鈕
            break;
            
        case 'voting':
            // 投票和結束邏輯保持不變
            logToScriptKillGame('最終討論結束，現在進入投票環節。請投票指認兇手！', 'system');
            const detailedVotes = {}; 
            const alivePlayers = scriptKillGameState.players;
            for (const voter of alivePlayers) {
                let targetId = voter.isUser
                    ? await waitForUserActionSK('請投票指認兇手', 'vote')
                    : await triggerScriptKillAiAction(voter.id, 'vote');
                detailedVotes[voter.id] = targetId;
                if (targetId) {
                    const targetPlayer = scriptKillGameState.players.find(p => p.id === targetId);
                    logToScriptKillGame(`${voter.name} 投票給了 ${targetPlayer.name}。`);
                } else {
                    logToScriptKillGame(`${voter.name} 棄票了。`);
                }
            }
            scriptKillGameState.votes = detailedVotes;
            scriptKillGameState.gamePhase = 'end';
            await sleep(2000);
            await processScriptKillTurn();
            break;

        case 'end':
            // 結束邏輯保持不變
            logToScriptKillGame('投票結束，正在公佈真相...', 'system');
            await sleep(2000);
            const voteCounts = {};
            for (const voterId in scriptKillGameState.votes) {
                const targetId = scriptKillGameState.votes[voterId];
                if (targetId) { voteCounts[targetId] = (voteCounts[targetId] || 0) + 1; }
            }
            let maxVotes = 0, votedPlayerIds = [];
            for (const playerId in voteCounts) {
                if (voteCounts[playerId] > maxVotes) {
                    maxVotes = voteCounts[playerId];
                    votedPlayerIds = [playerId];
                } else if (voteCounts[playerId] === maxVotes) {
                    votedPlayerIds.push(playerId);
                }
            }
            const killer = scriptKillGameState.players.find(p => p.role.isKiller);
            let winner = '', resultText = '';
            if (votedPlayerIds.length === 1 && votedPlayerIds[0] === killer.id) {
                winner = '好人陣營';
                resultText = `恭喜！你們成功指認出兇手【${killer.role.name} (${killer.name})】！好人陣營勝利！`;
            } else {
                winner = '兇手陣營';
                resultText = `很遺憾，真正的兇手是【${killer.role.name} (${killer.name})】！兇手陣營勝利！`;
            }
            logToScriptKillGame(resultText, 'system');
            await sleep(3000);
            logToScriptKillGame(`【真相】\n${scriptKillGameState.script.truth}`, 'system');
            await showCustomAlert("請稍候...", "AI正在生成本局複盤摘要...");
            const aiSummary = await generateAiSkSummary();
            const summary = generateSkSummary(winner, aiSummary);
            showScriptKillSummaryModal(summary); 
            scriptKillGameState.isActive = false;
            updateActionAreaSK(); 
            break;
    }
}
// ▲▲▲ 替換結束 ▲▲▲



/**
 * 【劇本殺】渲染遊戲主介面
 */
function renderScriptKillGameScreen(options = {}) {
    // 這部分和狼人殺的渲染函數非常相似，我們直接複用
    const playersGrid = document.getElementById('script-kill-players-grid');
    const logContainer = document.getElementById('script-kill-game-log');
    
    playersGrid.innerHTML = '';
    scriptKillGameState.players.forEach(player => {
        const seat = document.createElement('div');
        seat.className = 'player-seat';
        const avatarClass = `player-avatar ${options.speakingPlayerId === player.id ? 'speaking' : ''}`;
        
        seat.innerHTML = `
            <img src="${player.avatar}" class="${avatarClass}">
            <span class="player-name">${player.role.name}</span>
        `;
        playersGrid.appendChild(seat);
    });

    logContainer.innerHTML = '';
    scriptKillGameState.gameLog.forEach(log => {
        const logEl = document.createElement('div');
        if (log.type === 'speech') {
            logEl.className = 'log-entry speech';
            const { player, speech } = log.message;
            logEl.innerHTML = `
                <img src="${player.avatar}" class="speech-avatar">
                <div class="speech-content">
                    <span class="speaker">${player.role.name} (${player.name})</span>
                    <span class="speech-text">${speech.replace(/\n/g, '<br>')}</span>
                </div>
            `;
        } else {
            logEl.className = `log-entry ${log.type}`;
            logEl.innerHTML = String(log.message).replace(/\n/g, '<br>');
        }
        logContainer.appendChild(logEl);
    });
    logContainer.scrollTop = logContainer.scrollHeight;
}

/**
 * 【劇本殺】添加一條遊戲日誌
 */
function logToScriptKillGame(message, type = 'system') {
    scriptKillGameState.gameLog.push({ message, type });
    renderScriptKillGameScreen();
}

/**
 * 【劇本殺 V4 - 新流程版】更新底部操作區域的按鈕
 */
function updateActionAreaSK() {
    const actionArea = document.getElementById('script-kill-action-area');
    actionArea.innerHTML = '';
    const user = scriptKillGameState.players.find(p => p.isUser);
    
    const phase = scriptKillGameState.gamePhase;
    const searchCount = scriptKillGameState.evidenceCounts[user.id] || 0;

    if (phase === 'evidence_round_1' || phase === 'evidence_round_2') {
        let searchesLeftInRound, totalInRound;
        if (phase === 'evidence_round_1') {
            searchesLeftInRound = 2 - searchCount;
            totalInRound = 2;
        } else { // evidence_round_2
            searchesLeftInRound = 3 - searchCount;
            totalInRound = 1;
        }
        
        const searchBtn = document.createElement('button');
        searchBtn.id = 'sk-search-evidence-btn';
        searchBtn.className = 'form-button';
        searchBtn.textContent = `搜證 (${searchesLeftInRound}/${totalInRound})`;
        searchBtn.disabled = searchesLeftInRound <= 0;
        actionArea.appendChild(searchBtn);
        
        const endSearchBtn = document.createElement('button');
        endSearchBtn.id = 'sk-end-search-btn';
        endSearchBtn.className = 'form-button-secondary';
        endSearchBtn.textContent = (phase === 'evidence_round_1') ? '進入第一輪討論' : '進入第二輪討論';
        actionArea.appendChild(endSearchBtn);

    } else if (phase === 'discussion_round_1' || phase === 'discussion_round_2' || phase === 'discussion_round_3') {
        const speakBtn = document.createElement('button');
        speakBtn.id = 'sk-speak-btn';
        speakBtn.className = 'form-button';
        speakBtn.textContent = '我要發言';
        actionArea.appendChild(speakBtn);
    } else if (!scriptKillGameState.isActive && phase === 'end') {
        const backBtn = document.createElement('button');
        backBtn.className = 'form-button';
        backBtn.textContent = '返回遊戲大廳';
        backBtn.onclick = () => showScreen('game-hall-screen');
        actionArea.appendChild(backBtn);
    }
}



// ▼▼▼ 【劇本殺輸入框美化版】請用這個【全新】的函數，完整替換掉你舊的 waitForUserActionSK 函數 ▼▼▼
/**
 * 【劇本殺 V2 - 輸入框美化版】等待使用者行動的通用函數
 */
function waitForUserActionSK(promptText, actionType, placeholder = '') {
    return new Promise(resolve => {
        const actionArea = document.getElementById('script-kill-action-area');
        actionArea.innerHTML = '';
        actionArea.className = 'script-kill-action-area'; // 重置class

        if (actionType === 'speak') {
            // --- 這是我們美化後的發言輸入區 ---
            actionArea.classList.add('speaking-mode'); // 啟動新CSS

            const textarea = document.createElement('textarea');
            textarea.id = 'user-sk-speech-input'; // 使用劇本殺專用的ID
            textarea.rows = 1;
            textarea.placeholder = placeholder || '請輸入你的發言...';
            // 即時調整高度
            textarea.addEventListener('input', () => {
                textarea.style.height = 'auto';
                textarea.style.height = (textarea.scrollHeight) + 'px';
            });

            const endBtn = document.createElement('button');
            endBtn.id = 'sk-end-speech-btn'; // 使用劇本殺專用的ID
            endBtn.className = 'form-button';
            endBtn.textContent = '結束發言';

            actionArea.appendChild(textarea);
            actionArea.appendChild(endBtn);
            
            textarea.focus();

            endBtn.onclick = () => {
                const speech = textarea.value.trim() || "我沒什麼好說的，過。";
                actionArea.innerHTML = '';
                actionArea.classList.remove('speaking-mode');
                resolve(speech);
            };
            return; // 結束 'speak' 分支
        } 
        
        // --- 以下是投票邏輯，保持原樣 ---
        else if (actionType === 'vote') {
            const modal = document.getElementById('script-kill-vote-modal');
            const optionsEl = document.getElementById('sk-vote-options-list');
            optionsEl.innerHTML = '';
            
            scriptKillGameState.players.forEach(player => {
                const label = document.createElement('label');
                label.innerHTML = `<input type="radio" name="sk_vote_target" value="${player.id}"> ${player.role.name} (${player.name})`;
                optionsEl.appendChild(label);
            });
            
            document.getElementById('confirm-sk-vote-btn').onclick = () => {
                const selected = document.querySelector('input[name="sk_vote_target"]:checked');
                if (selected) {
                    modal.classList.remove('visible');
                    resolve(selected.value);
                } else {
                    alert('請選擇一個投票物件！');
                }
            };
            document.getElementById('cancel-sk-vote-btn').onclick = () => {
                modal.classList.remove('visible');
                resolve(null); // 用戶取消
            };
            modal.classList.add('visible');
        }
    });
}
// ▲▲▲ 替換結束 ▲▲▲
/**
 * 【全新】處理單個AI的搜證行動 (每次只搜一個線索)
 * @param {object} player - 正在行動的AI玩家物件
 */
async function handleAiSearch(player) {
    const script = scriptKillGameState.script;
    
    // 消耗一次搜證機會
    scriptKillGameState.evidenceCounts[player.id] = (scriptKillGameState.evidenceCounts[player.id] || 0) + 1;
    
    let foundMessage = ''; // 用於記錄本輪搜證的結果

    // 1. 增加隨機性：有30%的幾率什麼都搜不到
    if (Math.random() < 0.30) {
        foundMessage = "什麼都沒發現。";
    } else {
        // 2. 找出所有【全域還未被發現】的線索
        const uncollectedClues = script.clues.filter(c => !scriptKillGameState.collectedClueIds.has(c.description));

        if (uncollectedClues.length > 0) {
            // 3. 隨機找到一條新線索
            const foundClue = uncollectedClues[Math.floor(Math.random() * uncollectedClues.length)];
            const clueSource = foundClue.owner === '公共' ? '公共區域' : `角色 ${foundClue.owner} 的私人物品`;
            
            // 4. 將線索存入AI手牌和全域線索池
            player.evidence.push({ description: foundClue.description, source: clueSource });
            scriptKillGameState.collectedClueIds.add(foundClue.description);

            let revealed = true; // 默認公開

            // 5. 如果線索是關於自己的，讓AI決策是否公開
            if (foundClue.owner === player.role.name) {
                const revealDecision = await triggerScriptKillAiAction(player.id, 'reveal_clue', { clue: foundClue.description });
                if (revealDecision && revealDecision.action === 'hide') {
                    revealed = false;
                }
            }
            
            // 6. 根據AI的決策，記錄不同的搜證結果
            if (revealed) {
                foundMessage = `在【${clueSource}】發現並公開了線索：“${foundClue.description}”`;
            } else {
                foundMessage = `在【${clueSource}】發現了一條關於自己的線索，並選擇將其隱藏。`;
            }
        } else {
            foundMessage = "沒有發現更多新線索了。";
        }
    }
    
    // 7. 將搜證結果記錄到遊戲日誌
    logToScriptKillGame(`${player.name} 完成了一次搜證: ${foundMessage}`);
    await sleep(1500);
}

/**
 * 【劇本殺-AI核心】觸發AI行動
 */
async function triggerScriptKillAiAction(playerId, action, context = {}) {
    const player = scriptKillGameState.players.find(p => p.id === playerId);
    if (!player) return;
    
    const { proxyUrl, apiKey, model } = state.apiConfig;

// ▼▼▼ 請用下面這【一整塊】代碼，完整替換掉舊的 systemPrompt 變數定義 ▼▼▼
    let jsonFormat = '';
    let extraContext = '';
    let systemPrompt = `
# 任務: 劇本殺角色扮演
# 你的雙重身份 (必須嚴格遵守)
1.  **你的本體**: 你的真實身份是 **${player.name}**，你的核心性格是：**${player.persona}**。
2.  **你的劇本角色**: 在這場遊戲中，你需要扮演角色 **【${player.role.name}】**。
    -   **劇本身份設定**: ${player.role.description}
    -   **你的故事線 (時間線)**: ${player.role.storyline} 
    -   **劇本秘密任務**: ${player.role.tasks}

# 你已掌握的線索: 
${player.evidence.map(e => `- ${e.description}`).join('\n') || "(暫無線索)"}

# 當前遊戲階段: ${scriptKillGameState.gamePhase}
# 遊戲日誌 (最近50條):
${scriptKillGameState.gameLog.slice(-50).map(log => {
    if(log.type === 'speech') return `${log.message.player.role.name}: ${log.message.speech}`;
    return log.message;
}).join('\n')}
${extraContext}
# 你的行動指令
`;

// ▲▲▲ 替換結束 ▲▲▲


    switch(action) {
        case 'introduce':
            systemPrompt += '現在輪到你進行自我介紹。請根據你的人設，以第一人稱進行一段簡短的介紹。';
            jsonFormat = '{"action": "speak", "speech": "你的自我介紹..."}';
            break;
                    // ▼▼▼ 【全新】在這裡為AI添加“討論時間線”的新指令 ▼▼▼
        case 'discuss_timeline':
            systemPrompt += '現在是時間線陳述環節。請根據你的角色劇本（包括身份設定和秘密任務），詳細、清晰地陳述你在案發時間段內的行動軌跡。你的發言必須是第一人稱，並且要聽起來自然，可以適當隱藏對你不利的資訊，但不能憑空捏造。';
            jsonFormat = '{"action": "speak", "speech": "你的時間線陳述..."}';
            break;
        // ▲▲▲ 新增指令結束 ▲▲▲
        case 'discuss':
            systemPrompt += '現在是自由討論環節。請根據你掌握的線索和場上其他人的發言，發表你的看法、提出疑問或指證他人。';
            jsonFormat = '{"action": "speak", "speech": "你的發言..."}';
            break;
        case 'vote':
            systemPrompt += '現在是最終投票環節。請綜合所有資訊，投出你認為的兇手。';
            jsonFormat = '{"action": "vote", "targetId": "你投票的玩家ID"}';
            break;
            // ▼▼▼ 在 triggerScriptKillAiAction 函數的 switch 語句內添加這個 case ▼▼▼
case 'reveal_clue':
    systemPrompt += `你剛剛搜到了一個關於你自己的線索：“${context.clue}”。\n公開這條線索可能會讓你暴露，但也可能洗清嫌疑；隱藏它可能會讓你在後期被動。\n請根據你的人設和任務，決定是公開還是隱藏。`;
    jsonFormat = '{"action": "reveal" or "hide", "reasoning": "你的決策理由..."}';
    break;
// ▲▲▲ 添加結束 ▲▲▲
    }
    
    systemPrompt += `\n# 存活玩家列表:\n${scriptKillGameState.players.map(p => `- ${p.role.name} (id: ${p.id})`).join('\n')}\n# 輸出格式: 你的回復【必須且只能】是一個嚴格的JSON物件，格式如下:\n${jsonFormat}`;

    try {
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model, messages: messagesForApi, temperature: 1.0, response_format: { type: "json_object" } })
            });
        
        if (!response.ok) throw new Error(await response.text());
        const data = await response.json();
        const content = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, '');
// ▼▼▼ 用這塊新代碼替換舊的 return 邏輯 ▼▼▼
const aiAction = JSON.parse(content);

if (aiAction.action === 'speak') return aiAction.speech;
if (aiAction.action === 'vote') return aiAction.targetId;
if (action === 'reveal_clue') return aiAction; // 【核心修改】返回整個決策物件

return null;
// ▲▲▲ 替換結束 ▲▲▲
    } catch (error) {
        console.error(`AI (${player.name}) 行動失敗:`, error);
        // 返回一個保底的行動，防止遊戲卡死
        if (action === 'vote') {
            const potentialTargets = scriptKillGameState.players.filter(p => p.id !== player.id);
            return potentialTargets[Math.floor(Math.random() * potentialTargets.length)].id;
        }
        return "我...我需要再想想。";
    }
}

// ▼▼▼ 用這塊新代碼替換舊的 getBuiltInScript 函數 ▼▼▼

/**
 * 【劇本殺】根據ID獲取一個內置劇本
 * @param {string} scriptId - 要獲取的劇本的ID, 例如 'built_in_1'
 * @returns {object|null} - 找到的劇本對象，或 null
 */
function getBuiltInScript(scriptId) {
    // 【核心修改】我們現在從 BUILT_IN_SCRIPTS 陣列中查找匹配的劇本
    return BUILT_IN_SCRIPTS.find(script => script.id === scriptId) || null;
}

// ▲▲▲ 替換結束 ▲▲▲


// --- 【全新】劇本殺自訂劇本管理核心功能 ---

let editingScriptId = null; // 用於追蹤正在編輯的劇本ID

/**
 * 【總入口】打開自訂劇本管理模態框
 */
async function openScriptManager() {
    await renderScriptManagerList();
    document.getElementById('script-kill-manager-modal').classList.add('visible');
}

/**
 * 渲染自訂劇本列表
 */
async function renderScriptManagerList() {
    const listEl = document.getElementById('custom-scripts-list');
    listEl.innerHTML = '';
    const scripts = await db.scriptKillScripts.toArray();

    if (scripts.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">還沒有自訂劇本，點擊右上角“添加”創建一個吧！</p>';
        return;
    }

    scripts.forEach(script => {
        const item = document.createElement('div');
        item.className = 'list-item'; // 複用現有樣式
        item.innerHTML = `
            <div class="item-title">${script.name}</div>
            <div class="item-content">${(script.storyBackground || '暫無簡介').substring(0, 50)}...</div>
        `;
        // 為整個列表項添加點擊事件，用於編輯
        item.addEventListener('click', () => openScriptEditorForEdit(script.id));
        // 為列表項添加長按事件，用於刪除
        addLongPressListener(item, () => deleteCustomScript(script.id, script.name));
        listEl.appendChild(item);
    });
}

/**
 * 打開劇本編輯器（用於創建新劇本）
 */
function openScriptEditorForCreate() {
    editingScriptId = null; // 標記為創建模式
    document.getElementById('script-editor-title').textContent = '創建新劇本';
    document.getElementById('script-name-input').value = '';
    document.getElementById('script-background-input').value = '';
    // 提供一個JSON結構示例，方便使用者填寫
    const jsonExample = {
        roles: [
            { name: "角色A", description: "...", tasks: "...", isKiller: true },
            { name: "角色B", description: "...", tasks: "...", isKiller: false }
        ],
        clues: [
            { owner: "角色A", description: "線索描述...", isKey: false },
            { owner: "公共", description: "公共線索..." }
        ],
        truth: "真相是..."
    };
    document.getElementById('script-roles-json-input').value = JSON.stringify(jsonExample, null, 2);
    
    document.getElementById('script-kill-editor-modal').classList.add('visible');
}

/**
 * 打開劇本編輯器（用於編輯現有劇本）
 * @param {number} scriptId - 要編輯的劇本ID
 */
async function openScriptEditorForEdit(scriptId) {
    editingScriptId = scriptId;
    const script = await db.scriptKillScripts.get(scriptId);
    if (!script) return;

    document.getElementById('script-editor-title').textContent = `編輯劇本: ${script.name}`;
    document.getElementById('script-name-input').value = script.name;
    document.getElementById('script-background-input').value = script.storyBackground;
    
    // 將 roles, clues, truth 重新組合成一個物件並格式化為JSON
    const jsonData = {
        roles: script.roles,
        clues: script.clues,
        truth: script.truth
    };
    document.getElementById('script-roles-json-input').value = JSON.stringify(jsonData, null, 2);

    document.getElementById('script-kill-editor-modal').classList.add('visible');
}

// ▼▼▼ 用這塊【視覺化版】代碼，替換舊的 saveCustomScript 函數 ▼▼▼
/**
 * 【視覺化版】保存或更新自訂劇本
 */
async function saveCustomScript() {
    const name = document.getElementById('script-name-input').value.trim();
    const background = document.getElementById('script-background-input').value.trim();
    const truth = document.getElementById('sk-truth-input').value.trim();

    if (!name || !background || !truth) {
        alert('劇本名稱、故事背景和最終真相都不能為空！');
        return;
    }

    // 從 currentEditingScriptData 全域變數中獲取角色和線索資料
    if (!currentEditingScriptData.roles || currentEditingScriptData.roles.length === 0) {
        alert("請至少添加一個角色！");
        return;
    }

    try {
        const scriptData = {
            name: name,
            storyBackground: background,
            roles: currentEditingScriptData.roles,
            clues: currentEditingScriptData.clues,
            truth: truth,
            isBuiltIn: false
        };

        if (editingScriptId) {
            await db.scriptKillScripts.update(editingScriptId, scriptData);
            alert('劇本更新成功！');
        } else {
            await db.scriptKillScripts.add(scriptData);
            alert('新劇本保存成功！');
        }

        document.getElementById('script-kill-editor-modal').classList.remove('visible');
        await renderScriptManagerList(); // 刷新管理列表
        editingScriptId = null;

    } catch (error) {
        alert(`保存失敗: ${error.message}`);
    }
}
// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 把這一整塊全新的功能函數，黏貼到 init() 函數的【正上方】 ▼▼▼

// --- 【全新】劇本殺視覺化編輯器核心功能 ---

let currentEditingScriptData = { roles: [], clues: [] }; // 用於暫存正在編輯的劇本資料
let editingItemIndex = -1; // -1 表示新建，否則為被編輯項的索引

/**
 * 渲染視覺化劇本編輯器的主介面
 */
function renderVisualScriptEditor() {
    const rolesContainer = document.getElementById('sk-roles-container');
    const cluesContainer = document.getElementById('sk-clues-container');
    rolesContainer.innerHTML = '';
    cluesContainer.innerHTML = '';

    // 渲染角色列表
    currentEditingScriptData.roles.forEach((role, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'sk-editor-item';
        itemEl.innerHTML = `
            <div class="item-info">
                <div class="item-name">${role.name} ${role.isKiller ? '🔪' : ''}</div>
                <div class="item-meta">${role.description.substring(0, 20)}...</div>
            </div>
            <div class="item-actions">
                <button class="form-button-secondary edit-role-btn" data-index="${index}">編輯</button>
                <button class="form-button-secondary delete-role-btn" data-index="${index}" style="border-color:#ff3b30; color:#ff3b30;">刪除</button>
            </div>
        `;
        rolesContainer.appendChild(itemEl);
    });

    // 渲染線索列表
    currentEditingScriptData.clues.forEach((clue, index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'sk-editor-item';
        itemEl.innerHTML = `
            <div class="item-info">
                <div class="item-name">線索 ${index + 1}</div>
                <div class="item-meta">歸屬於: ${clue.owner}</div>
            </div>
            <div class="item-actions">
                <button class="form-button-secondary edit-clue-btn" data-index="${index}">編輯</button>
                <button class="form-button-secondary delete-clue-btn" data-index="${index}" style="border-color:#ff3b30; color:#ff3b30;">刪除</button>
            </div>
        `;
        cluesContainer.appendChild(itemEl);
    });
}

/**
 * 打開角色編輯器（新建或編輯）
 */
function openRoleEditor(index = -1) {
    editingItemIndex = index;
    const modal = document.getElementById('sk-item-editor-modal');
    document.getElementById('sk-role-editor-fields').style.display = 'block';
    document.getElementById('sk-clue-editor-fields').style.display = 'none';

    if (index > -1) { // 編輯模式
        const role = currentEditingScriptData.roles[index];
        document.getElementById('sk-item-editor-title').textContent = `編輯角色: ${role.name}`;
        document.getElementById('sk-role-name-input').value = role.name;
        document.getElementById('sk-role-desc-input').value = role.description;
        // ▼▼▼ 在這裡添加下面這行新代碼 ▼▼▼
        document.getElementById('sk-role-storyline-input').value = role.storyline || ''; // 使用 || '' 確保舊資料不會顯示'undefined'
        // ▲▲▲ 新代碼黏貼結束 ▲▲▲
        document.getElementById('sk-role-tasks-input').value = role.tasks;
        document.getElementById('sk-role-killer-toggle').checked = role.isKiller;
    } else { // 新建模式
        document.getElementById('sk-item-editor-title').textContent = '添加新角色';
        document.getElementById('sk-role-name-input').value = '';
        document.getElementById('sk-role-desc-input').value = '';
        // ▼▼▼ 在這裡添加下面這行新代碼 ▼▼▼
        document.getElementById('sk-role-storyline-input').value = ''; // 新建時清空
        // ▲▲▲ 新代碼黏貼結束 ▲▲▲
        document.getElementById('sk-role-tasks-input').value = '';
        document.getElementById('sk-role-killer-toggle').checked = false;
    }
    modal.classList.add('visible');
}

/**
 * 打開線索編輯器（新建或編輯）
 */
function openClueEditor(index = -1) {
    editingItemIndex = index;
    const modal = document.getElementById('sk-item-editor-modal');
    document.getElementById('sk-role-editor-fields').style.display = 'none';
    document.getElementById('sk-clue-editor-fields').style.display = 'block';
    
    // 動態填充線索歸屬的下拉式功能表
    const ownerSelect = document.getElementById('sk-clue-owner-select');
    ownerSelect.innerHTML = '<option value="公共">公共線索</option>';
    currentEditingScriptData.roles.forEach(role => {
        const option = document.createElement('option');
        option.value = role.name;
        option.textContent = `角色: ${role.name}`;
        ownerSelect.appendChild(option);
    });

    if (index > -1) { // 編輯模式
        const clue = currentEditingScriptData.clues[index];
        document.getElementById('sk-item-editor-title').textContent = `編輯線索 ${index + 1}`;
        ownerSelect.value = clue.owner;
        document.getElementById('sk-clue-desc-input').value = clue.description;
        document.getElementById('sk-clue-key-toggle').checked = clue.isKey || false;
    } else { // 新建模式
        document.getElementById('sk-item-editor-title').textContent = '添加新線索';
        ownerSelect.value = '公共';
        document.getElementById('sk-clue-desc-input').value = '';
        document.getElementById('sk-clue-key-toggle').checked = false;
    }
    modal.classList.add('visible');
}

/**
 * 保存子編輯器（角色或線索）中的資料
 */
function saveItemFromEditor() {
    const isRoleEditor = document.getElementById('sk-role-editor-fields').style.display === 'block';
    
    if (isRoleEditor) {
        const roleData = {
            name: document.getElementById('sk-role-name-input').value.trim(),
            description: document.getElementById('sk-role-desc-input').value.trim(),
            // ▼▼▼ 在這裡添加下面這行新代碼 ▼▼▼
            storyline: document.getElementById('sk-role-storyline-input').value.trim(),
            // ▲▲▲ 新代碼黏貼結束 ▲▲▲
            tasks: document.getElementById('sk-role-tasks-input').value.trim(),
            isKiller: document.getElementById('sk-role-killer-toggle').checked
        };
        if (!roleData.name) { alert("角色名稱不能為空！"); return; }
        
        if (editingItemIndex > -1) {
            currentEditingScriptData.roles[editingItemIndex] = roleData;
        } else {
            currentEditingScriptData.roles.push(roleData);
        }
    } else {
        const clueData = {
            owner: document.getElementById('sk-clue-owner-select').value,
            description: document.getElementById('sk-clue-desc-input').value.trim(),
            isKey: document.getElementById('sk-clue-key-toggle').checked
        };
        if (!clueData.description) { alert("線索描述不能為空！"); return; }

        if (editingItemIndex > -1) {
            currentEditingScriptData.clues[editingItemIndex] = clueData;
        } else {
            currentEditingScriptData.clues.push(clueData);
        }
    }
    
    document.getElementById('sk-item-editor-modal').classList.remove('visible');
    renderVisualScriptEditor(); // 刷新主編輯器介面
}

/**
 * 替換 openScriptEditorForCreate 函數
 */
function openScriptEditorForCreate() {
    editingScriptId = null; 
    currentEditingScriptData = { roles: [], clues: [] }; // 清空暫存數據
    document.getElementById('script-editor-title').textContent = '創建新劇本';
    document.getElementById('script-name-input').value = '';
    document.getElementById('script-background-input').value = '';
    document.getElementById('sk-truth-input').value = '';
    renderVisualScriptEditor(); // 渲染空的編輯器
    document.getElementById('script-kill-editor-modal').classList.add('visible');
}

/**
 * 替換 openScriptEditorForEdit 函數
 */
async function openScriptEditorForEdit(scriptId) {
    editingScriptId = scriptId;
    const script = await db.scriptKillScripts.get(scriptId);
    if (!script) return;

    // 將資料庫資料載入到暫存物件
    currentEditingScriptData = {
        roles: script.roles || [],
        clues: script.clues || []
    };

    document.getElementById('script-editor-title').textContent = `編輯劇本: ${script.name}`;
    document.getElementById('script-name-input').value = script.name;
    document.getElementById('script-background-input').value = script.storyBackground;
    document.getElementById('sk-truth-input').value = script.truth;
    
    renderVisualScriptEditor(); // 渲染帶有資料的編輯器
    document.getElementById('script-kill-editor-modal').classList.add('visible');
}

// --- ▲▲▲ 新增功能函數結束 ▲▲▲


/**
 * 刪除一個自訂劇本
 * @param {number} scriptId - 要刪除的劇本ID
 * @param {string} scriptName - 劇本名稱，用於確認提示
 */
async function deleteCustomScript(scriptId, scriptName) {
    const confirmed = await showCustomConfirm(
        '刪除劇本', 
        `確定要永久刪除自訂劇本《${scriptName}》嗎？`,
        { confirmButtonClass: 'btn-danger' }
    );
    if (confirmed) {
        await db.scriptKillScripts.delete(scriptId);
        await renderScriptManagerList();
        alert('劇本已刪除。');
    }
}

// --- ▲▲▲ 新增功能函數結束 ▲▲▲
// ▼▼▼ 在 init() 函數的【正上方】黏貼下面這一整塊新代碼 ▼▼▼

/**
 * 【劇本殺】AI核心：調用AI為整局遊戲生成複盤摘要
 * @returns {Promise<string>} - AI生成的摘要文本
 */
async function generateAiSkSummary() {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        return "（AI摘要生成失敗：API未配置）";
    }

    const formattedLog = scriptKillGameState.gameLog.map(log => {
        if (log.type === 'speech') {
            return `${log.message.player.role.name}: ${log.message.speech}`;
        }
        return log.message;
    }).join('\n');
    
    const killer = scriptKillGameState.players.find(p => p.role.isKiller)?.role.name || '未知';

    const prompt = `
# 任務
你是一位專業的劇本殺複盤DM。請根據以下完整的遊戲日誌，用200字左右，客觀、精煉地總結本局遊戲的【關鍵事件】、【重要線索】和【玩家邏輯】。

# 核心要求
- 你的總結需要有邏輯、有條理，像一個真正的遊戲複盤。
- 點出關鍵線索是如何被發現和利用的。
- 分析兇手(${killer})是如何隱藏自己的，以及好人陣營的推理亮點或誤區。
- 你的輸出【必須且只能】是複盤摘要的純文字內容，不要包含任何額外的對話或標題。

# 遊戲日誌
${formattedLog}
`;

    try {
        const messagesForApi = [{ role: 'user', content: prompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);

        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 0.7 })
            });

        if (!response.ok) throw new Error(await response.text());
        const data = await response.json();
        return (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).trim();
    } catch (error) {
        console.error("AI摘要生成失敗:", error);
        return "（AI摘要生成失敗，請檢查網路或API設置）";
    }
}

// ▼▼▼ 用這個【功能增強版】函數，完整替換你舊的 generateSkSummary 函數 ▼▼▼
/**
 * 【劇本殺 V2 - 增強版】生成遊戲複盤的文本，包含AI摘要和投票詳情
 * @param {string} winner - 勝利的陣營名稱
 * @param {string} aiSummary - AI生成的摘要文本
 * @returns {string} - 格式化後的完整複盤Markdown文本
 */
function generateSkSummary(winner, aiSummary) {
    const roleNameMap = {
        wolf: '狼人', villager: '平民', seer: '預言家',
        witch: '女巫', hunter: '獵人', guard: '守衛', idiot: '白癡'
    };

    let summaryText = `**劇本殺 - 遊戲複盤**\n\n`;
    summaryText += `**劇本:** ${scriptKillGameState.script.name}\n`;
    summaryText += `🏆 **勝利方:** ${winner}\n\n`;
    
    summaryText += `**本局摘要:**\n${aiSummary}\n\n`; 
    
    summaryText += `**玩家身份:**\n`;
    scriptKillGameState.players.forEach(p => {
        const roleName = p.role.name || '未知角色';
        const isKiller = p.role.isKiller ? ' (🔪兇手)' : '';
        summaryText += `- ${p.name}: 扮演 ${roleName}${isKiller}\n`;
    });

    // --- ▼▼▼ 這就是我們本次新增的核心代碼！▼▼▼ ---
    summaryText += `\n**投票詳情:**\n`;
    const votes = scriptKillGameState.votes;
    const playerMap = new Map(scriptKillGameState.players.map(p => [p.id, p.name]));
    
    for (const voterId in votes) {
        const voterName = playerMap.get(voterId) || '未知投票者';
        const targetId = votes[voterId];
        
        if (targetId) { // 如果不是棄票
            const targetName = playerMap.get(targetId) || '未知目標';
            summaryText += `- ${voterName}  →  ${targetName}\n`;
        } else { // 如果是棄票
            summaryText += `- ${voterName}  →  棄票\n`;
        }
    }
    // --- ▲▲▲ 新增代碼結束 ▲▲▲ ---

    return summaryText;
}
// ▲▲▲ 替換結束 ▲▲▲


/**
 * 【劇本殺】顯示遊戲結算卡片模態框
 * @param {string} summaryText - 複盤文本
 */
function showScriptKillSummaryModal(summaryText) {
    const modal = document.getElementById('script-kill-summary-modal');
    const contentEl = document.getElementById('script-kill-summary-content');
    
    contentEl.innerHTML = renderMarkdown(summaryText);
    
    const repostBtn = document.getElementById('repost-sk-summary-btn');
    const newRepostBtn = repostBtn.cloneNode(true);
    repostBtn.parentNode.replaceChild(newRepostBtn, repostBtn);
    newRepostBtn.onclick = () => openSkSummaryTargetPicker(summaryText);

    const backBtn = document.getElementById('back-to-hall-from-sk-btn');
    const newBackBtn = backBtn.cloneNode(true);
    backBtn.parentNode.replaceChild(newBackBtn, backBtn);
    newBackBtn.onclick = () => {
        modal.classList.remove('visible');
        showScreen('game-hall-screen');
    };

    modal.classList.add('visible');
}

/**
 * 【劇本殺】打開複盤發送目標選擇器
 * @param {string} summaryText - 要轉發的複盤文本
 */
function openSkSummaryTargetPicker(summaryText) {
    const modal = document.getElementById('script-kill-target-picker-modal');
    const listEl = document.getElementById('script-kill-target-list');
    listEl.innerHTML = '';

    const aiPlayers = scriptKillGameState.players.filter(p => !p.isUser);

    if (aiPlayers.length === 0) {
        alert("沒有可轉發的AI玩家。");
        return;
    }

    aiPlayers.forEach(player => {
        const item = document.createElement('div');
        item.className = 'player-selection-item';
        item.innerHTML = `
            <input type="checkbox" class="script-kill-target-checkbox" value="${player.id}" checked>
            <img src="${player.avatar || defaultAvatar}" alt="${player.name}">
            <span class="name">${player.name}</span>
        `;
        listEl.appendChild(item);
    });

    const confirmBtn = document.getElementById('sk-confirm-share-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.onclick = () => {
        const selectedIds = Array.from(document.querySelectorAll('.script-kill-target-checkbox:checked')).map(cb => cb.value);
        if (selectedIds.length > 0) {
            sendSkSummaryToSelectedPlayers(summaryText, selectedIds);
        } else {
            alert("請至少選擇一個轉發物件！");
        }
    };
    
    modal.classList.add('visible');
}

/**
 * 【劇本殺】將遊戲複盤發送到【選定】的AI角色的單聊中
 * @param {string} summaryText - 複盤文本
 * @param {string[]} targetIds - 目標AI角色的ID陣列
 */
async function sendSkSummaryToSelectedPlayers(summaryText, targetIds) {
    document.getElementById('script-kill-summary-modal').classList.remove('visible');
    document.getElementById('script-kill-target-picker-modal').classList.remove('visible');
    let sentCount = 0;
    
    const aiContext = `[系統指令：剛剛結束了一局劇本殺，這是遊戲複盤。請根據這個複盤內容，以你的角色人設，和用戶聊聊剛才的遊戲。]\n\n${summaryText}`;

    for (const chatId of targetIds) {
        const chat = state.chats[chatId];
        if (chat) {
            const visibleMessage = {
                role: 'user',
                type: 'text',
                timestamp: Date.now(),
                content: summaryText
            };
            const hiddenInstruction = {
                role: 'system',
                content: aiContext,
                timestamp: Date.now() + 1,
                isHidden: true
            };
            
            chat.history.push(visibleMessage, hiddenInstruction);
            await db.chats.put(chat);
            sentCount++;
        }
    }
    
    await showCustomAlert("轉發成功", `遊戲複盤已發送至 ${sentCount} 位AI玩家的單聊中！`);
    showScreen('game-hall-screen');
}

// ▲▲▲ 新代碼黏貼結束 ▲▲▲
// ▼▼▼ 【全新】這是劇本殺AI生成功能的所有核心函數 ▼▼▼

function openAiScriptGenerator() {
    // 隱藏劇本管理彈窗
    document.getElementById('script-kill-manager-modal').classList.remove('visible');
    
    const modal = document.getElementById('sk-ai-generator-modal');
    // ▼▼▼ 在這裡修改 ▼▼▼
    document.getElementById('sk-ai-elements-input').value = ''; // 清空要素輸入框
    document.getElementById('sk-ai-summary-input').value = '';  // 清空梗概輸入框
    // ▲▲▲ 修改結束 ▲▲▲
    document.getElementById('sk-ai-result-preview').textContent = '點擊“開始生成”後，結果將顯示在這裡...';
    document.getElementById('sk-ai-generator-save-btn').disabled = true;
    tempGeneratedScriptData = null;

    modal.classList.add('visible');
}


/**
 * 【AI核心 V2 - 強制時間線版】根據使用者的要素和梗概，調用AI生成劇本
 */
async function generateSkScriptWithAI() {
    // 1. 從新的兩個輸入框獲取資料
    const elements = document.getElementById('sk-ai-elements-input').value.trim();
    const summary = document.getElementById('sk-ai-summary-input').value.trim();
const playerCount = document.getElementById('sk-ai-player-count-input').value;

    if (!elements) { // 核心要素是必填的
        alert("請輸入劇本的核心要素！");
        return;
    }

    const previewEl = document.getElementById('sk-ai-result-preview');
    const saveBtn = document.getElementById('sk-ai-generator-save-btn');
    previewEl.textContent = '🧠 AI正在奮力創作中，這可能需要1-2分鐘，請耐心等待...';
    saveBtn.disabled = true;

    // 2. 構建給AI的【全新、更嚴格】的指令(Prompt)
const systemPrompt = `
# 任務
你是一個專業的劇本殺劇本創作AI。你的任務是根據使用者提供的核心要素和劇情梗概，創作一個【${playerCount}人】的、完整、可玩的劇本殺劇本。

# 用戶提供的核心要素:
-   **玩家人數**: ${playerCount}人
-   **核心元素**: ${elements}
-   **劇情梗概**: ${summary || '（用戶未提供詳細梗概，請根據核心元素自由發揮）'}

# 【【【時間線鐵律：這是最高指令，必須嚴格遵守】】】
在生成每個角色的 "storyline" (故事線) 欄位時，你【必須】遵循以下規則：
1.  **必須包含明確的時間點**：每一段關鍵行動前，都必須有一個具體的時間，格式為【**HH:mm**】（例如：**20:30** 或 **晚上8點15分**）。
2.  **必須是具體的行動軌跡**：禁止使用“後來”、“過了一會兒”等模糊描述。必須清楚地寫出角色在【什麼時間】、【什麼地點】、【做了什麼事】。
3.  **提供清晰的示例**:
    -   **【【錯誤的模糊示例】】**: "晚上我和他吵了一架，然後離開了。"
    -   **【【正確的詳細示例】】**: "**20:30**: 我在書房因為專案資金問題和王總監大吵一架，他威脅要解雇我。 **20:45**: 我憤怒地摔門而出，回到了自己的工位。"

# 劇本創作核心要求
1.  **完整性**: 你必須生成劇本的所有組成部分，包括：劇本名稱(name)、故事背景(storyBackground)、角色設定(roles)、線索卡(clues)、以及最終真相(truth)。
2.  **角色設定 (roles)**:
    -   必須是一個包含【${playerCount}個】角色物件的陣列。
    -   每個角色物件必須包含以下欄位:
        -   name: 角色名稱 (字串)。
        -   description: 角色簡介 (字串, 簡短描述)。
        -   storyline: 角色的個人故事線或時間線 (字串, **必須遵守【時間線鐵律】**)。
        -   tasks: 角色的秘密任務 (字串)。
        -   isKiller: 是否是兇手 (布林值, true 或 false)。
    -   劇本中【必須有且只有一個】角色的 isKiller 為 true。
3.  **線索卡 (clues)**:
    -   必須是一個包含多個線索物件的陣列。
    -   每個線索物件必須包含以下欄位:
        -   owner: 線索歸屬 (字串, 可以是某個角色名，也可以是 "公共")。
        -   description: 線索的詳細描述 (字串)。
        -   isKey: 是否是關鍵線索 (布林值, true 或 false)。
    -   至少要有一條關鍵線索。
4.  **最終真相 (truth)**: 必須清晰、有邏輯地揭示整個案件的真相、兇手的動機和作案手法。

# 【格式鐵律】
你的回復【必須且只能】是一個嚴格的JSON物件，直接以 '{' 開頭，以 '}' 結尾。禁止包含任何 "json", "\`\`\`" 或其他解釋性文字。
`;


    // 3. 調用API (這部分邏輯與之前相同)
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 0.8, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API請求失敗: ${response.status} - ${await response.text()}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, '').trim();
        
        const generatedScript = JSON.parse(rawContent);

        if (!generatedScript.name || !generatedScript.storyBackground || !Array.isArray(generatedScript.roles) || !Array.isArray(generatedScript.clues) || !generatedScript.truth) {
            throw new Error("AI返回的JSON格式不完整，缺少必要的欄位。");
        }
        
        previewEl.textContent = JSON.stringify(generatedScript, null, 2);
        tempGeneratedScriptData = generatedScript;
        saveBtn.disabled = false;

        await showCustomAlert("生成成功！", "劇本已生成，請在下方預覽。如果滿意，可以點擊保存。");

    } catch (error) {
        console.error("AI劇本生成失敗:", error);
        previewEl.textContent = `生成失敗！請檢查API設置或網路後重試。\n\n錯誤資訊: ${error.message}`;
        await showCustomAlert('生成失敗', `發生了一個錯誤：\n${error.message}`);
    }
}

/**
 * 保存AI生成的劇本
 */
async function saveAiGeneratedScript() {
    if (!tempGeneratedScriptData) {
        alert("沒有可以保存的劇本資料。");
        return;
    }

    try {
        const scriptToSave = {
            ...tempGeneratedScriptData,
            isBuiltIn: false // 標記為非內置劇本
        };

        // 存入資料庫
        await db.scriptKillScripts.add(scriptToSave);
        
        document.getElementById('sk-ai-generator-modal').classList.remove('visible'); // 關閉AI生成器
        await renderScriptManagerList(); // 刷新劇本管理列表
        
        alert(`劇本《${scriptToSave.name}》已成功保存到你的自訂劇本庫中！`);

    } catch (error) {
        console.error("保存AI劇本失敗:", error);
        alert(`保存失敗: ${error.message}`);
    }
}

// ▲▲▲ 新增功能函數結束 ▲▲▲

// ▲▲▲ 劇本殺功能函數結束 ▲▲▲
// ▼▼▼ 【全新】這裡是“你說我猜”遊戲的所有核心功能函數 ▼▼▼

// ▼▼▼ 【全新】這裡是“你說我猜”遊戲的所有核心功能函數 ▼▼▼

/**
 * 【你說我猜】打開遊戲設置介面 (V2 - 核取方塊版)
 */
async function openGuessWhatSetup() {
    // 重置遊戲狀態，以防上次遊戲資料殘留
    guessWhatGameState = { isActive: false, mode: 'ai_guesses', opponent: null, secretWord: '', gameLog: [], currentTurn: 'user' };

    showScreen('guess-what-setup-screen');
    const selectionEl = document.getElementById('guess-what-player-selection');
    selectionEl.innerHTML = '<p>正在載入玩伴列表...</p>';

    const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    const allNpcs = Object.values(state.chats).flatMap(chat => (chat.npcLibrary || []).map(npc => ({...npc, owner: chat.name})));
    let playerOptions = [
        ...singleChats.map(c => ({ id: c.id, name: c.name, avatar: c.settings.aiAvatar, type: '角色' })),
        ...allNpcs.map(n => ({ id: n.id, name: n.name, avatar: n.avatar, type: `NPC (${n.owner})` }))
    ];

    selectionEl.innerHTML = '';
    if (playerOptions.length === 0) {
        selectionEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">還沒有可以一起玩的好友哦~</p>';
        return;
    }
    
    // 【核心修改1】使用核取方塊，並添加專屬class
    playerOptions.forEach((player, index) => {
        const item = document.createElement('div');
        item.className = 'player-selection-item';
        item.innerHTML = `
            <input type="checkbox" class="guess-what-player-checkbox" value="${player.id}" id="opponent-${player.id}" ${index === 0 ? 'checked' : ''}>
            <img src="${player.avatar || defaultAvatar}" alt="${player.name}">
            <span class="name">${player.name}</span>
            <span class="type-tag">${player.type}</span>
        `;
        selectionEl.appendChild(item);
    });

    // 【核心修改2】添加事件監聽，實現單選效果
    selectionEl.addEventListener('click', (e) => {
        if (e.target.type === 'checkbox' && e.target.classList.contains('guess-what-player-checkbox')) {
            // 當點擊一個核取方塊時，取消其他所有同類核取方塊的選中狀態
            document.querySelectorAll('.guess-what-player-checkbox').forEach(cb => {
                if (cb !== e.target) cb.checked = false;
            });
        }
    });

    // 預設顯示“我出題”模式的輸入框
    document.getElementById('user-word-input-container').style.display = 'block';
}

/**
 * 【你說我猜】開始遊戲的核心邏輯 (V2 - 核取方塊版)
 */
async function startGuessWhatGame() {
    // 【核心修改】修改選擇器以匹配新的核取方塊class
    const selectedOpponentCheckbox = document.querySelector('.guess-what-player-checkbox:checked');
    if (!selectedOpponentCheckbox) {
        alert("請選擇一位玩伴！");
        return;
    }
    const opponentId = selectedOpponentCheckbox.value;
    const gameMode = document.querySelector('input[name="guess_what_mode"]:checked').value;
    const userWord = document.getElementById('guess-what-user-word').value.trim();

    if (gameMode === 'ai_guesses' && !userWord) {
        alert("“我出題”模式下，詞語不能為空！");
        return;
    }

    await showCustomAlert("請稍候...", "正在準備遊戲，AI也在摩拳擦掌...");

    const chat = Object.values(state.chats).find(c => c.id === opponentId);
    let opponentInfo = null;
    if (chat) { 
        opponentInfo = { id: chat.id, name: chat.name, avatar: chat.settings.aiAvatar, persona: chat.settings.aiPersona };
    } else {
        for (const c of Object.values(state.chats)) {
            const npc = (c.npcLibrary || []).find(n => n.id === opponentId);
            if (npc) {
                opponentInfo = { id: npc.id, name: npc.name, avatar: npc.avatar, persona: npc.persona };
                break;
            }
        }
    }
    if (!opponentInfo) { alert("找不到所選的玩伴信息！"); return; }

    guessWhatGameState.isActive = true;
    guessWhatGameState.mode = gameMode;
    guessWhatGameState.opponent = opponentInfo;
    guessWhatGameState.gameLog = [];

    document.getElementById('guess-what-game-title').textContent = `與 ${opponentInfo.name} 的遊戲`;
    const inputEl = document.getElementById('guess-what-user-input');

    if (gameMode === 'ai_guesses') { 
        guessWhatGameState.secretWord = userWord;
        guessWhatGameState.currentTurn = 'user'; 
        logToGuessWhatGame('遊戲開始！你來出題，請給出你的第一個提示。', 'system');
        inputEl.placeholder = "請給出第一個提示...";
        inputEl.disabled = false;
    } else { 
        const { secretWord, firstHint } = await triggerGuessWhatAiAction('generate_word');
        if (!secretWord) {
            await showCustomAlert("出題失敗", "抱歉，AI今天好像沒靈感，想不出題目來。請稍後再試或檢查API設置。");
            guessWhatGameState.isActive = false;
            showScreen('game-hall-screen'); 
            return;
        }
        guessWhatGameState.secretWord = secretWord;
        guessWhatGameState.currentTurn = 'user';
        logToGuessWhatGame(`遊戲開始！${opponentInfo.name} 已經想好了一個詞。`, 'system');
        logToGuessWhatGame({ player: opponentInfo, text: `【${opponentInfo.name}托著下巴想了想】第一個提示是... ${firstHint}` }, 'ai-turn');
        inputEl.placeholder = "請根據提示進行猜測...";
        inputEl.disabled = false;
    }

    showScreen('guess-what-game-screen');
    renderGuessWhatGameScreen();
    inputEl.focus();
    const actionArea = document.getElementById('guess-what-action-area');
    if(actionArea) actionArea.style.display = 'flex';
}


/**
 * 【你說我猜】渲染遊戲主介面
 */
function renderGuessWhatGameScreen() {
    const logContainer = document.getElementById('guess-what-game-log');
    logContainer.innerHTML = '';
    
    guessWhatGameState.gameLog.forEach(log => {
        const logEl = document.createElement('div');
        logEl.className = `guess-log-entry ${log.type}`;

        if (log.type === 'system') {
            logEl.textContent = log.message;
        } else {
            const avatarUrl = log.message.player.isUser ? (state.qzoneSettings.avatar || defaultAvatar) : log.message.player.avatar;
            logEl.innerHTML = `
                <img src="${avatarUrl}" class="avatar">
                <div class="bubble">
                    <div class="name">${log.message.player.name}</div>
                    <div>${log.message.text.replace(/\n/g, '<br>')}</div>
                </div>
            `;
        }
        logContainer.appendChild(logEl);
    });

    logContainer.scrollTop = logContainer.scrollHeight;
}

/**
 * 【你說我猜】添加一條遊戲日誌
 */
function logToGuessWhatGame(message, type = 'system') {
    guessWhatGameState.gameLog.push({ message, type });
    renderGuessWhatGameScreen();
}

/**
 * 【你說我猜 V5 | 裁判邏輯最終修復版】遊戲主迴圈/引擎
 * @param {string} userInput - 用戶剛剛的輸入
 */
async function processGuessWhatTurn(userInput) {
    if (!guessWhatGameState.isActive) return;

    const inputEl = document.getElementById('guess-what-user-input');
    const userPlayer = { id: 'user', name: state.qzoneSettings.nickname || '我', isUser: true };
    const aiPlayer = guessWhatGameState.opponent;
    const currentMode = guessWhatGameState.mode;

    // 1. 記錄並顯示使用者的行為
    logToGuessWhatGame({ player: userPlayer, text: userInput }, 'user-turn');

    // 2. 輪到AI行動，禁用輸入框
    guessWhatGameState.currentTurn = 'ai';
    inputEl.placeholder = `等待 ${aiPlayer.name} 的回應...`;
    inputEl.disabled = true;
    renderGuessWhatGameScreen();
    await sleep(1500);

    // 3. 讓AI根據上下文執行動作
    const aiResponse = await triggerGuessWhatAiAction(
        currentMode === 'ai_guesses' ? 'guess_word' : 'give_hint',
        userInput
    );
    
    // 4. 【核心修復】使用 switch 結構清晰地處理AI的每一種行動結果
    if (aiResponse) {
        switch (aiResponse.type) {
            case 'guess':
                const guessText = aiResponse.text;
                // 先把AI的猜測顯示出來
                logToGuessWhatGame({ player: aiPlayer, text: guessText }, 'ai-turn');

                // 調用裁判函數進行判斷
                if (isGuessCorrect(guessText, guessWhatGameState.secretWord)) {
                    await sleep(1000); // 停頓一下，讓玩家看到猜測內容
                    endGuessWhatGame('ai', `我猜對啦！答案就是【${guessWhatGameState.secretWord}】！`);
                    return; // 猜對了，遊戲結束，退出函數
                }
                // 如果沒猜對，則不執行任何操作，流程會自然地走到最後，把控制權還給用戶
                break;

            case 'hint':
                // AI給出新提示
                logToGuessWhatGame({ player: aiPlayer, text: aiResponse.text }, 'ai-turn');
                break;

            case 'game_over':
                // AI在給提示時直接判斷用戶猜對了
                endGuessWhatGame(aiResponse.winner, aiResponse.reason);
                return; // 遊戲結束，退出函數

            case 'error':
                // AI返回了錯誤資訊
                logToGuessWhatGame({ player: aiPlayer, text: aiResponse.text }, 'ai-turn');
                break;

            default:
                // 未知類型的回復，也記錄下來
                logToGuessWhatGame({ player: aiPlayer, text: '我好像有點跑神了，我們說到哪了？' }, 'ai-turn');
                console.warn("收到了未知的AI行動類型:", aiResponse);
                break;
        }
    } else {
        // API調用徹底失敗
        logToGuessWhatGame({ player: aiPlayer, text: '我...好像徹底斷線了...' }, 'ai-turn');
    }

    // 5. 如果遊戲沒有結束，則輪到用戶行動，恢復輸入框
    guessWhatGameState.currentTurn = 'user';
    inputEl.placeholder = currentMode === 'ai_guesses' ? "請繼續給出你的提示..." : "請根據提示繼續猜測...";
    inputEl.disabled = false;
    inputEl.focus();
}


/**
 * 【你說我猜】遊戲結束處理
 */
function endGuessWhatGame(winner, reason) {
    if (!guessWhatGameState.isActive) return; // 防止重複執行
    guessWhatGameState.isActive = false; // 標記遊戲為非啟動狀態
    
    // 立即隱藏遊戲中的輸入區域
    const actionArea = document.getElementById('guess-what-action-area');
    if(actionArea) actionArea.style.display = 'none';

    // 生成複盤文本
    const summaryText = generateGuessWhatSummary(winner, reason);
    // 顯示結算卡片
    showGuessWhatSummaryModal(summaryText);
}
/**
 * 【全新】判斷AI的猜測是否正確（簡單版）
 * @param {string} guess - AI猜測的詞語
 * @param {string} answer - 正確答案
 * @returns {boolean}
 */
function isGuessCorrect(guess, answer) {
    if (!guess || !answer) return false;

    // 為了更寬鬆的匹配，我們都轉為小寫並去除空格
    const cleanGuess = guess.toLowerCase().replace(/\s+/g, '');
    const cleanAnswer = answer.toLowerCase().replace(/\s+/g, '');

    // 只要猜測包含了答案，或者答案包含了猜測，就認為正確
    // 例如：答案是“霜淇淋”，猜測“霜淇淋車”或“淇淋”，都算對
    return cleanGuess.includes(cleanAnswer) || cleanAnswer.includes(cleanGuess);
}

/**
 * 【你說我猜-AI核心 V4 | 銅牆鐵壁版】調用AI執行遊戲邏輯，內置強大的重試機制
 * @param {string} actionType - AI需要執行的動作: 'generate_word', 'give_hint', 'guess_word'
 * @param {string} userInput - 用戶剛剛的輸入
 * @returns {Promise<object|null>} - AI的行動結果
 */
async function triggerGuessWhatAiAction(actionType, userInput = null) {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) return null;

    // --- 這部分Prompt邏輯保持不變 ---
    const opponent = guessWhatGameState.opponent;
    const historyText = guessWhatGameState.gameLog.map(log => log.type === 'system' ? `[系統提示: ${log.message}]` : `${log.message.player.name}: ${log.message.text}`).slice(-10).join('\n');
    let systemPrompt = `# 你的任務\n你正在扮演角色“${opponent.name}”，人設是：“${opponent.persona}”。\n你正在和“${state.qzoneSettings.nickname || '我'}”玩“你說我猜”遊戲。\n你的所有發言都【必須】嚴格符合你的人設和口吻，讓整個過程像一次真實的聊天互動。\n\n# 遊戲歷史 (最近的對話)\n${historyText}\n`;
    switch (actionType) {
        case 'generate_word': systemPrompt += `# 你的行動指令\n1. 根據你的人設，想一個常見的、2-5個字的中文詞語作為謎底。\n2. 為這個詞語，給出你的【第一條】符合人設的、有趣的提示。\n3. 你的回復【必須且只能】是一個嚴格的JSON物件，包含 "secretWord" 和 "firstHint" 兩個欄位。\n\n# JSON輸出格式示例:\n{"secretWord": "月亮", "firstHint": "【指了指天上】晚上才能看到的東西哦，圓圓的，亮亮的~"}`; break;
      case 'give_hint':
    systemPrompt += `# 遊戲規則
你是出題人，你的謎底是【${guessWhatGameState.secretWord}】。
用戶剛剛的猜測是：“${userInput}”。

# 你的行動指令
1.  首先判斷用戶的猜測是否正確。
2.  如果用戶猜對了，遊戲結束。
3.  如果用戶猜錯了，你【必須】根據使用者的錯誤猜測，給出【下一條】新的、更具針對性的提示，引導他們。
4.  【【【人設扮演鐵律】】】你的所有提示都【必須】符合你的人設和口吻，可以加入動作、表情、語氣詞，甚至可以對用戶【笨笨的猜測進行一些俏皮的吐槽】，讓遊戲更有趣。
5.  你的回復【必須且只能】是一個嚴格的JSON物件。

# JSON輸出格式
- 如果猜對了: \`{"type": "game_over", "winner": "user", "reason": "恭喜你猜對啦！就是【${guessWhatGameState.secretWord}】！"}\`
- 如果猜錯了: \`{"type": "hint", "text": "【歎氣】不對哦，再想想。提示是：[在這裡寫你的新提示]"}\``;
    break;

// ▼▼▼ 請用這整塊【修復後】的代碼，替換掉舊的 case 'guess_word' 代碼塊 ▼▼▼
        case 'guess_word':
            systemPrompt += `# 遊戲規則
你是猜題人，用戶正在描述一個詞語，你需要根據提示猜出這個詞。
用戶剛剛給你的新提示是：“${userInput}”。

# 你的行動指令
1.  綜合分析【遊戲歷史】中用戶給出的【所有提示】。
2.  根據所有線索，進行【一次】猜測。
3.  【【【人設扮演鐵律】】】你的猜測【必須】符合你的人設和口吻。你可以加入你的思考過程、情緒，甚至可以【對用戶的提示進行吐槽】。
4.  【【【趣味性指令】】】為了逗弄使用者，你可以【故意給出一些有趣的、沾點邊但明顯錯誤的答案】，然後再給出你認為最可能的答案。但這只是偶爾的調劑，你的最終目的還是要猜對。
5.  【【【絕對禁止】】】你【不能】再向用戶提問，你的任務是直接猜測。
6.  你的回復【必須且只能】是一個嚴格的JSON物件。

# JSON輸出格式 (注意：你無法判斷自己是否猜對，所以永遠使用這個格式)
{"type": "guess", "text": "【假裝恍-然大悟】哦~我知道了，是“電飯煲”對不對？...好吧好吧不逗你了，我猜是...[你的真實猜測]"}`;
            break;
// ▲▲▲ 替換結束 ▲▲▲


    }
    
    // --- 【核心改造】帶有智慧重試的API請求邏輯 ---
    const maxRetries = 3;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            const messagesForApi = [{ role: 'user', content: "請根據你在系統指令中讀到的規則，立即開始你的行動。" }];
            const isGemini = proxyUrl === GEMINI_API_URL;
            const geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);

            const response = isGemini 
                ? await fetch(geminiConfig.url, geminiConfig.data)
                : await fetch(`${proxyUrl}/v1/chat/completions`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                    body: JSON.stringify({ model: model, messages: [{ role: 'system', content: systemPrompt }, ...messagesForApi], temperature: 0.9, response_format: { type: "json_object" } })
                });

            // 智慧判斷錯誤類型
            if (!response.ok) {
                // 對於 4xx 類的用戶端錯誤 (如 401 Unauthorized, 400 Bad Request)，通常重試無效，直接拋出。
                if (response.status >= 400 && response.status < 500) {
                     const errorText = await response.text();
                     throw new Error(`API用戶端錯誤 (狀態碼 ${response.status}): ${errorText}`);
                }
                // 對於 5xx 伺服器錯誤或 429 速率限制，是可重試的。
                throw new Error(`API伺服器臨時錯誤 (狀態碼 ${response.status})`);
            }

            const data = await response.json();
            const content = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, '');
            return JSON.parse(content); // **成功，直接返回結果，跳出迴圈**

        } catch (error) {
            console.error(`“你說我猜”AI行動[${actionType}]失敗 (第 ${attempt}/${maxRetries} 次嘗試):`, error.message);
            
            // 如果是最後一次嘗試，或者是一個不可重試的錯誤，則跳出迴圈準備返回最終失敗資訊
            if (attempt === maxRetries || error.message.includes('API用戶端錯誤')) {
                break;
            }
            
            // 等待一段時間再重試（比如 1.5s, 3s, 4.5s）
            await sleep(1500 * attempt);
        }
    }

    // --- 所有重試都失敗後的最終處理 ---
    console.error(`“你說我猜”AI行動[${actionType}]在所有嘗試後均失敗。`);
    // 根據失敗的階段，返回一個特定的錯誤物件
    if (actionType === 'generate_word') {
        return { secretWord: null, firstHint: null };
    }
    // 返回一個全新的 'error' 類型，讓遊戲主迴圈知道如何處理
    return { type: 'error', text: '【歎了口氣】抱歉，我的網路好像出問題了，試了好幾次都沒連上...' };
}
// ▼▼▼ 【全新】“你說我猜”遊戲結算與轉發功能核心代碼 ▼▼▼

/**
 * 【你說我猜】生成遊戲複盤的文本
 * @param {string} winner - 勝利者 ('user' or 'ai')
 * @param {string} reason - 遊戲結束原因
 * @returns {string} 格式化後的複盤Markdown文本
 */
function generateGuessWhatSummary(winner, reason) {
    let summaryText = `**你說我猜 - 遊戲複盤**\n\n`;
    summaryText += `**遊戲結果:** ${reason}\n`;
    summaryText += `**謎底:** ${guessWhatGameState.secretWord}\n\n`;
    summaryText += `**參與玩家:** 我, ${guessWhatGameState.opponent.name}\n\n`;
    summaryText += `---\n\n**遊戲記錄:**\n`;
    
    const formattedLog = guessWhatGameState.gameLog.map(log => {
        if (log.type === 'system') {
            return `[系統提示: ${log.message}]`;
        } else {
            return `${log.message.player.name}: ${log.message.text}`;
        }
    }).join('\n');
    
    summaryText += formattedLog;

    return summaryText;
}

/**
 * 【你說我猜】顯示遊戲結算卡片模態框
 * @param {string} summaryText - 複盤文本
 */
function showGuessWhatSummaryModal(summaryText) {
    const modal = document.getElementById('guess-what-summary-modal');
    const contentEl = document.getElementById('guess-what-summary-content');
    
    contentEl.innerHTML = renderMarkdown(summaryText);
    
    // 使用克隆節點技巧，防止事件重複綁定
    const forwardBtn = document.getElementById('forward-guess-what-summary-btn');
    const newForwardBtn = forwardBtn.cloneNode(true);
    forwardBtn.parentNode.replaceChild(newForwardBtn, forwardBtn);
    
    const closeBtn = document.getElementById('close-guess-what-summary-btn');
    const newCloseBtn = closeBtn.cloneNode(true);
    closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);

    // 檢查對手是否是主要角色（有獨立聊天視窗），而不是NPC
    const opponentId = guessWhatGameState.opponent.id;
    const canForward = state.chats[opponentId] !== undefined;

    if (canForward) {
        newForwardBtn.style.display = 'block';
        newForwardBtn.onclick = () => forwardGuessWhatSummary(summaryText);
    } else {
        // 如果對手是NPC，沒有獨立聊天視窗，則隱藏轉發按鈕
        newForwardBtn.style.display = 'none';
    }

    newCloseBtn.onclick = () => {
        modal.classList.remove('visible');
        showScreen('game-hall-screen');
    };

    modal.classList.add('visible');
}

/**
 * 【你說我猜】將遊戲複盤轉發到對應的AI角色的聊天中
 * @param {string} summaryText - 複盤文本
 */
async function forwardGuessWhatSummary(summaryText) {
    const opponentId = guessWhatGameState.opponent.id;
    const chat = state.chats[opponentId];
    
    if (!chat) {
        await showCustomAlert("轉發失敗", "找不到該玩家的聊天窗口。");
        return;
    }

    document.getElementById('guess-what-summary-modal').classList.remove('visible');

    // 創建對使用者可見的複盤消息
    const visibleMessage = {
        role: 'user',
        type: 'text',
        timestamp: Date.now(),
        content: summaryText
    };
    
    // 創建給AI看的隱藏指令
    const aiContext = `[系統指令：剛剛結束了一局“你說我猜”，這是遊戲複盤。請根據這個複盤內容，以你的角色人設，和用戶聊聊剛才的遊戲。]\n\n${summaryText}`;
    const hiddenInstruction = {
        role: 'system',
        content: aiContext,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    
    chat.history.push(visibleMessage, hiddenInstruction);
    await db.chats.put(chat);
    
    await showCustomAlert("轉發成功", `遊戲複盤已發送至與“${chat.name}”的聊天中！`);
    
    // 打開聊天並觸發AI回應
    openChat(chat.id);
    triggerAiResponse();
}

// ▲▲▲ 新增代碼黏貼結束 ▲▲▲
// ▼▼▼ 【全新】寵物功能核心函數 ▼▼▼

let currentPetData = null; // 用於暫存正在編輯的寵物資料
let isPetDragging = false; // 標記是否正在拖動寵物
let petDragOffset = { x: 0, y: 0 };

/**
 * 【領養系統改造版】打開寵物主面板（設置與互動）
 */
async function openPetModal() {
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) {
        alert("只有在單人聊天中才能養寵物哦！");
        return;
    }
    const chat = state.chats[state.activeChatId];

    // 核心判斷：檢查是否已領養
    if (!chat.settings.petAdopted) {
        // 如果未領養，彈出確認框
        const confirmed = await showCustomConfirm(
            '領養新寵物',
            `你還沒有為“${chat.name}”領養寵物，要現在開啟寵物系統嗎？`,
            { confirmText: '現在領養' }
        );

        if (confirmed) {
            // 用戶同意領養
            chat.settings.petAdopted = true;
            // 創建一個全新的預設寵物物件
            chat.settings.pet = {
                type: '無', name: '', image: '🥚', persona: '一隻可愛的小寵物，對世界充滿好奇。',
                petChatHistory: [], isCustomImage: false,
                display: { show: false, size: 100, top: '80%', left: '50%' },
                status: {
                    hunger: 100, happiness: 100, intimacyToUser: 50,
                    intimacyToChar: 50, lastUpdated: Date.now()
                }
            };
            await db.chats.put(chat);
            alert(`恭喜！你已成功為“${chat.name}”開啟寵物系統！現在來為它設置一下吧。`);
            // 領養成功後，再次調用本函數，這次會直接進入設置介面
            openPetModal(); 
        }
        // 如果用戶取消，則什麼也不做
        return;
    }

    // --- 如果已經領養，則執行原來的顯示邏輯 ---
    currentPetData = JSON.parse(JSON.stringify(chat.settings.pet)); 

    document.getElementById('pet-type-input').value = currentPetData.type === '無' ? '' : currentPetData.type;
    document.getElementById('pet-name-input').value = currentPetData.name;
    document.getElementById('pet-image-input').value = currentPetData.image;
    document.getElementById('pet-display-toggle').checked = currentPetData.display.show;
    document.getElementById('pet-size-slider').value = currentPetData.display.size;
    document.getElementById('pet-size-value').textContent = `${currentPetData.display.size}px`;
    document.getElementById('pet-persona-input').value = currentPetData.persona || '';
    
    updatePetPreview();

    if (currentPetData.type !== '無') {
        document.getElementById('pet-stats-area').style.display = 'flex';
        updatePetStatusUI(currentPetData);
    } else {
        document.getElementById('pet-stats-area').style.display = 'none';
    }

    const positionControls = document.getElementById('pet-position-controls');
    positionControls.style.display = currentPetData.display.show ? 'block' : 'none';
    
    document.getElementById('pet-modal').classList.add('visible');
}


/**
 * 計算並應用寵物的數值衰減
 * @param {object} pet - 寵物對象
 * @returns {boolean} - 如果數值發生了變化，返回 true
 */
function applyPetDecay(pet) {
    if (!pet || !pet.status) return false;

    const now = Date.now();
    const lastUpdated = pet.status.lastUpdated || now;
    const timeElapsed = now - lastUpdated;

    // 計算過去了多少個衰減週期
    const intervalsPassed = Math.floor(timeElapsed / PET_DECAY_INTERVAL);

    if (intervalsPassed > 0) {
        // 計算總共要衰減多少
        const totalHungerDecay = intervalsPassed * PET_DECAY_AMOUNT.hunger;
        const totalHappinessDecay = intervalsPassed * PET_DECAY_AMOUNT.happiness;

        // 應用衰減，確保不低於0
        pet.status.hunger = Math.max(0, pet.status.hunger - totalHungerDecay);
        pet.status.happiness = Math.max(0, pet.status.happiness - totalHappinessDecay);

        // 更新最後更新時間，只加上已經計算過的週期的時間，避免丟失零頭時間
        pet.status.lastUpdated = lastUpdated + intervalsPassed * PET_DECAY_INTERVAL;
        
        console.log(`寵物"${pet.name}"數值衰減: ${intervalsPassed}個週期, 飽食度-${totalHungerDecay}, 心情-${totalHappinessDecay}`);
        return true; // 數值已改變
    }

    return false; // 數值未改變
}

/**
 * 停止當前的寵物衰減計時器
 */
function stopPetDecayTimer() {
    if (petDecayTimer) {
        clearInterval(petDecayTimer);
        petDecayTimer = null;
        // console.log("寵物衰減計時器已停止。");
    }
}

/**
 * 為當前聊天中的寵物啟動衰減計時器
 */
function startPetDecayTimer() {
    stopPetDecayTimer(); // 先確保停止任何舊的計時器

    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.settings.pet || chat.settings.pet.type === '無') {
        return; // 如果當前聊天沒有寵物，則不啟動
    }
    
    // console.log(`為寵物"${chat.settings.pet.name}"啟動衰減計時器。`);
    
    // 使用 setInterval 定期檢查並應用衰減
    petDecayTimer = setInterval(async () => {
        const currentChat = state.chats[state.activeChatId];
        if (!currentChat) { // 安全檢查，如果聊天已關閉則停止計時器
            stopPetDecayTimer();
            return;
        }
        const pet = currentChat.settings.pet;
        
        if (applyPetDecay(pet)) {
            // 如果數值變化了，更新UI並保存到資料庫
            // 只有當寵物面板打開時才需要更新UI
            if (document.getElementById('pet-modal').classList.contains('visible')) {
                 updatePetStatusUI(pet);
            }
            await db.chats.put(currentChat);
        }
    }, 60 * 1000); // 每分鐘檢查一次，是否到達了衰減週期
}

// ▲▲▲ 新代碼黏貼結束 ▲▲▲


// ▼▼▼ 用這塊【已更新】的代碼，替換舊的 updatePetStatusUI 函數 ▼▼▼
/**
 * 【全新】更新寵物數值面板的UI顯示
 * @param {object} petData - 寵物的資料物件
 */
function updatePetStatusUI(petData) {
    const hunger = petData.status.hunger || 0;
    const happiness = petData.status.happiness || 0;
    // ★★★ 新增：獲取親密度數值 ★★★
    const intimacyToUser = petData.status.intimacyToUser || 0;
    const intimacyToChar = petData.status.intimacyToChar || 0;

    const hungerFill = document.querySelector('#pet-hunger-bar .stat-bar-fill');
    const happinessFill = document.querySelector('#pet-happiness-bar .stat-bar-fill');
    // ★★★ 新增：獲取親密度進度條元素 ★★★
    const intimacyUserFill = document.querySelector('#pet-intimacy-user-bar .stat-bar-fill');
    const intimacyCharFill = document.querySelector('#pet-intimacy-char-bar .stat-bar-fill');

    if (hungerFill) {
        hungerFill.style.width = `${hunger}%`;
        hungerFill.textContent = `${hunger}%`;
    }
    if (happinessFill) {
        happinessFill.style.width = `${happiness}%`;
        happinessFill.textContent = `${happiness}%`;
    }
    // ★★★ 新增：渲染親密度進度條 ★★★
    if (intimacyUserFill) {
        intimacyUserFill.style.width = `${intimacyToUser}%`;
        intimacyUserFill.textContent = `${intimacyToUser}%`;
    }
    if (intimacyCharFill) {
        intimacyCharFill.style.width = `${intimacyToChar}%`;
        intimacyCharFill.textContent = `${intimacyToChar}%`;
    }
}
// ▲▲▲ 替換結束 ▲▲▲



/**
 * 在彈窗中更新寵物的預覽
 */
function updatePetPreview() {
    const previewDisplay = document.getElementById('pet-preview-display');
    const nameEl = document.getElementById('pet-preview-name');
    const typeEl = document.getElementById('pet-preview-type');
    
    const imageInput = document.getElementById('pet-image-input').value.trim();

    if (imageInput.startsWith('http') || imageInput.startsWith('data:image')) {
        previewDisplay.innerHTML = `<img src="${imageInput}" style="width: 60px; height: 60px; object-fit: contain;">`;
    } else {
        previewDisplay.textContent = imageInput || '🥚';
    }
    
    nameEl.textContent = document.getElementById('pet-name-input').value.trim() || '(未命名)';
    typeEl.textContent = document.getElementById('pet-type-input').value.trim() || '物種';
}


/**
 * 保存寵物設置
 */
async function savePetSettings() {
    const chat = state.chats[state.activeChatId];
    
    // 從UI讀取數據
    const type = document.getElementById('pet-type-input').value.trim() || '無';
    const name = document.getElementById('pet-name-input').value.trim();
    const image = document.getElementById('pet-image-input').value.trim() || '🥚';
    
    const newPetSettings = {
        ...currentPetData, // 保留如位置等未在主面板修改的屬性
        type: type,
        name: name,
        image: image,
        persona: document.getElementById('pet-persona-input').value.trim(),
        isCustomImage: image.startsWith('http') || image.startsWith('data:image'),
        display: {
            ...currentPetData.display,
            show: document.getElementById('pet-display-toggle').checked,
            size: parseInt(document.getElementById('pet-size-slider').value)
        }
    };

    // 更新到 state 和資料庫
    chat.settings.pet = newPetSettings;
    await db.chats.put(chat);
    
    // 刷新聊天介面上的寵物
    renderChatPet();
    
    document.getElementById('pet-modal').classList.remove('visible');
    currentPetData = null; // 清理臨時資料
    alert('寵物資訊已保存！');
}

/**
 * 在聊天介面上渲染寵物
 */
function renderChatPet() {
    const chat = state.chats[state.activeChatId];
    const petContainer = document.getElementById('chat-pet-container');
    const petEl = document.getElementById('chat-pet');

    if (!chat || chat.isGroup || !chat.settings.petAdopted || !chat.settings.pet || !chat.settings.pet.display.show) {
        petEl.style.display = 'none';
        return;
    }

    const pet = chat.settings.pet;
    petEl.style.display = 'block';
    
    if (pet.isCustomImage) {
        petEl.innerHTML = `<img src="${pet.image}" alt="${pet.name}">`;
    } else {
        petEl.innerHTML = pet.image;
    }
    
    // 應用樣式
    petEl.style.fontSize = `${pet.display.size}px`;
    petEl.style.width = `${pet.display.size}px`;
    petEl.style.height = `${pet.display.size}px`;
    petEl.style.top = pet.display.top;
    petEl.style.left = pet.display.left;
}

// ▼▼▼ 用這塊【新代碼】替換舊的 handlePetInteraction 函數 ▼▼▼
/**
 * 處理用戶與寵物的互動 (V2 - 增強互動記錄)
 * @param {string} action - 互動類型, e.g., 'feed', 'play'
 */
async function handlePetInteraction(action) {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.settings.petAdopted || !chat.settings.pet || chat.settings.pet.type === '無') {
        alert("你還沒有寵物，或者還沒有給它設定種類哦！");
        return;
    }

    const pet = chat.settings.pet;
    let actionText = '';
    const myNickname = chat.settings.myNickname || '我';

    switch(action) {
        case 'feed':
            pet.status.hunger = Math.min(100, pet.status.hunger + 20);
            pet.status.happiness = Math.min(100, pet.status.happiness + 5);
            pet.status.intimacyToUser = Math.min(100, pet.status.intimacyToUser + 10);
            actionText = `${myNickname} 喂了 ${pet.name} 一些食物。`;
            break;
        case 'play':
            pet.status.hunger = Math.max(0, pet.status.hunger - 10);
            pet.status.happiness = Math.min(100, pet.status.happiness + 15);
            pet.status.intimacyToUser = Math.min(100, pet.status.intimacyToUser + 15);
            actionText = `${myNickname} 陪 ${pet.name} 玩了一會兒。`;
            break;
        case 'touch':
            pet.status.happiness = Math.min(100, pet.status.happiness + 10);
            pet.status.intimacyToUser = Math.min(100, pet.status.intimacyToUser + 5);
            actionText = `${myNickname} 輕輕地撫摸了 ${pet.name}。`;
            break;
        case 'chat':
            openPetChat();
            return; 
    }
    
    updatePetStatusUI(pet);
    chat.settings.pet = pet; 

    // ★★★ 核心修改1：創建對使用者【可見】的系統消息 ★★★
    const visibleMessage = {
        role: 'system',
        type: 'pat_message',
        content: `[系統：${actionText}]`,
        timestamp: Date.now()
    };
    chat.history.push(visibleMessage);
    
    // ★★★ 核心修改2：創建給AI看的【隱藏】指令 ★★★
    const hiddenMessageForAI = {
        role: 'system',
        content: `[系統提示：用戶剛剛和寵物“${pet.name}”進行了互動：${actionText}。]`,
        timestamp: Date.now() + 1, // 確保時間戳記在後
        isHidden: true
    };
    chat.history.push(hiddenMessageForAI);

    await db.chats.put(chat);
    
    if (document.getElementById('chat-interface-screen').classList.contains('active')) {
        appendMessage(visibleMessage, chat);
    }
    
    document.getElementById('pet-modal').classList.remove('visible');
}
// ▲▲▲ 替換結束 ▲▲▲


// ▼▼▼ 【全新】寵物對話功能核心函數 ▼▼▼

/**
 * 打開寵物聊天模態框
 */
function openPetChat() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.settings.pet || chat.settings.pet.type === '無') {
        alert("先給你的寵物起個名字和種類吧！");
        return;
    }
    
    // 關閉主設置面板，打開聊天面板
    document.getElementById('pet-modal').classList.remove('visible');
    const chatModal = document.getElementById('pet-chat-modal');
    document.getElementById('pet-chat-title').textContent = `和“${chat.settings.pet.name}”的對話`;
    document.getElementById('pet-chat-input').value = '';
    
    renderPetChatHistory(); // 渲染歷史記錄
    chatModal.classList.add('visible');
}

/**
 * 渲染寵物的聊天記錄
 */
function renderPetChatHistory() {
    const chat = state.chats[state.activeChatId];
    const pet = chat.settings.pet;
    const messagesEl = document.getElementById('pet-chat-messages');
    messagesEl.innerHTML = '';

    if (!pet.petChatHistory || pet.petChatHistory.length === 0) {
        messagesEl.innerHTML = `<p style="text-align:center; color: var(--text-secondary);">試著和它打個招呼吧！</p>`;
        return;
    }
    
    // 獲取用戶頭像
    const myAvatar = chat.settings.myAvatar || defaultAvatar;

    pet.petChatHistory.forEach(msg => {
        const wrapper = document.createElement('div');
        // 【核心】這裡的 msg.sender 會是 'user', 'pet', 或 'char'
        wrapper.className = `message-wrapper ${msg.sender}`; 
        
        const bubble = document.createElement('div');
        bubble.className = 'message-bubble';
        
        let avatarSrc = '';
        let avatarHtml = '';

        // ▼▼▼ 問題就在下面這段邏輯，我們來修復它 ▼▼▼
        if (msg.sender === 'user') {
            // 如果是用戶發的，使用用戶頭像
            avatarSrc = myAvatar;
            avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
        } else if (msg.sender === 'char') {
            // 【【【這就是新增的修復邏輯！】】】
            // 如果是角色(char)發的，就使用角色的頭像
            avatarSrc = chat.settings.aiAvatar || defaultAvatar;
            avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
        } else { // 剩下的情況就是寵物(pet)自己發的
            avatarSrc = pet.isCustomImage ? pet.image : null;
            if (avatarSrc) {
                // 如果是圖片，顯示圖片
                avatarHtml = `<img src="${avatarSrc}" class="avatar">`;
            } else {
                // 如果是Emoji，直接顯示Emoji
                avatarHtml = `<div class="avatar" style="font-size: 28px; text-align: center;">${pet.image}</div>`;
            }
        }
        // ▲▲▲ 修復結束 ▲▲▲
        
        bubble.innerHTML = `
            ${avatarHtml}
            <div class="content">${msg.content.replace(/\n/g, '<br>')}</div>
        `;
        wrapper.appendChild(bubble);
        messagesEl.appendChild(wrapper);
    });

    messagesEl.scrollTop = messagesEl.scrollHeight;
}

// ▼▼▼ 用這塊【新代碼】替換舊的 handleSendToPet 函數 ▼▼▼
/**
 * 處理使用者在寵物聊天框中發送消息
 */
async function handleSendToPet() {
    const chat = state.chats[state.activeChatId];
    const pet = chat.settings.pet;
    const input = document.getElementById('pet-chat-input');
    const userInput = input.value.trim();
    if (!userInput) return;

    input.value = '';
    input.style.height = 'auto';

    pet.petChatHistory.push({ sender: 'user', content: userInput });
    renderPetChatHistory();

    const petResponse = await getPetApiResponse(pet);
    if (petResponse) {
        pet.petChatHistory.push({ sender: 'pet', content: petResponse });
        renderPetChatHistory();
    }
    
    // ★★★ 核心修改：創建對使用者【可見】的系統消息，記錄這次對話 ★★★
    const visibleLog = `[系統：你和寵物“${pet.name}”進行了對話。你說：“${userInput}”，它回應：“${petResponse}”。]`;
    const visibleMessage = {
        role: 'system',
        type: 'pat_message', // 使用這個類型來顯示居中灰色氣泡
        content: visibleLog,
        timestamp: Date.now()
    };
    chat.history.push(visibleMessage);

    // 只有當用戶正在查看當前聊天時，才即時追加到介面上
    if (document.getElementById('chat-interface-screen').classList.contains('active') && state.activeChatId === chat.id) {
        appendMessage(visibleMessage, chat);
    }
    
    // 創建給AI看的【隱藏】指令，這部分保持不變
    const hiddenMessageForAI = `[系統提示：用戶剛剛和寵物“${pet.name}”進行了一次對話。用戶說：“${userInput}”，寵物回應：“${petResponse}”。]`;
    const hiddenMessage = {
        role: 'system',
        content: hiddenMessageForAI,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    await db.chats.put(chat);
}
// ▲▲▲ 替換結束 ▲▲▲


// ▼▼▼ 用這塊【已修復】的代碼替換舊的 getPetApiResponse 函數 ▼▼▼
/**
 * 【AI核心】為寵物獲取API回復
 * @param {object} pet - 寵物對象
 * @returns {Promise<string|null>} - AI生成的寵物回復文本
 */
async function getPetApiResponse(pet) {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert("請先配置API！");
        return "（我好像斷線了...）";
    }

    // ★★★ 核心修復2：重構對話歷史的生成邏輯 ★★★
    const historyForPet = pet.petChatHistory.slice(-6).map(msg => {
        let senderName;
        if (msg.sender === 'user') {
            senderName = '主人';
        } else if (msg.sender === 'char') {
            senderName = msg.senderName; // 正確獲取Char的名字
        } else { // 'pet'
            senderName = pet.name;
        }
        return `${senderName}: ${msg.content}`;
    }).join('\n');

    const systemPrompt = `你現在正在扮演一隻寵物。
# 你的核心設定
- 你的種類: ${pet.type}
- 你的名字: ${pet.name}
- 你的性格和背景故事: ${pet.persona}

# 核心規則
1. 你【必須】完全代入你的角色設定進行回復。
2. 你的回復應該是簡短、可愛的，符合一隻寵物的說話方式（例如，使用擬聲詞、簡單的詞彙）。
3. 你的回復【只能是純文字】，不要包含任何JSON或特殊格式。

# 最近的對話
${historyForPet}

現在，請根據上面的對話，繼續你的回應。`;

    try {
        const messagesForApi = [{ role: 'user', content: "請根據你在系統指令中讀到的規則，立即開始你的行動。" }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
        
        const response = isGemini ? await fetch(geminiConfig.url, geminiConfig.data) : await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
            body: JSON.stringify({
                model: model,
                messages: [{ role: 'system', content: systemPrompt }, ...messagesForApi],
                temperature: 0.9,
            })
        });

        if (!response.ok) throw new Error(await response.text());
        const data = await response.json();
        return (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).trim();
    } catch (error) {
        console.error("獲取寵物回復失敗:", error);
        return "（嗚...我好像說不出話了...）";
    }
}
// ▲▲▲ 替換結束 ▲▲▲


/**
 * 初始化寵物的拖拽功能
 */
function initPetDragging() {
    const petEl = document.getElementById('chat-pet');
    const container = document.getElementById('chat-pet-container');

    const onDragStart = (e) => {
        if (!petEl.style.display || petEl.style.display === 'none') return;
        e.preventDefault();
        isPetDragging = true;
        
        const rect = petEl.getBoundingClientRect();
        const coords = getEventCoords(e);

        petDragOffset.x = coords.x - rect.left;
        petDragOffset.y = coords.y - rect.top;

        document.addEventListener('mousemove', onDragMove);
        document.addEventListener('mouseup', onDragEnd);
        document.addEventListener('touchmove', onDragMove, { passive: false });
        document.addEventListener('touchend', onDragEnd);
    };

    const onDragMove = (e) => {
        if (!isPetDragging) return;
        e.preventDefault();
        
        const containerRect = container.getBoundingClientRect();
        const coords = getEventCoords(e);

        let newLeft = coords.x - petDragOffset.x - containerRect.left;
        let newTop = coords.y - petDragOffset.y - containerRect.top;

        // 邊界檢測
        newLeft = Math.max(0, Math.min(newLeft, container.clientWidth - petEl.offsetWidth));
        newTop = Math.max(0, Math.min(newTop, container.clientHeight - petEl.offsetHeight));
        
        // 用百分比存儲，以適應不同螢幕尺寸
        petEl.style.left = `${(newLeft / container.clientWidth) * 100}%`;
        petEl.style.top = `${(newTop / container.clientHeight) * 100}%`;
    };

    const onDragEnd = async () => {
        if (!isPetDragging) return;
        isPetDragging = false;
        
        // 拖動結束後，保存新的位置
        const chat = state.chats[state.activeChatId];
        if (chat && chat.settings.pet) {
            chat.settings.pet.display.top = petEl.style.top;
            chat.settings.pet.display.left = petEl.style.left;
            await db.chats.put(chat);
        }

        document.removeEventListener('mousemove', onDragMove);
        document.removeEventListener('mouseup', onDragEnd);
        document.removeEventListener('touchmove', onDragMove);
        document.removeEventListener('touchend', onDragEnd);
    };

    petEl.addEventListener('mousedown', onDragStart);
    petEl.addEventListener('touchstart', onDragStart, { passive: true });
}

// ▲▲▲ 寵物功能核心函數結束 ▲▲▲
/**
 * 【全新】顯示微博內容生成的目標角色選擇器
 * @returns {Promise<object|string|null>} - 返回選中的角色物件, 'all', 或 null (如果用戶取消)
 */
async function showCharacterSelectorForWeibo() {
    // 1. 找出所有單聊角色
    const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

    if (singleChats.length === 0) {
        alert("還沒有任何角色可以生成內容哦。");
        return null;
    }

    // 2. 準備彈窗的選項
    const options = [
        // 添加一個“隨機”選項，保留原來的功能
        { text: '✨ 隨機 (所有角色)', value: 'all' }, 
        // 遍歷所有角色，為每個角色創建一個選項
        ...singleChats.map(chat => ({
            text: `👤 ${chat.name}`, // 選項顯示的名字
            value: chat.id         // 選項的值是角色的唯一ID
        }))
    ];

    // 3. 調用你現有的操作功能表彈窗，並等待用戶選擇
    const selectedId = await showChoiceModal("請選擇本次生成的主角", options);

    // 4. 根據使用者的選擇，返回不同的結果
    if (selectedId === null) {
        return null; // 用戶點擊了“取消”
    }
    if (selectedId === 'all') {
        return 'all'; // 用戶選擇了“隨機”
    }

    // 如果用戶選擇了某個角色，就返回那個角色的完整資料物件
    return state.chats[selectedId];
}
/**
 * 【全新 | V2多選版】顯示微博內容生成的目標角色選擇器
 * @returns {Promise<Array|string|null>} - 返回選中的角色ID陣列, 'all', 或 null
 */
async function showMultiCharacterSelectorForWeibo() {
    return new Promise(resolve => {
        const modal = document.getElementById('weibo-char-selector-modal');
        const listEl = document.getElementById('weibo-char-selector-list');
        const confirmBtn = document.getElementById('weibo-confirm-char-select-btn');
        const cancelBtn = document.getElementById('weibo-cancel-char-select-btn');
        const selectAllBtn = document.getElementById('weibo-select-all-btn');
        const deselectAllBtn = document.getElementById('weibo-deselect-all-btn');

        listEl.innerHTML = '';
        const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);

        if (singleChats.length === 0) {
            alert("還沒有任何角色可以生成內容哦。");
            resolve(null);
            return;
        }

        // 添加一個“隨機”選項
        const randomOption = document.createElement('div');
        randomOption.className = 'player-selection-item';
        randomOption.innerHTML = `
            <input type="radio" name="weibo-char-choice" value="all" id="weibo-char-random" checked style="margin-right: 15px;">
            <label for="weibo-char-random" style="display:flex; align-items:center; width:100%; cursor:pointer;">
                <span class="name">✨ 隨機選擇 (所有角色)</span>
            </label>
        `;
        listEl.appendChild(randomOption);
        
        // 添加一個“指定”選項的標題
        const specificOptionHeader = document.createElement('div');
        specificOptionHeader.className = 'player-selection-item';
        specificOptionHeader.innerHTML = `
            <input type="radio" name="weibo-char-choice" value="specific" id="weibo-char-specific" style="margin-right: 15px;">
            <label for="weibo-char-specific" style="display:flex; align-items:center; width:100%; cursor:pointer;">
                <span class="name">👤 指定以下角色</span>
            </label>
        `;
        listEl.appendChild(specificOptionHeader);

        // 渲染所有可選的角色
        singleChats.forEach(chat => {
            const item = document.createElement('div');
            item.className = 'player-selection-item';
            item.style.paddingLeft = '50px'; // 向內縮進，表示是“指定”的子選項
            item.innerHTML = `
                <input type="checkbox" class="weibo-char-checkbox" value="${chat.id}" id="weibo-char-${chat.id}">
                <label for="weibo-char-${chat.id}" style="display:flex; align-items:center; width:100%; cursor:pointer;">
                    <img src="${chat.settings.aiAvatar || defaultAvatar}" alt="${chat.name}">
                    <span class="name">${chat.name}</span>
                </label>
            `;
            listEl.appendChild(item);
        });

        const cleanup = () => {
            modal.classList.remove('visible');
            // 清除事件監聽器，防止記憶體洩漏
            newConfirmBtn.removeEventListener('click', onConfirm);
            cancelBtn.removeEventListener('click', onCancel);
            selectAllBtn.removeEventListener('click', onSelectAll);
            deselectAllBtn.removeEventListener('click', onDeselectAll);
        };
        
        const onConfirm = () => {
            const choice = document.querySelector('input[name="weibo-char-choice"]:checked').value;
            if (choice === 'all') {
                cleanup();
                resolve('all');
            } else {
                const selectedIds = Array.from(document.querySelectorAll('.weibo-char-checkbox:checked')).map(cb => cb.value);
                if (selectedIds.length === 0) {
                    alert("請至少選擇一個指定的角色！");
                    return;
                }
                cleanup();
                resolve(selectedIds);
            }
        };

        const onCancel = () => { cleanup(); resolve(null); };
        const onSelectAll = () => document.querySelectorAll('.weibo-char-checkbox').forEach(cb => cb.checked = true);
        const onDeselectAll = () => document.querySelectorAll('.weibo-char-checkbox').forEach(cb => cb.checked = false);

        // 使用克隆節點技巧來確保事件只被綁定一次
        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

        newConfirmBtn.addEventListener('click', onConfirm);
        cancelBtn.addEventListener('click', onCancel);
        selectAllBtn.addEventListener('click', onSelectAll);
        deselectAllBtn.addEventListener('click', onDeselectAll);

        modal.classList.add('visible');
    });
}
// ▼▼▼ 把這一整塊全新的功能函數，黏貼到 <script> 內的功能函式定義區 ▼▼▼

/**
 * 【線下模式】渲染預設下拉清單
 */
function renderOfflinePresetsSelector() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.settings.offlineMode) return;

    const select = document.getElementById('offline-preset-select');
    const presets = chat.settings.offlineMode.presets || [];
    select.innerHTML = '<option value="">-- 使用自訂輸入 --</option>'; // 預設選項
    presets.forEach((preset, index) => {
        const option = document.createElement('option');
        option.value = index; // 使用陣列索引作為值
        option.textContent = preset.name;
        select.appendChild(option);
    });
}

/**
 * 【線下模式】當使用者選擇一個預設時，自動填充輸入框
 */
function handleOfflinePresetSelection() {
    const chat = state.chats[state.activeChatId];
    if (!chat || !chat.settings.offlineMode) return;
    
    const select = document.getElementById('offline-preset-select');
    const selectedIndex = select.value;

    if (selectedIndex !== "") {
        const preset = chat.settings.offlineMode.presets[parseInt(selectedIndex)];
        if (preset) {
            document.getElementById('offline-prompt-input').value = preset.prompt;
            document.getElementById('offline-style-input').value = preset.style;
        }
    }
}

/**
 * 【線下模式】打開預設管理的操作功能表
 */
async function openOfflinePresetManager() {
    const select = document.getElementById('offline-preset-select');
    const selectedIndex = select.value;

    // 彈出一個包含多個選項的功能表
    const choice = await showChoiceModal("管理線下模式預設", [
        { text: '💾 保存當前為新預設', value: 'save_new' },
        { text: '✏️ 更新選中預設', value: 'update_selected', disabled: selectedIndex === "" },
        { text: '🗑️ 刪除選中預設', value: 'delete_selected', disabled: selectedIndex === "" }
    ]);
    
    // 根據使用者的選擇執行操作
    switch (choice) {
        case 'save_new':
            await saveCurrentAsOfflinePreset();
            break;
        case 'update_selected':
            if (selectedIndex !== "") await updateSelectedOfflinePreset(parseInt(selectedIndex));
            break;
        case 'delete_selected':
            if (selectedIndex !== "") await deleteSelectedOfflinePreset(parseInt(selectedIndex));
            break;
    }
}

/**
 * 【線下模式】將當前輸入框的內容保存為一個新預設
 */
async function saveCurrentAsOfflinePreset() {
    const chat = state.chats[state.activeChatId];
    const name = await showCustomPrompt("保存新預設", "請輸入預設名稱：");
    
    if (name && name.trim()) {
        const newPreset = {
            name: name.trim(),
            prompt: document.getElementById('offline-prompt-input').value.trim(),
            style: document.getElementById('offline-style-input').value.trim()
        };
        chat.settings.offlineMode.presets.push(newPreset);
        await db.chats.put(chat); // 保存回資料庫
        renderOfflinePresetsSelector(); // 刷新下拉清單
        alert(`預設 "${name.trim()}" 已保存！`);
    }
}

/**
 * 【線下模式】用當前輸入框的內容更新選中的預設
 */
async function updateSelectedOfflinePreset(index) {
    const chat = state.chats[state.activeChatId];
    const preset = chat.settings.offlineMode.presets[index];
    if (!preset) return;

    const confirmed = await showCustomConfirm("確認更新", `確定要用當前內容覆蓋預設 "${preset.name}" 嗎？`);
    if (confirmed) {
        preset.prompt = document.getElementById('offline-prompt-input').value.trim();
        preset.style = document.getElementById('offline-style-input').value.trim();
        await db.chats.put(chat);
        alert("預設已更新！");
    }
}

/**
 * 【線下模式】刪除選中的預設
 */
async function deleteSelectedOfflinePreset(index) {
    const chat = state.chats[state.activeChatId];
    const preset = chat.settings.offlineMode.presets[index];
    if (!preset) return;

    const confirmed = await showCustomConfirm("確認刪除", `確定要刪除預設 "${preset.name}" 嗎？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        chat.settings.offlineMode.presets.splice(index, 1);
        await db.chats.put(chat);
        renderOfflinePresetsSelector(); // 刷新下拉清單
        // 刪除後清空輸入框
        document.getElementById('offline-prompt-input').value = '';
        document.getElementById('offline-style-input').value = '';
        alert("預設已刪除。");
    }
}

// ▲▲▲ 新功能函數黏貼結束 ▲▲▲
// ▼▼▼ 【全新】微博私信功能核心函數 ▼▼▼

// ▼▼▼ 【全新】微博私信功能核心函數 ▼▼▼

/**
 * 【總入口】當用戶點擊關注清單時，打開私信介面
 * @param {object} targetInfo - 包含被點擊角色/NPC資訊的物件
 */
async function openWeiboDms(targetInfo) {
    currentViewingDmsFor = targetInfo;
    const charId = targetInfo.isNpc ? targetInfo.ownerId : targetInfo.id;
    const chat = state.chats[charId];
    if (!chat) return;

    // 檢查並生成粉絲私信資料
    const dmsData = await generateAndCacheFanDms(chat);
    
    // 渲染私信列表
    renderDmList(dmsData, targetInfo.name);

    // 顯示私信清單螢幕
    showScreen('weibo-dm-list-screen');
}

/**
 * 【AI核心】檢查或生成角色的粉絲私信資料
 * @param {object} characterChat - 角色/NPC的 "主人" 的聊天物件
 * @returns {Promise<Array>} - 粉絲私信對話陣列
 */
async function generateAndCacheFanDms(characterChat, addMore = false) {
    // 如果不是“繼續生成”，且緩存已存在，則直接返回
    if (!addMore && characterChat.weiboDms && characterChat.weiboDms.length > 0) {
        console.log(`從緩存載入 "${characterChat.name}" 的粉絲私信。`);
        return characterChat.weiboDms;
    }

    const alertMessage = addMore ? "正在生成更多私信內容..." : `正在為“${characterChat.name}”生成粉絲私信內容...`;
    await showCustomAlert("請稍候...", alertMessage);
    
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先配置API！');
        return [];
    }

    const truncatedMainPersona = (characterChat.settings.aiPersona || '一個普通的角色').substring(0, 500);
    const truncatedWeiboInstruction = (characterChat.settings.weiboInstruction || '無特殊指令').substring(0, 400);
    
    // 如果是繼續生成，把現有對話作為上下文
    const existingDmsContext = addMore ? `
# 已有私信記錄 (供你參考，你可以選擇延續對話或開啟新對話):
${JSON.stringify(characterChat.weiboDms, null, 2)}
` : '';

        // 【優化後】的AI指令
        const systemPrompt = `
# 任務
你現在是角色“${characterChat.name}”的社交媒體運營助理。
你的任務是根據該角色的【所有資訊】，虛構一個包含${addMore ? '2-3' : '3-5'}位不同粉絲的私信列表，並為每位粉絲創作一段生動、真實的對話歷史。
${existingDmsContext}

# 角色資訊 (你必須綜合參考以下所有資訊)
- 角色名: ${characterChat.name}
- 公開職業: ${characterChat.settings.weiboProfession || '未設定'}
- 核心人設 (最高優先順序): ${truncatedMainPersona}
- 微博互動準則 (處理私信時需遵守): ${truncatedWeiboInstruction}

# 核心規則
1.  **粉絲多樣性**: 創作${addMore ? '2-3' : '3-5'}位不同類型的粉絲（例如：狂熱粉、事業粉、CP粉、黑粉、路人粉、廣告商等）。
2.  **【【【對話鮮活度鐵律】】】**: 為了讓對話更真實，你必須：
    -   **避免機械問答**：不要生成“你好”-“你好”之類的無意義對話。讓對話像一個正在進行的真實互動片段。
    -   **注入情緒和語氣**：粉絲的語氣可以是興奮的、擔憂的、質疑的、開玩笑的。角色的回應也要符合人設，可能是冷淡的、溫柔的、官方的，或者乾脆已讀不回。
    -   **使用網路語言**: 適當加入符合粉絲圈文化的網路用語、emoji或顏文字，讓對話更接地氣。
    -   **內容多樣化**: 私信內容不應只局限於工作，也可以是粉絲分享自己的日常、表達關心、提出一些私人問題等。
3.  **角色回應**: 根據角色的【微博互動準則】和【核心人設】，決定角色是否會回復私信以及如何回復。例如，一個高冷的角色可能只會回復重要資訊，或者乾脆不回復。
4.  **格式鐵律**: 你的回復【必須且只能】是一個嚴格的JSON陣列，直接以 '[' 開頭，以 ']' 結尾。

# JSON物件結構 (注意：你不再需要提供頭像URL)
{
  "fanName": "粉絲的微博昵稱",
  "fanPersona": "對這位粉絲的簡單描述 (例如: '一個擔心哥哥事業的媽媽粉')",
  "messages": [
    { "sender": "fan", "text": "粉絲發的第一條消息..." },
    { "sender": "char", "text": "角色回復的消息..." }
  ]
}

現在，請開始生成私信列表。`;


    try {
        const messagesForApi = [{ role: 'user', content: systemPrompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.0, response_format: { type: "json_object" } })
            });
        
        if (!response.ok) {
            throw new Error(`API請求失敗: ${response.status} - ${await response.text()}`);
        }
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const newDmsData = JSON.parse(cleanedContent);
        // 【已修復】在這裡為AI生成的資料手動添加隨機頭像
        if (Array.isArray(newDmsData)) {
            // 這是你提供的兩個頭像URL
            const fanAvatars = [
                'https://i.postimg.cc/PxZrFFFL/o-o-1.jpg',
                'https://i.postimg.cc/Qd0Y537F/com-xingin-xhs-20251011153800.png'
            ];

            // 遍歷AI生成的每一段對話，這次我們加入了 index 參數
            newDmsData.forEach((convo, index) => {
                // 【核心修改】使用索引和取餘運算子(%)來交替分配頭像
                convo.fanAvatarUrl = fanAvatars[index % fanAvatars.length];
            });
        }


        if (Array.isArray(newDmsData)) {
            if (addMore) {
                // 合併新舊資料
                characterChat.weiboDms.push(...newDmsData);
            } else {
                characterChat.weiboDms = newDmsData;
            }
            await db.chats.put(characterChat);
            return characterChat.weiboDms;
        }
        throw new Error("AI返回的資料不是一個有效的陣列。");
    } catch (error) {
        console.error("生成粉絲私信失敗:", error);
        await showCustomAlert('生成失敗', `抱歉，生成私信時發生了一個錯誤。\n\n詳細資訊:\n${error.message}`);
        return characterChat.weiboDms || []; // 失敗時返回舊資料或空陣列
    }
}

/**
 * 渲染粉絲私信列表
 * @param {Array} dmsData - 私信對話陣列
 * @param {string} charName - 角色名
 */
function renderDmList(dmsData, charName) {
    const listEl = document.getElementById('weibo-dm-list');
    const titleEl = document.getElementById('weibo-dm-list-title');
    listEl.innerHTML = '';
    titleEl.textContent = `${charName}的私信`;

    if (!dmsData || dmsData.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">還沒有收到任何私信哦</p>';
        return;
    }

    dmsData.forEach((convo, index) => {
        const lastMsg = convo.messages[convo.messages.length - 1];
        const item = document.createElement('div');
        item.className = 'dm-list-item';
        item.dataset.fanIndex = index; // 用索引來標識
        item.innerHTML = `
            <img src="${convo.fanAvatarUrl}" class="dm-avatar">
            <div class="dm-info">
                <div class="dm-name">${convo.fanName}</div>
                <div class="dm-last-msg">${lastMsg.text}</div>
            </div>
        `;
        listEl.appendChild(item);
    });
}

/**
 * 打開私信詳情頁
 * @param {number} fanIndex - 粉絲在私信陣列中的索引
 */
function openDmDetail(fanIndex) {
    const charId = currentViewingDmsFor.isNpc ? currentViewingDmsFor.ownerId : currentViewingDmsFor.id;
    const chat = state.chats[charId];
    const conversation = chat.weiboDms[fanIndex];
    
    if (conversation) {
        renderDmDetail(conversation, chat);
        showScreen('weibo-dm-detail-screen');
    }
}

/**
 * 渲染私信詳情頁的聊天氣泡
 * @param {object} conversation - 單個粉絲的對話物件
 * @param {object} characterChat - 角色的聊天物件
 */
function renderDmDetail(conversation, characterChat) {
    const messagesEl = document.getElementById('weibo-dm-messages');
    const titleEl = document.getElementById('weibo-dm-detail-title');
    messagesEl.innerHTML = '';
    titleEl.textContent = conversation.fanName;
    
    const charAvatar = characterChat.settings.aiAvatar || defaultAvatar;

    conversation.messages.forEach((msg, index) => {
        const isFan = msg.sender === 'fan';
        const wrapper = document.createElement('div');
        wrapper.className = `message-wrapper ${isFan ? 'fan' : 'char'}`;

        const bubble = document.createElement('div');
        bubble.className = `message-bubble`;

        const avatarHtml = `<img src="${isFan ? conversation.fanAvatarUrl : charAvatar}" class="avatar">`;
        const contentHtml = `<div class="content">${msg.text.replace(/\n/g, '<br>')}</div>`;
        
        // ★★★ 只有粉絲的消息才添加刪除按鈕 ★★★
        const deleteBtnHtml = isFan 
            ? `<button class="dm-message-delete-btn" data-message-index="${index}">×</button>` 
            : '';

        bubble.innerHTML = `${avatarHtml}${contentHtml}`;
        // 將刪除按鈕添加到wrapper，而不是bubble內部，以方便定位
        wrapper.innerHTML = deleteBtnHtml; 
        wrapper.appendChild(bubble);

        messagesEl.appendChild(wrapper);
    });
    
    messagesEl.scrollTop = messagesEl.scrollHeight;
}
/**
 * 【全新】清空當前角色的所有粉絲私信
 */
async function handleClearAllDms() {
    if (!currentViewingDmsFor) return;

    const charId = currentViewingDmsFor.isNpc ? currentViewingDmsFor.ownerId : currentViewingDmsFor.id;
    const chat = state.chats[charId];
    if (!chat || !chat.weiboDms || chat.weiboDms.length === 0) {
        alert("沒有可以清空的私信。");
        return;
    }

    const confirmed = await showCustomConfirm(
        '確認清空',
        `確定要清空“${currentViewingDmsFor.name}”收到的所有粉絲私信嗎？此操作不可恢復。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.weiboDms = []; // 清空陣列
        await db.chats.put(chat); // 保存到資料庫
        renderDmList(chat.weiboDms, currentViewingDmsFor.name); // 重新渲染列表
        alert('所有私信已清空。');
    }
}

/**
 * ★★★ 處理刪除單條私信的邏輯 ★★★
 * @param {number} fanIndex - 粉絲對話的索引
 * @param {number} messageIndex - 要刪除的消息的索引
 */
async function handleDeleteWeiboDm(fanIndex, messageIndex) {
    const charId = currentViewingDmsFor.isNpc ? currentViewingDmsFor.ownerId : currentViewingDmsFor.id;
    const chat = state.chats[charId];
    if (!chat || !chat.weiboDms[fanIndex]) return;

    const conversation = chat.weiboDms[fanIndex];
    const messageText = conversation.messages[messageIndex].text.substring(0, 30);
    
    const confirmed = await showCustomConfirm(
        '刪除私信',
        `確定要刪除這條私信嗎？\n\n“${messageText}...”`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        // 從消息陣列中移除
        conversation.messages.splice(messageIndex, 1);
        
        // 如果一個對話的所有消息都被刪除了，可以選擇是否刪除整個對話
        if (conversation.messages.length === 0) {
            chat.weiboDms.splice(fanIndex, 1);
            await db.chats.put(chat);
            // 返回私信列表
            renderDmList(chat.weiboDms, currentViewingDmsFor.name);
            showScreen('weibo-dm-list-screen');
        } else {
            await db.chats.put(chat);
            // 重新渲染當前對話
            renderDmDetail(conversation, chat);
        }
        alert('私信已刪除。');
    }
}

/**
 * ★★★ 處理點擊“繼續生成”按鈕的邏輯 ★★★
 */
async function handleGenerateMoreDms() {
    const charId = currentViewingDmsFor.isNpc ? currentViewingDmsFor.ownerId : currentViewingDmsFor.id;
    const chat = state.chats[charId];
    if (!chat) return;

    // 調用核心AI函數，並傳入 addMore=true 參數
    const newDmsData = await generateAndCacheFanDms(chat, true);
    
    // 渲染更新後的私信列表
    renderDmList(newDmsData, currentViewingDmsFor.name);
}

// ▲▲▲ 核心功能函數黏貼結束 ▲▲▲
// ▼▼▼ 【全新】黏貼這一整塊聊天總結功能的核心函數 ▼▼▼
// ▼▼▼ 在JS頂部變數區，黏貼下面這2塊代碼 ▼▼▼

// 全域變數，用於存儲所有正在運行的物流更新計時器，方便在離開頁面時清除
let logisticsUpdateTimers = [];

// 物流時間線範本 (delay單位是毫秒)
// 你可以隨意修改這裡的文本和延遲時間，打造你自己的物流故事！
const logisticsTimelineTemplate = [
    { text: '您的訂單已提交', delay: 1000 * 2 }, // 2秒
    { text: '付款成功，等待商家打包', delay: 1000 * 10 }, // 10秒後
    { text: '【{city}倉庫】已打包，等待快遞攬收', delay: 1000 * 60 * 5 }, // 5分鐘後
    { text: '【{city}快遞】已攬收', delay: 1000 * 60 * 20 }, // 20分鐘後
    { text: '快件已到達【{city}分撥中心】', delay: 1000 * 60 * 60 * 2 }, // 2小時後
    { text: '【{city}分撥中心】已發出，下一站【{next_city}】', delay: 1000 * 60 * 60 * 8 }, // 8小時後
    { text: '快件已到達【{user_city}轉運中心】', delay: 1000 * 60 * 60 * 20 }, // 20小時後
    { text: '快件正在派送中，派送員：兔兔快遞員，電話：123-4567-8910，請保持電話暢通', delay: 1000 * 60 * 60 * 24 }, // 24小時後
    { text: '您的快件已簽收，感謝您在桃寶購物，期待再次為您服務！', delay: 1000 * 60 * 60 * 28 }, // 28小時後
];

// ▲▲▲ 黏貼結束 ▲▲▲

let isSummarizing = false; // 全域鎖，防止重複觸發總結

// ▼▼▼ 【V2 - 流程分離版】用這整塊代碼替換舊的 checkAndTriggerSummary 函數 ▼▼▼
/**
 * 【總入口 V2】檢查是否需要觸發總結或提醒
 * @param {string} chatId - 當前聊天的ID
 */
async function checkAndTriggerSummary(chatId) {
    if (isSummarizing) return; 

    const chat = state.chats[chatId];
    if (!chat || !chat.settings.summary || !chat.settings.summary.enabled) return;

    const summarySettings = chat.settings.summary;
    // 核心修改：我們不再從0開始，而是從上次總結的位置開始計算
    const lastSummaryIndex = summarySettings.lastSummaryIndex;
    const messagesSinceLastSummary = chat.history.slice(lastSummaryIndex + 1);

    if (messagesSinceLastSummary.length >= summarySettings.count) {
        isSummarizing = true; 
        if (summarySettings.mode === 'auto') {
            await performAutomaticSummary(chatId);
        } else {
            // 對於手動模式，現在只彈提醒
            await notifyForManualSummary(chatId);
        }
        isSummarizing = false;
    }
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 【V2 - 範圍精確版】用這整塊代碼替換舊的 performAutomaticSummary 函數 ▼▼▼
/**
 * 自動在後臺執行總結，只總結觸發條件的N條消息
 */
async function performAutomaticSummary(chatId) {
    console.log(`自動總結觸發 for chat: ${chatId}`);
    const chat = state.chats[chatId];
    const summarySettings = chat.settings.summary;

    // 【核心修改】精確截取最後N條消息作為總結範圍
    const messagesToSummarize = chat.history.slice(-summarySettings.count);
    
    try {
        const summaryText = await generateSummary(chatId, messagesToSummarize);
        if (summaryText) {
            await saveSummaryAsMemory(chatId, summaryText);
        }
    } catch (e) {
        // generateSummary 內部已經處理了錯誤彈窗，這裡我們只需要記錄日誌即可
        console.error("自動總結過程中發生未捕獲的錯誤:", e);
    }
}
// ▲▲▲ 替換結束 ▲▲▲


// ▼▼▼ 【V2 - 僅提醒版】用這整塊新代碼替換舊的 promptForManualSummary 函數 ▼▼▼
/**
 * 彈出提示框，【提醒】用戶可以進行手動總結了
 */
async function notifyForManualSummary(chatId) {
    console.log(`手動總結提醒觸發 for chat: ${chatId}`);
    
    // 只彈出一個簡單的通知
    await showCustomAlert(
        '總結提醒',
        '對話已達到設定長度，你可以隨時在“聊天設置”中點擊“立即手動總結”來生成對話記憶。'
    );

    // 【重要】提醒過後，更新“上次總結位置”，以防止每條新消息都彈窗。
    // 這意味著計時器會從現在重新開始計算。
    const chat = state.chats[chatId];
    chat.settings.summary.lastSummaryIndex = chat.history.length - 1;
    await db.chats.put(chat);
}
// ▲▲▲ 替換結束 ▲▲▲


/**
 * 【AI核心 V2 - 已優化】調用API生成總結內容
 * @param {string} chatId - 聊天的ID
 * @param {Array | null} specificMessages - 如果提供，則只總結這個陣列裡的消息；如果為null，則總結自上次以來的所有消息。
 * @returns {Promise<string|null>} - AI生成的總結文本
 */
async function generateSummary(chatId, specificMessages = null) {
    const chat = state.chats[chatId];
    const { proxyUrl, apiKey, model } = state.apiConfig;

    if (!proxyUrl || !apiKey || !model) {
        throw new Error('API未配置，無法生成總結。');
    }

    const summarySettings = chat.settings.summary;
    let messagesToSummarize;

    if (specificMessages && specificMessages.length > 0) {
        messagesToSummarize = specificMessages;
    } else {
        const lastSummaryIndex = summarySettings.lastSummaryIndex > -1 ? summarySettings.lastSummaryIndex : 0;
        messagesToSummarize = chat.history.slice(lastSummaryIndex + 1);
    }
    
    // --- 核心優化：在總結前，先過濾掉任何舊的總結內容 ---
    const filteredMessagesForSummary = messagesToSummarize.filter(msg => msg.type !== 'summary');

    if (filteredMessagesForSummary.length === 0) {
        // 如果是手動點擊，但沒有新消息，給個提示
        if (!specificMessages) {
             await showCustomAlert("無需總結", "自上次總結以來沒有新的對話內容。");
        }
        return null;
    }
    // --- 優化結束 ---

    // 使用過濾後的消息來構建對話文本
    const conversationText = filteredMessagesForSummary.map(msg => {
        const sender = msg.role === 'user' ? (chat.isGroup ? (chat.settings.myNickname || '我') : '我') : (msg.senderName || chat.name);
        let content = '';
        if (typeof msg.content === 'string') {
            content = msg.content;
        } else if (Array.isArray(msg.content)) {
            content = '[圖片]';
        } else if (msg.type) {
            content = `[${msg.type}]`;
        }
        return `${sender}: ${content}`;
    }).join('\n');

    const systemPrompt = summarySettings.prompt + `\n\n--- 對話開始 ---\n${conversationText}\n--- 對話結束 ---`;
    
    try {
        if (!specificMessages) {
             await showCustomAlert("正在生成...", "AI正在努力總結你們的對話，請稍候...");
        }
        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model,
                messages: [{ role: 'user', content: systemPrompt }],
                temperature: 0.3,
            })
        });

        if (!response.ok) throw new Error(await response.text());
        const data = await response.json();
        return data.choices[0].message.content;

    } catch (error) {
        console.error("生成總結失敗:", error);
        await showCustomAlert('總結失敗', `發生錯誤: ${error.message}`);
        return null;
    }
}

/**
 * 將生成的總結作為一條特殊的記憶消息保存起來
 */
async function saveSummaryAsMemory(chatId, summaryText) {
    const chat = state.chats[chatId];
    
    // 記錄下總結操作發生時的最後一條消息的索引
    const newLastSummaryIndex = chat.history.length - 1;

    const summaryMessage = {
        role: 'system',
        type: 'summary', // 特殊類型
        content: summaryText,
        timestamp: Date.now(),
        isHidden: true // 這條消息對AI可見，但對用戶隱藏
    };

    chat.history.push(summaryMessage);
    chat.settings.summary.lastSummaryIndex = newLastSummaryIndex; // 更新索引
    
    await db.chats.put(chat);
    console.log(`新的總結已作為記憶保存 for chat: ${chatId}`);
}

// --- 以下是總結管理介面的函數 ---

let editingSummaryTimestamp = null;

// ▼▼▼ 用這塊【修改後】的代碼替換舊的 openSummaryViewer 函數 ▼▼▼
async function openSummaryViewer() {
    const chat = state.chats[state.activeChatId];
    document.getElementById('summary-viewer-title').textContent = `“${chat.name}”的對話記憶`;
    
    const listEl = document.getElementById('summary-list');
    listEl.innerHTML = '';
    
    const summaries = chat.history.filter(msg => msg.type === 'summary');

    if (summaries.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: #8a8a8a;">還沒有生成過任何總結。</p>';
    } else {
        [...summaries].reverse().forEach(summary => {
            const card = document.createElement('div');
            card.className = 'summary-item-card';
            card.innerHTML = `
                <div class="summary-actions">
                    <!-- 【核心新增】這就是單條精簡總結按鈕 -->
                    <button class="concise-summary-btn" data-timestamp="${summary.timestamp}" title="精簡總結">✨</button>
                    <button class="edit-summary-btn" data-timestamp="${summary.timestamp}" title="編輯">✏️</button>
                    <button class="delete-summary-btn" data-timestamp="${summary.timestamp}" title="刪除">🗑️</button>
                </div>
                <div class="summary-content">${summary.content.replace(/\n/g, '<br>')}</div>
                <div class="summary-meta">
                    <span>生成於: ${new Date(summary.timestamp).toLocaleString()}</span>
                </div>
            `;
            listEl.appendChild(card);
        });
    }
    
    document.getElementById('chat-settings-modal').classList.remove('visible');
    document.getElementById('summary-viewer-modal').classList.add('visible');
}
// ▲▲▲ 替換結束 ▲▲▲


/**
 * 編輯一條總結
 */
async function editSummary(timestamp) {
    const chat = state.chats[state.activeChatId];
    const summary = chat.history.find(msg => msg.timestamp === timestamp);
    if (!summary) return;

    const newContent = await showCustomPrompt(
        '編輯總結',
        '修改總結內容:',
        summary.content,
        'textarea'
    );

    if (newContent !== null) {
        summary.content = newContent.trim();
        await db.chats.put(chat);
        openSummaryViewer(); // 重新渲染列表
    }
}

/**
 * 【已修復】刪除一條總結，並智慧更新總結索引
 */
async function deleteSummary(timestamp) {
    const confirmed = await showCustomConfirm('確認刪除', '確定要刪除這條總結記憶嗎？這可能會影響AI的長期記憶。', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        
        // 1. 從歷史記錄中過濾掉被刪除的總結
        chat.history = chat.history.filter(msg => msg.timestamp !== timestamp);

        // 2. --- 核心修復：重新計算 lastSummaryIndex ---
        // 找到剩下的總結中，最新的那一條
        const lastRemainingSummary = chat.history.filter(m => m.type === 'summary').pop();
        
        let newLastSummaryIndex;

        if (lastRemainingSummary) {
            // 3. 如果還有其他總結，就找到它在歷史記錄中的位置
            const lastSummaryMessageIndexInHistory = chat.history.findIndex(m => m.timestamp === lastRemainingSummary.timestamp);
            // 4. 新的索引就是它前面那條普通消息的索引
            newLastSummaryIndex = lastSummaryMessageIndexInHistory > 0 ? (lastSummaryMessageIndexInHistory - 1) : -1;
        } else {
            // 5. 如果一條總結都不剩了，就徹底重置索引
            newLastSummaryIndex = -1;
        }
        
        // 6. 更新設置
        if (chat.settings.summary) {
            chat.settings.summary.lastSummaryIndex = newLastSummaryIndex;
        }

        // 保存更改並刷新UI
        await db.chats.put(chat);
        openSummaryViewer();
        await showCustomAlert('操作成功', '總結已刪除！');
    }
}

// ▼▼▼ 把這一整塊全新的功能函數，黏貼到你的JS代碼中 ▼▼▼

/**
 * 【AI核心】調用API將指定文本精簡為摘要
 * @param {string} originalText - 原始的、較長的總結文本
 * @returns {Promise<string|null>} - AI生成的精簡摘要，如果失敗則返回null
 */
async function generateConciseSummary(originalText) {
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        throw new Error('API未配置，無法生成精簡摘要。');
    }

    // 核心Prompt：指示AI將內容精簡為一句話
    const systemPrompt = `請你將以下內容精簡為一句話的核心摘要，保留最關鍵的人物、事件和結論，字數控制在20字以內：\n\n--- 內容開始 ---\n${originalText}\n--- 內容結束 ---`;

    try {
        const response = await fetch(`${proxyUrl}/v1/chat/completions`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
            body: JSON.stringify({
                model: model,
                messages: [{ role: 'user', content: systemPrompt }],
                temperature: 0.5, // 使用較低的溫度，讓總結更精確
            })
        });

        if (!response.ok) throw new Error(await response.text());
        const data = await response.json();
        return data.choices[0].message.content;

    } catch (error) {
        console.error("生成精簡摘要失敗:", error);
        await showCustomAlert('精簡失敗', `發生錯誤: ${error.message}`);
        return null;
    }
}

/**
 * 處理單條總結的精簡
 * @param {number} timestamp - 要精簡的總結消息的時間戳記
 */
async function handleConciseSummary(timestamp) {
    const chat = state.chats[state.activeChatId];
    const summary = chat.history.find(msg => msg.timestamp === timestamp);
    if (!summary) return;

    await showCustomAlert("請稍候...", "AI正在努力為您精簡內容...");

    const conciseText = await generateConciseSummary(summary.content);

    if (conciseText) {
        summary.content = conciseText.trim(); // 用精簡後的文本替換原文
        await db.chats.put(chat); // 保存到資料庫
        await openSummaryViewer(); // 重新渲染列表
        await showCustomAlert('成功', '本條總結已精簡！');
    }
}

/**
 * 處理全部總結的精簡
 */
async function handleConciseAllSummaries() {
    const chat = state.chats[state.activeChatId];
    const summaries = chat.history.filter(msg => msg.type === 'summary');

    if (summaries.length === 0) {
        alert("沒有可以精簡的總結。");
        return;
    }

    const confirmed = await showCustomConfirm(
        '確認全部精簡',
        `確定要精簡全部 ${summaries.length} 條總結嗎？此操作會覆蓋原始內容且不可恢復。`,
        { confirmButtonClass: 'btn-danger' }
    );
    if (!confirmed) return;

    await showCustomAlert("請稍候...", `正在批量精簡 ${summaries.length} 條總結，這可能需要一些時間...`);

    try {
        // 使用 for...of 迴圈來逐條處理，避免同時發送太多API請求導致被限制
        for (const summary of summaries) {
            const conciseText = await generateConciseSummary(summary.content);
            if (conciseText) {
                summary.content = conciseText.trim();
            }
            // 每處理完一條，稍微等待一下，給API一點喘息時間
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        await db.chats.put(chat);
        await openSummaryViewer();
        await showCustomAlert('成功', '所有總結都已精簡完畢！');
    } catch (error) {
        // generateConciseSummary 內部已經處理了錯誤彈窗，這裡我們只需要確保流程正常結束
        console.error("批量精簡時出錯:", error);
    }
}

// ▲▲▲ 新功能函數黏貼結束 ▲▲▲

// ▲▲▲ 聊天總結功能核心函數黏貼結束 ▲▲▲
// ▼▼▼ 【全新】黏貼這個新函數到你的JS功能函式定義區 ▼▼▼
/**
 * 使用者點擊“立即手動總結”按鈕時觸發的函數
 */
async function triggerManualSummaryNow() {
    if (isSummarizing) {
        alert("正在處理上一個總結任務，請稍候...");
        return;
    }

    isSummarizing = true; // 上鎖

    try {
        // 調用 generateSummary，但不傳遞第二個參數，這樣它就會總結自上次以來的所有新消息
        const summaryText = await generateSummary(state.activeChatId, null);
        
        if (summaryText) {
            await saveSummaryAsMemory(state.activeChatId, summaryText);
            await showCustomAlert('總結完成', '新的對話記憶已生成！');
            // 成功後，刷新總結管理列表
            if (document.getElementById('summary-viewer-modal').classList.contains('visible')) {
                openSummaryViewer();
            }
        }
    } catch (e) {
        // generateSummary 內部已經處理了錯誤彈窗
        console.error("手動總結過程中發生未捕獲的錯誤:", e);
    } finally {
        isSummarizing = false; // 解鎖
    }
}
// ▲▲▲ 新函數黏貼結束 ▲▲▲
// ▼▼▼ 在這裡黏貼下面這一整塊新代碼 ▼▼▼

/**
 * 【全新】更新角色手機錢包的餘額和交易記錄
 * @param {string} charId - 要更新錢包的角色ID
 * @param {number} amount - 交易金額 (正數為收入, 負數為支出)
 * @param {string} description - 交易描述 (例如: "轉帳給 XX", "收到 XX 的紅包")
 */
async function updateCharacterBankBalance(charId, amount, description) {
    // 安全檢查：如果缺少關鍵資訊，則直接返回
    if (!charId || !amount || isNaN(amount)) {
        console.warn("updateCharacterBankBalance 調用失敗：缺少charId或有效的amount。");
        return;
    }

    // 從全域狀態中獲取角色物件
    const chat = state.chats[charId];
    // 安全檢查：確保角色存在且不是群聊
    if (!chat || chat.isGroup) {
        console.warn(`updateCharacterBankBalance 跳過：找不到ID為 ${charId} 的角色或該ID為群聊。`);
        return;
    }

    // --- 確保資料結構完整，相容舊資料 ---
    if (!chat.characterPhoneData) {
        chat.characterPhoneData = {};
    }
    if (!chat.characterPhoneData.bank) {
        chat.characterPhoneData.bank = { balance: 0, transactions: [] };
    }
    // 如果舊資料的餘額不是數位，則強制設為0
    if (typeof chat.characterPhoneData.bank.balance !== 'number') {
        chat.characterPhoneData.bank.balance = 0;
    }
    // 如果舊資料的交易記錄不是陣列，則創建一個空陣列
    if (!Array.isArray(chat.characterPhoneData.bank.transactions)) {
        chat.characterPhoneData.bank.transactions = [];
    }

    // --- 核心邏輯 ---
    // 1. 創建一條新的交易記錄
    const newTransaction = {
        type: amount > 0 ? '收入' : '支出',
        amount: Math.abs(amount), // 交易記錄裡的金額總是正數
        description: description,
        timestamp: Date.now() // 記錄交易發生的時間
    };

    // 2. 更新餘額
    chat.characterPhoneData.bank.balance += amount;

    // 3. 將新交易記錄添加到清單的開頭（讓最新的顯示在最前面）
    chat.characterPhoneData.bank.transactions.unshift(newTransaction);

    // 4. 將更新後的角色資料保存回資料庫
    await db.chats.put(chat);
    
    console.log(`✅ 錢包同步成功: 角色[${chat.name}], 交易[${description}], 金額[${amount.toFixed(2)}], 新餘額[${chat.characterPhoneData.bank.balance.toFixed(2)}]`);
}

// ▲▲▲ 新代碼黏貼結束 ▲▲▲
// ▼▼▼ 把這一整塊全新的功能函數，黏貼到 init() 函數的正上方 ▼▼▼

/* --- 【全新】“桃寶”App 核心功能函數 --- */

let currentEditingProductId = null; // 用於追蹤正在編輯的商品ID
/**
 * 【全新 | 已修復】清空桃寶首頁的所有商品及購物車
 */
async function clearTaobaoProducts() {
    // 1. 修改提示語，告知用戶購物車也會被清空
    const confirmed = await showCustomConfirm(
        '確認清空',
        '確定要清空桃寶首頁的所有商品嗎？此操作將【一併清空購物車】，且無法恢復。',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        try {
            // 使用資料庫事務，確保兩步操作要麼都成功，要麼都失敗，更安全
            await db.transaction('rw', db.taobaoProducts, db.taobaoCart, async () => {
                // 清空商品庫
                await db.taobaoProducts.clear();
                // ▼▼▼ 核心新增代碼1：清空購物車資料庫 ▼▼▼
                await db.taobaoCart.clear();
            });
            
            // 重新渲染UI
            await renderTaobaoProducts(); 
            // ▼▼▼ 核心新增代碼2：刷新購物車UI（讓頁面變空） ▼▼▼
            await renderTaobaoCart();
            // ▼▼▼ 核心新增代碼3：更新購物車角標（讓紅點消失） ▼▼▼
            updateCartBadge();

            // 2. 修改成功提示
            await showCustomAlert('操作成功', '所有商品及購物車已被清空！');

        } catch (error) {
            console.error("清空桃寶商品時出錯:", error);
            await showCustomAlert('操作失敗', `發生錯誤: ${error.message}`);
        }
    }
}


/**
 * 【總入口】打開“桃寶”App，並渲染默認視圖
 */
async function openTaobaoApp() {
    showScreen('taobao-screen');
    await renderTaobaoProducts(); // 預設顯示所有商品
    renderBalanceDetails(); // 刷新餘額顯示
}

// ▼▼▼ 請將這一整塊全新的功能函數，完整地黏貼到 // 桃寶 App 功能函數區的末尾 ▼▼▼

/**
 * 【全新】切換“桃寶”App內的不同視圖（首頁、購物車、訂單、我的）
 */
function switchTaobaoView(viewId) {
    document.querySelectorAll('.taobao-view').forEach(v => v.classList.remove('active'));
    document.getElementById(viewId).classList.add('active');

    document.querySelectorAll('.taobao-tab').forEach(t => {
        t.classList.toggle('active', t.dataset.view === viewId);
    });

    // 根據切換的視圖，執行對應的渲染函數
    if (viewId === 'orders-view') {
        renderTaobaoOrders();
    } else if (viewId === 'my-view') {
        renderBalanceDetails();
    } else if (viewId === 'cart-view') {
        renderTaobaoCart(); // ★★★ 新增：切換到購物車時，渲染購物車內容
    }
}

/**
 * 【全新】渲染購物車頁面
 */
async function renderTaobaoCart() {
    const listEl = document.getElementById('cart-item-list');
    const checkoutBar = document.getElementById('cart-checkout-bar');
    listEl.innerHTML = '';
    
    const cartItems = await db.taobaoCart.toArray();

    if (cartItems.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">購物車空空如也~</p>';
        checkoutBar.style.display = 'none';
        updateCartBadge(0);
        return;
    }
    
    checkoutBar.style.display = 'flex';
    let totalPrice = 0;
    let totalItems = 0;

    for (const item of cartItems) {
        const product = await db.taobaoProducts.get(item.productId);
        if (!product) continue;

        totalItems += item.quantity;
        totalPrice += product.price * item.quantity;

        const itemEl = document.createElement('div');
        itemEl.className = 'cart-item';
        itemEl.innerHTML = `
            <img src="${product.imageUrl}" class="product-image" data-product-id="${product.id}">
            <div class="cart-item-info" data-product-id="${product.id}">
                <div class="product-name">${product.name}</div>
                <div class="product-price">¥${product.price.toFixed(2)}</div>
            </div>
            <div class="quantity-controls">
                <button class="quantity-decrease" data-cart-id="${item.id}" ${item.quantity <= 1 ? 'disabled' : ''}>-</button>
                <span class="quantity-display">${item.quantity}</span>
                <button class="quantity-increase" data-cart-id="${item.id}">+</button>
            </div>
            <button class="delete-cart-item-btn" data-cart-id="${item.id}">×</button>
        `;
        listEl.appendChild(itemEl);
    }
    
    document.getElementById('cart-total-price').textContent = `¥ ${totalPrice.toFixed(2)}`;
    const checkoutBtn = document.getElementById('checkout-btn');
    checkoutBtn.textContent = `結算(${totalItems})`;
    checkoutBtn.dataset.totalPrice = totalPrice; // 把總價存起來，方便結算時用

    updateCartBadge(totalItems);
}

/**
 * 【全新】更新購物車圖示上的角標數量
 */
function updateCartBadge() {
    const badge = document.getElementById('cart-item-count-badge');
    db.taobaoCart.toArray().then(items => {
        const totalCount = items.reduce((sum, item) => sum + item.quantity, 0);
        if (totalCount > 0) {
            badge.textContent = totalCount > 99 ? '99+' : totalCount;
            badge.style.display = 'inline-block';
        } else {
            badge.style.display = 'none';
        }
    });
}

/**
 * 【全新】處理加入購物車的邏輯
 */
async function handleAddToCart(productId) {
    const existingItem = await db.taobaoCart.where('productId').equals(productId).first();
    if (existingItem) {
        // 如果已存在，則數量+1
        await db.taobaoCart.update(existingItem.id, { quantity: existingItem.quantity + 1 });
    } else {
        // 如果不存在，則新增
        await db.taobaoCart.add({ productId: productId, quantity: 1 });
    }
    await showCustomAlert('成功', '寶貝已加入購物車！');
    updateCartBadge(); // 更新角標
}

/**
 * 【全新】處理購物車內商品數量的變化
 */
async function handleChangeCartItemQuantity(cartId, change) {
    const item = await db.taobaoCart.get(cartId);
    if (!item) return;

    const newQuantity = item.quantity + change;
    if (newQuantity <= 0) {
        // 如果數量減到0，就刪除該項
        await handleRemoveFromCart(cartId);
    } else {
        await db.taobaoCart.update(cartId, { quantity: newQuantity });
        await renderTaobaoCart();
    }
}

/**
 * 【全新】從購物車中移除商品
 */
async function handleRemoveFromCart(cartId) {
    await db.taobaoCart.delete(cartId);
    await renderTaobaoCart();
}

// ▼▼▼ 用這塊【已集成評價功能】的代碼，完整替換舊的 openProductDetail 函數 ▼▼▼
/**
 * 【全新】打開商品詳情彈窗 (已集成評價功能)
 */
async function openProductDetail(productId) {
    const product = await db.taobaoProducts.get(productId);
    if (!product) return;

    const modal = document.getElementById('product-detail-modal');
    const bodyEl = document.getElementById('product-detail-body');
    const reviewsSection = document.getElementById('product-reviews-section');
    const reviewsListEl = document.getElementById('product-reviews-list');
    const generateBtn = document.getElementById('generate-reviews-btn');
    
    // 渲染商品基本資訊
    bodyEl.innerHTML = `
        <img src="${product.imageUrl}" class="product-image" alt="${product.name}">
        <h2 class="product-name">${product.name}</h2>
        <p class="product-price">${product.price.toFixed(2)}</p>
        <p style="color: #888; font-size: 13px;">店鋪: ${product.store || '桃寶自營'}</p>
    `;

    // ★★★ 渲染評價區域 ★★★
    reviewsListEl.innerHTML = '';
    if (product.reviews && product.reviews.length > 0) {
        // 如果有評價，就渲染它們
        product.reviews.forEach(review => {
            const reviewEl = document.createElement('div');
            reviewEl.className = 'product-review-item';
            reviewEl.innerHTML = `
                <div class="review-author">${review.author}</div>
                <p>${review.text}</p>
            `;
            reviewsListEl.appendChild(reviewEl);
        });
        generateBtn.style.display = 'none'; // 有評價了就隱藏生成按鈕
    } else {
        // 如果沒有評價，就顯示提示和生成按鈕
        reviewsListEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary); font-size: 13px;">還沒有人評價哦~</p>';
        generateBtn.style.display = 'block';
    }

    // 重新綁定“生成評價”按鈕的事件 (使用克隆節點防止重複綁定)
    const newGenerateBtn = generateBtn.cloneNode(true);
    generateBtn.parentNode.replaceChild(newGenerateBtn, generateBtn);
    newGenerateBtn.addEventListener('click', () => generateProductReviews(productId));

    // 重新綁定“加入購物車”按鈕的事件
    const addToCartBtn = document.getElementById('detail-add-to-cart-btn');
    const newAddToCartBtn = addToCartBtn.cloneNode(true);
    addToCartBtn.parentNode.replaceChild(newAddToCartBtn, addToCartBtn);
    newAddToCartBtn.onclick = async () => {
        await handleAddToCart(productId);
        modal.classList.remove('visible'); // 添加後自動關閉彈窗
    };
    
    // 綁定關閉按鈕
    document.getElementById('close-product-detail-btn').onclick = () => modal.classList.remove('visible');

    modal.classList.add('visible');
}

/**
 * 【全新】AI核心：為指定商品生成評價
 * @param {number} productId - 商品的ID
 */
async function generateProductReviews(productId) {
    await showCustomAlert("請稍候...", "正在召喚買家秀大軍...");
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先配置API！');
        return;
    }
    
    const product = await db.taobaoProducts.get(productId);
    if (!product) return;

    const prompt = `
# 任務
你是一位專業的電商評論生成器。請你為以下商品生成3-5條風格各異的模擬買家評價。

# 商品資訊
- 名稱: ${product.name}
- 價格: ${product.price}元
- 分類: ${product.category || '未分類'}

# 核心規則
1.  **風格多樣**: 生成的評論應包含不同風格，例如：
    -   **好評**: 詳細誇讚商品的某個優點。
    -   **中評/追評**: 描述使用一段時間後的感受，可能提到一些小瑕疵。
    -   **差評**: 吐槽商品的某個缺點，但語氣要像真實買家。
    -   **搞笑評論**: 寫一些幽默風趣的評論。
    -   **簡潔評論**: 例如“好評”、“還行”、“物流很快”。
2.  **昵稱真實**: 評論的作者昵稱 ("author") 必須是隨機的、生活化的、符合購物App用戶習慣的。例如：“匿名使用者”、“小王不吃香菜”、“可樂愛好者”。
3.  **格式鐵律**: 你的回復【必須且只能】是一個嚴格的JSON陣列，每個物件代表一條評論，並包含 "author" 和 "text" 兩個欄位。

# JSON輸出格式示例:
[
  { "author": "匿名使用者", "text": "物流很快，包裝也很好，寶貝跟描述的一樣，好評！" },
  { "author": "是小張呀", "text": "有點色差，不過還能接受。先用用看，過段時間再來追評。" }
]
`;
    try {
        const messagesForApi = [{ role: 'user', content: prompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.0, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API請求失敗: ${await response.text()}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const newReviews = JSON.parse(cleanedContent);

        if (Array.isArray(newReviews) && newReviews.length > 0) {
            // 將AI生成的評價保存到商品資料中
            await db.taobaoProducts.update(productId, { reviews: newReviews });
            await showCustomAlert("生成成功！", `已成功生成 ${newReviews.length} 條評價。`);
            // 重新打開詳情頁，刷新顯示
            await openProductDetail(productId);
        } else {
            throw new Error("AI返回的資料格式不正確。");
        }
    } catch (error) {
        console.error("生成商品評價失敗:", error);
        await showCustomAlert('生成失敗', `發生錯誤: ${error.message}`);
    }
}
// ▲▲▲ 新增功能函數結束 ▲▲▲

// ▼▼▼ 用這塊【已集成物流】的代碼，替換舊的 handleCheckout 函數 ▼▼▼
/**
 * 【全新】結算購物車
 */
async function handleCheckout() {
    const checkoutBtn = document.getElementById('checkout-btn');
    const totalPrice = parseFloat(checkoutBtn.dataset.totalPrice);
    
    if (totalPrice <= 0) return;

    const currentBalance = state.globalSettings.userBalance || 0;
    if (currentBalance < totalPrice) {
        alert("餘額不足！請先去“我的”頁面充值。");
        return;
    }
    
    const confirmed = await showCustomConfirm(
        '確認支付',
        `本次將花費 ¥${totalPrice.toFixed(2)}，確定要結算嗎？`,
        { confirmText: '立即支付' }
    );
    
    if (confirmed) {
        const cartItems = await db.taobaoCart.toArray();
        const productPromises = cartItems.map(item => db.taobaoProducts.get(item.productId));
        const productsInCart = await Promise.all(productPromises);
        const validProducts = productsInCart.filter(Boolean);

        let description = '購買商品: ';
        const itemNames = validProducts.map(p => `“${p.name}”`);
        if (itemNames.length > 2) {
            description += itemNames.slice(0, 2).join('、') + ` 等${itemNames.length}件商品`;
        } else {
            description += itemNames.join('、');
        }
        
        await updateUserBalanceAndLogTransaction(-totalPrice, description);

        // ★★★ 核心修改：為每個訂單創建物流歷史起點 ★★★
        const newOrders = cartItems.map((item, index) => ({
            productId: item.productId,
            quantity: item.quantity,
            timestamp: Date.now() + index, // 訂單創建時間
            status: '已付款，等待發貨'
            // 我們不再需要在資料庫裡存 logisticsHistory，因為它是動態類比的
        }));
        
        await db.taobaoOrders.bulkAdd(newOrders);
        await db.taobaoCart.clear();
        await renderTaobaoCart();

        alert('支付成功！寶貝正在火速打包中~');
        switchTaobaoView('orders-view');
    }
}
// ▲▲▲ 替換結束 ▲▲▲




// ▼▼▼ 【最終修復版】請用這整塊代碼，完整替換舊的 renderTaobaoProducts 函數 ▼▼▼
/**
 * 【最終修復版】渲染商品列表，杜絕重複並移除多餘按鈕
 */
async function renderTaobaoProducts(category = null) {
    const gridEl = document.getElementById('product-grid');
    const categoryTabsEl = document.getElementById('product-category-tabs');
    
    // 我們仍然保留清空操作，這是個好習慣
    gridEl.innerHTML = '';

    const allProducts = await db.taobaoProducts.orderBy('name').toArray();
    const categories = [...new Set(allProducts.map(p => p.category).filter(Boolean))];

    // 渲染分類頁簽 (這部分邏輯是正確的，保持不變)
    categoryTabsEl.innerHTML = `<button class="category-tab-btn ${!category ? 'active' : ''}" data-category="all">全部</button>`;
    categories.forEach(cat => {
        categoryTabsEl.innerHTML += `<button class="category-tab-btn ${category === cat ? 'active' : ''}" data-category="${cat}">${cat}</button>`;
    });

    const productsToRender = category 
        ? allProducts.filter(p => p.category === category)
        : allProducts;

    if (productsToRender.length === 0) {
        gridEl.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: var(--text-secondary);">還沒有商品哦，點擊右上角“+”添加吧！</p>';
        return;
    }

    productsToRender.forEach(product => {
        // ★★★ 核心修復1：在這裡檢查商品是否已存在 ★★★
        // 如果頁面上已經有一個帶有相同商品ID的卡片了，就直接跳過，不執行後面的添加操作。
        if (gridEl.querySelector(`[data-product-id="${product.id}"]`)) {
            console.warn(`檢測到重複商品，已跳過渲染: ${product.name}`);
            return; // 跳過本次迴圈
        }

        const card = document.createElement('div');
        card.className = 'product-card';
        card.dataset.productId = product.id;

        // ★★★ 核心修復2：移除了您不想要的“加入購物車”按鈕 ★★★
        card.innerHTML = `
            <img src="${product.imageUrl}" class="product-image" alt="${product.name}">
            <div class="product-info">
                <div class="product-name">${product.name}</div>
                <div class="product-price">${product.price.toFixed(2)}</div>
            </div>
        `;
        // 長按刪除功能保持不變
        addLongPressListener(card, () => showProductActions(product.id));

        // 最終將創建好的卡片添加到頁面
        gridEl.appendChild(card);
    });
}
// ▲▲▲ 替換結束 ▲▲▲




/**
 * 渲染“我的訂單”清單
 */
async function renderTaobaoOrders() {
    const listEl = document.getElementById('order-list');
    listEl.innerHTML = '';
    const orders = await db.taobaoOrders.reverse().sortBy('timestamp');

    if (orders.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary);">還沒有任何訂單記錄</p>';
        return;
    }

    for (const order of orders) {
        const product = await db.taobaoProducts.get(order.productId);
        if (!product) continue;

        const item = document.createElement('div');
        item.className = 'order-item';
        item.dataset.orderId = order.id;
        item.innerHTML = `
            <img src="${product.imageUrl}" class="product-image">
            <div class="order-info">
                <div class="product-name">${product.name}</div>
                <div class="order-status">${order.status}</div>
                <div class="order-time">${new Date(order.timestamp).toLocaleString()}</div>
            </div>
        `;
        listEl.appendChild(item);
    }
}

/**
 * 渲染“我的”頁面的餘額
 */
function renderTaobaoBalance() {
    const balance = state.globalSettings.userBalance || 0;
    document.getElementById('user-balance-display').textContent = `¥ ${balance.toFixed(2)}`;
}

/**
 * 打開添加商品的方式選擇彈窗
 */
function openAddProductChoiceModal() {
    document.getElementById('add-product-choice-modal').classList.add('visible');
}

/**
 * 打開手動添加/編輯商品的彈窗
 */
function openProductEditor(productId = null) {
    currentEditingProductId = productId;
    const modal = document.getElementById('product-editor-modal');
    const titleEl = document.getElementById('product-editor-title');
    
    if (productId) {
        titleEl.textContent = '編輯商品';
        // (非同步) 載入現有商品資料
        db.taobaoProducts.get(productId).then(product => {
            if (product) {
                document.getElementById('product-name-input').value = product.name;
                document.getElementById('product-price-input').value = product.price;
                document.getElementById('product-image-input').value = product.imageUrl;
                document.getElementById('product-category-input').value = product.category || '';
            }
        });
    } else {
        titleEl.textContent = '添加新商品';
        // 清空輸入框
        document.getElementById('product-name-input').value = '';
        document.getElementById('product-price-input').value = '';
        document.getElementById('product-image-input').value = '';
        document.getElementById('product-category-input').value = '';
    }
    modal.classList.add('visible');
}

// ▼▼▼ 用這塊【新代碼】替換舊的 saveProduct 函數 ▼▼▼
/**
 * 保存手動添加或編輯的商品
 */
async function saveProduct() {
    const name = document.getElementById('product-name-input').value.trim();
    const price = parseFloat(document.getElementById('product-price-input').value);
    let imageUrl = document.getElementById('product-image-input').value.trim(); // 核心修改1：使用let
    const category = document.getElementById('product-category-input').value.trim();

    // 核心修改2：現在圖片URL不是必填項了
    if (!name || isNaN(price) || price <= 0) {
        alert("請填寫所有必填項（名稱、有效價格）！");
        return;
    }

    // 核心修改3：如果圖片URL為空，就調用我們的新函數獲取一個隨機預設圖
    if (!imageUrl) {
        imageUrl = getRandomDefaultProductImage();
    }

    const productData = { name, price, imageUrl, category };

    if (currentEditingProductId) {
        await db.taobaoProducts.update(currentEditingProductId, productData);
        alert('商品已更新！');
    } else {
        await db.taobaoProducts.add(productData);
        alert('新商品已添加！');
    }

    document.getElementById('product-editor-modal').classList.remove('visible');
    await renderTaobaoProducts(); // 刷新商品列表
    currentEditingProductId = null;
}
// ▲▲▲ 替換結束 ▲▲▲


/**
 * 打開識別連結的彈窗
 */
function openAddFromLinkModal() {
    document.getElementById('link-paste-area').value = '';
    document.getElementById('add-from-link-modal').classList.add('visible');
}

// ▼▼▼ 用這塊【新代碼】替換舊的 handleAddFromLink 函數 ▼▼▼
/**
 * 核心功能：處理黏貼的分享文案
 */
async function handleAddFromLink() {
    const text = document.getElementById('link-paste-area').value;
    const nameMatch = text.match(/「(.+?)」/);

    if (!nameMatch || !nameMatch[1]) {
        alert('無法識別商品名稱！請確保黏貼了包含「商品名」的完整分享文案。');
        return;
    }

    const name = nameMatch[1];
    
    document.getElementById('add-from-link-modal').classList.remove('visible');
    
    const priceStr = await showCustomPrompt(`商品: ${name}`, "請輸入價格 (元):", "", "number");
    if (priceStr === null) return;
    const price = parseFloat(priceStr);
    if (isNaN(price) || price <= 0) {
        alert("請輸入有效的價格！");
        return;
    }

    // 核心修改1：讓圖片URL變成可選
    let imageUrl = await showCustomPrompt(`商品: ${name}`, "請輸入圖片連結 (URL, 可選):");
    if (imageUrl === null) return; // 如果用戶點取消，則中斷操作

    // 核心修改2：如果使用者沒填圖片連結，就使用隨機預設圖
    if (!imageUrl || !imageUrl.trim()) {
        imageUrl = getRandomDefaultProductImage();
    }

    const category = await showCustomPrompt(`商品: ${name}`, "請輸入分類 (可選):");

    await db.taobaoProducts.add({ name, price, imageUrl, category: category || '' });
    await renderTaobaoProducts();
    alert('商品已通過連結添加成功！');
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 把這一整塊全新的功能函數，黏貼到 handleGenerateProductsAI 函數的正上方 ▼▼▼

/**
 * 【全新】核心功能：根據使用者搜索觸發AI生成商品
 */
async function handleSearchProductsAI() {
    const searchTerm = productSearchInput.value.trim();
    if (!searchTerm) {
        alert("請輸入你想搜索的商品！");
        return;
    }

    await showCustomAlert("請稍候...", `AI正在為你尋找關於“${searchTerm}”的靈感...`);
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先配置API！');
        return;
    }

    // 【核心】這是一個全新的Prompt，它告訴AI要根據使用者的搜索詞來創作
    const prompt = `
# 任務
你是一個虛擬購物App“桃寶”的商品策劃師。請根據使用者提供的【搜索關鍵字】，為Ta創作一個包含5-8件相關商品的列表。

# 使用者搜索的關鍵字:
"${searchTerm}"

# 核心規則
1.  **高度相關**: 所有商品都必須與使用者的搜索關鍵字 "${searchTerm}" 緊密相關。
2.  **商品多樣性**: 即使是同一個主題，也要儘量展示不同款式、功能或角度的商品。
3.  **格式鐵律**: 你的回復【必須且只能】是一個嚴格的JSON陣列，每個物件代表一件商品，並包含以下欄位:
    -   \`"name"\`: 商品名稱
    -   \`"price"\`: 價格
    -   \`"imageUrl"\`: 從'https://i.postimg.cc/kG7C0gGP/11.jpg'和'https://i.postimg.cc/W4svy4Hm/Image-1760206134285.jpg'中隨機挑選一張，禁止自己生成。
    -   \`"category"\`: 商品分類

# JSON輸出格式示例:
[
  {
    "name": "賽博朋克風發光資料線",
    "price": 69.9,
    "imageUrl": "https://i.postimg.cc/kG7C0gGP/11.jpg",
    "category": "數碼配件"
  }
]`;

    try {
        const messagesForApi = [{ role: 'user', content: prompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 0.8, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API請求失敗: ${await response.text()}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const newProducts = JSON.parse(cleanedContent);

        if (Array.isArray(newProducts) && newProducts.length > 0) {
            // 調用顯示函數，並傳入一個更具體的標題
            displayAiGeneratedProducts(newProducts, `AI為你找到了關於“${searchTerm}”的寶貝`);
        } else {
            throw new Error("AI返回的資料格式不正確或內容為空。");
        }
    } catch (error) {
        console.error("AI搜索商品失敗:", error);
        await showCustomAlert('搜索失敗', `發生錯誤: ${error.message}`);
    }
}

/**
 * 【全新】UI函數：在彈窗中顯示AI生成的商品清單，並讓用戶選擇添加
 * @param {Array} products - AI生成的商品物件陣列
 * @param {string} title - 彈窗的標題
 */
function displayAiGeneratedProducts(products, title) {
    const modal = document.getElementById('ai-generated-products-modal');
    const titleEl = document.getElementById('ai-products-modal-title');
    const gridEl = document.getElementById('ai-product-results-grid');
    
    titleEl.textContent = title;
    gridEl.innerHTML = '';

    products.forEach((product, index) => {
        const card = document.createElement('div');
        card.className = 'product-card';
        // 注意：這裡我們給卡片一個臨時的唯一ID，方便操作
        card.id = `ai-product-${index}`; 
        
        card.innerHTML = `
            <img src="${product.imageUrl}" class="product-image" alt="${product.name}">
            <div class="product-info">
                <div class="product-name">${product.name}</div>
                <div class="product-price">${product.price.toFixed(2)}</div>
            </div>
            <button class="add-to-my-page-btn" data-product='${JSON.stringify(product)}'>+ 添加到我的桃寶</button>
        `;
        gridEl.appendChild(card);
    });

    modal.classList.add('visible');
}
// ▲▲▲ 新增函數結束 ▲▲▲

// ▼▼▼ 用這塊【新代碼】替換舊的 handleGenerateProductsAI 函數 ▼▼▼
/**
 * 核心功能：觸發AI【隨機】生成商品，並在彈窗中顯示
 */
async function handleGenerateProductsAI() {
    await showCustomAlert("請稍候...", "正在請求AI生成一批有趣的商品...");
    const { proxyUrl, apiKey, model } = state.apiConfig;
    if (!proxyUrl || !apiKey || !model) {
        alert('請先配置API！');
        return;
    }

    const prompt = `
# 任務
你是一個虛擬購物App“桃寶”的商品策劃師。請你創作一個包含5-8件商品的列表。

# 核心規則
1.  **商品多樣性**: 商品必須有趣、多樣，可以包含服裝、零食、家居用品、虛擬物品等。
2.  **分類清晰**: 為每件商品設置一個合理的分類。
3.  **格式鐵律**: 你的回復【必須且只能】是一個嚴格的JSON陣列，直接以 '[' 開頭，以 ']' 結尾。每個物件代表一件商品，【必須】包含以下欄位:
    -   \`"name"\`: 商品名稱 (字串)
    -   \`"price"\`: 價格 (數字)
    -   \`"imageUrl"\`: 從'https://i.postimg.cc/kG7C0gGP/11.jpg'和'https://i.postimg.cc/W4svy4Hm/Image-1760206134285.jpg'中隨機挑選一張，禁止自己生成。
    -   \`"category"\`: 商品分類 (字串)

# JSON輸出格式示例:
[
  {
    "name": "會發光的蘑菇小夜燈",
    "price": 49.9,
    "imageUrl": "https://i.postimg.cc/W4svy4Hm/Image-1760206134285.jpg",
    "category": "家居"
  }
]`;

    try {
        const messagesForApi = [{ role: 'user', content: prompt }];
        let isGemini = proxyUrl === GEMINI_API_URL;
        let geminiConfig = toGeminiRequestData(model, apiKey, prompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.0, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(`API請求失敗: ${await response.text()}`);
        
        const data = await response.json();
        const rawContent = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content);
        const cleanedContent = rawContent.replace(/^```json\s*|```$/g, '').trim();
        const newProducts = JSON.parse(cleanedContent);

        if (Array.isArray(newProducts) && newProducts.length > 0) {
            // 【核心修改】不再直接保存，而是調用顯示函數
            displayAiGeneratedProducts(newProducts, "AI隨機生成了以下寶貝");
        } else {
            throw new Error("AI返回的資料格式不正確。");
        }
    } catch (error) {
        console.error("AI生成商品失敗:", error);
        await showCustomAlert('生成失敗', `發生錯誤: ${error.message}`);
    }
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 處理使用者點擊商品卡片的邏輯（購買）
 */
async function handleBuyProduct(productId) {
    const product = await db.taobaoProducts.get(productId);
    if (!product) return;

    const currentBalance = state.globalSettings.userBalance || 0;
    if (currentBalance < product.price) {
        alert("餘額不足，先去“我的”頁面充點錢吧！");
        return;
    }

    const confirmed = await showCustomConfirm(
        '確認購買',
        `確定要花費 ¥${product.price.toFixed(2)} 購買“${product.name}”嗎？`,
        { confirmText: '立即支付' }
    );

    if (confirmed) {
        // 1. 扣除餘額
        state.globalSettings.userBalance -= product.price;
        await db.globalSettings.put(state.globalSettings);

        // 2. 創建訂單
        const newOrder = {
            productId: productId,
            timestamp: Date.now(),
            status: '已付款，等待發貨'
        };
        await db.taobaoOrders.add(newOrder);
        
        // 模擬物流更新
        setTimeout(async () => {
            const orderToUpdate = await db.taobaoOrders.where({ timestamp: newOrder.timestamp }).first();
            if (orderToUpdate) {
                await db.taobaoOrders.update(orderToUpdate.id, { status: '已發貨，運輸中' });
            }
        }, 1000 * 10); // 10秒後更新為已發貨

        alert('購買成功！你可以在“我的訂單”中查看物流資訊。');
        renderTaobaoBalance(); // 刷新餘額顯示
    }
}

/**
 * 長按商品時顯示操作功能表
 */
async function showProductActions(productId) {
    const choice = await showChoiceModal("商品操作", [
        { text: '✏️ 編輯商品', value: 'edit' },
        { text: '🗑️ 刪除商品', value: 'delete' }
    ]);

    if (choice === 'edit') {
        openProductEditor(productId);
    } else if (choice === 'delete') {
        const product = await db.taobaoProducts.get(productId);
        const confirmed = await showCustomConfirm(
            '確認刪除',
            `確定要刪除商品“${product.name}”嗎？`,
            { confirmButtonClass: 'btn-danger' }
        );
        if (confirmed) {
            await db.taobaoProducts.delete(productId);
            await renderTaobaoProducts();
            alert('商品已刪除。');
        }
    }
}
// ▼▼▼ 把這兩塊全新的函數，黏貼到 init() 函數的上方 ▼▼▼

/**
 * 【全新】核心函數：更新使用者餘額並記錄一筆交易
 * @param {number} amount - 交易金額 (正數為收入, 負數為支出)
 * @param {string} description - 交易描述 (例如: "轉帳給 XX", "收到 XX 的紅包")
 */
async function updateUserBalanceAndLogTransaction(amount, description) {
    if (isNaN(amount)) return; // 安全檢查

    // 確保餘額是數字
    state.globalSettings.userBalance = (state.globalSettings.userBalance || 0) + amount;

    const newTransaction = {
        type: amount > 0 ? 'income' : 'expense',
        amount: Math.abs(amount),
        description: description,
        timestamp: Date.now()
    };

    // 使用資料庫事務，確保兩步操作要麼都成功，要麼都失敗
    await db.transaction('rw', db.globalSettings, db.userWalletTransactions, async () => {
        await db.globalSettings.put(state.globalSettings);
        await db.userWalletTransactions.add(newTransaction);
    });
    
    console.log(`用戶錢包已更新: 金額=${amount.toFixed(2)}, 新餘額=${state.globalSettings.userBalance.toFixed(2)}`);
}

/**
 * 【全新】渲染“我的”頁面的餘額和交易明細
 */
async function renderBalanceDetails() {
    // 1. 渲染當前餘額
    const balance = state.globalSettings.userBalance || 0;
    document.getElementById('user-balance-display').textContent = `¥ ${balance.toFixed(2)}`;

    // 2. 渲染交易明細清單
    const listEl = document.getElementById('balance-details-list');
    listEl.innerHTML = ''; // 清空舊列表

    const transactions = await db.userWalletTransactions.reverse().sortBy('timestamp');

    if (transactions.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: var(--text-secondary); margin-top: 20px;">還沒有任何明細記錄</p>';
        return;
    }
    
    // 給列表加個標題
    listEl.innerHTML = '<h3 style="margin-bottom: 10px; color: var(--text-secondary);">餘額明細</h3>';

    transactions.forEach(item => {
        const itemEl = document.createElement('div');
        itemEl.className = 'transaction-item';
        const sign = item.type === 'income' ? '+' : '-';
        
        itemEl.innerHTML = `
            <div class="transaction-info">
                <div class="description">${item.description}</div>
                <div class="timestamp">${new Date(item.timestamp).toLocaleString()}</div>
            </div>
            <div class="transaction-amount ${item.type}">
                ${sign} ${item.amount.toFixed(2)}
            </div>
        `;
        listEl.appendChild(itemEl);
    });
}
// ▲▲▲ 新函數黏貼結束 ▲▲▲
// ▼▼▼ 在 init() 函數的上方，黏貼下面這 3 個新函數 ▼▼▼

/**
 * 【全新】打開物流詳情頁面
 * @param {number} orderId - 被點擊的訂單ID
 */
async function openLogisticsView(orderId) {
    const order = await db.taobaoOrders.get(orderId);
    if (!order) {
        alert("找不到該訂單！");
        return;
    }

    // 每次打開都先清空舊的計時器
    logisticsUpdateTimers.forEach(timerId => clearTimeout(timerId));
    logisticsUpdateTimers = [];

    // 顯示物流頁面，並開始渲染
    showScreen('logistics-screen');
    await renderLogisticsView(order);
}

/**
 * 【全新】渲染物流詳情頁面的所有內容
 * @param {object} order - 訂單物件
 */
async function renderLogisticsView(order) {
    const contentArea = document.getElementById('logistics-content-area');
    contentArea.innerHTML = '載入中...';

    const product = await db.taobaoProducts.get(order.productId);
    if (!product) {
        contentArea.innerHTML = '無法載入商品資訊。';
        return;
    }

    // 渲染頂部的商品資訊卡片
    contentArea.innerHTML = `
        <div class="logistics-product-summary">
            <img src="${product.imageUrl}" class="product-image">
            <div class="info">
                <div class="name">${product.name} (x${order.quantity})</div>
                <div class="status" id="logistics-main-status">查詢中...</div>
            </div>
        </div>
        <div class="logistics-timeline" id="logistics-timeline-container"></div>
    `;

    const timelineContainer = document.getElementById('logistics-timeline-container');
    const mainStatusEl = document.getElementById('logistics-main-status');
    const creationTime = order.timestamp; // 使用訂單的創建時間作為起點

    // 準備一些隨機城市名，讓物流看起來更真實
    const cities = ["東莞", "廣州", "長沙", "武漢", "鄭州", "北京", "上海", "成都", "西安"];
    const startCity = getRandomItem(cities);
    let nextCity = getRandomItem(cities.filter(c => c !== startCity));
    const userCity = getRandomItem(cities.filter(c => c !== startCity && c !== nextCity)) || '您的城市';
    
    // --- 這就是模擬物流的核心 ---
    let cumulativeDelay = 0;
    logisticsTimelineTemplate.forEach(stepInfo => {
        cumulativeDelay += stepInfo.delay;
        const eventTime = creationTime + cumulativeDelay; // 計算出這個步驟“應該”發生的時間
        const now = Date.now();

        // 替換文本中的預留位置
        const stepText = stepInfo.text.replace(/{city}/g, startCity).replace('{next_city}', nextCity).replace('{user_city}', userCity);

        // 如果這個步驟的發生時間已經過去或就是現在
        if (now >= eventTime) {
            // 就立即把它渲染到頁面上
            addLogisticsStep(timelineContainer, mainStatusEl, stepText, eventTime, true);
        } else {
            // 否則，它就是一個“未來”的步驟
            const delayUntilEvent = eventTime - now; // 計算還有多久才發生
            // 設置一個計時器，在未來的那個時間點執行
            const timerId = setTimeout(() => {
                // 執行前再次檢查用戶是否還停留在物流頁面
                if (document.getElementById('logistics-screen').classList.contains('active')) {
                    addLogisticsStep(timelineContainer, mainStatusEl, stepText, eventTime, true);
                }
            }, delayUntilEvent);
            // 把這個計時器的ID存起來，方便離開頁面時清除
            logisticsUpdateTimers.push(timerId);
        }
    });

    // 如果訂單剛剛創建，可能還沒有任何步驟滿足時間條件，此時手動顯示第一條
    if (timelineContainer.children.length === 0) {
        const firstStep = logisticsTimelineTemplate[0];
        const stepText = firstStep.text.replace(/{city}/g, startCity).replace('{next_city}', nextCity).replace('{user_city}', userCity);
        addLogisticsStep(timelineContainer, mainStatusEl, stepText, creationTime, true);
    }
}

/**
 * 【全新】在時間軸上添加一個物流步驟的輔助函數
 * @param {HTMLElement} container - 時間軸的DOM容器
 * @param {HTMLElement} mainStatusEl - 頂部主狀態的DOM元素
 * @param {string} text - 物流資訊文本
 * @param {number} timestamp - 該步驟發生的時間戳記
 * @param {boolean} prepend - 是否添加到最前面（最新的步驟放前面）
 */
function addLogisticsStep(container, mainStatusEl, text, timestamp, prepend = false) {
    const stepEl = document.createElement('div');
    stepEl.className = 'logistics-step';
    stepEl.innerHTML = `
        <div class="logistics-step-content">
            <div class="status-text">${text}</div>
            <div class="timestamp">${new Date(timestamp).toLocaleString('zh-CN')}</div>
        </div>
    `;

    if (prepend) {
        container.prepend(stepEl); // 插入到最前面
        mainStatusEl.textContent = text; // 更新頂部的狀態
    } else {
        container.appendChild(stepEl);
    }
}
// ▲▲▲ 黏貼結束 ▲▲▲
// ▼▼▼ 把這一整塊全新的功能函數，黏貼到 init() 函數的正上方 ▼▼▼

/**
 * 【全新】處理角色手機錢包餘額和交易記錄的通用函數
 * @param {string} charId - 要更新錢包的角色ID
 * @param {number} amount - 交易金額 (正數為收入, 負數為支出)
 * @param {string} description - 交易描述
 */
async function updateCharacterPhoneBankBalance(charId, amount, description) {
    const chat = state.chats[charId];
    if (!chat || chat.isGroup) return;

    if (!chat.characterPhoneData) chat.characterPhoneData = {};
    if (!chat.characterPhoneData.bank) chat.characterPhoneData.bank = { balance: 0, transactions: [] };
    if (typeof chat.characterPhoneData.bank.balance !== 'number') chat.characterPhoneData.bank.balance = 0;

    chat.characterPhoneData.bank.balance += amount;

    const newTransaction = {
        type: amount > 0 ? '收入' : '支出',
        amount: Math.abs(amount),
        description: description,
        timestamp: Date.now()
    };
    
    // 讓最新的交易記錄顯示在最前面
    if (!Array.isArray(chat.characterPhoneData.bank.transactions)) {
        chat.characterPhoneData.bank.transactions = [];
    }
    chat.characterPhoneData.bank.transactions.unshift(newTransaction);

    await db.chats.put(chat);
    console.log(`✅ 角色[${chat.name}]錢包已更新: 金額=${amount.toFixed(2)}, 新餘額=${chat.characterPhoneData.bank.balance.toFixed(2)}`);
}

/**
 * 【全新】打開一個單選的角色選擇器，讓使用者選擇一個代付物件
 * @returns {Promise<string|null>} - 返回選中的角色ID，如果取消則返回null
 */
async function openCharSelectorForCart() {
    return new Promise(resolve => {
        // 複用分享功能的彈窗，很方便
        const modal = document.getElementById('share-target-modal');
        const listEl = document.getElementById('share-target-list');
        const titleEl = document.getElementById('share-target-modal-title');
        const confirmBtn = document.getElementById('confirm-share-target-btn');
        const cancelBtn = document.getElementById('cancel-share-target-btn');

        titleEl.textContent = '分享給誰代付？';
        listEl.innerHTML = '';

        const singleChats = Object.values(state.chats).filter(c => !c.isGroup);

        if (singleChats.length === 0) {
            alert("你還沒有任何可以分享的好友哦。");
            modal.classList.remove('visible');
            resolve(null);
            return;
        }

        // 使用 radio 選項按鈕
        singleChats.forEach(chat => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.innerHTML = `
                <input type="radio" name="cart-share-target" value="${chat.id}" id="target-${chat.id}" style="margin-right: 15px;">
                <label for="target-${chat.id}" style="display:flex; align-items:center; width:100%; cursor:pointer;">
                    <img src="${chat.settings.aiAvatar || defaultAvatar}" class="avatar">
                    <span class="name">${chat.name}</span>
                </label>
            `;
            listEl.appendChild(item);
        });

        modal.classList.add('visible');

        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        const newCancelBtn = cancelBtn.cloneNode(true);
        cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
        
        const cleanup = () => modal.classList.remove('visible');

        newConfirmBtn.onclick = () => {
            const selectedRadio = document.querySelector('input[name="cart-share-target"]:checked');
            if (selectedRadio) {
                cleanup();
                resolve(selectedRadio.value);
            } else {
                alert("請選擇一個代付物件！");
            }
        };

        newCancelBtn.onclick = () => {
            cleanup();
            resolve(null);
        };
    });
}

/**
 * 【全新】清空桃寶購物車
 */
async function clearTaobaoCart() {
    await db.taobaoCart.clear();
    await renderTaobaoCart();
    updateCartBadge();
}

/**
 * 【全新】根據購物車內容創建訂單
 * @param {Array} cartItems - 購物車專案陣列
 */
async function createOrdersFromCart(cartItems) {
    if (!cartItems || cartItems.length === 0) return;
    const newOrders = cartItems.map((item, index) => ({
        productId: item.productId,
        quantity: item.quantity,
        timestamp: Date.now() + index, // 防止時間戳記完全相同
        status: '已付款，等待發貨'
    }));
    await db.taobaoOrders.bulkAdd(newOrders);
    // 簡單模擬物流更新
    setTimeout(async () => {
        const ordersToUpdate = await db.taobaoOrders.where('status').equals('已付款，等待發貨').toArray();
        for (const order of ordersToUpdate) {
            await db.taobaoOrders.update(order.id, { status: '已發貨，運輸中' });
        }
    }, 1000 * 10);
}

// ▼▼▼ 請用下面這整塊【修復後】的代碼，完整替換掉你舊的 handleShareCart 函數 ▼▼▼

/**
 * 【全新總入口 | 已修復備註名】處理“分享給Ta代付”的全部邏輯
 */
async function handleShareCart() {
    const cartItems = await db.taobaoCart.toArray();
    if (cartItems.length === 0) {
        alert("購物車是空的，先去加點寶貝吧！");
        return;
    }

    const targetChatId = await openCharSelectorForCart();
    if (!targetChatId) return;

    const char = state.chats[targetChatId];
    if (!char) return;

    let totalPrice = 0;
    const productPromises = cartItems.map(item => db.taobaoProducts.get(item.productId));
    const products = await Promise.all(productPromises);
    cartItems.forEach((item, index) => {
        const product = products[index];
        if (product) {
            totalPrice += product.price * item.quantity;
        }
    });

    const charBalance = char.characterPhoneData?.bank?.balance || 0;
    if (charBalance < totalPrice) {
        await showCustomAlert("代付失敗", `“${char.name}”的錢包餘額不足！\n需要 ¥${totalPrice.toFixed(2)}，但餘額只有 ¥${charBalance.toFixed(2)}。`);
        return;
    }
    
    const confirmed = await showCustomConfirm(
        '確認代付',
        `將分享購物車給“${char.name}”並請求代付，共計 ¥${totalPrice.toFixed(2)}。\n這將會清空你的購物車，並從Ta的錢包扣款。確定嗎？`,
        { confirmText: '確定' }
    );

    if (!confirmed) return;
    
    await showCustomAlert("處理中...", "正在通知Ta代付並下單...");
    
    // --- ▼▼▼ 這就是本次的核心修改 ▼▼▼ ---

    // 1. 獲取角色的手機資料，準備查找備註名
    const characterPhoneData = char.characterPhoneData || { chats: {} };
    
    // 2. 在角色的連絡人中，找到代表“使用者”的那個連絡人對象
    //    （通常是那個沒有聊天記錄的特殊連絡人條目）
    const userContactInData = Object.values(characterPhoneData.chats || {}).find(c => !c.history || c.history.length === 0);
    
    // 3. 獲取角色給用戶的備註名，如果沒設置，就默認用“我”
    const remarkForUser = userContactInData ? userContactInData.remarkName : '我';
    
    // 4. 使用這個新的備註名來創建交易記錄
    const description = `為“${remarkForUser}”的桃寶購物車買單`;
    await updateCharacterPhoneBankBalance(targetChatId, -totalPrice, description);
    
    // --- ▲▲▲ 修改結束 ▲▲▲ ---

    await createOrdersFromCart(cartItems);

    const itemsSummary = products.map((p, i) => `${p.name} x${cartItems[i].quantity}`).join('、 ');
    
    // 給AI看的隱藏指令，告訴它發生了什麼
    const hiddenMessage = {
        role: 'system',
        content: `[系統提示：用戶剛剛與你分享了TA的購物車，並請求你為總價為 ¥${totalPrice.toFixed(2)} 的商品付款。你已經同意並支付了，你的錢包餘額已被扣除。商品包括：${itemsSummary}。請根據你的人設對此作出回應，例如表示寵溺、抱怨花錢太多或者詢問買了什麼。]`,
        timestamp: Date.now(),
        isHidden: true
    };
    char.history.push(hiddenMessage);
    await db.chats.put(char);

    await clearTaobaoCart();

    await showCustomAlert("操作成功", `“${char.name}”已成功為你買單！`);
    renderChatList();
    
    openChat(targetChatId); // 跳轉到聊天介面
    triggerAiResponse(); // 讓AI回應這次代付
}

// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 把下面這兩塊全新的函數，黏貼到你的JS功能函式定義區 ▼▼▼

/**
 * 【全新】處理“為Ta購買”的全部邏輯
 */
async function handleBuyForChar() {
    const cartItems = await db.taobaoCart.toArray();
    if (cartItems.length === 0) {
        alert("購物車是空的，先去加點寶貝吧！");
        return;
    }

    const targetChatId = await openCharSelectorForCart();
    if (!targetChatId) return; // 用戶取消選擇

    const char = state.chats[targetChatId];
    if (!char) return;

    let totalPrice = 0;
    const productPromises = cartItems.map(item => db.taobaoProducts.get(item.productId));
    const products = await Promise.all(productPromises);
    products.forEach((product, index) => {
        if (product) {
            totalPrice += product.price * cartItems[index].quantity;
        }
    });

    // 檢查用戶餘額
    if ((state.globalSettings.userBalance || 0) < totalPrice) {
        alert(`餘額不足！本次需要 ¥${totalPrice.toFixed(2)}，但你的餘額只有 ¥${(state.globalSettings.userBalance || 0).toFixed(2)}。`);
        return;
    }

    const confirmed = await showCustomConfirm(
        '確認贈送',
        `確定要花費 ¥${totalPrice.toFixed(2)} 為“${char.name}”購買購物車中的所有商品嗎？`,
        { confirmText: '為Ta買單' }
    );

    if (confirmed) {
        await showCustomAlert("正在處理...", "正在為你心愛的Ta下單...");

        // 1. 扣除用戶餘額
        await updateUserBalanceAndLogTransaction(-totalPrice, `為 ${char.name} 購買商品`);
        
        // 2. 將購物車內容轉化為訂單（記錄在你的訂單裡）
        await createOrdersFromCart(cartItems);

        // 3. 發送禮物通知給對方
        await sendGiftNotificationToChar(targetChatId, products, cartItems, totalPrice);
        
        // 4. 清空購物車
        await clearTaobaoCart();

        await showCustomAlert("贈送成功！", `你為“${char.name}”購買的禮物已下單，並已通過私信通知對方啦！`);
        renderChatList(); // 刷新清單，顯示未讀消息
    }
}

// ▼▼▼ 用這塊【新代碼】替換舊的 sendGiftNotificationToChar 函數 ▼▼▼
// ▼▼▼ 把下面這兩塊全新的函數，黏貼到你的JS功能函式定義區 ▼▼▼

/**
 * 【全新】處理“為Ta購買”的全部邏輯
 */
async function handleBuyForChar() {
    const cartItems = await db.taobaoCart.toArray();
    if (cartItems.length === 0) {
        alert("購物車是空的，先去加點寶貝吧！");
        return;
    }

    const targetChatId = await openCharSelectorForCart();
    if (!targetChatId) return; // 用戶取消選擇

    const char = state.chats[targetChatId];
    if (!char) return;

    let totalPrice = 0;
    const productPromises = cartItems.map(item => db.taobaoProducts.get(item.productId));
    const products = await Promise.all(productPromises);
    products.forEach((product, index) => {
        if (product) {
            totalPrice += product.price * cartItems[index].quantity;
        }
    });

    // 檢查用戶餘額
    if ((state.globalSettings.userBalance || 0) < totalPrice) {
        alert(`餘額不足！本次需要 ¥${totalPrice.toFixed(2)}，但你的餘額只有 ¥${(state.globalSettings.userBalance || 0).toFixed(2)}。`);
        return;
    }

    const confirmed = await showCustomConfirm(
        '確認贈送',
        `確定要花費 ¥${totalPrice.toFixed(2)} 為“${char.name}”購買購物車中的所有商品嗎？`,
        { confirmText: '為Ta買單' }
    );

    if (confirmed) {
        await showCustomAlert("正在處理...", "正在為你心愛的Ta下單...");

        // 1. 扣除用戶餘額
        await updateUserBalanceAndLogTransaction(-totalPrice, `為 ${char.name} 購買商品`);
        
        // 2. 將購物車內容轉化為訂單（記錄在你的訂單裡）
        await createOrdersFromCart(cartItems);

        // 3. 發送禮物通知給對方
        await sendGiftNotificationToChar(targetChatId, products, cartItems, totalPrice);
        
        // 4. 清空購物車
        await clearTaobaoCart();

        await showCustomAlert("贈送成功！", `你為“${char.name}”購買的禮物已下單，並已通過私信通知對方啦！`);
        renderChatList(); // 刷新清單，顯示未讀消息
    }
}

// ▼▼▼ 用這塊【最終正確版】代碼，完整替換舊的 sendGiftNotificationToChar 函數 ▼▼▼

/**
 * 【全新 | 最終正確版】發送禮物通知到指定角色的聊天
 * 效果：發送一條本質是文本、但外觀是卡片的消息。
 *      - 使用者介面顯示為漂亮的禮物卡片。
 *      - 消息資料中包含完整的文本資訊。
 *      - AI 仍然通過隱藏的系統指令接收資訊。
 */
async function sendGiftNotificationToChar(targetChatId, products, cartItems, totalPrice) {
    const chat = state.chats[targetChatId];
    if (!chat) return;

    const itemsSummary = products.map((p, i) => `${p.name} x${cartItems[i].quantity}`).join('、');
    
    // 1. 【核心】先準備好這條消息的“文本內容”
    const messageTextContent = `我給你買了新禮物，希望你喜歡！\n商品清單：${itemsSummary}\n合計：¥${totalPrice.toFixed(2)}`;

    // 2. 創建對使用者【可見】的消息物件。現在它同時擁有 “文本內容” 和 “卡片樣式指令”
    const visibleMessage = {
        role: 'user',
        
        // 【核心修改】為這條消息添加一個 content 屬性，這就是它的“文本本體”
        // 當你複製這條消息時，複製出來的內容就是這個。
        content: messageTextContent, 
        
        // 同時保留 type 和 payload，它們告訴渲染器“把這條消息畫成卡片”
        type: 'gift_notification', 
        timestamp: Date.now(),
        payload: {
            senderName: state.qzoneSettings.nickname || '我',
            itemSummary: itemsSummary,
            totalPrice: totalPrice,
            itemCount: cartItems.length,
        }
    };
    chat.history.push(visibleMessage);

    // 3. 【這部分不變】創建一條給AI看的【隱藏】指令，確保AI能理解並回應
    const hiddenMessage = {
        role: 'system',
        content: `[系統指令：用戶剛剛為你購買了${cartItems.length}件商品，總價值為${totalPrice.toFixed(2)}元。商品包括：${itemsSummary}。請根據你的人設對此表示感謝或作出其他反應。]`,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    chat.history.push(hiddenMessage);

    // 4. 【這部分不變】未讀消息只增加1條
    chat.unreadCount = (chat.unreadCount || 0) + 1;
    await db.chats.put(chat);
    
    // 5. 【這部分不變】發送橫幅通知
    if (state.activeChatId !== targetChatId) {
        showNotification(targetChatId, '你收到了一份禮物！');
    }
}
// ▲▲▲ 替換結束 ▲▲▲




// ▼▼▼ 【全新】購物車代付功能核心函數 ▼▼▼

/**
 * 【全新總入口 | 無隱藏消息版】處理使用者點擊“分享給Ta代付”按鈕的邏輯
 */
async function handleShareCartRequest() {
    const cartItems = await db.taobaoCart.toArray();
    if (cartItems.length === 0) {
        alert("購物車是空的，先去加點寶貝吧！");
        return;
    }

    const targetChatId = await openCharSelectorForCart();
    if (!targetChatId) return;

    const chat = state.chats[targetChatId];
    if (!chat) return;

    let totalPrice = 0;
    const productPromises = cartItems.map(item => db.taobaoProducts.get(item.productId));
    const products = await Promise.all(productPromises);
    const itemsSummary = products.map((p, i) => {
        if(p) {
            totalPrice += p.price * cartItems[i].quantity;
            return `${p.name} x${cartItems[i].quantity}`;
        }
        return '';
    }).filter(Boolean).join('、 ');
    
    const charBalance = chat.characterPhoneData?.bank?.balance || 0;

    const confirmed = await showCustomConfirm(
        '確認代付請求',
        `將向“${chat.name}”發起購物車代付請求，共計 ¥${totalPrice.toFixed(2)}。`,
        { confirmText: '發送請求' }
    );

    if (!confirmed) return;

    // --- ▼▼▼【核心修改】在這裡，我們只創建一條消息 ▼▼▼ ---
    
    // 1. 直接將所有資訊都放入 content 欄位，讓用戶也能看到
    const requestContent = `[購物車代付請求]
總金額: ¥${totalPrice.toFixed(2)}
商品: ${itemsSummary}
(你的當前餘額: ¥${charBalance.toFixed(2)})
請使用 'cart_payment_response' 指令回應。`;

    // 2. 創建一條普通的使用者消息，不再有 isHidden 標記
    const requestMessage = {
        role: 'user', // 由用戶發出
        type: 'cart_share_request', // 類型保持不變，用於UI渲染
        timestamp: Date.now(),
        content: requestContent, // 將包含所有資訊的文本作為內容
        payload: { // payload 依然保留，用於UI渲染卡片
            totalPrice: totalPrice,
            itemCount: cartItems.length,
            status: 'pending' 
        }
    };
    
    // 3. 將這條【單一的】消息添加到歷史記錄
    chat.history.push(requestMessage);

    // --- ▲▲▲ 修改結束 ▲▲▲ ---

    await db.chats.put(chat);
    
    await showCustomAlert("請求已發送", `已將代付請求發送給“${chat.name}”，請在聊天中查看TA的回應。`);
    
    openChat(targetChatId);
}


/**
 * 【輔助函數】打開一個單選的角色選擇器，讓使用者選擇代付物件
 * (這個函數複用了分享功能的彈窗，稍作修改)
 */
async function openCharSelectorForCart() {
    return new Promise(resolve => {
        const modal = document.getElementById('share-target-modal');
        const listEl = document.getElementById('share-target-list');
        const titleEl = document.getElementById('share-target-modal-title');
        const confirmBtn = document.getElementById('confirm-share-target-btn');
        const cancelBtn = document.getElementById('cancel-share-target-btn');

        titleEl.textContent = '分享給誰代付？';
        listEl.innerHTML = '';

        const singleChats = Object.values(state.chats).filter(c => !c.isGroup);

        if (singleChats.length === 0) {
            alert("你還沒有任何可以分享的好友哦。");
            modal.classList.remove('visible');
            resolve(null);
            return;
        }

        // 使用 radio 選項按鈕
        singleChats.forEach(chat => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.innerHTML = `
                <input type="radio" name="cart-share-target" value="${chat.id}" id="target-${chat.id}" style="margin-right: 15px;">
                <label for="target-${chat.id}" style="display:flex; align-items:center; width:100%; cursor:pointer;">
                    <img src="${chat.settings.aiAvatar || defaultAvatar}" class="avatar">
                    <span class="name">${chat.name}</span>
                </label>
            `;
            listEl.appendChild(item);
        });

        modal.classList.add('visible');

        const newConfirmBtn = confirmBtn.cloneNode(true);
        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
        const newCancelBtn = cancelBtn.cloneNode(true);
        cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);
        
        const cleanup = () => modal.classList.remove('visible');

        newConfirmBtn.onclick = () => {
            const selectedRadio = document.querySelector('input[name="cart-share-target"]:checked');
            if (selectedRadio) {
                cleanup();
                resolve(selectedRadio.value);
            } else {
                alert("請選擇一個代付物件！");
            }
        };

        newCancelBtn.onclick = () => {
            cleanup();
            resolve(null);
        };
    });
}

/**
 * 【輔助函數】清空使用者的桃寶購物車
 */
async function clearTaobaoCart() {
    await db.taobaoCart.clear();
    updateCartBadge();
    // 如果用戶正好在看購物車，就刷新一下
    if (document.getElementById('cart-view').classList.contains('active')) {
        renderTaobaoCart();
    }
}

/**
 * 【輔助函數】根據購物車內容創建訂單
 * @param {Array} cartItems - 從資料庫讀出的購物車專案陣列
 */
async function createOrdersFromCart(cartItems) {
    if (!cartItems || cartItems.length === 0) return;
    const newOrders = cartItems.map((item, index) => ({
        productId: item.productId,
        quantity: item.quantity,
        timestamp: Date.now() + index, // 防止時間戳記完全相同
        status: '已付款，等待發貨'
    }));
    await db.taobaoOrders.bulkAdd(newOrders);
    
    // 模擬10秒後自動發貨
    setTimeout(async () => {
        const orderIds = newOrders.map(order => order.timestamp);
        const ordersToUpdate = await db.taobaoOrders.where('timestamp').anyOf(orderIds).toArray();
        for (const order of ordersToUpdate) {
            await db.taobaoOrders.update(order.id, { status: '已發貨，運輸中' });
        }
        console.log(`${ordersToUpdate.length} 個新訂單狀態已更新為“已發貨”。`);
    }, 1000 * 10);
}

// ▲▲▲ 新功能函數結束 ▲▲▲

/* --- “桃寶”App 功能函數結束 --- */
// ▼▼▼ 【全新】這是角色手機外觀設置的所有核心函數，請黏貼到JS功能區 ▼▼▼

/**
 * 【總入口】打開角色手機的外觀設置頁面
 */
function openCharPhoneAppearanceSettings() {
    renderCharPhoneAppearanceScreen(); // 渲染頁面內容
    showCharacterPhonePage('character-phone-appearance-screen'); // 顯示頁面
    loadCharPhonePresetsToDropdown();
}

/**
 * 【全新 | 已修復】渲染角色手機的外觀設置頁面
 */
function renderCharPhoneAppearanceScreen() {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    if (!chat) return;

    // --- 渲染壁紙預覽 (邏輯不變) ---
    const wallpaperPreview = document.getElementById('char-phone-wallpaper-preview');
    const wallpaperUrl = chat.characterPhoneData.wallpaper || '';
    if (wallpaperUrl) {
        wallpaperPreview.style.backgroundImage = `url(${wallpaperUrl})`;
        wallpaperPreview.textContent = '';
    } else {
        wallpaperPreview.style.backgroundImage = 'none';
        wallpaperPreview.textContent = '暫無壁紙';
    }
// --- 渲染App內壁紙預覽 ---
const appWallpaperPreview = document.getElementById('char-phone-app-wallpaper-preview');
const appWallpaperUrl = newAppWallpaperBase64 || chat.characterPhoneData.appWallpaper || '';
if (appWallpaperUrl) {
    appWallpaperPreview.style.backgroundImage = `url(${appWallpaperUrl})`;
    appWallpaperPreview.textContent = '';
} else {
    appWallpaperPreview.style.backgroundImage = 'none';
    appWallpaperPreview.textContent = '點擊下方上傳';
}
// --- App內壁紙預覽渲染結束 ---
    // --- 渲染App圖示設置清單 (核心修復) ---
    const iconGrid = document.getElementById('char-phone-icon-settings-grid');
    iconGrid.innerHTML = '';
    const customIcons = chat.characterPhoneData.appIcons || {};

    // ★★★ 我們已經把那行礙事的 `if (app.id === 'appearance') continue;` 刪掉了！★★★
    CHAR_PHONE_APPS.forEach(app => {
        const customIconUrl = customIcons[app.id];
        // 使用預設圖示作為備用
        const currentIconUrl = customIconUrl || (DEFAULT_APP_ICONS[app.id] || '');
        const currentIconHtml = currentIconUrl ? `<img src="${currentIconUrl}" style="width:100%; height:100%; object-fit:cover;">` : app.svg;
        
        const itemEl = document.createElement('div');
        itemEl.className = 'icon-setting-item'; 
        itemEl.dataset.iconId = app.id; 
        itemEl.innerHTML = `
            <div class="icon-preview" style="width: 50px; height: 50px; border-radius: 12px; display: flex; justify-content: center; align-items: center; padding: 8px; background: #f0f2f5;">
                ${currentIconHtml}
            </div>
            <span style="font-size: 13px;">${app.name}</span>
            <button class="change-icon-btn" data-icon-id="${app.id}" style="padding: 4px 10px; font-size: 12px; border: 1px solid #ccc; background-color: #f0f0f0; border-radius: 5px; cursor: pointer;">更換</button>
        `;
        iconGrid.appendChild(itemEl);
    });
    
    // --- 渲染小元件預覽 (邏輯不變) ---
    const widgets = chat.characterPhoneData.widgets || {};
    const widgetPreview1 = document.getElementById('char-phone-widget-preview-1');
    const widgetPreview2 = document.getElementById('char-phone-widget-preview-2');

    if (widgets.widget1_url) {
        widgetPreview1.style.backgroundImage = `url(${widgets.widget1_url})`;
        widgetPreview1.textContent = '';
    } else {
        widgetPreview1.style.backgroundImage = 'none';
        widgetPreview1.textContent = '點擊上傳';
    }
    
    if (widgets.widget2_url) {
        widgetPreview2.style.backgroundImage = `url(${widgets.widget2_url})`;
        widgetPreview2.textContent = '';
    } else {
        widgetPreview2.style.backgroundImage = 'none';
        widgetPreview2.textContent = '點擊上傳';
    }
}



/**
 * 處理角色手機壁紙的更換和移除
 * @param {string} newUrl - 新的壁紙URL，如果為空字串則表示移除
 */
async function handleCharPhoneWallpaperChange(newUrl) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    
    chat.characterPhoneData.wallpaper = newUrl;
    await db.chats.put(chat);
    
    // 立即應用壁紙到角色手機主螢幕
    const phoneScreen = document.getElementById('character-phone-screen');
    if (newUrl) {
        phoneScreen.style.backgroundImage = `url(${newUrl})`;
        phoneScreen.style.backgroundColor = 'transparent';
    } else {
        phoneScreen.style.backgroundImage = 'none';
        const isDarkMode = document.getElementById('phone-screen').classList.contains('dark-mode');
        phoneScreen.style.backgroundColor = isDarkMode ? '#000' : '#f0f2f5';
    }
    
    // 刷新設置頁面的預覽
    renderCharPhoneAppearanceScreen();
    alert(newUrl ? '壁紙已更新！' : '壁紙已移除！');
}

/**
 * 處理角色手機App圖示的更換
 * @param {string} iconId - 要更換的App的ID
 */
async function handleChangeCharPhoneIcon(iconId) {
    if (!activeCharacterPhoneId) return;
    
    const choice = await showChoiceModal("更換圖示", [
        { text: '📁 從本地上傳', value: 'local' },
        { text: '🌐 使用網路URL', value: 'url' },
        { text: '🔄 恢復默認', value: 'reset' }
    ]);

    let newIconUrl = null;

    if (choice === 'local') {
        newIconUrl = await uploadImageLocally();
    } else if (choice === 'url') {
        newIconUrl = await showCustomPrompt("圖示URL", "請輸入圖片連結");
    } else if (choice === 'reset') {
        const chat = state.chats[activeCharacterPhoneId];
        if (chat.characterPhoneData.appIcons && chat.characterPhoneData.appIcons[iconId]) {
            delete chat.characterPhoneData.appIcons[iconId];
            await db.chats.put(chat);
            renderCharPhoneAppearanceScreen();
            renderCharacterAppGrid();
            alert('圖示已恢復預設。');
        }
        return;
    }

    if (newIconUrl && newIconUrl.trim()) {
        const chat = state.chats[activeCharacterPhoneId];
        if (!chat.characterPhoneData.appIcons) {
            chat.characterPhoneData.appIcons = {};
        }
        chat.characterPhoneData.appIcons[iconId] = newIconUrl.trim();
        await db.chats.put(chat);
        
        renderCharPhoneAppearanceScreen(); // 刷新設置頁面
        renderCharacterAppGrid(); // 刷新主螢幕
        alert('圖示已更新！');
    }
}

// ▲▲▲ 新增函數黏貼結束 ▲▲▲
// ▼▼▼ 把這一整塊全新的功能函數，黏貼到 init() 函數的上方 ▼▼▼

let currentViewingWeiboProfileId = null; // 全域變數，記錄正在查看哪個角色的主頁

/**
 * 【全新】打開指定角色的微博主頁
 * @param {string} charId - 要查看的角色的ID
 */
async function openWeiboCharProfile(charId) {
    currentViewingWeiboProfileId = charId;
    const chat = state.chats[charId];
    if (!chat) return;

    // 渲染角色主頁內容
    await renderWeiboCharProfile(charId);
    
    // 渲染該角色的微博Feed
    await renderCharSpecificFeed(charId);

    // 切換到角色主頁螢幕
    showScreen('weibo-char-profile-screen');
    
    // 隱藏關注列表彈窗（如果它還開著）
    document.getElementById('weibo-following-modal').classList.remove('visible');
}

/**
 * 【全新】渲染角色微博主頁的個人資料部分 (V2 - 支持粉絲/關注數)
 * @param {string} charId - 角色的ID
 */
async function renderWeiboCharProfile(charId) {
    const chat = state.chats[charId];
    if (!chat) return;

    // 渲染基礎資訊（這部分不變）
    document.getElementById('weibo-char-profile-title').textContent = `${chat.name}的主頁`;
    document.getElementById('weibo-char-avatar-img').src = chat.settings.weiboAvatar || chat.settings.aiAvatar;
    document.getElementById('weibo-char-nickname').textContent = chat.settings.weiboNickname || chat.name;
    document.getElementById('weibo-char-background-img').src = chat.settings.weiboBackground;
    document.getElementById('weibo-char-profession-display').textContent = chat.settings.weiboProfession || '職業未設定';
    
    // --- ▼▼▼ 這就是我們新增的核心邏輯 ▼▼▼ ---

    // 1. 從設置中讀取關注數和粉絲數
    document.getElementById('weibo-char-following-count').textContent = chat.settings.weiboFollowingCount || '0';
    document.getElementById('weibo-char-fans-count').textContent = chat.settings.weiboFansCount || '0';

    // 2. 動態計算並顯示微博數
    const postCount = await db.weiboPosts.where('authorId').equals(charId).count();
    document.getElementById('weibo-char-posts-count').textContent = postCount;
    
    // --- ▲▲▲ 新增邏輯結束 ▲▲▲ ---

    // 渲染頭像框 (這部分不變)
    const frameImg = document.getElementById('weibo-char-avatar-frame');
    const frameUrl = chat.settings.weiboAvatarFrame || '';
    if (frameUrl) {
        frameImg.src = frameUrl;
        frameImg.style.display = 'block';
    } else {
        frameImg.style.display = 'none';
    }
}


/**
 * 【全新】渲染指定角色的微博Feed
 * @param {string} charId - 角色的ID
 */
async function renderCharSpecificFeed(charId) {
    const feedEl = document.getElementById('char-weibo-feed-list');
    feedEl.innerHTML = '';
    
    const posts = await db.weiboPosts.where('authorId').equals(charId).reverse().sortBy('timestamp');
    
    if (posts.length === 0) {
        feedEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">Ta 還沒有發過微博哦。</p>';
        return;
    }

    posts.forEach(post => {
        // 複用我們強大的微博帖子創建函數
        feedEl.appendChild(createWeiboPostElement(post));
    });
}

/**
 * 【全新】打開角色微博資料的編輯器
 */
async function openCharWeiboEditor() {
    if (!currentViewingWeiboProfileId) return;
    const chat = state.chats[currentViewingWeiboProfileId];
    if (!chat) return;

    // 填充當前資料到編輯器
    document.getElementById('char-weibo-editor-avatar-preview').src = chat.settings.weiboAvatar || chat.settings.aiAvatar;
    document.getElementById('char-weibo-editor-nickname-input').value = chat.settings.weiboNickname || chat.name;
    document.getElementById('char-weibo-editor-bg-preview').src = chat.settings.weiboBackground;

    // 顯示彈窗
    document.getElementById('char-weibo-editor-modal').classList.add('visible');
}

/**
 * 【全新】保存對角色微博資料的修改
 */
async function saveCharWeiboProfile() {
    if (!currentViewingWeiboProfileId) return;
    const chat = state.chats[currentViewingWeiboProfileId];
    if (!chat) return;

    // 從編輯器獲取新資料
    chat.settings.weiboAvatar = document.getElementById('char-weibo-editor-avatar-preview').src;
    chat.settings.weiboNickname = document.getElementById('char-weibo-editor-nickname-input').value.trim();
    chat.settings.weiboBackground = document.getElementById('char-weibo-editor-bg-preview').src;

    // 保存到資料庫
    await db.chats.put(chat);
    
    // 刷新主頁顯示
    await renderWeiboCharProfile(currentViewingWeiboProfileId);
    
    document.getElementById('char-weibo-editor-modal').classList.remove('visible');
    alert('角色微博資料已保存！');
}

// ▲▲▲ 新功能函數黏貼結束 ▲▲▲
// ▼▼▼ 在 const db = ... 的正上方，黏貼下面這一整塊新代碼 ▼▼▼

/**
 * 【全新】根據角色人設和職業，生成初始的微博關注數和粉絲數
 * @param {object} chat - 角色的聊天物件
 * @returns {{following: string, fans: string}}
 */
function getInitialWeiboStats(chat) {
    const persona = (chat.settings.aiPersona || '') + (chat.settings.weiboProfession || '');
    const keywords = ["偶像", "明星", "演員", "歌手", "博主", "網紅", "UP主", "主播", "選手", "畫家", "作家"];
    const isPublicFigure = keywords.some(keyword => persona.includes(keyword));

    let fansCount, followingCount;

    if (isPublicFigure) {
        fansCount = Math.floor(100000 + Math.random() * 9900000); // 10萬 - 1000萬
        followingCount = Math.floor(50 + Math.random() * 450); // 50 - 500
    } else {
        fansCount = Math.floor(100 + Math.random() * 4900); // 100 - 5000
        followingCount = Math.floor(50 + Math.random() * 250); // 50 - 300
    }

    return {
        fans: formatNumberToChinese(fansCount),
        following: formatNumberToChinese(followingCount)
    };
}

/**
 * 【全新】將數位格式化為帶“萬”或“億”的字串
 * @param {number} num - 原始數字
 * @returns {string} - 格式化後的字串
 */
function formatNumberToChinese(num) {
    if (num >= 100000000) {
        return (num / 100000000).toFixed(1).replace(/\.0$/, '') + '億';
    }
    if (num >= 10000) {
        return (num / 10000).toFixed(1).replace(/\.0$/, '') + '萬';
    }
    return String(num);
}

// ▲▲▲ 新代碼黏貼結束 ▲▲▲
// ▼▼▼ 【最終修復版】用這整塊代碼，完整替換你舊的 playMinimaxAudio 函數 ▼▼▼
let isIntentionalStop = false;
// ▼▼▼ 步驟 1：添加或替換這兩行代碼 ▼▼▼
let isTtsPlaying = false; // 全域鎖，true表示有語音正在播放或載入
let currentTtsAudioBubble = null; // 記錄當前正在播放動畫或音訊的氣泡元素
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 第1步：在這裡黏貼下面這個【全新的】輔助函數 ▼▼▼
/**
 * 【全新】查找從指定位置開始的所有連續AI語音訊息
 * @param {Array} history - 完整的聊天歷史記錄陣列
 * @param {number} startIndex - 開始查找的索引位置
 * @returns {Array} - 一個包含所有連續AI語音訊息物件的陣列
 */
function findConsecutiveAiVoiceMessages(history, startIndex) {
    const messagesToPlay = [];
    if (startIndex < 0 || startIndex >= history.length) {
        return messagesToPlay;
    }

    // 從點擊的那條消息開始，向後遍歷
    for (let i = startIndex; i < history.length; i++) {
        const msg = history[i];
        // 檢查這條消息是否是AI發送的，並且類型是語音
        if (msg.role === 'assistant' && msg.type === 'voice_message') {
            messagesToPlay.push(msg); // 如果是，就把它加入待播放清單
        } else {
            // 一旦遇到不是AI語音的消息（比如使用者的回復，或AI的圖片/文字消息），就立刻停止查找
            break;
        }
    }
    return messagesToPlay;
}
// ▲▲▲ 新函數黏貼結束 ▲▲▲
// ▼▼▼ 第1步：在這裡黏貼這個【全新的】停止函數 ▼▼▼

// ▼▼▼ 第2步：用這整塊【V2 - 精准停止版】代碼，完整替換舊的 stopMinimaxAudio 函數 ▼▼▼

/**
 * 【V2 - 精准停止版】停止當前正在播放的Minimax TTS語音
 */
function stopMinimaxAudio() {
    if (!isTtsPlaying) return;

    // 核心修改1：在執行停止操作前，先設置“故意停止”的標誌為 true
    isIntentionalStop = true;

    const ttsPlayer = document.getElementById('tts-audio-player');
    ttsPlayer.pause();
    ttsPlayer.src = ''; // 這行代碼會觸發 onerror 事件

    if (window.currentAnimatingBubbles) {
        window.currentAnimatingBubbles.forEach(b => b.classList.remove('playing'));
    }

    isTtsPlaying = false;
    currentTtsAudioBubble = null;
    window.currentAnimatingBubbles = null;
    console.log('Minimax TTS: Playback stopped by user.');

    // 核心修改2：用一個微小的延遲來重置標誌位元
    // 這能確保 onerror 事件有足夠的時間檢查到標誌位元，然後再將其重置
    setTimeout(() => {
        isIntentionalStop = false;
    }, 100);
}

// ▲▲▲ 替換結束 ▲▲▲



// ▼▼▼ 第3步：用這整塊【V8 - 錯誤處理終極版】代碼，完整替換舊的 playMinimaxAudio 函數 ▼▼▼

/**
 * 【V8 - 錯誤處理終極版】調用 Minimax TTS API 生成語音並播放
 * @param {string} text - 要轉換為語音的合併後的文本
 * @param {string} voiceId - Minimax 的語音 ID
 * @param {Array<HTMLElement>} bubblesToAnimate - 需要播放動畫的所有語音氣泡元素的陣列
 */
async function playMinimaxAudio(text, voiceId, bubblesToAnimate) {
    // 播放前先停止，確保環境乾淨
    stopMinimaxAudio(); 
    // 等待一小會兒，確保舊的播放機完全清理乾淨
    await new Promise(resolve => setTimeout(resolve, 50));

    const ttsPlayer = document.getElementById('tts-audio-player');
    const firstBubble = bubblesToAnimate[0]; 

    // --- 準備播放新的語音 ---
    isTtsPlaying = true;
    currentTtsAudioBubble = firstBubble;
    window.currentAnimatingBubbles = bubblesToAnimate;
    bubblesToAnimate.forEach(b => b.classList.add('playing'));

    // 暫停主音樂播放機
    const mainAudioPlayer = document.getElementById('audio-player');
    if (mainAudioPlayer && !mainAudioPlayer.paused) {
        mainAudioPlayer.pause();
        musicState.isPlaying = false;
        updatePlayerUI();
    }

    // --- 請求並播放語音 ---
    const groupId = state.apiConfig.minimaxGroupId;
    const apiKey = state.apiConfig.minimaxApiKey;
    if (!groupId || !apiKey) {
        await showCustomAlert('語音播放失敗', '尚未配置Minimax的Group ID和API Key。');
        stopMinimaxAudio();
        return;
    }

    try {
        const response = await fetch(`https://api.minimax.chat/v1/text_to_speech?GroupId=${groupId}`, {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type': 'application/json' },
            body: JSON.stringify({ text: text, voice_id: voiceId, model: 'speech-01', speed: 1.0, pitch: 0, timber_list: [] })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Minimax API 錯誤: ${errorData.base_resp?.status_msg || response.statusText}`);
        }
        // 【核心修復】檢查返回的內容類別型，如果不是音訊就直接報錯！
        const contentType = response.headers.get('Content-Type');
        if (!contentType || !contentType.startsWith('audio/')) {
            const errorData = await response.json().catch(() => response.text()); // 嘗試解析錯誤資訊
            throw new Error(`Minimax API 未返回有效的音訊文件，而是返回了: ${JSON.stringify(errorData)}`);
        }
        const audioBlob = await response.blob();
        const audioUrl = URL.createObjectURL(audioBlob);

        ttsPlayer.src = audioUrl;
        
        const cleanupAndReset = () => {
            if (isTtsPlaying) { // 只有在還在播放狀態時才清理
                isTtsPlaying = false;
                URL.revokeObjectURL(audioUrl); 
                if (window.currentAnimatingBubbles) {
                    window.currentAnimatingBubbles.forEach(b => b.classList.remove('playing'));
                }
                currentTtsAudioBubble = null;
                window.currentAnimatingBubbles = null;
            }
        };

       ttsPlayer.onended = cleanupAndReset;
        
        // ▼▼▼ 使用這段【修復後】的代碼進行替換 ▼▼▼
        ttsPlayer.onerror = (e) => {
             if (!isIntentionalStop) {
                 // 1. 【保留】在控制台列印錯誤，方便你自己調試問題
                 console.error("TTS音訊播放時發生錯誤，已自動切換為文本顯示:", e);
                 // 2. 【核心修改】我們不再彈出任何煩人的提示框！
                 //    showCustomAlert('播放失敗', '播放音訊檔時發生未知錯誤。');  <-- 這行代碼被刪掉了！
             } else {
                 console.log("Intentional stop triggered error event, alert skipped.");
             }
             // 3. 【保留】無論如何，都調用 cleanupAndReset 來停止播放動畫，恢復UI
             cleanupAndReset();
        };
        // ▲▲▲ 替換結束 ▲▲▲

        await ttsPlayer.play();

    } catch (error) {
        console.error("Minimax TTS 調用失敗:", error);
        await showCustomAlert('語音合成失敗', `錯誤資訊: ${error.message}`);
        stopMinimaxAudio();
    }
}
// ▲▲▲ 替換結束 ▲▲▲



// ▼▼▼ 【全新】角色手機外觀預設功能核心函數 ▼▼▼

/**
 * 啟用或禁用角色手機預設管理按鈕
 * @param {boolean} isEnabled - 是否啟用
 */
function toggleCharPhonePresetButtons(isEnabled) {
    document.getElementById('apply-char-phone-preset-btn').disabled = !isEnabled;
    document.getElementById('update-char-phone-preset-btn').disabled = !isEnabled;
    document.getElementById('rename-char-phone-preset-btn').disabled = !isEnabled;
    document.getElementById('delete-char-phone-preset-btn').disabled = !isEnabled;
    document.getElementById('export-char-phone-preset-btn').disabled = !isEnabled;
}

/**
 * 載入角色手機外觀預設到下拉清單
 */
async function loadCharPhonePresetsToDropdown() {
    const selector = document.getElementById('char-phone-preset-selector');
    if (!selector) return;
    selector.innerHTML = '<option value="">-- 請選擇一個預設 --</option>';
    const presets = await db.charPhonePresets.toArray();
    presets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        selector.appendChild(option);
    });
    activeCharPhonePresetId = null;
    toggleCharPhonePresetButtons(false);
}

/**
 * 當用戶從下拉清單選擇一個預設時觸發
 */
function handleCharPhonePresetSelection() {
    const selector = document.getElementById('char-phone-preset-selector');
    activeCharPhonePresetId = selector.value ? parseInt(selector.value) : null;
    toggleCharPhonePresetButtons(!!activeCharPhonePresetId);
}

// ▼▼▼ 用這塊【修復後】的代碼，完整替換你舊的 applySelectedCharPhonePreset 函數 ▼▼▼
async function applySelectedCharPhonePreset() {
    if (!activeCharPhonePresetId) {
        alert("請先從下拉清單中選擇一個要應用的預設。");
        return;
    }
    if (!activeCharacterPhoneId) {
        alert("錯誤：沒有找到當前正在操作的角色手機。");
        return;
    }
    const preset = await db.charPhonePresets.get(activeCharPhonePresetId);
    const chat = state.chats[activeCharacterPhoneId];

    if (preset && preset.data && chat) {
        // 將預設資料深拷貝一份，應用到角色的手機資料上
        chat.characterPhoneData.wallpaper = preset.data.wallpaper || '';
        chat.characterPhoneData.appIcons = { ...DEFAULT_APP_ICONS, ...(preset.data.appIcons || {}) };
        chat.characterPhoneData.widgets = { ...(preset.data.widgets || {}) };
        
        // ★★★ 這就是我們新增的一行！★★★
        chat.characterPhoneData.appWallpaper = preset.data.appWallpaper || '';

        await db.chats.put(chat);
        
        // 刷新手機介面以顯示新外觀
        openCharacterPhone(activeCharacterPhoneId);
        
        // 刷新外觀設置頁面，以便預覽和資料同步
        renderCharPhoneAppearanceScreen();

        alert(`已成功為“${chat.name}”應用預設: "${preset.name}"！`);
    } else {
        alert("應用預設失敗，找不到預設或角色資料。");
    }
}
// ▲▲▲ 替換結束 ▲▲▲


/**
 * 保存當前角色手機的外觀設置為一個新的預設
 */
async function saveCurrentCharPhonePreset() {
    if (!activeCharacterPhoneId) return;

    const presetName = await showCustomPrompt("保存預設", "請為這個外觀方案起個名字：");
    if (!presetName || !presetName.trim()) {
        if (presetName !== null) alert("名字不能為空！");
        return;
    }

    const chat = state.chats[activeCharacterPhoneId];
    // 從當前角色的資料中提取外觀設置
    const presetData = {
        wallpaper: chat.characterPhoneData.wallpaper || '',
        appIcons: { ...(chat.characterPhoneData.appIcons || {}) },
        widgets: { ...(chat.characterPhoneData.widgets || {}) },
        appWallpaper: chat.characterPhoneData.appWallpaper || '',
    };

    await db.charPhonePresets.add({ name: presetName.trim(), data: presetData });
    await loadCharPhonePresetsToDropdown();
    alert(`外觀預設 "${presetName.trim()}" 已保存！`);
}

/**
 * 更新當前選中的預設
 */
async function updateSelectedCharPhonePreset() {
    if (!activeCharPhonePresetId || !activeCharacterPhoneId) return;

    const currentPreset = await db.charPhonePresets.get(activeCharPhonePresetId);
    if (!currentPreset) return;

    const confirmed = await showCustomConfirm(
        "確認更新",
        `確定要用當前手機的外觀覆蓋預設 "${currentPreset.name}" 嗎？`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const chat = state.chats[activeCharacterPhoneId];
        const presetData = {
            wallpaper: chat.characterPhoneData.wallpaper || '',
            appIcons: { ...(chat.characterPhoneData.appIcons || {}) },
            widgets: { ...(chat.characterPhoneData.widgets || {}) },
            appWallpaper: chat.characterPhoneData.appWallpaper || '',
        };
        await db.charPhonePresets.update(activeCharPhonePresetId, { data: presetData });
        await showCustomAlert('成功', `預設 "${currentPreset.name}" 已更新！`);
    }
}

/**
 * 重命名選中的預設
 */
async function renameSelectedCharPhonePreset() {
    if (!activeCharPhonePresetId) return;
    const currentPreset = await db.charPhonePresets.get(activeCharPhonePresetId);
    const newName = await showCustomPrompt("重命名", "請輸入新的名稱：", currentPreset.name);
    if (newName && newName.trim()) {
        await db.charPhonePresets.update(activeCharPhonePresetId, { name: newName.trim() });
        await loadCharPhonePresetsToDropdown();
        document.getElementById('char-phone-preset-selector').value = activeCharPhonePresetId;
        alert("重命名成功！");
    }
}

/**
 * 刪除選中的預設
 */
async function deleteSelectedCharPhonePreset() {
    if (!activeCharPhonePresetId) return;
    const currentPreset = await db.charPhonePresets.get(activeCharPhonePresetId);
    const confirmed = await showCustomConfirm("確認刪除", `確定要刪除預設 "${currentPreset.name}" 嗎？`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        await db.charPhonePresets.delete(activeCharPhonePresetId);
        await loadCharPhonePresetsToDropdown();
        alert("預設已刪除。");
    }
}

/**
 * 匯出選中的預設
 */
async function exportCharPhonePreset() {
    if (!activeCharPhonePresetId) return;
    const preset = await db.charPhonePresets.get(activeCharPhonePresetId);
    const blob = new Blob([JSON.stringify(preset, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `[CharPhone]${preset.name}.json`;
    a.click();
    URL.revokeObjectURL(url);
}

/**
 * 導入預設文件
 */
function importCharPhonePreset(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);
            if (data.name && data.data) {
                await db.charPhonePresets.add({ name: `${data.name} (導入)`, data: data.data });
                await loadCharPhonePresetsToDropdown();
                alert(`預設 "${data.name}" 導入成功！`);
            } else {
                alert("導入失敗：檔案格式不正確。");
            }
        } catch (error) {
            alert(`導入失敗：檔解析錯誤。${error.message}`);
        }
    };
    reader.readAsText(file);
}

// ▲▲▲ 角色手機外觀預設功能函數結束 ▲▲▲
// ▼▼▼ 把下面這一整塊全新的代碼，黏貼到 init() 函數的上方 ▼▼▼

/**
 * [全新] 在外觀設置頁面渲染出所有App的名稱設置項
 */
function renderAppNameSettings() {
    const grid = document.getElementById('icon-rename-grid');
    if (!grid) return;
    grid.innerHTML = '';

    const appLabels = state.globalSettings.appLabels || {};

    // 遍歷預設標籤物件，以確保所有app都有設置項
    for (const appId in DEFAULT_APP_LABELS) {
        if (DEFAULT_APP_LABELS.hasOwnProperty(appId)) {
            const defaultName = DEFAULT_APP_LABELS[appId];
            const currentName = appLabels[appId] || defaultName;

            const item = document.createElement('div');
            item.className = 'form-group';
            item.style.marginBottom = '0'; // 讓佈局更緊湊
            item.innerHTML = `
                <label for="rename-input-${appId}">${defaultName}</label>
                <input type="text" id="rename-input-${appId}" class="app-rename-input" data-appid="${appId}" value="${currentName}">
            `;
            grid.appendChild(item);
        }
    }
}

/**
 * [全新] 將保存的App名稱應用到主螢幕的圖示上
 */
function applyAppLabels() {
    const appLabels = state.globalSettings.appLabels || {};
    
    for (const appId in DEFAULT_APP_LABELS) {
        if (DEFAULT_APP_LABELS.hasOwnProperty(appId)) {
            const defaultName = DEFAULT_APP_LABELS[appId];
            const customName = appLabels[appId] || defaultName;

            // 這個選擇器會同時找到主螢幕和Dock欄上的所有圖示
            const icons = document.querySelectorAll(`.desktop-app-icon [id="icon-img-${appId}"]`);
            
            icons.forEach(iconImg => {
                const appIconContainer = iconImg.closest('.desktop-app-icon');
                if (appIconContainer) {
                    const labelElement = appIconContainer.querySelector('.label');
                    if (labelElement) {
                        labelElement.textContent = customName;
                    }
                }
            });
        }
    }
}

/**
 * [全新] 從輸入框讀取並保存用戶修改的App名稱
 */
function saveAppLabels() {
    const appNameInputs = document.querySelectorAll('.app-rename-input');
    if (!state.globalSettings.appLabels) {
        state.globalSettings.appLabels = {};
    }

    appNameInputs.forEach(input => {
        const appId = input.dataset.appid;
        const newName = input.value.trim();
        const defaultName = DEFAULT_APP_LABELS[appId];

        // 如果用戶輸入了新名字，且和默認名字不一樣，就保存
        if (newName && newName !== defaultName) {
            state.globalSettings.appLabels[appId] = newName;
        } else {
            // 如果用戶清空了輸入框，或者改回了默認名字，就刪除保存記錄，以恢復預設
            delete state.globalSettings.appLabels[appId];
        }
    });
}


// ▼▼▼ 請用這整塊【全新修復版】代碼，替換掉你舊的 handleImportSillyTavernWorldBook 函數 ▼▼▼
/**
 * 【全新 | 已修復】處理導入的SillyTavern世界書檔
 * @param {File} file - 用戶選擇的JSON檔
 */
async function handleImportSillyTavernWorldBook(file) {
    // 使用FileReader來讀取檔內容
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const text = e.target.result;
            const data = JSON.parse(text);

            // 驗證檔案格式是否正確，確保包含'entries'物件
            if (!data.entries || typeof data.entries !== 'object') {
                throw new Error("檔案格式無效。SillyTavern世界書應包含'entries'物件。");
            }

            // 從檔案名提取名稱，作為新的分類名
            let categoryName = file.name.replace(/\.(json|jsonl)$/i, '').trim();
            if (!categoryName) categoryName = '導入的世界書';

            // 檢查該分類是否已存在，如果不存在則創建
            let category = await db.worldBookCategories.where('name').equals(categoryName).first();
            if (!category) {
                const newCategoryId = await db.worldBookCategories.add({ name: categoryName });
                category = { id: newCategoryId, name: categoryName };
                console.log(`創建了新的世界書分類: ${categoryName} (ID: ${newCategoryId})`);
            } else {
                console.log(`將條目添加到已存在的分類: ${categoryName} (ID: ${category.id})`);
            }

            const newBooks = [];
            // 遍歷SillyTavern worldbook中的所有條目
            for (const key in data.entries) {
                const entry = data.entries[key];
                
                // ★★★ 核心修改：移除了 !entry.disable 的檢查，現在會導入所有條目 ★★★
                if (entry) { 
                    // 使用entry.comment作為書名，如果為空則使用"條目 key"作為備用
                    const entryName = (entry.comment || `條目 ${key}`).trim();
                    const entryContent = (entry.content || '').trim();
                    // 確保書名和內容都不為空
                    if (entryName && entryContent) {
                        newBooks.push({
                            id: 'wb_' + Date.now() + Math.random(), // 創建唯一ID
                            name: entryName,
                            content: entryContent,
                            categoryId: category.id // 歸屬到新的分類
                        });
                    }
                }
            }

            if (newBooks.length === 0) {
                alert('沒有找到任何可導入的有效條目。');
                return;
            }
            
            // 批量將新書添加到資料庫，效率更高
            await db.worldBooks.bulkAdd(newBooks);
            // 更新記憶體中的state，以便UI能立即刷新
            state.worldBooks.push(...newBooks); 

            // 重新渲染世界書清單，顯示新內容
            await renderWorldBookScreen();
            await showCustomAlert('導入成功', `成功將《${categoryName}》中的 ${newBooks.length} 個條目導入到世界書！`);

        } catch (error) {
            console.error("導入世界書失敗:", error);
            await showCustomAlert('導入失敗', `無法解析檔，請確保它是有效的SillyTavern世界書JSON檔。\n\n錯誤: ${error.message}`);
        }
    };
    // 以UTF-8編碼讀取檔內容
    reader.readAsText(file, 'UTF-8');
}
// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 【全新】這是“心動飛行棋”的所有核心功能函數 ▼▼▼
/**
 * 【全新】匯出指定的飛行棋問題庫
 * @param {number} bankId - 要匯出的問題庫的ID
 */
async function exportLudoQuestionBank(bankId) {
    try {
        const bank = await db.ludoQuestionBanks.get(bankId);
        const questions = await db.ludoQuestions.where('bankId').equals(bankId).toArray();

        if (!bank) {
            alert("錯誤：找不到要匯出的題庫。");
            return;
        }

        // 1. 準備要匯出的資料結構，只包含純粹的資料
        const exportData = {
            bankName: bank.name,
            questions: questions.map(q => ({
                text: q.text,
                type: q.type
            }))
        };

        // 2. 將資料轉換為格式化的JSON字串
        const jsonString = JSON.stringify(exportData, null, 2);
        
        // 3. 創建Blob對象
        const blob = new Blob([jsonString], { type: 'application/json' });
        
        // 4. 創建並觸發下載連結
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        const dateStr = new Date().toISOString().split('T')[0];
        link.href = url;
        link.download = `[飛行棋題庫]${bank.name}-${dateStr}.json`;
        document.body.appendChild(link);
        link.click();
        
        // 5. 清理臨時創建的物件
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        await showCustomAlert('匯出成功', `問題庫“${bank.name}”已成功匯出！`);

    } catch (error) {
        console.error("匯出飛行棋題庫失敗:", error);
        await showCustomAlert('匯出失敗', `發生了一個錯誤: ${error.message}`);
    }
}

/**
 * 【全新】處理導入的飛行棋問題庫文件
 * @param {File} file - 用戶選擇的JSON檔
 */
async function importLudoQuestionBank(file) {
    if (!file) return;

    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const text = e.target.result;
            const data = JSON.parse(text);

            // 1. 驗證檔案格式
            if (!data.bankName || !Array.isArray(data.questions)) {
                throw new Error("檔案格式無效。必須包含 'bankName' 和 'questions' 陣列。");
            }

            // 2. 檢查題庫名稱是否已存在
            let newBankName = data.bankName;
            const existingBank = await db.ludoQuestionBanks.where('name').equals(newBankName).first();
            if (existingBank) {
                newBankName = `${newBankName} (導入)`; // 如果重名，自動添加尾碼
            }

            // 3. 創建新的題庫
            const newBankId = await db.ludoQuestionBanks.add({ name: newBankName });

            // 4. 準備要批量添加的新問題
            const questionsToAdd = data.questions.map(q => ({
                bankId: newBankId,
                text: q.text,
                type: q.type || 'both_answer' // 相容舊的沒有type的題庫
            }));

            // 5. 如果有問題，就批量添加到資料庫
            if (questionsToAdd.length > 0) {
                await db.ludoQuestions.bulkAdd(questionsToAdd);
            }

            // 6. 刷新UI並給出提示
            await renderLudoQuestionBanks();
            await showCustomAlert('導入成功', `問題庫“${newBankName}”已成功導入，包含 ${questionsToAdd.length} 個問題！`);

        } catch (error) {
            console.error("導入飛行棋題庫失敗:", error);
            await showCustomAlert('導入失敗', `無法解析檔，請確保它是正確的題庫備份檔案。\n\n錯誤: ${error.message}`);
        }
    };
    reader.readAsText(file, 'UTF-8');
}

/**
 * 【飛行棋】打開遊戲設置介面 (V2 - 核取方塊版)
 */
async function openLudoSetup() {
    showScreen('ludo-setup-screen');
    const selectionEl = document.getElementById('ludo-player-selection');
    selectionEl.innerHTML = '<p>正在載入角色列表...</p>';

    // 【核心修改】為了保持統一，我們在這裡也載入NPC作為可選玩伴
    const singleChats = Object.values(state.chats).filter(chat => !chat.isGroup);
    const allNpcs = Object.values(state.chats).flatMap(chat => (chat.npcLibrary || []).map(npc => ({...npc, owner: chat.name})));
    let playerOptions = [
        ...singleChats.map(c => ({ id: c.id, name: c.name, avatar: c.settings.aiAvatar, type: '角色' })),
        ...allNpcs.map(n => ({ id: n.id, name: n.name, avatar: n.avatar, type: `NPC (${n.owner})` }))
    ];

    selectionEl.innerHTML = '';
    if (playerOptions.length === 0) {
        selectionEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">還沒有可以一起玩的好友哦~</p>';
        return;
    }

    // 【核心修改1】渲染核取方塊列表
    playerOptions.forEach((player, index) => {
        const item = document.createElement('div');
        item.className = 'player-selection-item';
        item.innerHTML = `
            <input type="checkbox" class="ludo-player-checkbox" value="${player.id}" id="ludo-opponent-${player.id}" ${index === 0 ? 'checked' : ''}>
            <img src="${player.avatar || defaultAvatar}" alt="${player.name}">
            <span class="name">${player.name}</span>
            <span class="type-tag">${player.type}</span>
        `;
        selectionEl.appendChild(item);
    });

    // 【核心修改2】添加事件監聽以實現單選
    selectionEl.addEventListener('click', (e) => {
        if (e.target.type === 'checkbox' && e.target.classList.contains('ludo-player-checkbox')) {
            document.querySelectorAll('.ludo-player-checkbox').forEach(cb => {
                if (cb !== e.target) cb.checked = false;
            });
        }
    });

    // 載入問題庫到下拉清單
    const bankSelect = document.getElementById('ludo-question-bank-select');
    bankSelect.innerHTML = '';
    const banks = await db.ludoQuestionBanks.toArray();
    if (banks.length === 0) {
        bankSelect.innerHTML = '<option value="">暫無可用題庫</option>';
    } else {
        banks.forEach(bank => {
            const option = document.createElement('option');
            option.value = bank.id;
            option.textContent = bank.name;
            bankSelect.appendChild(option);
        });
    }
}

/**
 * 【飛行棋】開始遊戲的核心邏輯 (V2 - 核取方塊版)
 */
async function startLudoGame() {
    // 【核心修改】修改選擇器以匹配新的核取方塊class
    const selectedOpponentRadio = document.querySelector('.ludo-player-checkbox:checked');
    if (!selectedOpponentRadio) {
        alert("請選擇一位玩伴！");
        return;
    }
    const opponentId = selectedOpponentRadio.value;
    const opponentChat = state.chats[opponentId] || Object.values(state.chats).flatMap(c => c.npcLibrary).find(n => n.id === opponentId);

    const selectedBankId = parseInt(document.getElementById('ludo-question-bank-select').value);
    if (isNaN(selectedBankId)) {
        alert("請選擇一個有效的問題庫！");
        return;
    }

    // 查找對手的完整資訊（和舊邏輯一樣）
    let opponentInfo = null;
    const mainChat = Object.values(state.chats).find(c => c.id === opponentId);
    if (mainChat) {
        opponentInfo = { ...mainChat, persona: mainChat.settings.aiPersona, avatar: mainChat.settings.aiAvatar };
    } else {
        for (const c of Object.values(state.chats)) {
            const npc = (c.npcLibrary || []).find(n => n.id === opponentId);
            if (npc) {
                opponentInfo = npc;
                break;
            }
        }
    }
    if (!opponentInfo) { alert("找不到所選的玩伴信息！"); return; }
    
    // 初始化遊戲狀態 (和舊邏輯一樣)
    ludoGameState = {
        isActive: true,
        opponent: opponentInfo,
        players: [],
        currentTurnIndex: 0,
        gameLog: [],
        boardLayout: [],
        isDiceRolling: false,
        activeQuestionBankId: selectedBankId
    };
    const userPlayer = { id: 'user', name: '你', avatar: state.qzoneSettings.avatar || defaultAvatar, piecePosition: -1, isUser: true };
    const charPlayer = { id: opponentInfo.id, name: opponentInfo.name, avatar: opponentInfo.avatar || defaultAvatar, piecePosition: -1, isUser: false, persona: opponentInfo.persona };
    if (Math.random() > 0.5) {
        ludoGameState.players = [userPlayer, charPlayer];
    } else {
        ludoGameState.players = [charPlayer, userPlayer];
    }
    ludoGameState.currentTurnIndex = 0;
    generateLudoBoard();
    showScreen('ludo-game-screen');
    renderLudoGameScreen();
    logToLudoGame('遊戲開始！擲出6點即可起飛。', 'system');
    await sleep(1000);
    await processLudoTurn();
}



// 【已修復】請用下面這個函數完整替換你舊的 renderLudoGameScreen 函數
function renderLudoGameScreen(options = {}) {
    if (!ludoGameState.isActive) return;

    const userPieceEl = document.getElementById('ludo-user-piece');
    const charPieceEl = document.getElementById('ludo-char-piece');
    if(!userPieceEl || !charPieceEl) return;

    userPieceEl.style.backgroundImage = `url(${ludoGameState.players.find(p => p.isUser).avatar})`;
    charPieceEl.style.backgroundImage = `url(${ludoGameState.players.find(p => !p.isUser).avatar})`;

    ludoGameState.players.forEach(player => {
        const pieceEl = player.isUser ? userPieceEl : charPieceEl;
        const pos = player.piecePosition;

        if (pos === -1) { // 在起點
            const startCell = document.querySelector('.ludo-cell.start');
            // ▼▼▼ 核心修復1：加上 if (startCell) 的安全檢查 ▼▼▼
            if (startCell) {
                pieceEl.style.left = `${startCell.offsetLeft + (player.isUser ? 0 : 5)}px`;
                pieceEl.style.top = `${startCell.offsetTop + (player.isUser ? 0 : 5)}px`;
            }
        } else if (pos >= LUDO_BOARD_SIZE) { // 已到終點
            const endCell = document.querySelector('.ludo-cell.end');
            // ▼▼▼ 核心修復2：加上 if (endCell) 的安全檢查 ▼▼▼
            if (endCell) {
                pieceEl.style.left = `${endCell.offsetLeft + (player.isUser ? 0 : 5)}px`;
                pieceEl.style.top = `${endCell.offsetTop + (player.isUser ? 0 : 5)}px`;
            }
        } else {
            const cell = document.querySelector(`.ludo-cell[data-index="${pos}"]`);
            if (cell) {
                pieceEl.style.left = `${cell.offsetLeft + (player.isUser ? 0 : 5)}px`;
                pieceEl.style.top = `${cell.offsetTop + (player.isUser ? 0 : 5)}px`;
            }
        }
    });

    const logContainer = document.getElementById('ludo-game-log');
    logContainer.innerHTML = ludoGameState.gameLog.map(log => 
        `<div class="log-entry ${log.type}">${log.message.replace(/\n/g, '<br>')}</div>`
    ).join('');
    logContainer.scrollTop = logContainer.scrollHeight;
}

/**
 * 【全新】飛行棋專用的使用者輸入函數
 * @param {string} promptText - 提示文字 (雖然我們沒用上，但保留介面)
 * @param {string} placeholder - 輸入框的占位元文字
 * @returns {Promise<string>} - 返回使用者的輸入內容
 */
function waitForLudoUserAction(promptText, placeholder) {
    return new Promise(resolve => {
        const actionArea = document.getElementById('ludo-action-area');
        actionArea.innerHTML = ''; // 清空舊內容（比如骰子）
        actionArea.classList.add('speaking-mode'); // 複用劇本殺的發言樣式

        const textarea = document.createElement('textarea');
        textarea.id = 'ludo-user-speech-input'; // 使用新ID，避免衝突
        textarea.rows = 1;
        textarea.placeholder = placeholder || '請輸入你的回答...';
        
        // 即時調整高度
        textarea.addEventListener('input', () => {
            textarea.style.height = 'auto';
            textarea.style.height = (textarea.scrollHeight) + 'px';
        });

        const confirmBtn = document.createElement('button');
        confirmBtn.className = 'form-button'; // 使用通用按鈕樣式
        confirmBtn.textContent = '確認回答';

        actionArea.appendChild(textarea);
        actionArea.appendChild(confirmBtn);
        textarea.focus();

        confirmBtn.onclick = () => {
            const answer = textarea.value.trim() || '...（跳過）';
            actionArea.innerHTML = ''; // 清空輸入框和按鈕
            actionArea.classList.remove('speaking-mode');
            resolve(answer);
        };
    });
}
// ▲▲▲ 新代碼黏貼結束 ▲▲▲

// ▼▼▼ 用這塊【V2 - 支持新問題類型】的代碼，完整替換你舊的 handleLudoQuestionEvent 函數 ▼▼▼
async function handleLudoQuestionEvent(player) {
    // 1. 根據遊戲狀態獲取問題庫
    const questionBankId = ludoGameState.activeQuestionBankId;
    let questions = [];
    if (questionBankId) {
        questions = await db.ludoQuestions.where('bankId').equals(questionBankId).toArray();
    }

    // 2. 如果題庫是空的，提示並直接進入下一回合
    if (questions.length === 0) {
        logToLudoGame('當前題庫是空的，跳過本輪問答。', 'system');
        await sleep(1500);
        await advanceTurn(); // 別忘了切換回合
        return;
    }

    // 3. 隨機抽一個問題
    const questionObj = getRandomItem(questions);
    const questionText = questionObj.text;

    // 4. 【核心】彈出模式選擇框，讓使用者決定怎麼玩
    const mode = await showAnswerModeSelector(questionText);
    if (!mode) {
        logToLudoGame('玩家取消了答題，遊戲繼續。', 'system');
        await advanceTurn(); // 取消也要切換回合
        return;
    }

    // 5. 根據選擇的模式，執行不同的流程
    logToLudoGame(`【${mode === 'both_answer' ? '共同回答' : '一人回答，一人評價'}】抽到的問題是：“${questionText}”`, 'system');
    await sleep(1500);

    const currentPlayer = player;
    const otherPlayer = ludoGameState.players.find(p => p.id !== currentPlayer.id);

    // --- 流程分支 ---
    if (mode === 'both_answer') {
        logToLudoGame(`請 <strong>${currentPlayer.name}</strong> 先回答。`, 'system');
        let answer1 = currentPlayer.isUser 
            ? await waitForLudoUserAction('輪到你回答問題', '請輸入你的回答...')
            : await triggerLudoAiAction('answer_question', { question: questionText });
        logToLudoGame(`<strong>${currentPlayer.name}:</strong> ${answer1}`, currentPlayer.isUser ? 'user' : 'char');
        await sleep(2000);

        logToLudoGame(`現在請 <strong>${otherPlayer.name}</strong> 回答。`, 'system');
        let answer2 = otherPlayer.isUser 
            ? await waitForLudoUserAction('輪到你回答問題', '請輸入你的回答...')
            : await triggerLudoAiAction('answer_question', { question: questionText });
        logToLudoGame(`<strong>${otherPlayer.name}:</strong> ${answer2}`, otherPlayer.isUser ? 'user' : 'char');
    
    } else if (mode === 'single_answer') {
        logToLudoGame(`請 <strong>${currentPlayer.name}</strong> 先回答。`, 'system');
        let answer = currentPlayer.isUser
            ? await waitForLudoUserAction('輪到你回答問題', '請輸入你的回答...')
            : await triggerLudoAiAction('answer_question', { question: questionText });
        logToLudoGame(`<strong>${currentPlayer.name}:</strong> ${answer}`, currentPlayer.isUser ? 'user' : 'char');
        await sleep(2000);

        logToLudoGame(`現在請 <strong>${otherPlayer.name}</strong> 對Ta的回答發表一下看法吧。`, 'system');
        let evaluation = otherPlayer.isUser
            ? await waitForLudoUserAction(`對“${answer}”的看法`, '請輸入你的評價...')
            : await triggerLudoAiAction('evaluate_answer', { question: questionText, answer: answer });
        logToLudoGame(`<strong>${otherPlayer.name}:</strong> ${evaluation}`, otherPlayer.isUser ? 'user' : 'char');
    }

    // 6. 問答流程結束後，提示並切換到下一回合
    await sleep(1500);
    logToLudoGame('本輪問答結束，遊戲繼續！', 'system');
    await advanceTurn();
}
// ▲▲▲ 替換結束 ▲▲▲

/**
 * 【飛行棋】添加一條遊戲日誌
 */
function logToLudoGame(message, type) {
    ludoGameState.gameLog.push({ message, type });
    renderLudoGameScreen();
}
// ▼▼▼ 在這裡黏貼下面的新函數 ▼▼▼
/**
 * 【全新】一個帶“魔法”的擲骰子函數
 * @param {object} player - 正在擲骰子的玩家物件
 * @returns {number} - 最終的骰子點數
 */
function rollTheDice(player) {
    // 如果玩家還在起點（沒有起飛）
    if (player.piecePosition === -1) {
        // 就有50%的超高概率直接擲出6！
        if (Math.random() < 0.5) {
            return 6;
        }
        // 另外50%的概率，隨機擲出1-5
        return Math.floor(Math.random() * 5) + 1;
    }
    // 如果已經起飛了，就恢復正常的公平骰子
    return Math.floor(Math.random() * 6) + 1;
}
// ▲▲▲ 新函數黏貼結束 ▲▲▲

/**
 * 【飛行棋】遊戲主迴圈
 */
async function processLudoTurn() {
    if (!ludoGameState.isActive) return;

    const currentPlayer = ludoGameState.players[ludoGameState.currentTurnIndex];
    logToLudoGame(`輪到 <strong>${currentPlayer.name}</strong> 行動了。`, 'system');
    
    if (currentPlayer.isUser) {
        // 用戶回合
        const actionArea = document.getElementById('ludo-action-area');
        actionArea.innerHTML = `
            <div id="ludo-dice-container" title="點擊擲骰子">
                <div class="dice">
                    <div class="face front">1</div><div class="face back">6</div>
                    <div class="face right">3</div><div class="face left">4</div>
                    <div class="face top">2</div><div class="face bottom">5</div>
                </div>
            </div>
        `;
        document.getElementById('ludo-dice-container').onclick = handleUserRollDice;
    } else {
        // AI回合
        document.getElementById('ludo-action-area').innerHTML = `<p>${currentPlayer.name} 正在思考...</p>`;
        await sleep(2000);
const diceRoll = rollTheDice(currentPlayer); 
        await handlePlayerMove(currentPlayer, diceRoll, false);
    }
}

/**
 * 【飛行棋】處理用戶擲骰子
 */
async function handleUserRollDice() {
    if (ludoGameState.isDiceRolling) return;
    ludoGameState.isDiceRolling = true;
    
    const diceEl = document.querySelector('.dice');
    diceEl.classList.add('rolling');
    document.getElementById('ludo-dice-container').onclick = null; // 防止重複點擊

    const userPlayer = ludoGameState.players.find(p => p.isUser); // 先找到使用者玩家物件
    const diceRoll = rollTheDice(userPlayer); // 調用新函數
    
    setTimeout(async () => {
        diceEl.classList.remove('rolling');
        // 根據點數旋轉到對應面 (這是一個簡化的視覺效果)
        const rotations = { 1: 'rotateY(0deg)', 2: 'rotateX(-90deg)', 3: 'rotateY(-90deg)', 4: 'rotateY(90deg)', 5: 'rotateX(90deg)', 6: 'rotateY(180deg)' };
        diceEl.style.transform = rotations[diceRoll];
        
        const userPlayer = ludoGameState.players.find(p => p.isUser);
        await handlePlayerMove(userPlayer, diceRoll, true);

        ludoGameState.isDiceRolling = false;
    }, 1500);
}

// ▼▼▼ 用這塊【已修復】的代碼，完整替換你舊的 handlePlayerMove 函數 ▼▼▼
async function handlePlayerMove(player, diceRoll, isUserMove) {
    logToLudoGame(`<strong>${player.name}</strong> 擲出了 <strong>${diceRoll}</strong> 點！`, isUserMove ? 'user' : 'char');

    if (player.piecePosition === -1) { // 如果棋子還在起點
        if (diceRoll === 6) {
            player.piecePosition = 0; // 起飛到第0格
            logToLudoGame(`<strong>${player.name}</strong> 的棋子起飛了！`, 'system');
            renderLudoGameScreen();
            
            if (!isUserMove) {
                await triggerLudoAiAction('roll_6');
            }
            logToLudoGame(`擲出6點，<strong>${player.name}</strong> 再行動一次。`, 'system');
            await sleep(1000);
            await processLudoTurn(); // 重新執行當前玩家的回合
        } else {
            logToLudoGame('點數不是6，無法起飛。', 'system');
            await advanceTurn(); // 切換到下一位玩家
        }
        return; // 結束本次移動處理
    }

    // --- ▼▼▼ 核心修復從這裡開始 ▼▼▼ ---

    const newPosition = player.piecePosition + diceRoll;
    const finalPositionIndex = LUDO_BOARD_SIZE - 1; // 終點格子的索引

    // 1. 【核心修改】只要新位置大於或等於終點，就直接判定勝利！
    if (newPosition >= finalPositionIndex) {
        player.piecePosition = finalPositionIndex; // 無論擲出幾點，都讓棋子停在終點格子上
        renderLudoGameScreen();
        logToLudoGame(`🎉 <strong>${player.name}</strong> 到達了終點！`, 'system');
        await triggerLudoAiAction(isUserMove ? 'user_win' : 'char_win');
        ludoGameState.isActive = false;
        document.getElementById('ludo-action-area').innerHTML = '';
        await sleep(1000);
        showLudoSummary(player.name); // 顯示結算介面
        return; // 遊戲結束，直接返回
    } 
    // 2. 如果不是勝利，就正常移動
    else {
        player.piecePosition = newPosition;
    }
    
    // --- ▲▲▲ 核心修復到這裡結束 ▲▲▲ ---

    renderLudoGameScreen();
    await sleep(500);

    // 檢查是否踩到對方棋子
    const opponent = ludoGameState.players.find(p => p.id !== player.id);
    if (player.piecePosition === opponent.piecePosition && opponent.piecePosition !== -1) {
        opponent.piecePosition = -1; // 將對方棋子送回起點
        logToLudoGame(`💥 <strong>${player.name}</strong> 踩中了 <strong>${opponent.name}</strong>！`, 'system');
        renderLudoGameScreen();
        await triggerLudoAiAction(isUserMove ? 'kick_char' : 'kick_user');
        await sleep(1000);
    }
    
    // 檢查是否踩到事件格子
    const cellIndex = ludoGameState.boardLayout.findIndex(c => c && c.index === player.piecePosition);
    if (cellIndex > -1 && ludoGameState.boardLayout[cellIndex].event) {
        const eventType = ludoGameState.boardLayout[cellIndex].event;
        if (eventType === 'question') {
            await handleLudoQuestionEvent(player);
            return;
        }
    }
    
    // 如果擲出6點，再行動一次
    if (diceRoll === 6) {
        if (!isUserMove) {
            await triggerLudoAiAction('roll_6');
        }
        logToLudoGame(`擲出6點，<strong>${player.name}</strong> 再行動一次。`, 'system');
        await sleep(1000);
        await processLudoTurn();
    } else {
        await advanceTurn(); // 否則切換到下一位玩家
    }
}
// ▲▲▲ 替換結束 ▲▲▲



/**
 * 【飛行棋】推進到下一個回合
 */
async function advanceTurn() {
    ludoGameState.currentTurnIndex = (ludoGameState.currentTurnIndex + 1) % ludoGameState.players.length;
    await processLudoTurn();
}

// ▼▼▼ 用這塊【優化後】的代碼，完整替換你舊的 triggerLudoAiAction 函數 ▼▼▼
async function triggerLudoAiAction(eventType, context = {}) {
    const aiPlayer = ludoGameState.players.find(p => !p.isUser);
    const userPlayer = ludoGameState.players.find(p => p.isUser);

    const eventPrompts = {
        roll_6: "你擲出了6點，可以再行動一次！",
        kick_char: "你剛剛把我踢回了起點！",
        kick_user: "我剛剛把你的棋子踢回了起點！",
        char_win: "我贏得了這場遊戲！",
        user_win: "你贏得了這場遊戲！"
    };
    
    let eventPrompt = eventPrompts[eventType] || "請根據當前情況自由發揮。";
    
    // --- ▼▼▼ 核心修改1：為不同的問答場景提供更詳細的指令 ▼▼▼ ---
    if (eventType === 'answer_question') {
        eventPrompt = `現在請根據你的人設，詳細回答這個問題：“${context.question}”`;
    } else if (eventType === 'evaluate_answer') {
        eventPrompt = `對於問題“${context.question}”，對方的回答是：“${context.answer}”。現在請你以你的角色身份，對這個回答詳細地發表一下看法或感受。`;
    }

    const systemPrompt = `
# 角色扮演指令
你正在和你的伴侶(${userPlayer.name})玩一場心動的線上飛行棋遊戲。
你的名字是"${aiPlayer.name}"，你的人設是：${aiPlayer.persona}
你的回復必須完全符合你的人設，自然地表達你的情緒。

# 遊戲當前狀態
- 你的棋子位置: ${aiPlayer.piecePosition}
- 對方的棋子位置: ${userPlayer.piecePosition}
- 當前回合: 輪到 ${ludoGameState.players[ludoGameState.currentTurnIndex].name}

# 剛剛發生的事件
${eventPrompt}

# 你的任務
根據以上所有資訊，生成一段符合你人設的回應。你的回應可以包含動作、心理活動和對話，讓互動更生動，要非常的貼合你的人設，以人設為主。

# 輸出格式
你的回復【必須且只能】是一個嚴格的JSON物件，格式如下:
{"speech": "你的回應..."}
`;
    
    try {
        const { proxyUrl, apiKey, model } = state.apiConfig;
        let isGemini = proxyUrl === GEMINI_API_URL;
        let messagesForApi = [{ role: 'user', content: systemPrompt }];
        let geminiConfig = toGeminiRequestData(model, apiKey, systemPrompt, messagesForApi, isGemini);
        
        const response = isGemini 
            ? await fetch(geminiConfig.url, geminiConfig.data) 
            : await fetch(`${proxyUrl}/v1/chat/completions`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}`},
                body: JSON.stringify({ model: model, messages: messagesForApi, temperature: 1.0, response_format: { type: "json_object" } })
            });

        if (!response.ok) throw new Error(await response.text());
        const data = await response.json();
        const content = (isGemini ? data.candidates[0].content.parts[0].text : data.choices[0].message.content).replace(/^```json\s*|```$/g, '');
        const aiResponse = JSON.parse(content);

        if (eventType === 'answer_question' || eventType === 'evaluate_answer') {
            return aiResponse.speech || "嗯...讓我想想。";
        }
        
        if (aiResponse.speech) {
            logToLudoGame(`<strong>${aiPlayer.name}:</strong> ${aiResponse.speech}`, 'char');
        }

    } catch (error) {
        console.error("飛行棋AI回應失敗:", error);
        if (eventType === 'answer_question' || eventType === 'evaluate_answer') {
            return "我...我不知道該怎麼回答了。";
        }
    }
}
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 【最終智慧版 | 問題數量精確匹配】用這塊代碼，完整替換你舊的 generateLudoBoard 函數 ▼▼▼
/**
 * 【飛行棋】生成棋盤格子 (V4 - 問題數量精確匹配版)
 */
async function generateLudoBoard() {
    const boardEl = document.getElementById('ludo-board');
    boardEl.innerHTML = '';
    const pathCoordinates = [
        [0,0],[1,0],[2,0],[3,0],[4,0],[5,0],[6,0],[7,0],[8,0],[9,0],
        [9,1],[9,2],[8,2],[7,2],[6,2],[5,2],[4,2],[3,2],[2,2],[1,2],[0,2],
        [0,3],[0,4],[1,4],[2,4],[3,4],[4,4],[5,4],[6,4],[7,4],[8,4],[9,4],
        [9,5],[8,5],[7,5],[6,5],[5,5],[4,5],[3,5],[2,5],[1,5],[0,5]
    ];

    let cells = Array(60).fill(null);
    pathCoordinates.slice(0, LUDO_BOARD_SIZE).forEach((coord, i) => {
        const pos = coord[1] * 10 + coord[0];
        cells[pos] = { type: 'path', index: i };
    });

    cells[21] = { type: 'start', index: -1 };
    cells[38] = { type: 'end', index: LUDO_BOARD_SIZE };

    // --- ▼▼▼ 這就是本次的【核心修改】 ▼▼▼ ---

    // 1. 獲取當前遊戲選擇的問題庫ID
    const questionBankId = ludoGameState.activeQuestionBankId;
    let questionsInBank = [];

    // 2. 從資料庫中載入該問題庫的所有問題
    if (questionBankId) {
        questionsInBank = await db.ludoQuestions.where('bankId').equals(questionBankId).toArray();
    }
    
    // 3. 篩選出所有可以放置問題的普通格子
    const availableCellIndices = [];
    cells.forEach((cellData, index) => {
        // 我們不在起點、終點，以及緊鄰起點的第一格放問題
        if (cellData && cellData.type === 'path' && cellData.index > 0) {
            availableCellIndices.push(index);
        }
    });

    // 4. 打亂這些格子的順序，讓問題隨機分佈
    availableCellIndices.sort(() => Math.random() - 0.5);

    // 5. 【關鍵】確定要放置的問題數量：取 問題庫總數 和 可用格子數 中較小的一個
    const eventCount = Math.min(questionsInBank.length, availableCellIndices.length);
    
    // 如果問題數量比可用格子還多，給個提示
    if (questionsInBank.length > availableCellIndices.length) {
        console.warn(`飛行棋警告：問題庫中的問題數量(${questionsInBank.length})超過了棋盤上的可用格子數量(${availableCellIndices.length})，部分問題將不會出現。`);
    }
    
    // 6. 放置與問題庫數量相等的問號格子
    for (let i = 0; i < eventCount; i++) {
        const cellIndexToModify = availableCellIndices[i];
        if (cells[cellIndexToModify]) {
            cells[cellIndexToModify].event = 'question';
        }
    }
    
    // --- ▲▲▲ 修改結束 ▲▲▲ ---

    ludoGameState.boardLayout = cells;

    // 後續的渲染邏輯保持不變...
    cells.forEach((cellData, i) => {
        if (cellData) {
            const cellEl = document.createElement('div');
            cellEl.className = 'ludo-cell';

            if(cellData.type === 'path') {
                cellEl.dataset.index = cellData.index;
                cellEl.innerHTML = `<span class="cell-number">${cellData.index + 1}</span>`;
            }
            if(cellData.type === 'start') {
                 cellEl.classList.add('start');
                 cellEl.innerHTML = '🏠';
            }
            if(cellData.type === 'end') {
                 cellEl.classList.add('end');
                 cellEl.innerHTML = '🏁';
            }
            if (cellData.event === 'question') {
                cellEl.classList.add(`event-truth`);
                cellEl.innerHTML += '❓';
            }
            
            const position = ludoGameState.boardLayout.indexOf(cellData);
            const row = Math.floor(position / 10);
            const col = position % 10;
            cellEl.style.gridRowStart = row + 1;
            cellEl.style.gridColumnStart = col + 1;
            
            boardEl.appendChild(cellEl);
        }
    });
}
// ▲▲▲ 替換結束 ▲▲▲


// ▼▼▼ 把這一整塊全新的功能函數，黏貼到 init() 函數的【正上方】 ▼▼▼

// ▼▼▼ 用這整塊新代碼，替換掉所有舊的飛行棋問題庫核心函數 ▼▼▼

/* --- 【全新 | V2分類版】飛行棋問題庫功能核心函數 --- */

let activeQuestionBankId = null; // 用於追蹤正在編輯的問題庫ID
let editingQuestionId = null; // 用於追蹤正在編輯的問題ID

// ▼▼▼ 用這塊【已修復】的代碼，完整替換你舊的 migrateDefaultLudoQuestions 函數 ▼▼▼
/**
 * 【資料移轉】在首次載入時，將舊的硬編碼問題遷移到資料庫
 */
async function migrateDefaultLudoQuestions() {
    const defaultBankName = "默認題庫";
    const existingBank = await db.ludoQuestionBanks.where('name').equals(defaultBankName).first();
    // 如果“默認題庫”已經存在，就說明遷移過了，直接返回
    if (existingBank) return;
    
    console.log("正在遷移飛行棋預設問題到資料庫...");

    // 創建默認題庫
    const bankId = await db.ludoQuestionBanks.add({ name: defaultBankName });
    
    // ★★★ 核心修改：將問題庫改為物件陣列，並為每個問題添加類型 ★★★
    const defaultQuestions = [
        // --- 類型1: 共同回答 (雙方都需要回答) ---
        { type: 'both_answer', text: '如果我們一起去旅行，你最想去哪裡，為什麼？' },
        { type: 'both_answer', text: '你認為一段完美的關係中，最不可或缺的三個要素是什麼？' },
        { type: 'both_answer', text: '分享一件最近因為我而讓你感到心動或開心的小事。' },
        { type: 'both_answer', text: '回憶一下，我們第一次見面時，你對我的第一印象是什麼？' },
        { type: 'both_answer', text: '如果我們可以一起學習一項新技能，你希望是什麼？' },
        { type: 'both_answer', text: '描述一個你最希望和我一起度過的完美週末。' },
        { type: 'both_answer', text: '你覺得我們之間最有默契的一件事是什麼？' },
        { type: 'both_answer', text: '如果用一種動物來形容我，你覺得是什麼？為什麼？' },
        { type: 'both_answer', text: '在未來的一年裡，你最想和我一起完成的一件事是什麼？' },
        { type: 'both_answer', text: '分享一部你最近很喜歡、並且想推薦給我一起看的電影或劇。' },
        { type: 'both_answer', text: '我們下次約會，你希望穿什麼風格的衣服？' },

        // --- 類型2: 一人回答，對方評價 ---
        { type: 'single_answer', text: '描述一下我最讓你心動的一個瞬間。' },
        { type: 'single_answer', text: '誠實地說，我做的哪件事曾經讓你偷偷生過氣？' },
        { type: 'single_answer', text: '如果我有一種超能力，你希望是什麼？' },
        { type: 'single_answer', text: '給我三個最貼切的標籤。' },
        { type: 'single_answer', text: '在你心裡，我的形象和你的理想型有多接近？' },
        { type: 'single_answer', text: '分享一個你覺得我可能不知道的，關於你的小秘密。' },
        { type: 'single_answer', text: '如果我們的故事是一首歌，你覺得歌名應該叫什麼？' },
        { type: 'single_answer', text: '說一件你覺得我做得比你好/更擅長的事情。' },
        { type: 'single_answer', text: '如果可以回到我們認識的任意一天，你會選擇哪一天，想做什麼？' },
        { type: 'single_answer', text: '用三個詞來形容你眼中的我們的關係。' }
    ];

    const questionsToAdd = defaultQuestions.map(q => ({
        bankId: bankId,
        text: q.text,
        type: q.type // <-- 關鍵修復：把類型也存進去！
    }));
    
    await db.ludoQuestions.bulkAdd(questionsToAdd);
    console.log(`成功遷移了 ${questionsToAdd.length} 條默認問題。`);
}
// ▲▲▲ 替換結束 ▲▲▲


/**
 * 打開問題庫管理彈窗
 */
async function openLudoQuestionBankManager() {
    await renderLudoQuestionBanks();
    document.getElementById('ludo-qbank-manager-modal').classList.add('visible');
}

/**
 * 渲染問題庫列表
 */
async function renderLudoQuestionBanks() {
    const listEl = document.getElementById('ludo-qbank-list');
    listEl.innerHTML = '';
    const banks = await db.ludoQuestionBanks.toArray();

    if (banks.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">還沒有問題庫，點擊右上角“新建”創建一個吧！</p>';
    } else {
        banks.forEach(bank => {
            const item = document.createElement('div');
            item.className = 'list-item';
            item.innerHTML = `<div class="item-title">${bank.name}</div>`;
            item.addEventListener('click', () => openLudoQuestionEditor(bank.id, bank.name));
addLongPressListener(item, async () => {
    // ▼▼▼ 核心修改在這裡：在功能表裡增加一個 'export' 選項 ▼▼▼
    const choice = await showChoiceModal(`操作“${bank.name}”`, [
        { text: '✏️ 重命名', value: 'rename' },
        { text: '📤 匯出', value: 'export' }, // <-- 新增的匯出選項
        { text: '🗑️ 刪除', value: 'delete', isDanger: true }
    ]);

    if (choice === 'rename') {
        const newName = await showCustomPrompt('重命名問題庫', '請輸入新的名稱：', bank.name);
        if (newName && newName.trim()) {
            await db.ludoQuestionBanks.update(bank.id, { name: newName.trim() });
            await renderLudoQuestionBanks();
        }
    } else if (choice === 'export') {
        // ▼▼▼ 在這裡調用我們新寫的匯出函數 ▼▼▼
        await exportLudoQuestionBank(bank.id);
    } else if (choice === 'delete') {
        const confirmed = await showCustomConfirm('確認刪除', `確定要刪除問題庫“${bank.name}”嗎？這將同時刪除庫內所有問題。`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            await db.transaction('rw', db.ludoQuestionBanks, db.ludoQuestions, async () => {
                await db.ludoQuestions.where('bankId').equals(bank.id).delete();
                await db.ludoQuestionBanks.delete(bank.id);
            });
            await renderLudoQuestionBanks();
        }
    }
});
            listEl.appendChild(item);
        });
    }
}

/**
 * 添加一個新的問題庫
 */
async function addNewLudoQuestionBank() {
    const name = await showCustomPrompt('新建問題庫', '請輸入問題庫的名稱：');
    if (name && name.trim()) {
        await db.ludoQuestionBanks.add({ name: name.trim() });
        await renderLudoQuestionBanks();
    }
}

/**
 * 打開指定問題庫的問題編輯器
 */
async function openLudoQuestionEditor(bankId, bankName) {
    activeQuestionBankId = bankId;
    document.getElementById('ludo-question-editor-title').textContent = `編輯 - ${bankName}`;
    await renderLudoQuestionsInBank(bankId);
    document.getElementById('ludo-question-editor-modal').classList.add('visible');
}

/**
 * 渲染一個問題庫中的所有問題
 */
async function renderLudoQuestionsInBank(bankId) {
    const listEl = document.getElementById('ludo-question-list');
    listEl.innerHTML = '';
    const questions = await db.ludoQuestions.where('bankId').equals(bankId).toArray();

    if (questions.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary); padding: 50px 0;">這個題庫還是空的，點擊右上角“+”添加第一個問題吧！</p>';
    } else {
        questions.forEach(q => {
            const item = document.createElement('div');
            item.className = 'list-item';
            
            // ★★★ 核心修改：根據問題類型添加標籤 ★★★
            const typeText = q.type === 'single_answer' ? '一人回答' : '共同回答';
            const typeClass = q.type === 'single_answer' ? 'single-answer' : 'both-answer';
            
            item.innerHTML = `
                <div class="item-title" style="white-space: normal; display: flex; align-items: center;">
                    <span>${q.text}</span>
                    <span class="question-type-tag ${typeClass}">${typeText}</span>
                </div>
            `;
            
            item.addEventListener('click', () => openSingleQuestionEditor(q.id));
            addLongPressListener(item, async () => {
                const confirmed = await showCustomConfirm('刪除問題', '確定要刪除這個問題嗎？', { confirmButtonClass: 'btn-danger' });
                if(confirmed) {
                    await db.ludoQuestions.delete(q.id);
                    await renderLudoQuestionsInBank(bankId);
                }
            });
            listEl.appendChild(item);
        });
    }
}

/**
 * 打開單個問題編輯器（用於新建或編輯）
 */
async function openSingleQuestionEditor(questionId = null) {
    editingQuestionId = questionId;
    const modal = document.getElementById('ludo-single-question-editor-modal');
    const titleEl = document.getElementById('ludo-single-question-title');
    const textInput = document.getElementById('ludo-question-text-input');
    const typeRadios = document.querySelectorAll('input[name="ludo_question_type"]');

    if (questionId) {
        // 編輯模式
        const question = await db.ludoQuestions.get(questionId);
        if (!question) return;
        titleEl.textContent = '編輯問題';
        textInput.value = question.text;
        typeRadios.forEach(radio => radio.checked = radio.value === (question.type || 'both_answer'));
    } else {
        // 新建模式
        titleEl.textContent = '添加新問題';
        textInput.value = '';
        typeRadios[0].checked = true; // 默認選中“共同回答”
    }
    
    modal.classList.add('visible');
}

/**
 * 保存單個問題（新建或更新）
 */
async function saveSingleQuestion() {
    const text = document.getElementById('ludo-question-text-input').value.trim();
    if (!text) {
        alert('問題內容不能為空！');
        return;
    }
    const type = document.querySelector('input[name="ludo_question_type"]:checked').value;

    if (editingQuestionId) {
        // 更新
        await db.ludoQuestions.update(editingQuestionId, { text, type });
    } else {
        // 新建
        await db.ludoQuestions.add({ bankId: activeQuestionBankId, text, type });
    }

    document.getElementById('ludo-single-question-editor-modal').classList.remove('visible');
    await renderLudoQuestionsInBank(activeQuestionBankId); // 刷新列表
    editingQuestionId = null;
}

/**
 * 飛行棋觸發問答事件的總控函數
 */
async function handleLudoQuestionEvent(player) {
    const questionBankId = ludoGameState.activeQuestionBankId;
    let questions = [];
    if (questionBankId) {
        questions = await db.ludoQuestions.where('bankId').equals(questionBankId).toArray();
    }

    if (questions.length === 0) {
        logToLudoGame('當前題庫是空的，跳過本輪問答。', 'system');
        await sleep(1500);
        await advanceTurn();
        return;
    }

    const questionObj = getRandomItem(questions);
    const questionText = questionObj.text;
    
    // ★★★ 核心修改：不再彈窗讓使用者選擇，直接從問題物件中獲取模式 ★★★
    const mode = questionObj.type || 'both_answer'; // 如果老資料沒有type，則預設為共同回答
    
    logToLudoGame(`【${mode === 'both_answer' ? '共同回答' : '一人回答，一人評價'}】抽到的問題是：“${questionText}”`, 'system');
    await sleep(1500);

    const currentPlayer = player;
    const otherPlayer = ludoGameState.players.find(p => p.id !== currentPlayer.id);

    if (mode === 'both_answer') {
        logToLudoGame(`請 <strong>${currentPlayer.name}</strong> 先回答。`, 'system');
        let answer1 = currentPlayer.isUser 
            ? await waitForLudoUserAction('輪到你回答問題', '請輸入你的回答...')
            : await triggerLudoAiAction('answer_question', { question: questionText });
        logToLudoGame(`<strong>${currentPlayer.name}:</strong> ${answer1}`, currentPlayer.isUser ? 'user' : 'char');
        await sleep(2000);

        logToLudoGame(`現在請 <strong>${otherPlayer.name}</strong> 回答。`, 'system');
        let answer2 = otherPlayer.isUser 
            ? await waitForLudoUserAction('輪到你回答問題', '請輸入你的回答...')
            : await triggerLudoAiAction('answer_question', { question: questionText });
        logToLudoGame(`<strong>${otherPlayer.name}:</strong> ${answer2}`, otherPlayer.isUser ? 'user' : 'char');
    
    } else if (mode === 'single_answer') {
        logToLudoGame(`請 <strong>${currentPlayer.name}</strong> 回答這個問題。`, 'system');
        let answer = currentPlayer.isUser
            ? await waitForLudoUserAction('輪到你回答問題', '請輸入你的回答...')
            : await triggerLudoAiAction('answer_question', { question: questionText });
        logToLudoGame(`<strong>${currentPlayer.name}:</strong> ${answer}`, currentPlayer.isUser ? 'user' : 'char');
        await sleep(2000);

        logToLudoGame(`現在請 <strong>${otherPlayer.name}</strong> 對Ta的回答發表一下看法吧。`, 'system');
        let evaluation = otherPlayer.isUser
            ? await waitForLudoUserAction(`對“${answer}”的看法`, '請輸入你的評價...')
            : await triggerLudoAiAction('evaluate_answer', { question: questionText, answer: answer });
        logToLudoGame(`<strong>${otherPlayer.name}:</strong> ${evaluation}`, otherPlayer.isUser ? 'user' : 'char');
    }

    await sleep(1500);
    logToLudoGame('本輪問答結束，遊戲繼續！', 'system');
    await advanceTurn();
}
// ▲▲▲ 替換結束 ▲▲▲
/**
 * 【全新】顯示飛行棋遊戲結算卡片
 * @param {string} winnerName - 勝利者的名字
 */
function showLudoSummary(winnerName) {
    const modal = document.getElementById('ludo-summary-modal');
    const contentEl = document.getElementById('ludo-summary-content');

    // 1. 提取問答記錄檔
    let qaLogHtml = '<h4>心動問答記錄檔</h4>';
    const questionsAndAnswers = [];
    let currentQuestion = null;

    ludoGameState.gameLog.forEach(log => {
        // 通過識讀系統日誌裡的特定文本來找到“問題”
        if (log.type === 'system' && log.message.includes('抽到的問題是')) {
            const questionText = log.message.match(/“(.+?)”/);
            if (questionText && questionText[1]) {
                currentQuestion = { question: questionText[1], answers: [] };
                questionsAndAnswers.push(currentQuestion);
            }
        } 
        // 如果我們剛剛找到了一個問題，那麼後續的用戶或角色發言就是“回答”
        else if (currentQuestion && (log.type === 'user' || log.type === 'char') && !log.message.includes('擲出了')) {
            const answerText = log.message.replace(/<strong>.*?<\/strong>:\s*/, '');
            const speakerNameMatch = log.message.match(/<strong>(.*?)<\/strong>/);
            if (speakerNameMatch && speakerNameMatch[1]) {
                currentQuestion.answers.push({ speaker: speakerNameMatch[1], text: answerText });
            }
        }
    });
    
    // 2. 將提取出的問答記錄檔格式化為HTML
    if(questionsAndAnswers.length > 0){
        questionsAndAnswers.forEach((qa, index) => {
            qaLogHtml += `<div class="qa-item">
                <div class="qa-question">Q${index + 1}: ${qa.question}</div>`;
            qa.answers.forEach(ans => {
                 qaLogHtml += `<div class="qa-answer"><strong>${ans.speaker}:</strong> ${ans.text}</div>`;
            });
            qaLogHtml += `</div>`;
        });
    } else {
        qaLogHtml += '<p>本局沒有觸發任何問答。</p>';
    }

    // 3. 拼接完整的結算卡片內容
    contentEl.innerHTML = `
        <h3>🎉 恭喜 ${winnerName} 獲勝！ 🎉</h3>
        <div class="ludo-qa-log">${qaLogHtml}</div>
    `;
    
    // 4. 為按鈕綁定事件 (使用克隆節點技巧防止重複綁定)
    const shareBtn = document.getElementById('share-ludo-summary-btn');
    const backBtn = document.getElementById('back-to-hall-from-ludo-btn');
    
    const newShareBtn = shareBtn.cloneNode(true);
    shareBtn.parentNode.replaceChild(newShareBtn, shareBtn);
    newShareBtn.onclick = () => {
        // 準備純文字格式的複盤內容用於分享
        const summaryForShare = `飛行棋遊戲結束啦！🎉\n\n勝利者: ${winnerName}\n\n--- 心動問答 ---\n` + 
            questionsAndAnswers.map((qa, i) => 
                `Q${i+1}: ${qa.question}\n` + 
                qa.answers.map(ans => `${ans.speaker}: ${ans.text}`).join('\n')
            ).join('\n\n');
        
        shareLudoSummary(summaryForShare, winnerName);
    };

    const newBackBtn = backBtn.cloneNode(true);
    backBtn.parentNode.replaceChild(newBackBtn, backBtn);
    newBackBtn.onclick = () => {
        modal.classList.remove('visible');
        showScreen('game-hall-screen');
    };

    // 5. 顯示結算彈窗
    modal.classList.add('visible');
}

/**
 * 【全新】將飛行棋遊戲複盤發送給對手
 * @param {string} summaryText - 要發送的複盤文本
 */
async function shareLudoSummary(summaryText, winnerName) { 
    const opponentId = ludoGameState.opponent?.id;
    if (!opponentId) {
        alert("找不到對手資訊，無法分享。");
        return;
    }

    const chat = state.chats[opponentId];
    if (!chat) {
         alert("找不到與對手的聊天窗口，無法分享。");
        return;
    }

    // 創建對使用者可見的複盤消息
    const visibleMessage = {
        role: 'user',
        type: 'text',
        timestamp: Date.now(),
        content: summaryText
    };
    
    // 創建給AI看的隱藏指令，讓它可以就遊戲結果發表感想
    const aiContext = `[系統指令：剛剛結束了一局飛行棋。重要：本次遊戲的勝利者是【${winnerName}】。這是遊戲複盤，請根據這個結果，以你的角色人設，和用戶聊聊剛才的遊戲。]\n\n${summaryText}`;
    const hiddenInstruction = {
        role: 'system',
        content: aiContext,
        timestamp: Date.now() + 1,
        isHidden: true
    };
    
    chat.history.push(visibleMessage, hiddenInstruction);
    await db.chats.put(chat);

    // 關閉結算卡片
    document.getElementById('ludo-summary-modal').classList.remove('visible');
    
    await showCustomAlert("分享成功", `遊戲複盤已發送至與“${chat.name}”的聊天中！`);

    // 跳轉到聊天介面並讓AI回應
    openChat(chat.id);
    triggerAiResponse();
}


// ▲▲▲ 新增代碼黏貼結束 ▲▲▲

// ▲▲▲ 新功能函數黏貼結束 ▲▲▲
        // ===================================================================
        // 4. 初始化函數 init()
        // ===================================================================
        async function init() {
await migrateDefaultLudoQuestions();
    // ▼▼▼ 在 init()    // ▼▼▼ 在這裡黏貼下面這幾行新代碼 ▼▼▼
    // 更新小元件的月份顯示
    const monthElement = document.getElementById('widget-month-display');
    if (monthElement) {
        const currentMonth = new Date().getMonth() + 1; // getMonth()返回0-11，所以要+1
        monthElement.textContent = currentMonth;
    }
    // ▲▲▲ 新代碼黏貼結束 ▲▲▲ 函數的【最開頭】，黏貼下面這兩行代碼 ▼▼▼
    const savedTheme = localStorage.getItem('ephone-theme') || 'light'; // 預設為日間模式
    applyTheme(savedTheme);
    // ▲▲▲ 黏貼結束 ▲▲▲

    // ▼▼▼ 新增代碼 ▼▼▼
    const customBubbleStyleTag = document.createElement('style');
    customBubbleStyleTag.id = 'custom-bubble-style';
    document.head.appendChild(customBubbleStyleTag);
    // ▲▲▲ 新增結束 ▲▲▲

    // ▼▼▼ 新增代碼 ▼▼▼
    const previewBubbleStyleTag = document.createElement('style');
    previewBubbleStyleTag.id = 'preview-bubble-style';
    document.head.appendChild(previewBubbleStyleTag);
    // ▲▲▲ 新增結束 ▲▲▲


    // ▼▼▼ 修改這兩行 ▼▼▼
    applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // 清除真實聊天介面的自訂樣式
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // 清除預覽區的自訂樣式
    // ▲▲▲ 修改結束 ▲▲▲

            window.showScreen = showScreen;
            window.openLoversSpaceFromCard = openLoversSpaceFromCard; // <-- 在這裡添加這一行
            window.renderChatListProxy = renderChatList;
            window.renderApiSettingsProxy = renderApiSettings;
            window.renderWallpaperScreenProxy = renderWallpaperScreen;
            window.renderWorldBookScreenProxy = renderWorldBookScreen;

            await loadAllDataFromDB();
            // 在 loadAllDataFromDB 函數末尾，init(); 調用之前添加
if (typeof state.globalSettings.notificationSoundUrl === 'undefined') {
    state.globalSettings.notificationSoundUrl = 'https://files.catbox.moe/k369mf.mp3';
}
            // ▼▼▼ 把新代碼黏貼到這裡 ▼▼▼
            renderHomeScreenProfileFrame(); // 初始化時渲染主頁頭像框
            // ▲▲▲ 黏貼結束 ▲▲▲
            applyHomeIconWidgetTextColor(state.globalSettings.homeIconWidgetTextColor);
            await loadAllFontPresetsOnStartup(); // <---- 在這裡添加這一行新代碼
            await addDefaultDarkModeThemeIfNeeded();
            applyWidgetData();

if (state.globalSettings.homeIconWidgetTextColor) {
    applyHomeIconWidgetTextColor(state.globalSettings.homeIconWidgetTextColor);
}

// 2. 應用已保存的“去除陰影”設置
document.getElementById('phone-screen').classList.toggle('no-home-font-shadow', !!state.globalSettings.removeHomeFontShadow);

            // 初始化未讀動態計數
            const storedCount = parseInt(localStorage.getItem('unreadPostsCount')) || 0;
            updateUnreadIndicator(storedCount);
            
            // ▲▲▲ 代碼添加結束 ▲▲▲

            if (state.globalSettings && state.globalSettings.fontUrl) {
                applyCustomFont(state.globalSettings.fontUrl);
            }

    // ▼▼▼ 在這裡黏貼新代碼 ▼▼▼
    // 【核心修復】初始化時，自動載入並應用已保存的主題
    if (state.globalSettings.activeThemeId) {
        const activeTheme = await db.themes.get(state.globalSettings.activeThemeId);
        if (activeTheme) {
            console.log(`正在應用已保存的主題: "${activeTheme.name}"`);
            applyThemeCss(activeTheme.css);
        }
    }
    // ▲▲▲ 新代碼黏貼結束 ▲▲▲

            updateClock();
            setInterval(updateClock, 1000 * 30);
            applyGlobalWallpaper();
            initBatteryManager(); 

applyAppIcons();
applyAppLabels();
    // ▼▼▼ 在這裡添加下面這行代碼 ▼▼▼
    initDraggableLyricsBar(); // 初始化懸浮歌詞欄的拖動功能
    // ▲▲▲ 添加結束 ▲▲▲

            // ==========================================================
            // --- 各種事件監聽器 ---
            // ==========================================================
            // ▼▼▼ 在 init() 函數的事件監聽器區域末尾，添加下面這行代碼 ▼▼▼
// ▼▼▼ 用這塊新代碼，替換舊的 weibo-screen 事件監聽器 ▼▼▼
            // ▼▼▼ 【全新】“查角色手機”功能事件監聽器 (V2 - 單獨生成版) ▼▼▼

            // 1. 綁定主螢幕上的“查手機”APP圖示
            document.getElementById('check-phone-btn').addEventListener('click', openCharacterSelectionScreen);

            // 2. 角色選擇列表的點擊事件 (事件委託)
            document.getElementById('character-selection-list').addEventListener('click', (e) => {
                const item = e.target.closest('.character-select-item');
                if (item && item.dataset.chatId) {
                    openCharacterPhone(item.dataset.chatId);
                }
            });

            // 3. 【總生成/清空】角色手機頂部的“刷新”和“清空”按鈕
            document.getElementById('generate-character-data-btn').addEventListener('click', generateCharacterPhoneData);
            document.getElementById('clear-character-data-btn').addEventListener('click', clearCharacterPhoneData);

// ▼▼▼ 請用這一整塊【功能增強版】的代碼，完整替換掉你舊的 character-phone-container 事件監聽器 ▼▼▼
document.getElementById('character-phone-container').addEventListener('click', (e) => {
    const backBtn = e.target.closest('.back-btn');
    const actionBtn = e.target.closest('.action-btn');

    // 1. 處理返回按鈕
    if (backBtn) {
        if (backBtn.dataset.targetPage) {
            showCharacterPhonePage(backBtn.dataset.targetPage);
        } else if (backBtn.dataset.targetScreen) {
            showScreen(backBtn.dataset.targetScreen);
        }
        return;
    }
    
    // 2. 處理所有操作按鈕（生成 + 刪除）
    if (actionBtn) {
        switch (actionBtn.id) {
            // --- 單獨生成按鈕 ---
            case 'generate-chat-message-btn': 
                generateCharacterPhoneDataSegment('chats'); break;
            case 'generate-cart-item-btn':
                generateCharacterPhoneDataSegment('shoppingCart'); break;
            case 'generate-memo-btn':
                generateCharacterPhoneDataSegment('memos'); break;
            case 'generate-browser-history-btn':
                generateCharacterPhoneDataSegment('browserHistory'); break;
            case 'generate-album-photo-btn':
                generateCharacterPhoneDataSegment('photoAlbum'); break;
            case 'generate-bank-transaction-btn':
                generateCharacterPhoneDataSegment('bank'); break;
            case 'generate-trajectory-btn':
                generateCharacterPhoneDataSegment('trajectory'); break;
            case 'generate-app-usage-btn':
                generateCharacterPhoneDataSegment('appUsage'); break;
            case 'generate-diary-entry-btn':
                generateCharacterPhoneDataSegment('diary'); break;

            // --- ★★★ 這就是我們新增的全部刪除按鈕的邏輯 ★★★ ---
            case 'clear-npc-chats-btn':
                handleClearCharacterDataSegment('chats'); break;
            case 'clear-cart-items-btn':
                handleClearCharacterDataSegment('shoppingCart'); break;
            case 'clear-memos-btn':
                handleClearCharacterDataSegment('memos'); break;
            case 'clear-browser-history-btn':
                handleClearCharacterDataSegment('browserHistory'); break;
            case 'clear-album-photos-btn':
                handleClearCharacterDataSegment('photoAlbum'); break;
            case 'clear-bank-transactions-btn':
                handleClearCharacterDataSegment('bank.transactions'); break;
            case 'clear-trajectory-btn':
                handleClearCharacterDataSegment('trajectory'); break;
            case 'clear-app-usage-btn':
                handleClearCharacterDataSegment('appUsage'); break;
            case 'clear-diary-entries-btn':
                handleClearCharacterDataSegment('diary'); break;
        }
    }
});
// ▲▲▲ 替換結束 ▲▲▲


// ▼▼▼ 【V3最終美化版】主螢幕預設功能事件綁定 ▼▼▼
document.getElementById('home-preset-selector').addEventListener('change', handleHomePresetSelection);
document.getElementById('apply-home-preset-btn').addEventListener('click', applySelectedHomeScreenPreset);
// 【核心修改】這裡按鈕的ID變了
document.getElementById('save-home-preset-btn').addEventListener('click', saveCurrentHomeScreenAsPreset); 
document.getElementById('update-home-preset-btn').addEventListener('click', updateSelectedHomeScreenPreset); // <-- 新增這一行
document.getElementById('rename-home-preset-btn').addEventListener('click', renameSelectedHomeScreenPreset);
document.getElementById('delete-home-preset-btn').addEventListener('click', deleteSelectedHomeScreenPreset);
document.getElementById('export-home-preset-btn').addEventListener('click', exportHomeScreenPreset);
document.getElementById('import-home-preset-btn').addEventListener('click', () => document.getElementById('import-home-preset-input').click());
document.getElementById('import-home-preset-input').addEventListener('change', (e) => {
    importHomeScreenPreset(e.target.files[0]);
    e.target.value = null;
});

            document.getElementById('theme-toggle-switch').addEventListener('change', toggleTheme);
// ▼▼▼ 【全新】聊天記錄搜索功能事件綁定 ▼▼▼
document.getElementById('search-chat-btn').addEventListener('click', openChatSearchScreen);

document.getElementById('search-back-btn').addEventListener('click', () => {
    // 返回時，重新打開聊天設置彈窗
    showScreen('chat-interface-screen');
    document.getElementById('chat-settings-btn').click();
});

document.getElementById('perform-search-btn').addEventListener('click', performChatSearch);

// 使用事件委託來處理所有搜索結果的點擊
document.getElementById('chat-search-results-list').addEventListener('click', (e) => {
    const item = e.target.closest('.search-result-item');
    if (item && item.dataset.timestamp) {
        jumpToMessage(parseInt(item.dataset.timestamp));
    }
});
// ▲▲▲ 新事件綁定結束 ▲▲▲
// ▼▼▼ 在 init() 函數的事件監聽器區域，黏貼這行新代碼 ▼▼▼

document.getElementById('create-weibo-post-btn').addEventListener('click', openWeiboPublisherClean);

// ▲▲▲ 新代碼黏貼結束 ▲▲▲

// ▼▼▼ 在 init() 函數的事件監聽器區域末尾，黏貼下面這行新代碼 ▼▼▼
document.getElementById('delete-expired-songs-btn').addEventListener('click', deleteExpiredSearchedSongs);
// ▼▼▼ 【修改】用這塊【功能增強版】的代碼，完整替換掉你舊的 weibo-following-list-container 事件監聽器 ▼▼▼
document.getElementById('weibo-following-list-container').addEventListener('click', (e) => {
    const item = e.target.closest('.weibo-following-item');
    if (!item) return;

    // 1. 檢查點擊的是否是“操作”按鈕
    const triggerBtn = e.target.closest('.weibo-action-trigger-btn');
    if (triggerBtn) {
        const targetInfo = {
            id: triggerBtn.dataset.targetId,
            name: triggerBtn.dataset.targetName,
            isNpc: triggerBtn.dataset.isNpc === 'true',
            ownerId: triggerBtn.dataset.ownerId || null
        };
        openWeiboActionModal(targetInfo);
    } 
    // 2. 如果點擊的不是操作按鈕，就視為點擊了整行，觸發“查看私信”
    else {
        // 先隱藏當前的關注列表彈窗
        document.getElementById('weibo-following-modal').classList.remove('visible');
        
        // 從整行item上獲取角色資訊
        const actionBtn = item.querySelector('.weibo-action-trigger-btn'); // 找到這一行的按鈕以獲取資料
        if (actionBtn) {
            const targetInfo = {
                id: actionBtn.dataset.targetId,
                name: actionBtn.dataset.targetName,
                isNpc: actionBtn.dataset.isNpc === 'true',
                ownerId: actionBtn.dataset.ownerId || null
            };
            // ★★★ 核心修改：調用我們新寫的總入口函數 ★★★
            openWeiboDms(targetInfo);
        }
    }
});
// ▲▲▲ 替換結束 ▲▲▲

// ▲▲▲ 替換結束 ▲▲▲
document.getElementById('cancel-weibo-action-btn').addEventListener('click', () => {
    document.getElementById('weibo-action-modal').classList.remove('visible');
});

document.getElementById('confirm-weibo-action-btn').addEventListener('click', handleWeiboAiAction);

// ▲▲▲ 新代碼黏貼結束 ▲▲▲

// 【已修改】為“生成熱搜”和“生成廣場”按鈕綁定新的帶角色選擇的事件
document.getElementById('generate-hot-search-btn').addEventListener('click', async () => {
    const targets = await showMultiCharacterSelectorForWeibo(); // 調用新的多選函數
    if (targets) { 
        await generateHotSearch(targets); 
    }
});
document.getElementById('generate-plaza-feed-btn').addEventListener('click', async () => {
    const targets = await showMultiCharacterSelectorForWeibo();
    if (targets) {
        await generatePlazaFeed(null, targets); 
    }
});


// ▼▼▼ 在 init() 的事件監聽器區域末尾，黏貼這整塊新代碼 ▼▼▼

// --- 微博熱搜與廣場功能事件綁定 ---

// 1. 綁定熱搜詳情頁的“返回”按鈕
document.getElementById('back-from-hottopic-btn').addEventListener('click', () => {
    switchToWeiboView('weibo-hot-search-view');
});

// 2. 綁定熱搜詳情頁的“換一批”按鈕
document.getElementById('refresh-hottopic-feed-btn').addEventListener('click', () => {
    if (currentHotTopic) {
        generateHotSearchFeed(currentHotTopic);
    }
});

// ▲▲▲ 新代碼黏貼結束 ▲▲▲

    // ▼▼▼ 第2步 第5處修改（新增事件監聽器） ▼▼▼
    // 【全新】角色表情包管理功能事件綁定
    document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
        if (e.target.id === 'manage-char-stickers-btn') {
            document.getElementById('chat-settings-modal').classList.remove('visible');
            openCharStickerManager();
        }
    });

    document.getElementById('back-from-sticker-manager').addEventListener('click', () => {
        showScreen('chat-interface-screen');
        document.getElementById('chat-settings-btn').click();
    });

    // 表情管理頁簽切換
    const stickerTabExclusive = document.getElementById('sticker-tab-exclusive');
    const stickerTabCommon = document.getElementById('sticker-tab-common');
    const stickerContentExclusive = document.getElementById('sticker-content-exclusive');
    const stickerContentCommon = document.getElementById('sticker-content-common');

    stickerTabExclusive.addEventListener('click', () => {
        stickerTabExclusive.classList.add('active');
        stickerTabCommon.classList.remove('active');
        stickerContentExclusive.style.display = 'block';
        stickerContentCommon.style.display = 'none';
    });

    stickerTabCommon.addEventListener('click', () => {
        stickerTabCommon.classList.add('active');
        stickerTabExclusive.classList.remove('active');
        stickerContentCommon.style.display = 'block';
        stickerContentExclusive.style.display = 'none';
    });

    // 綁定各種添加/上傳按鈕
    document.getElementById('add-exclusive-sticker-btn').addEventListener('click', () => bulkAddCharStickers('exclusive'));
    document.getElementById('upload-exclusive-sticker-btn').addEventListener('click', () => uploadCharStickersLocal('exclusive'));
    document.getElementById('add-common-sticker-btn').addEventListener('click', () => bulkAddCharStickers('common'));
    document.getElementById('upload-common-sticker-btn').addEventListener('click', () => uploadCharStickersLocal('common'));

    // ▲▲▲ 新增事件監聽器結束 ▲▲▲

// ▲▲▲ 新代碼黏貼結束 ▲▲▲

// ▼▼▼ 【全新】心聲歷史記錄刪除功能事件綁定 ▼▼▼
document.getElementById('clear-all-history-btn').addEventListener('click', clearAllInnerVoiceHistory);

// 使用事件委託處理單條刪除
document.getElementById('inner-voice-history-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('history-item-delete-btn')) {
        const timestamp = parseInt(e.target.dataset.timestamp);
        if (!isNaN(timestamp)) {
            deleteSingleInnerVoice(timestamp);
        }
    }
});
// ▲▲▲ 心聲歷史刪除事件綁定結束 ▲▲▲

 // ▼▼▼ 這是我們新加的導入功能事件監聽 ▼▼▼
        document.getElementById('import-character-card-btn').addEventListener('click', () => {
            // 點擊我們的新按鈕時，就去觸發那個隱藏的檔選擇框
            document.getElementById('character-card-input').click();
        });

        document.getElementById('character-card-input').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                // 當用戶選擇了檔後，調用我們的總處理函數
                handleCharacterImport(file);
            }
            // 清空選擇，這樣用戶下次還能選擇同一個檔
            event.target.value = null; 
        });
        // ▲▲▲ 新事件監聽結束 ▲▲▲
// ▼▼▼ 在 init() 的事件監聽器區域，黏貼這行新代碼 ▼▼▼
document.getElementById('phone-screen').addEventListener('click', unlockAudioContext, { once: true });
// ▲▲▲ 新代碼黏貼結束 ▲▲▲
            document.getElementById('custom-modal-cancel').addEventListener('click', hideCustomModal);
            document.getElementById('custom-modal-overlay').addEventListener('click', (e) => { if (e.target === modalOverlay) hideCustomModal(); });
            document.getElementById('export-data-btn').addEventListener('click', exportBackup);
            document.getElementById('import-btn').addEventListener('click', () => document.getElementById('import-data-input').click());
            document.getElementById('import-data-input').addEventListener('change', e => importBackup(e.target.files[0]));
            document.getElementById('back-to-list-btn').addEventListener('click', () => { 
 stopPetDecayTimer();
    // ▼▼▼ 修改這兩行 ▼▼▼
    applyScopedCss('', '#chat-messages', 'custom-bubble-style'); // 清除真實聊天介面的自訂樣式
    applyScopedCss('', '#settings-preview-area', 'preview-bubble-style'); // 清除預覽區的自訂樣式
    // ▲▲▲ 修改結束 ▲▲▲

exitSelectionMode(); state.activeChatId = null;
// 【心聲功能】返回列表時，隱藏心形按鈕
document.getElementById('char-heart-btn').style.display = 'none';
 showScreen('chat-list-screen'); });
            // ▼▼▼ 在 init() 的事件監聽器區域末尾，黏貼這段新代碼 ▼▼▼
            // 為歌曲封面/歌詞區域綁定點擊切換事件
            document.getElementById('music-display-area').addEventListener('click', () => {
                const displayArea = document.getElementById('music-display-area');
                // 直接切換 .show-lyrics 這個類，CSS會自動處理顯示/隱藏
                displayArea.classList.toggle('show-lyrics');
            });
            // ▲▲▲ 新代碼黏貼結束 ▲▲▲

                        document.getElementById('add-chat-btn').addEventListener('click', async () => { 
                const name = await showCustomPrompt('創建新聊天', '請輸入Ta的名字'); 
                if (name && name.trim()) { 
                    const newChatId = 'chat_' + Date.now(); 
                    
                    // ▼▼▼ 從這裡開始替換 ▼▼▼
                const newChat = {
                    id: newChatId,
                    name: name.trim(),
                    isGroup: false,
                    isPinned: false,
                    npcLibrary: [], // 角色專屬NPC庫
                    relationship: { status: 'friend', blockedTimestamp: null, applicationReason: '' },
                    status: { text: '線上', lastUpdate: Date.now(), isBusy: false },
                    settings: {
                        aiPersona: '你是誰呀。',
                        myPersona: '我是誰呀。',
                        maxMemory: 10,
                        aiAvatar: defaultAvatar,
                        myAvatar: defaultAvatar,
                        background: '',
                        theme: 'default',
                        fontSize: 13,
                        customCss: '',
                        linkedWorldBookIds: [],
                        aiAvatarLibrary: [],
                        stickerLibrary: [], // 專屬表情庫
                        // === 以下是本次修復新增的初始化屬性 ===
                        linkedMemories: [], // 【修復核心】初始化記憶互通陣列
                        offlineMode: { enabled: false, prompt: '', style: '', wordCount: 300, presets: [] }, // 初始化線下模式
                        timePerceptionEnabled: true, // 初始化時間感知
                        customTime: '', // 初始化自訂時間
                        isCoupleAvatar: false, // 初始化情侶頭像開關
                        coupleAvatarDescription: '', // 初始化情侶頭像描述
                        weiboProfession: '', // 初始化微博職業
                        weiboInstruction: '' // 初始化微博指令
                    },
                    history: [],
                    musicData: { totalTime: 0 },
                    // 手機資料也保持完整
                    characterPhoneData: {
                        lastGenerated: null, chats: {}, shoppingCart: [], memos: [],
                        browserHistory: [], photoAlbum: [], bank: { balance: 0, transactions: [] },
                        trajectory: [], appUsage: [], diary: []
                    }
                };
// ▲▲▲ 替換到這裡結束 ▲▲▲


                    state.chats[newChatId] = newChat; 
                    await db.chats.put(newChat); 
                    renderChatList(); 
                } 
            });

            // ▼▼▼ 【修正】創建群聊按鈕現在打開連絡人選擇器 ▼▼▼
document.getElementById('add-group-chat-btn').addEventListener('click', openContactPickerForGroupCreate);
// ▲▲▲ 替換結束 ▲▲▲                      
            document.getElementById('transfer-cancel-btn').addEventListener('click', () => document.getElementById('transfer-modal').classList.remove('visible'));
            document.getElementById('transfer-confirm-btn').addEventListener('click', sendUserTransfer);

            document.getElementById('listen-together-btn').addEventListener('click', handleListenTogetherClick);
            document.getElementById('music-exit-btn').addEventListener('click', () => endListenTogetherSession(true));
            document.getElementById('music-return-btn').addEventListener('click', returnToChat);
            document.getElementById('music-play-pause-btn').addEventListener('click', togglePlayPause);
            document.getElementById('music-next-btn').addEventListener('click', playNext);
            document.getElementById('music-prev-btn').addEventListener('click', playPrev);
            document.getElementById('music-mode-btn').addEventListener('click', changePlayMode);
            document.getElementById('music-playlist-btn').addEventListener('click', () => { updatePlaylistUI(); document.getElementById('music-playlist-panel').classList.add('visible'); });
            document.getElementById('close-playlist-btn').addEventListener('click', () => document.getElementById('music-playlist-panel').classList.remove('visible'));
            document.getElementById('add-song-url-btn').addEventListener('click', addSongFromURL);
            document.getElementById('add-song-local-btn').addEventListener('click', () => document.getElementById('local-song-upload-input').click());
            document.getElementById('local-song-upload-input').addEventListener('change', addSongFromLocal);
            // ▼▼▼ 【全新】BGM搜索功能事件綁定 ▼▼▼
document.getElementById('add-song-search-btn').addEventListener('click', addSongFromSearch);

document.getElementById('cancel-music-search-btn').addEventListener('click', () => {
    document.getElementById('music-search-results-modal').classList.remove('visible');
});

document.getElementById('search-results-list').addEventListener('click', (e) => {
    const item = e.target.closest('.search-result-item');
    if (item && item.dataset.songJson) {
        const songData = JSON.parse(item.dataset.songJson);
        handleSearchResultClick(songData);
    }
});
// ▲▲▲ 新增事件綁定結束 ▲▲▲

            audioPlayer.addEventListener('ended', playNext);

            const chatInput = document.getElementById('chat-input');
            // ▼▼▼ 找到 id="send-btn" 的 click 事件監聽器 ▼▼▼
document.getElementById('send-btn').addEventListener('click', async () => { 
    const content = chatInput.value.trim(); 
    if (!content || !state.activeChatId) return; 
        // --- ▼▼▼【核心修復代碼】▼▼▼ ---
    try {
        const command = JSON.parse(content);
        // 檢查：這是否是一個讓角色發微博的指令？
        if (command && command.type === 'weibo_post') {
            const chat = state.chats[state.activeChatId];
            if (chat.isGroup) {
                alert("不能在群聊中為單個角色發佈微博。");
                return;
            }

            // 創建一個新的微博帖子物件
            const newPost = {
                authorId: chat.id, // 關鍵！作者ID是當前角色的ID，而不是'user'
                authorType: 'char',
                authorNickname: chat.name,
                authorAvatar: chat.settings.aiAvatar || defaultAvatar,
                content: command.content || '',
                timestamp: Date.now(),
                likes: [],
                comments: [],
                baseLikesCount: command.baseLikesCount || 0,
                baseCommentsCount: command.baseCommentsCount || 0
            };

            // 如果JSON裡有路人評論，就解析並添加
            if (command.comments && typeof command.comments === 'string') {
                newPost.comments = command.comments.split('\n').map(c => {
                    const parts = c.split(/[:：]/);
                    const commenter = parts.shift() || '路人';
                    const commentText = parts.join(':').trim();
                    return { commentId: 'comment_' + Date.now() + Math.random(), authorNickname: commenter, commentText: commentText };
                }).filter(c => c.commentText);
            }

            await db.weiboPosts.add(newPost);
            
            // 刷新“關注的人”列表，新微博就會出現了！
            await renderFollowingWeiboFeed();

            await showCustomAlert('操作成功', `已為 “${chat.name}” 發佈了一條新微博！`);
            
            chatInput.value = ''; // 清空輸入框
            return; // 結束函數，不再執行後面的代碼
        }
    } catch (e) {
        // 如果解析JSON失敗，說明它不是指令，只是普通文本，就讓代碼繼續往下走
    }
    // --- ▲▲▲【修復代碼結束】▲▲▲ ---
    const chat = state.chats[state.activeChatId]; 
    
    // --- 【核心修改】在這裡添加 ---
    const msg = { 
        role: 'user', 
        content, 
        timestamp: Date.now() 
    };

    // 檢查當前是否處於引用回復模式
    if (currentReplyContext) {
        msg.quote = currentReplyContext; // 將引用資訊附加到消息物件上
    }
    // --- 【修改結束】 ---
    
    chat.history.push(msg); 
    await db.chats.put(chat); 
    appendMessage(msg, chat); 
    renderChatList(); 
    chatInput.value = ''; 
    chatInput.style.height = 'auto'; 
    chatInput.focus(); 
    
    // --- 【核心修改】發送後，取消引用模式 ---
    cancelReplyMode(); 
});
            document.getElementById('wait-reply-btn').addEventListener('click', triggerAiResponse);
            chatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); document.getElementById('send-btn').click(); } });
            chatInput.addEventListener('input', () => { chatInput.style.height = 'auto'; chatInput.style.height = (chatInput.scrollHeight) + 'px'; });

            document.getElementById('wallpaper-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if(file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); newWallpaperBase64 = dataUrl; renderWallpaperScreen(); } });
// ▼▼▼ 用這【一整塊】代碼，完整替換掉舊的 'save-wallpaper-btn' 事件監聽器 ▼▼▼
document.getElementById('save-wallpaper-btn').addEventListener('click', async () => {
    let changesMade = false;

    // 保存壁紙
    if (newWallpaperBase64) {
        state.globalSettings.wallpaper = newWallpaperBase64;
        changesMade = true;
    }

    // 保存鎖屏壁紙
    if (newLockscreenWallpaperBase64) {
        state.globalSettings.lockscreenWallpaper = newLockscreenWallpaperBase64;
        changesMade = true;
    }

    // 【新增】保存全域聊天背景
    if (newGlobalBgBase64 === 'REMOVED') { // 如果標記為已移除
        state.globalSettings.globalChatBackground = '';
        changesMade = true;
    } else if (newGlobalBgBase64) { // 如果有新上傳的
        state.globalSettings.globalChatBackground = newGlobalBgBase64;
        changesMade = true;
    }

    // 保存密碼
    const newPassword = document.getElementById('password-set-input').value;
    state.globalSettings.password = newPassword;

    state.globalSettings.ringtoneUrl = document.getElementById('ringtone-url-input').value.trim();
state.globalSettings.notificationSoundUrl = document.getElementById('notification-sound-url-input').value.trim();
    const activeThemeSelector = document.getElementById('theme-selector');
    if (activeThemeSelector.value) {
        state.globalSettings.activeThemeId = parseInt(activeThemeSelector.value);
    } else {
        state.globalSettings.activeThemeId = null;
    }
    
    const isLockEnabled = document.getElementById('enable-lock-screen-toggle').checked;
    state.globalSettings.enableLockScreen = isLockEnabled;
    localStorage.setItem('lockScreenEnabled', isLockEnabled);
// ▼▼▼ 在這裡黏貼下面這兩行新代碼 ▼▼▼
state.globalSettings.homeIconWidgetTextColor = document.getElementById('home-icon-widget-text-color-picker').value;
// 【全新】保存字體陰影設置
state.globalSettings.removeHomeFontShadow = document.getElementById('remove-home-font-shadow-toggle').checked;
// ▲▲▲ 新代碼黏貼結束 ▲▲▲
saveAppLabels();

    await db.globalSettings.put(state.globalSettings);

    // 應用所有更改
    if (changesMade) {
        applyGlobalWallpaper();        
        applyLockscreenWallpaper(); 
        newWallpaperBase64 = null;        
        newLockscreenWallpaperBase64 = null; 
        newGlobalBgBase64 = null; // 清理臨時變數
    }
    applyAppIcons(); 
applyAppLabels();
    alert('外觀設置已保存並應用！');
    showScreen('home-screen');
});
// ▲▲▲ 替換結束 ▲▲▲

            document.getElementById('save-api-settings-btn').addEventListener('click', async () => { 

    const proxyUrl = document.getElementById('proxy-url').value.trim();
    const apiKey = document.getElementById('api-key').value.trim();
    const isBlocked = BLOCKED_API_SITES.some(blockedDomain => proxyUrl.includes(blockedDomain));

if (isBlocked) {
    alert('錯誤：該 API 網站已被禁用，無法使用。');
    return; // 阻止保存
}
// ▲▲▲ 新代碼黏貼結束 ▲▲▲

state.apiConfig.proxyUrl = document.getElementById('proxy-url').value.trim(); 
state.apiConfig.apiKey = document.getElementById('api-key').value.trim(); 
state.apiConfig.model = document.getElementById('model-select').value; 
    // 【核心新增】保存 Minimax 設置
    state.apiConfig.minimaxGroupId = document.getElementById('minimax-group-id').value.trim();
    state.apiConfig.minimaxApiKey = document.getElementById('minimax-api-key').value.trim();
await db.apiConfig.put(state.apiConfig); 

// 在 'save-api-settings-btn' 的 click 事件監聽器內部
// await db.apiConfig.put(state.apiConfig); 這行之後

// ▼▼▼ 將之前那段保存後臺活動設置的邏輯，替換為下面這個增強版 ▼▼▼

const backgroundSwitch = document.getElementById('background-activity-switch');
const intervalInput = document.getElementById('background-interval-input');
const newEnableState = backgroundSwitch.checked;
const oldEnableState = state.globalSettings.enableBackgroundActivity || false;

// 只有在用戶“從關到開”時，才彈出警告
if (newEnableState && !oldEnableState) {
    const userConfirmed = confirm(
        "【高費用警告】\n\n" +
        "您正在啟用“後臺角色活動”功能。\n\n" +
        "這會使您的AI角色們在您不和他們聊天時，也能“獨立思考”並主動給您發消息或進行社交互動，極大地增強沉浸感。\n\n" +
        "但請注意：\n" +
        "這會【在後臺自動、定期地調用API】，即使您不進行任何操作。根據您的角色數量和檢測間隔，這可能會導致您的API費用顯著增加。\n\n" +
        "您確定要開啟嗎？"
    );

    if (!userConfirmed) {
        backgroundSwitch.checked = false; // 使用者取消，把開關撥回去
        return; // 阻止後續邏輯
    }
}

state.globalSettings.enableBackgroundActivity = newEnableState;
state.globalSettings.backgroundActivityInterval = parseInt(intervalInput.value) || 60;
state.globalSettings.blockCooldownHours = parseFloat(document.getElementById('block-cooldown-input').value) || 1;
await db.globalSettings.put(state.globalSettings);

// 動態啟動或停止模擬器
stopBackgroundSimulation();
if (state.globalSettings.enableBackgroundActivity) {
    startBackgroundSimulation();
    console.log(`後臺活動模擬已啟動，間隔: ${state.globalSettings.backgroundActivityInterval}秒`);
} else {
    console.log("後臺活動模擬已停止。");
}
// ▲▲▲ 替換結束 ▲▲▲

alert('API設置已保存!'); });

                    // gemini 金鑰聚焦的時候顯示明文
        const ApiKeyInput = document.getElementById('api-key')
        ApiKeyInput.addEventListener('focus', (e) => {
            e.target.setAttribute('type', 'text')
        })
        ApiKeyInput.addEventListener('blur', (e) => {
            e.target.setAttribute('type', 'password')
        })


        document.getElementById('fetch-models-btn').addEventListener('click', async () => {
            const url = document.getElementById('proxy-url').value.trim();
            const key = document.getElementById('api-key').value.trim();
            if (!url || !key) return alert('請先填寫反代地址和金鑰');
            try {

                let  isGemini = url === GEMINI_API_URL;
                const response = await fetch(isGemini ? `${GEMINI_API_URL}?key=${getRandomValue(key)}` : `${url}/v1/models`,isGemini ? undefined : {headers: {'Authorization': `Bearer ${key}`}});
                if (!response.ok) throw new Error('無法獲取模型清單');
                const data = await response.json();
                let models = isGemini ? data.models : data.data;
                if(isGemini){
                    models = models.map((model)=>{
                        const parts = model.name.split('/');
                        return {
                            id:parts.length > 1 ? parts[1] : model.name
                        }
                    })
                }
                const modelSelect = document.getElementById('model-select');
                modelSelect.innerHTML = '';
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model.id;
                    option.textContent = model.id;
                    if (model.id === state.apiConfig.model) option.selected = true;
                    modelSelect.appendChild(option);
                });
                alert('模型清單已更新');
            } catch (error) {
                alert(`拉取模型失敗: ${error.message}`);
            }
        });
        // ▼▼▼ 【全新】世界書導入功能事件綁定 ▼▼▼
document.getElementById('import-world-book-btn').addEventListener('click', () => {
    // 點擊“導入”按鈕時，觸發隱藏的檔選擇框
    document.getElementById('world-book-import-input').click();
});

document.getElementById('world-book-import-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        // 當用戶選擇了檔後，調用我們的核心處理函數
        handleImportSillyTavernWorldBook(file);
    }
    // 每次用完後清空，這樣用戶下次還能選擇同一個檔
    e.target.value = null; 
});
// ▲▲▲ 新增事件綁定結束 ▲▲▲

            document.getElementById('add-world-book-btn').addEventListener('click', async () => { const name = await showCustomPrompt('創建世界書', '請輸入書名'); if (name && name.trim()) { const newBook = { id: 'wb_' + Date.now(), name: name.trim(), content: '' }; await db.worldBooks.add(newBook); state.worldBooks.push(newBook); renderWorldBookScreen(); openWorldBookEditor(newBook.id); } });
            document.getElementById('save-world-book-btn').addEventListener('click', async () => { if (!editingWorldBookId) return; const book = state.worldBooks.find(wb => wb.id === editingWorldBookId); if (book) { const newName = document.getElementById('world-book-name-input').value.trim(); if (!newName) { alert('書名不能為空！'); return; } book.name = newName; book.content = document.getElementById('world-book-content-input').value; 

        // ▼▼▼ 【核心修改】在這裡保存分類ID ▼▼▼
        const categoryId = document.getElementById('world-book-category-select').value;
        // 如果選擇了“未分類”，存入 null；否則存入數字ID
        book.categoryId = categoryId ? parseInt(categoryId) : null; 
        // ▲▲▲ 修改結束 ▲▲▲

await db.worldBooks.put(book); document.getElementById('world-book-editor-title').textContent = newName; editingWorldBookId = null; renderWorldBookScreen(); showScreen('world-book-screen'); } });
// ▼▼▼ 第3步：用這整塊【全新的】代碼，完整替換舊的 'chat-messages' 點擊事件監聽器 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', async (e) => {
    
    const voiceBody = e.target.closest('.voice-message-body');
    if (voiceBody) {
        const bubble = voiceBody.closest('.message-bubble');
        if (!bubble) return;

        // 如果是使用者自己的語音，只切換文字顯示，不播放
        if (bubble.classList.contains('user')) {
            toggleVoiceTranscript(bubble);
            return;
        }

// ▼▼▼ 請用下面這段【已修復點擊收起功能】的代碼，完整替換你舊的AI語音點擊處理邏輯 ▼▼▼
        // 如果是AI的語音訊息
        const chat = state.chats[state.activeChatId];
        if (!chat) return;

        // --- 核心邏輯開始 ---

        // 1. 檢查是否點擊了正在播放的語音條
        if (isTtsPlaying && currentTtsAudioBubble === bubble) {
            // 如果是，則停止播放並收起所有關聯的文字
            stopMinimaxAudio(); 
        } 
        // 2. 檢查點擊的是否是已經展開了文字但沒有播放的語音條
        else if (bubble.dataset.state === 'expanded') {
            // 如果是，則只收起文字，不影響其他
            toggleVoiceTranscript(bubble);
        }
        // 3. 如果以上都不是，說明是想開始播放或只展開文字
        else {
            const clickedTimestamp = parseInt(bubble.dataset.timestamp);
            const startIndex = chat.history.findIndex(m => m.timestamp === clickedTimestamp);
            if (startIndex === -1) return;

            // 查找連續的語音訊息
            const messagesToPlay = findConsecutiveAiVoiceMessages(chat.history, startIndex);
            if (messagesToPlay.length > 0) {
                const bubblesToAnimate = messagesToPlay.map(m => document.querySelector(`.message-bubble[data-timestamp="${m.timestamp}"]`)).filter(Boolean);
                
                // 檢查配置，決定是播放還是只顯示文字
                const groupId = state.apiConfig.minimaxGroupId;
                const apiKey = state.apiConfig.minimaxApiKey;
                const voiceId = chat.settings.minimaxVoiceId;

                if (groupId && apiKey && voiceId) {
                    // 【播放分支】
                    // 先展開所有文字
                    bubblesToAnimate.forEach(b => {
                        if (b.dataset.state !== 'expanded') {
                            toggleVoiceTranscript(b);
                        }
                    });
                    // 然後調用播放機
                    const combinedText = messagesToPlay.map(m => m.content.trim()).join('，');
                    playMinimaxAudio(combinedText, voiceId, bubblesToAnimate);
                } else {
                    // 【只顯示文字分支】
                    // 只展開當前點擊的這一個語音條的文字
                    toggleVoiceTranscript(bubble);
                }
            }
        }
        
        return; // 處理完語音後退出
    }
// ▲▲▲ 替換結束 ▲▲▲




    // --- 你原來的其他點擊事件邏輯 ---
    const aiImage = e.target.closest('.ai-generated-image');
    if (aiImage) {
        const description = aiImage.dataset.description;
        if (description) showCustomAlert('照片描述', description);
        return;
    }
    const linkCard = e.target.closest('.link-share-card');
    if (linkCard && linkCard.closest('.message-bubble.is-link-share')) {
        const timestamp = parseInt(linkCard.dataset.timestamp);
        if (!isNaN(timestamp)) {
            openBrowser(timestamp);
        }
    }
    const packetCard = e.target.closest('.red-packet-card');
    if (packetCard) {
        const messageBubble = packetCard.closest('.message-bubble');
        if (messageBubble && messageBubble.dataset.timestamp) {
            const timestamp = parseInt(messageBubble.dataset.timestamp);
            handlePacketClick(timestamp);
        }
    }
    const pollCard = e.target.closest('.poll-card');
    if (pollCard) {
        const timestamp = parseInt(pollCard.dataset.pollTimestamp);
        if (isNaN(timestamp)) return;
        const optionItem = e.target.closest('.poll-option-item');
        if (optionItem && !pollCard.classList.contains('closed')) {
            handleUserVote(timestamp, optionItem.dataset.option);
            return;
        }
        const actionBtn = e.target.closest('.poll-action-btn');
        if (actionBtn) {
            if (pollCard.classList.contains('closed')) {
                showPollResults(timestamp);
            } else {
                endPoll(timestamp);
            }
            return;
        }
        if (pollCard.classList.contains('closed')) {
            showPollResults(timestamp);
        }
    }
    const card = e.target.closest('.waimai-card');
    if (card) {
        const messageBubble = card.closest('.message-bubble');
        const invitationMsg = state.chats[state.activeChatId].history.find(m => m.timestamp === parseInt(messageBubble.dataset.timestamp));
        if (invitationMsg && invitationMsg.type === 'lovers_space_invitation' && invitationMsg.status === 'pending') {
            const choice = e.target.dataset.choice;
            if (choice) {
                handleLoversSpaceResponse(invitationMsg.timestamp, choice);
            }
        }
    }
    const repostCard = e.target.closest('.link-share-card[data-post-id]');
    if (repostCard) {
        const postId = parseInt(repostCard.dataset.postId);
        if (!isNaN(postId)) {
            openPost(postId);
        }
    }
    
    // 【新增】處理分享卡片的點擊
    const shareCard = e.target.closest('.link-share-card[data-timestamp]');
    if (shareCard && shareCard.closest('.message-bubble.is-link-share')) {
        const timestamp = parseInt(shareCard.dataset.timestamp);
        if(!isNaN(timestamp)) {
            const msg = state.chats[state.activeChatId].history.find(m=>m.timestamp===timestamp);
            if(msg && msg.type === 'share_card') openSharedHistoryViewer(timestamp);
            else if(msg && msg.type === 'share_link') openBrowser(timestamp);
        }
    }
    
    // 【新增】處理已撤回消息的點擊
    const placeholder = e.target.closest('.recalled-message-placeholder');
    if (placeholder) {
        const wrapper = placeholder.closest('.message-wrapper');
        const chat = state.chats[state.activeChatId];
        if (chat && wrapper) {
            const timestamp = parseInt(wrapper.dataset.timestamp);
            const recalledMsg = chat.history.find(m => m.timestamp === timestamp);
            if (recalledMsg && recalledMsg.recalledData) {
                let originalContentText = '';
                const recalled = recalledMsg.recalledData;
                if (recalled.originalType === 'text') {
                    originalContentText = `原文: "${recalled.originalContent}"`;
                } else {
                    originalContentText = `撤回了一條[${recalled.originalType}]類型的消息`;
                }
                showCustomAlert('已撤回的消息', originalContentText);
            }
        }
    }
});
// ▲▲▲ 替換結束 ▲▲▲
            const chatSettingsModal = document.getElementById('chat-settings-modal');
            const worldBookSelectBox = document.querySelector('.custom-multiselect .select-box');
            const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');

function updateWorldBookSelectionDisplay() { const checkedBoxes = worldBookCheckboxesContainer.querySelectorAll('input:checked'); const displayText = document.querySelector('.selected-options-text'); if (checkedBoxes.length === 0) { displayText.textContent = '-- 點擊選擇 --'; } else if (checkedBoxes.length > 2) { displayText.textContent = `已選擇 ${checkedBoxes.length} 項`; } else { displayText.textContent = Array.from(checkedBoxes).map(cb => cb.parentElement.textContent.trim()).join(', '); } }        
            
            worldBookSelectBox.addEventListener('click', (e) => { e.stopPropagation(); worldBookCheckboxesContainer.classList.toggle('visible'); worldBookSelectBox.classList.toggle('expanded'); });
            document.getElementById('world-book-checkboxes-container').addEventListener('change', updateWorldBookSelectionDisplay);
            window.addEventListener('click', (e) => { if (!document.querySelector('.custom-multiselect').contains(e.target)) { worldBookCheckboxesContainer.classList.remove('visible'); worldBookSelectBox.classList.remove('expanded'); } });

// ▼▼▼ 請用這段【完整、全新的代碼】替換舊的 chat-settings-btn 點擊事件 ▼▼▼
document.getElementById('chat-settings-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const isGroup = chat.isGroup;
// ▼▼▼ 在 const chat = ... 的下一行，黏貼這段新代碼 ▼▼▼
// 計算總消息條數並更新顯示
const totalMessages = chat.history.length;
const countDisplay = document.getElementById('total-message-count-display');
if (countDisplay) {
    countDisplay.textContent = `${totalMessages} 條`;
}
// ▲▲▲ 新代碼黏貼結束 ▲▲▲

    // --- 統一顯示/隱藏控制項 ---
    // ▼▼▼ 在 chat-settings-btn 的 click 事件中，黏貼這段代碼 ▼▼▼
const videoCallSettingsGroup = document.getElementById('video-call-settings-group');
const visualCallSwitch = document.getElementById('visual-video-call-switch');
const imageUploadsDiv = document.getElementById('video-call-image-uploads');
// --- 載入聊天總結設置 ---
const summarySettings = chat.settings.summary || {};
const summaryToggle = document.getElementById('summary-toggle');
const summaryDetails = document.getElementById('summary-details-container');

summaryToggle.checked = summarySettings.enabled || false;
summaryDetails.style.display = summaryToggle.checked ? 'block' : 'none';

document.querySelector(`input[name="summary-mode"][value="${summarySettings.mode || 'auto'}"]`).checked = true;
document.getElementById('summary-count-input').value = summarySettings.count || 20;
document.getElementById('summary-prompt-input').value = summarySettings.prompt || '請你以第三人稱的視角，客觀、冷靜、不帶任何感情色彩地總結以下對話的核心事件和資訊。禁止進行任何角色扮演或添加主觀評論。';

// 為開關添加即時交互
summaryToggle.onchange = () => {
    summaryDetails.style.display = summaryToggle.checked ? 'block' : 'none';
};
// ▲▲▲ 新代碼黏貼結束 ▲▲▲
if (isGroup) {
    videoCallSettingsGroup.style.display = 'none'; // 群聊不支持，隱藏整個設置區
} else {
    videoCallSettingsGroup.style.display = 'block'; // 單聊顯示
    
    // 載入當前設置
    visualCallSwitch.checked = chat.settings.visualVideoCallEnabled || false;
    imageUploadsDiv.style.display = visualCallSwitch.checked ? 'block' : 'none';
    document.getElementById('char-video-image-preview').src = chat.settings.charVideoImage || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
    document.getElementById('user-video-image-preview').src = chat.settings.userVideoImage || 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';

    // 為開關添加即時交互
    visualCallSwitch.onchange = () => {
        imageUploadsDiv.style.display = visualCallSwitch.checked ? 'block' : 'none';
    };
}
// ▲▲▲ 黏貼結束 ▲▲▲
    
    // --- 線下模式UI渲染 ---
    const offlineModeSettings = chat.settings.offlineMode || { enabled: false, presets: [] }; // 安全獲取
    const offlineToggle = document.getElementById('offline-mode-toggle');
    const offlineDetails = document.getElementById('offline-mode-details');

    // 1. 設置開關狀態並綁定事件
    offlineToggle.checked = offlineModeSettings.enabled;
    offlineDetails.style.display = offlineToggle.checked ? 'block' : 'none';
    offlineToggle.onchange = () => {
        offlineDetails.style.display = offlineToggle.checked ? 'block' : 'none';
    };

    // 2. 填充輸入框
    document.getElementById('offline-prompt-input').value = offlineModeSettings.prompt || '';
    document.getElementById('offline-style-input').value = offlineModeSettings.style || '';
    document.getElementById('offline-word-count-input').value = offlineModeSettings.wordCount || 300;

    // 3. 渲染預設下拉清單
    renderOfflinePresetsSelector();

    // ▲▲▲ 新代碼黏貼結束 ▲▲▲

// ▼▼▼ 【全新】為氣泡導入/匯出按鈕綁定事件 ▼▼▼
document.getElementById('export-bubble-preset-btn').addEventListener('click', exportSelectedBubblePreset);

document.getElementById('import-bubble-preset-btn').addEventListener('click', () => {
    // 點擊“導入”按鈕時，觸發隱藏的檔選擇框
    document.getElementById('import-bubble-preset-input').click();
});

document.getElementById('import-bubble-preset-input').addEventListener('change', (e) => {
    // 當用戶選擇了檔後，調用導入函數處理
    importBubblePreset(e.target.files[0]);
    e.target.value = null; // 每次用完後清空，方便下次選擇同一個檔
});
// ▲▲▲ 新事件綁定結束 ▲▲▲

// --- 全新視頻通話功能事件綁定 (V2 修正版) ---

// 綁定新介面的掛斷按鈕
document.getElementById('hang-up-btn-visual').addEventListener('click', endVideoCall);

// 【新增】綁定新介面的發言按鈕
document.getElementById('user-speak-btn-visual').addEventListener('click', async () => {
    if (!videoCallState.isActive) return;
    const userInput = await showCustomPrompt('你說', '請輸入你想說的話...');
    if (userInput && userInput.trim()) {
        triggerAiInCallAction(userInput.trim());
    }
});

// 綁定切換鏡頭按鈕 (也是小窗本身)
document.getElementById('switch-camera-btn').addEventListener('click', switchVideoViews);
document.getElementById('video-pip-view').addEventListener('click', switchVideoViews);

// 【修正】綁定兩個介面的重roll按鈕
document.getElementById('reroll-call-btn').addEventListener('click', handleVideoCallReroll);
document.getElementById('reroll-call-btn-text').addEventListener('click', handleVideoCallReroll);

// ▲▲▲ 替換結束 ▲▲▲



    document.getElementById('chat-name-group').style.display = 'block';
    document.getElementById('minimax-voice-id-group').style.display = isGroup ? 'none' : 'block';
    document.getElementById('my-persona-group').style.display = 'block';
    document.getElementById('my-avatar-group').style.display = 'block';
    document.getElementById('my-group-nickname-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('group-avatar-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('group-members-group').style.display = isGroup ? 'block' : 'none';
    document.getElementById('ai-persona-group').style.display = isGroup ? 'none' : 'block';
    document.getElementById('ai-avatar-group').style.display = isGroup ? 'none' : 'block';
        // ▼▼▼ 在這裡黏貼新代碼 ▼▼▼
    document.getElementById('npc-library-group').style.display = isGroup ? 'none' : 'block';
    // ▲▲▲ 黏貼結束 ▲▲▲
            // ▼▼▼ 第2步 第1處修改（新增代碼） ▼▼▼
        // 【修改】根據是否為單聊或群聊，顯示表情管理按鈕
        const charStickerGroup = document.getElementById('char-sticker-group');
        if (charStickerGroup) {
            // 現在無論是單聊還是群聊，這個按鈕都會顯示
            charStickerGroup.style.display = 'block';
        }

// 【核心新增】根據是否為群聊，顯示或隱藏微博設置
document.getElementById('weibo-profession-group').style.display = isGroup ? 'none' : 'block';
document.getElementById('weibo-instruction-group').style.display = isGroup ? 'none' : 'block';
    // 【核心修改1】根據是否為群聊，顯示或隱藏“好友分組”區域
    document.getElementById('assign-group-section').style.display = isGroup ? 'none' : 'block';
    
    // --- 載入表單數據 ---
    document.getElementById('chat-name-input').value = chat.name;
    document.getElementById('my-persona').value = chat.settings.myPersona;
    document.getElementById('my-avatar-preview').src = chat.settings.myAvatar || (isGroup ? defaultMyGroupAvatar : defaultAvatar);
    document.getElementById('max-memory').value = chat.settings.maxMemory;
// ▼▼▼ 【全新】記憶互通功能 - UI渲染邏輯 (V2 - 帶頭像版) ▼▼▼
const memoryLinkSelectBox = document.querySelector('#memory-link-multiselect .select-box');
const memoryLinkCheckboxesContainer = document.getElementById('memory-link-checkboxes-container');
memoryLinkCheckboxesContainer.innerHTML = ''; // 清空舊選項

// 1. 獲取除了當前聊天以外的所有聊天
const otherChats = Object.values(state.chats).filter(c => c.id !== chat.id);

// 2. 動態創建帶頭像的核取方塊
otherChats.forEach(otherChat => {
    const existingLink = chat.settings.linkedMemories.find(link => link.chatId === otherChat.id);
    const isChecked = existingLink ? 'checked' : '';
    
    // 【核心修改1】根據是群聊還是單聊，獲取正確的頭像URL
    const avatarUrl = otherChat.isGroup 
        ? (otherChat.settings.groupAvatar || defaultGroupAvatar) 
        : (otherChat.settings.aiAvatar || defaultAvatar);

    const label = document.createElement('label');
    
    // 【核心修改2】構建包含 <img> 標籤的新HTML結構
    label.innerHTML = `
        <input type="checkbox" value="${otherChat.id}" ${isChecked}>
        <img src="${avatarUrl}" class="avatar-preview">
        <span>${otherChat.name} ${otherChat.isGroup ? '(群聊)' : ''}</span>
    `;
    memoryLinkCheckboxesContainer.appendChild(label);
});


// 3. 更新已選數量的顯示和記憶條數
function updateMemoryLinkDisplay() {
    const checkedBoxes = memoryLinkCheckboxesContainer.querySelectorAll('input:checked');
    const displayText = memoryLinkSelectBox.querySelector('.selected-options-text');
    if (checkedBoxes.length === 0) {
        displayText.textContent = '-- 點擊選擇 --';
    } else {
        displayText.textContent = `已連結 ${checkedBoxes.length} 個聊天`;
    }
}

    // 4. 載入記憶條數設置
    // 我們現在從一個獨立的設置項載入，確保它總能被正確讀取
    document.getElementById('link-memory-depth-input').value = chat.settings.linkMemoryDepth || 5;


// 5. 綁定事件
updateMemoryLinkDisplay(); // 初始化顯示
memoryLinkCheckboxesContainer.addEventListener('change', updateMemoryLinkDisplay);
// 使用克隆節點技巧來防止事件重複綁定
const newSelectBox = memoryLinkSelectBox.cloneNode(true);
memoryLinkSelectBox.parentNode.replaceChild(newSelectBox, memoryLinkSelectBox);
newSelectBox.addEventListener('click', (e) => {
    e.stopPropagation();
    memoryLinkCheckboxesContainer.classList.toggle('visible');
    newSelectBox.classList.toggle('expanded');
});
// ▲▲▲ 記憶互通UI邏輯結束 ▲▲▲

    // ▼▼▼ 在 max-memory 賦值的下一行，黏貼這一整塊代碼 ▼▼▼
const timeToggle = document.getElementById('time-perception-toggle');
const customTimeContainer = document.getElementById('custom-time-container');
const customTimeInput = document.getElementById('custom-time-input');

// 如果是舊聊天，給一個預設值 true（開啟）
const isTimeEnabled = chat.settings.timePerceptionEnabled ?? true; 
timeToggle.checked = isTimeEnabled;
customTimeInput.value = chat.settings.customTime || '';

// 根據開關狀態，決定是否顯示自訂時間輸入框
customTimeContainer.style.display = isTimeEnabled ? 'none' : 'block';
// ▲▲▲ 黏貼結束 ▲▲▲

    const bgPreview = document.getElementById('bg-preview');
    const removeBgBtn = document.getElementById('remove-bg-btn');
    if (chat.settings.background) {
        bgPreview.src = chat.settings.background;
        bgPreview.style.display = 'block';
        removeBgBtn.style.display = 'inline-block';
    } else {
        bgPreview.style.display = 'none';
        removeBgBtn.style.display = 'none';
    }

    if (isGroup) {
        document.getElementById('my-group-nickname-input').value = chat.settings.myNickname || '';
        document.getElementById('group-avatar-preview').src = chat.settings.groupAvatar || defaultGroupAvatar;
        renderGroupMemberSettings(chat.members);
        // 載入群聊後臺活動設置
const groupActivityGroup = document.getElementById('group-background-activity-group');
const groupActivitySwitch = document.getElementById('group-background-activity-switch');
const groupIntervalSettings = document.getElementById('group-background-interval-settings');
const groupIntervalInput = document.getElementById('group-background-interval-input');

groupActivityGroup.style.display = 'block'; // 顯示設定區域
const bgSettings = chat.settings.backgroundActivity || { enabled: false, interval: 120 };
groupActivitySwitch.checked = bgSettings.enabled;
groupIntervalInput.value = bgSettings.interval;
groupIntervalSettings.style.display = bgSettings.enabled ? 'block' : 'none';

// 為開關添加即時交互
groupActivitySwitch.onchange = () => {
    groupIntervalSettings.style.display = groupActivitySwitch.checked ? 'block' : 'none';
};
    } else {
        document.getElementById('ai-persona').value = chat.settings.aiPersona;
        // 【核心修復】載入當前角色的微博職業和指令
document.getElementById('weibo-profession-input').value = chat.settings.weiboProfession || '';
document.getElementById('weibo-instruction-input').value = chat.settings.weiboInstruction || '';
        document.getElementById('ai-avatar-preview').src = chat.settings.aiAvatar || defaultAvatar;
        document.getElementById('minimax-voice-id-input').value = chat.settings.minimaxVoiceId || '';
        // ▼▼▼ Part C.1: 在這裡黏貼【載入】情侶頭像設置的代碼 ▼▼▼
const coupleAvatarToggle = document.getElementById('couple-avatar-toggle');
const coupleAvatarDescContainer = document.getElementById('couple-avatar-desc-container');
const coupleAvatarDescInput = document.getElementById('couple-avatar-description');

coupleAvatarToggle.checked = chat.settings.isCoupleAvatar || false;
coupleAvatarDescInput.value = chat.settings.coupleAvatarDescription || '';

coupleAvatarDescContainer.style.display = coupleAvatarToggle.checked ? 'block' : 'none';

coupleAvatarToggle.onchange = () => {
    coupleAvatarDescContainer.style.display = coupleAvatarToggle.checked ? 'block' : 'none';
};
// ▲▲▲ 載入邏輯結束 ▲▲▲
        document.getElementById('group-background-activity-group').style.display = 'none';
        // 【核心修改2】如果是單聊，就載入分組列表到下拉清單
        const select = document.getElementById('assign-group-select');
        select.innerHTML = '<option value="">未分組</option>'; // 清空並設置預設選項
        const groups = await db.qzoneGroups.toArray();
        groups.forEach(group => {
            const option = document.createElement('option');
            option.value = group.id;
            option.textContent = group.name;
            // 如果當前好友已經有分組，就默認選中它
            if (chat.groupId === group.id) {
                option.selected = true;
            }
            select.appendChild(option);
        }); 
    }
    
// ▼▼▼ 用下面這段【全新邏輯】替換掉原來簡單的 forEach 迴圈 ▼▼▼

const worldBookCheckboxesContainer = document.getElementById('world-book-checkboxes-container');
worldBookCheckboxesContainer.innerHTML = '';
const linkedIds = new Set(chat.settings.linkedWorldBookIds || []);

// 1. 獲取所有分類和世界書
const categories = await db.worldBookCategories.toArray();
const books = state.worldBooks;

// 【核心改造】如果存在未分類的書籍，就創建一個“虛擬分類”
const hasUncategorized = books.some(book => !book.categoryId);
if (hasUncategorized) {
    categories.push({ id: 'uncategorized', name: '未分類' });
}

// 2. 將書籍按分類ID進行分組
const booksByCategoryId = books.reduce((acc, book) => {
    const categoryId = book.categoryId || 'uncategorized';
    if (!acc[categoryId]) {
        acc[categoryId] = [];
    }
    acc[categoryId].push(book);
    return acc;
}, {});

// 3. 遍歷分類，創建帶折疊功能的列表
categories.forEach(category => {
    const booksInCategory = booksByCategoryId[category.id] || [];
    if (booksInCategory.length > 0) {
        const allInCategoryChecked = booksInCategory.every(book => linkedIds.has(book.id));
        
        const header = document.createElement('div');
        header.className = 'wb-category-header';
        header.innerHTML = `
            <span class="arrow">▼</span>
            <input type="checkbox" class="wb-category-checkbox" data-category-id="${category.id}" ${allInCategoryChecked ? 'checked' : ''}>
            <span>${category.name}</span>
        `;
        
        const bookContainer = document.createElement('div');
        bookContainer.className = 'wb-book-container';
        bookContainer.dataset.containerFor = category.id;

        booksInCategory.forEach(book => {
            const isChecked = linkedIds.has(book.id);
            const label = document.createElement('label');
            // 【核心修復】給書名包一個span，方便CSS做省略號處理
            label.innerHTML = `<input type="checkbox" class="wb-book-checkbox" value="${book.id}" data-parent-category="${category.id}" ${isChecked ? 'checked' : ''}> <span class="wb-book-name">${book.name}</span>`;
            bookContainer.appendChild(label);
        });

        // 預設將所有資料夾設置為折疊狀態，保持介面整潔
        header.classList.add('collapsed');
        bookContainer.classList.add('collapsed');

        worldBookCheckboxesContainer.appendChild(header);
        worldBookCheckboxesContainer.appendChild(bookContainer);
    }
});

updateWorldBookSelectionDisplay(); // 更新頂部的已選數量顯示

// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 在 updateWorldBookSelectionDisplay(); 的下一行，黏貼這整塊新代碼 ▼▼▼


    // 載入並更新所有預覽相關控制項
    const themeRadio = document.querySelector(`input[name="theme-select"][value="${chat.settings.theme || 'default'}"]`);
    if (themeRadio) themeRadio.checked = true;
    const fontSizeSlider = document.getElementById('font-size-slider');
    fontSizeSlider.value = chat.settings.fontSize || 13;
    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
    const customCssInput = document.getElementById('custom-css-input');
    customCssInput.value = chat.settings.customCss || '';
    
    updateSettingsPreview(); 

// 【這三行就是我們新加的，現在已經放在正確的位置了】
renderBubblePresetSelector();
document.getElementById('bubble-style-preset-select').addEventListener('change', handlePresetSelectChange);
document.getElementById('manage-bubble-presets-btn').addEventListener('click', openBubblePresetManager);
    document.getElementById('chat-settings-modal').classList.add('visible');
});
// ▲▲▲ 替換結束 ▲▲▲
            
function renderGroupMemberSettings(members) { 
    const container = document.getElementById('group-members-settings'); 
    container.innerHTML = ''; 
    members.forEach(member => { 
        const div = document.createElement('div'); 
        div.className = 'member-editor'; 
        div.dataset.memberId = member.id; 
        // ★★★【核心重構】★★★
        // 顯示的是 groupNickname
        div.innerHTML = `<img src="${member.avatar}" alt="${member.groupNickname}"><div class="member-name">${member.groupNickname}</div>`; 
        div.addEventListener('click', () => openMemberEditor(member.id)); 
        container.appendChild(div); 
    }); 
}

function openMemberEditor(memberId) { 
    editingMemberId = memberId; 
    const chat = state.chats[state.activeChatId]; 
    const member = chat.members.find(m => m.id === memberId); 
    document.getElementById('member-name-input').value = member.groupNickname; 
    document.getElementById('member-persona-input').value = member.persona; 
    document.getElementById('member-avatar-preview').src = member.avatar; 
    document.getElementById('member-settings-modal').classList.add('visible'); 
}
            document.getElementById('cancel-member-settings-btn').addEventListener('click', () => { document.getElementById('member-settings-modal').classList.remove('visible'); editingMemberId = null; });
            document.getElementById('save-member-settings-btn').addEventListener('click', () => { 
    if (!editingMemberId) return; 
    const chat = state.chats[state.activeChatId]; 
    const member = chat.members.find(m => m.id === editingMemberId); 
    
    // ★★★【核心重構】★★★
    const newNickname = document.getElementById('member-name-input').value.trim();
    if (!newNickname) {
        alert("群昵稱不能為空！");
        return;
    }
    member.groupNickname = newNickname; // 只修改群昵稱
    member.persona = document.getElementById('member-persona-input').value; 
    member.avatar = document.getElementById('member-avatar-preview').src; 
    
    renderGroupMemberSettings(chat.members); 
    document.getElementById('member-settings-modal').classList.remove('visible'); 
});
            document.getElementById('reset-theme-btn').addEventListener('click', () => { document.getElementById('theme-default').checked = true; });
            document.getElementById('cancel-chat-settings-btn').addEventListener('click', () => { chatSettingsModal.classList.remove('visible'); });

document.getElementById('save-chat-settings-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    const newName = document.getElementById('chat-name-input').value.trim();
    if (!newName) return alert('備註名/群名不能為空！');
    chat.name = newName;
    // ▼▼▼ 【全新】記憶互通功能 - 保存邏輯 ▼▼▼
    const linkedMemoryCheckboxes = document.querySelectorAll('#memory-link-checkboxes-container input:checked');
    const memoryDepth = parseInt(document.getElementById('link-memory-depth-input').value) || 5;

    // ▼▼▼ 在這裡新增下面這一行 ▼▼▼
    chat.settings.linkMemoryDepth = memoryDepth; // 獨立保存記憶條數設置
    // ▲▲▲ 新增結束 ▲▲▲

    chat.settings.linkedMemories = Array.from(linkedMemoryCheckboxes).map(checkbox => ({
        chatId: checkbox.value,
        depth: memoryDepth // 對所有選中的連結應用相同的深度
    }));
    // ▲▲▲ 保存邏輯結束 ▲▲▲


    const selectedThemeRadio = document.querySelector('input[name="theme-select"]:checked');
    chat.settings.theme = selectedThemeRadio ? selectedThemeRadio.value : 'default';

    chat.settings.fontSize = parseInt(document.getElementById('font-size-slider').value);
    chat.settings.customCss = document.getElementById('custom-css-input').value.trim();

    chat.settings.myPersona = document.getElementById('my-persona').value;
    chat.settings.myAvatar = document.getElementById('my-avatar-preview').src;
const checkedBooks = document.querySelectorAll('#world-book-checkboxes-container input.wb-book-checkbox:checked');
    chat.settings.linkedWorldBookIds = Array.from(checkedBooks).map(cb => cb.value);

    if (chat.isGroup) {
        chat.settings.myNickname = document.getElementById('my-group-nickname-input').value.trim();
        chat.settings.groupAvatar = document.getElementById('group-avatar-preview').src;
        // 保存群聊後臺活動設置
const groupActivityEnabled = document.getElementById('group-background-activity-switch').checked;
const groupActivityInterval = parseInt(document.getElementById('group-background-interval-input').value) || 120;

// 確保 lastActivityTimestamp 欄位存在
const lastTimestamp = chat.settings.backgroundActivity ? chat.settings.backgroundActivity.lastActivityTimestamp : 0;

chat.settings.backgroundActivity = {
    enabled: groupActivityEnabled,
    interval: groupActivityInterval,
    lastActivityTimestamp: lastTimestamp // 保留上次的時間戳記
};

    } else {
        chat.settings.aiPersona = document.getElementById('ai-persona').value;
        chat.settings.aiAvatar = document.getElementById('ai-avatar-preview').src;
        chat.settings.minimaxVoiceId = document.getElementById('minimax-voice-id-input').value.trim();
        // ▼▼▼ Part C.2: 在這裡黏貼【保存】情侶頭像設置的代碼 ▼▼▼
chat.settings.isCoupleAvatar = document.getElementById('couple-avatar-toggle').checked;
chat.settings.coupleAvatarDescription = document.getElementById('couple-avatar-description').value.trim();
// ▲▲▲ 保存邏輯結束 ▲▲▲
        // ▼▼▼ 在 save-chat-settings-btn 的 click 事件的 else 塊內，黏貼這段代碼 ▼▼▼
        // 【核心新增】從輸入框讀取值並保存
    chat.settings.weiboProfession = document.getElementById('weibo-profession-input').value.trim();
    chat.settings.weiboInstruction = document.getElementById('weibo-instruction-input').value.trim();
// 保存視頻通話設置
chat.settings.visualVideoCallEnabled = document.getElementById('visual-video-call-switch').checked;
chat.settings.charVideoImage = document.getElementById('char-video-image-preview').src;
chat.settings.userVideoImage = document.getElementById('user-video-image-preview').src;
// ▲▲▲ 黏貼結束 ▲▲▲
        const selectedGroupId = document.getElementById('assign-group-select').value;
        chat.groupId = selectedGroupId ? parseInt(selectedGroupId) : null;
    }

    chat.settings.maxMemory = parseInt(document.getElementById('max-memory').value) || 10;
    // ▼▼▼ 在 chat.settings.maxMemory = ... 的下一行添加 ▼▼▼
chat.settings.timePerceptionEnabled = document.getElementById('time-perception-toggle').checked;
chat.settings.customTime = document.getElementById('custom-time-input').value;
// ▲▲▲ 添加結束 ▲▲▲
    // --- 保存線下模式設置 ---
    if (!chat.settings.offlineMode) chat.settings.offlineMode = {}; // 初始化
    chat.settings.offlineMode.enabled = document.getElementById('offline-mode-toggle').checked;
    chat.settings.offlineMode.prompt = document.getElementById('offline-prompt-input').value.trim();
    chat.settings.offlineMode.style = document.getElementById('offline-style-input').value.trim();
    chat.settings.offlineMode.wordCount = parseInt(document.getElementById('offline-word-count-input').value) || 300;
    // presets 的資料在管理函數中直接操作，這裡無需保存
// ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼
// --- 保存聊天總結設置 ---
if (!chat.settings.summary) chat.settings.summary = {}; // 初始化
chat.settings.summary.enabled = document.getElementById('summary-toggle').checked;
chat.settings.summary.mode = document.querySelector('input[name="summary-mode"]:checked').value;
chat.settings.summary.count = parseInt(document.getElementById('summary-count-input').value) || 20;
chat.settings.summary.prompt = document.getElementById('summary-prompt-input').value.trim();
// ▲▲▲ 新代碼黏貼結束 ▲▲▲
    await db.chats.put(chat);

    applyScopedCss(chat.settings.customCss, '#chat-messages', 'custom-bubble-style');
    
    chatSettingsModal.classList.remove('visible');
    renderChatInterface(state.activeChatId);
    renderChatList();
});
            document.getElementById('clear-chat-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const chat = state.chats[state.activeChatId]; const confirmed = await showCustomConfirm('清空聊天記錄', '此操作將永久刪除此聊天的所有消息，無法恢復。確定要清空嗎？', { confirmButtonClass: 'btn-danger' }); if (confirmed) { chat.history = []; await db.chats.put(chat); renderChatInterface(state.activeChatId); renderChatList(); chatSettingsModal.classList.remove('visible'); } });
            // ▼▼▼ 在 init() 的事件監聽器區域末尾，黏貼這段新代碼 ▼▼▼

// 匯出聊天記錄按鈕
document.getElementById('export-chat-history-btn').addEventListener('click', exportChatHistory);

// “導入聊天記錄”這個可見的按鈕
document.getElementById('import-chat-history-btn').addEventListener('click', () => {
    // 點擊它時，我們去觸發那個隱藏的檔選擇框
    document.getElementById('import-chat-history-input').click();
});

// 隱藏的檔選擇框
document.getElementById('import-chat-history-input').addEventListener('change', (event) => {
    const file = event.target.files[0];
    if (file) {
        importChatHistory(file);
    }
    // 每次選擇後清空，這樣下次還能選擇同一個檔
    event.target.value = null; 
});

// ▲▲▲ 新代碼黏貼結束 ▲▲▲

            const setupFileUpload = (inputId, callback) => { document.getElementById(inputId).addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise((res, rej) => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.onerror = () => rej(reader.error); reader.readAsDataURL(file); }); callback(dataUrl); event.target.value = null; } }); };
            setupFileUpload('ai-avatar-input', (base64) => document.getElementById('ai-avatar-preview').src = base64);
            setupFileUpload('my-avatar-input', (base64) => document.getElementById('my-avatar-preview').src = base64);
            setupFileUpload('group-avatar-input', (base64) => document.getElementById('group-avatar-preview').src = base64);
            setupFileUpload('member-avatar-input', (base64) => document.getElementById('member-avatar-preview').src = base64);
            setupFileUpload('bg-input', (base64) => { if(state.activeChatId) { state.chats[state.activeChatId].settings.background = base64; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = base64; bgPreview.style.display = 'block'; document.getElementById('remove-bg-btn').style.display = 'inline-block'; } });
            setupFileUpload('preset-avatar-input', (base64) => document.getElementById('preset-avatar-preview').src = base64);
            // ▼▼▼ 在 init() 函數的事件監聽器區域，添加這兩行 ▼▼▼
setupFileUpload('char-video-image-input', (base64) => document.getElementById('char-video-image-preview').src = base64);
setupFileUpload('user-video-image-input', (base64) => document.getElementById('user-video-image-preview').src = base64);
// ▲▲▲ 添加結束 ▲▲▲
            document.getElementById('remove-bg-btn').addEventListener('click', () => { if (state.activeChatId) { state.chats[state.activeChatId].settings.background = ''; const bgPreview = document.getElementById('bg-preview'); bgPreview.src = ''; bgPreview.style.display = 'none'; document.getElementById('remove-bg-btn').style.display = 'none'; } });

            const stickerPanel = document.getElementById('sticker-panel');
            document.getElementById('open-sticker-panel-btn').addEventListener('click', () => { renderStickerPanel(); stickerPanel.classList.add('visible'); });
            document.getElementById('close-sticker-panel-btn').addEventListener('click', () => stickerPanel.classList.remove('visible'));
            // ▼▼▼ 將原來的 add-sticker-btn 事件監聽器替換為下面這行 ▼▼▼
document.getElementById('add-sticker-btn').addEventListener('click', openBulkAddStickersModal);
// ▲▲▲ 替換結束 ▲▲▲
            document.getElementById('upload-sticker-btn').addEventListener('click', () => document.getElementById('sticker-upload-input').click());

            // ▼▼▼ 用下面這段【支持多選】的代碼，替換舊的 sticker-upload-input 事件監聽器 ▼▼▼
document.getElementById('sticker-upload-input').addEventListener('change', async (event) => {
    const files = event.target.files;
    if (!files.length) return;

    const newStickers = [];
    let canceled = false;

    // 使用 for...of 迴圈來逐個處理選中的文件
    for (const file of files) {
        if (canceled) break; // 如果用戶中途取消了，就跳出迴圈

        // 為每個檔生成一個臨時的本地預覽URL
        const previewUrl = URL.createObjectURL(file);
        
        // 彈出帶圖片預覽的命名框
        const name = await showCustomPrompt(
            `為表情命名 (${newStickers.length + 1}/${files.length})`,
            "請輸入表情名稱",
            file.name.replace(/\.[^/.]+$/, ""), // 默認使用檔案名作為名字
            'text',
            // 這是 showCustomPrompt 的一個隱藏功能，可以插入額外的HTML
            `<img src="${previewUrl}" style="max-width: 100px; max-height: 100px; margin-bottom: 10px; border-radius: 8px;">`
        );
        
        // 釋放臨時的預覽URL，避免記憶體洩漏
        URL.revokeObjectURL(previewUrl);
        
        if (name && name.trim()) {
            // 使用者確認命名，讀取檔內容並準備保存
            const base64Url = await new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.readAsDataURL(file);
            });
            
            newStickers.push({
                id: 'sticker_' + (Date.now() + newStickers.length),
                url: base64Url,
                name: name.trim()
            });
        } else if (name === null) {
            // 如果用戶點擊了“取消”
            const confirmCancel = await showCustomConfirm("確認取消", "確定要取消剩餘表情的上傳嗎？");
            if (confirmCancel) {
                canceled = true;
            }
        } else {
            alert("表情名不能為空！");
        }
    }
    
    // 迴圈結束後，如果收集到了新表情，就批量添加到資料庫
    if (newStickers.length > 0) {
        await db.userStickers.bulkAdd(newStickers);
        state.userStickers.push(...newStickers);
        renderStickerPanel();
        await showCustomAlert("上傳成功", `已成功添加 ${newStickers.length} 個新表情！`);
    }

    // 清空檔選擇器的值，以便下次能選擇相同的文件
    event.target.value = null;
});
// ▲▲▲ 替換結束 ▲▲▲

            document.getElementById('upload-image-btn').addEventListener('click', () => document.getElementById('image-upload-input').click());
            document.getElementById('image-upload-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (!file || !state.activeChatId) return; const reader = new FileReader(); reader.onload = async (e) => { const base64Url = e.target.result; const chat = state.chats[state.activeChatId]; const msg = { role: 'user', content: [{ type: 'image_url', image_url: { url: base64Url } }], timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); }; reader.readAsDataURL(file); event.target.value = null; });
            document.getElementById('voice-message-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const text = await showCustomPrompt("發送語音", "請輸入你想說的內容："); if (text && text.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'voice_message', content: text.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });
            document.getElementById('send-photo-btn').addEventListener('click', async () => { if (!state.activeChatId) return; const description = await showCustomPrompt("發送照片", "請用文字描述您要發送的照片："); if (description && description.trim()) { const chat = state.chats[state.activeChatId]; const msg = { role: 'user', type: 'user_photo', content: description.trim(), timestamp: Date.now() }; chat.history.push(msg); await db.chats.put(chat); appendMessage(msg, chat); renderChatList(); } });

// ▼▼▼ 【全新】外賣請求功能事件綁定 ▼▼▼
const waimaiModal = document.getElementById('waimai-request-modal');
document.getElementById('send-waimai-request-btn').addEventListener('click', () => {
    waimaiModal.classList.add('visible');
});

document.getElementById('waimai-cancel-btn').addEventListener('click', () => {
    waimaiModal.classList.remove('visible');
});

document.getElementById('waimai-confirm-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;
    
    const productInfoInput = document.getElementById('waimai-product-info');
    const amountInput = document.getElementById('waimai-amount');
    
    const productInfo = productInfoInput.value.trim();
    const amount = parseFloat(amountInput.value);

    if (!productInfo) {
        alert('請輸入商品資訊！');
        return;
    }
    if (isNaN(amount) || amount <= 0) {
        alert('請輸入有效的代付金額！');
        return;
    }

    const chat = state.chats[state.activeChatId];
    const now = Date.now();

    const myNickname = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
    
    const msg = {
        role: 'user',
        senderName: myNickname, 
        type: 'waimai_request',
        productInfo: productInfo,
        amount: amount,
        status: 'pending',
        countdownEndTime: now + 15 * 60 * 1000,
        timestamp: now
    };

    chat.history.push(msg);
    
    // 那一大段代碼已經被刪除了
    
    await db.chats.put(chat);
    appendMessage(msg, chat);
    renderChatList();

    productInfoInput.value = '';
    amountInput.value = '';
    waimaiModal.classList.remove('visible');
});         
            document.getElementById('open-persona-library-btn').addEventListener('click', openPersonaLibrary);
            document.getElementById('close-persona-library-btn').addEventListener('click', closePersonaLibrary);
            document.getElementById('add-persona-preset-btn').addEventListener('click', openPersonaEditorForCreate);
            document.getElementById('cancel-persona-editor-btn').addEventListener('click', closePersonaEditor);


// ▲▲▲ 替換到這裡結束 ▲▲▲


            document.getElementById('preset-action-edit').addEventListener('click', openPersonaEditorForEdit);
            document.getElementById('preset-action-delete').addEventListener('click', deletePersonaPreset);
            document.getElementById('preset-action-cancel').addEventListener('click', hidePresetActions);
            
            document.getElementById('selection-cancel-btn').addEventListener('click', exitSelectionMode);

// ▼▼▼ 【最終加強版】用這塊代碼替換舊的 selection-delete-btn 事件監聽器 ▼▼▼
document.getElementById('selection-delete-btn').addEventListener('click', async () => {
    if (selectedMessages.size === 0) return;
    const confirmed = await showCustomConfirm('刪除消息', `確定要刪除選中的 ${selectedMessages.size} 條消息嗎？這將改變AI的記憶。`, { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        
        // 1. 【核心加強】在刪除前，檢查被刪除的消息中是否包含投票
        let deletedPollsInfo = [];
        for (const timestamp of selectedMessages) {
            const msg = chat.history.find(m => m.timestamp === timestamp);
            if (msg && msg.type === 'poll') {
                deletedPollsInfo.push(`關於“${msg.question}”的投票(時間戳記: ${msg.timestamp})`);
            }
        }
        
        // 2. 更新後端的歷史記錄
        chat.history = chat.history.filter(msg => !selectedMessages.has(msg.timestamp));
        
        // 3. 【核心加強】構建更具體的“遺忘指令”
        let forgetReason = "一些之前的消息已被使用者刪除。";
        if (deletedPollsInfo.length > 0) {
            forgetReason += ` 其中包括以下投票：${deletedPollsInfo.join('；')}。`;
        }
        forgetReason += " 你應該像它們從未存在過一樣繼續對話，並相應地調整你的記憶和行為，不要再提及這些被刪除的內容。";

        const forgetInstruction = {
            role: 'system',
            content: `[系統提示：${forgetReason}]`,
            timestamp: Date.now(),
            isHidden: true 
        };
        chat.history.push(forgetInstruction);
        
        // 4. 將包含“遺忘指令”的、更新後的chat物件存回資料庫
        await db.chats.put(chat);
        
        // 5. 最後才更新UI
        renderChatInterface(state.activeChatId);
        renderChatList();
    }
});
// ▲▲▲ 替換結束 ▲▲▲

            document.getElementById('reset-font-btn').addEventListener('click', resetToDefaultFont);

            document.querySelectorAll('#chat-list-bottom-nav .nav-item').forEach(item => { item.addEventListener('click', () => switchToChatListView(item.dataset.view)); });
            document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
            document.getElementById('qzone-nickname').addEventListener('click', async () => { const newNickname = await showCustomPrompt("修改昵稱", "請輸入新的昵稱", state.qzoneSettings.nickname); if (newNickname && newNickname.trim()) { state.qzoneSettings.nickname = newNickname.trim(); await saveQzoneSettings(); renderQzoneScreen(); } });
            document.getElementById('qzone-avatar-container').addEventListener('click', () => document.getElementById('qzone-avatar-input').click());
            document.getElementById('qzone-banner-container').addEventListener('click', () => document.getElementById('qzone-banner-input').click());
            document.getElementById('qzone-avatar-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.avatar = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });
            document.getElementById('qzone-banner-input').addEventListener('change', async (event) => { const file = event.target.files[0]; if (file) { const dataUrl = await new Promise(res => { const reader = new FileReader(); reader.onload = () => res(reader.result); reader.readAsDataURL(file); }); state.qzoneSettings.banner = dataUrl; await saveQzoneSettings(); renderQzoneScreen(); } event.target.value = null; });

// ▼▼▼ 用下面這兩行，替換掉舊的事件綁定 ▼▼▼

document.getElementById('create-shuoshuo-btn').addEventListener('click', () => openQZonePublisher('shuoshuo'));
document.getElementById('create-post-btn').addEventListener('click', () => openQZonePublisher('complex'));

// ▲▲▲ 替換結束 ▲▲▲

            document.getElementById('open-album-btn').addEventListener('click', async () => { await renderAlbumList(); showScreen('album-screen'); });
            document.getElementById('album-back-btn').addEventListener('click', () => { showScreen('chat-list-screen'); switchToChatListView('qzone-screen'); });

// --- ↓↓↓ 從這裡開始複製 ↓↓↓ ---

document.getElementById('album-photos-back-btn').addEventListener('click', () => {
    state.activeAlbumId = null;
    showScreen('album-screen');
});

document.getElementById('album-upload-photo-btn').addEventListener('click', () => document.getElementById('album-photo-input').click());

document.getElementById('album-photo-input').addEventListener('change', async (event) => {
    if (!state.activeAlbumId) return;
    const files = event.target.files;
    if (!files.length) return;

    const album = await db.qzoneAlbums.get(state.activeAlbumId);
    
    for (const file of files) {
        const dataUrl = await new Promise(resolve => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.readAsDataURL(file);
        });
        await db.qzonePhotos.add({ albumId: state.activeAlbumId, url: dataUrl, createdAt: Date.now() });
    }

    const photoCount = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).count();
    const updateData = { photoCount };
    
    if (!album.photoCount || album.coverUrl.includes('placeholder')) {
        const firstPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
        if(firstPhoto) updateData.coverUrl = firstPhoto.url;
    }

    await db.qzoneAlbums.update(state.activeAlbumId, updateData);
    await renderAlbumPhotosScreen();
    await renderAlbumList();
    
    event.target.value = null;
    alert('照片上傳成功！');
});

// --- ↑↑↑ 複製到這裡結束 ↑↑↑ ---

// --- ↓↓↓ 從這裡開始複製，完整替換掉舊的 photos-grid-page 監聽器 ↓↓↓ ---

document.getElementById('photos-grid-page').addEventListener('click', async (e) => {
    const deleteBtn = e.target.closest('.photo-delete-btn');
    const photoThumb = e.target.closest('.photo-thumb');

    if (deleteBtn) {
        e.stopPropagation(); // 阻止事件冒泡到圖片上
        const photoId = parseInt(deleteBtn.dataset.photoId);
        const confirmed = await showCustomConfirm(
            '刪除照片',
            '確定要刪除這張照片嗎？此操作不可恢復。',
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            const deletedPhoto = await db.qzonePhotos.get(photoId);
            if (!deletedPhoto) return;
            
            await db.qzonePhotos.delete(photoId);

            const album = await db.qzoneAlbums.get(state.activeAlbumId);
            const photoCount = (album.photoCount || 1) - 1;
            const updateData = { photoCount };
            
            if (album.coverUrl === deletedPhoto.url) {
                const nextPhoto = await db.qzonePhotos.where('albumId').equals(state.activeAlbumId).first();
                updateData.coverUrl = nextPhoto ? nextPhoto.url : 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png';
            }
            
            await db.qzoneAlbums.update(state.activeAlbumId, updateData);
            await renderAlbumPhotosScreen();
            await renderAlbumList();
            alert('照片已刪除。');
        }
    } 
    else if (photoThumb) {
        // 這就是恢復的圖片點擊放大功能！
        openPhotoViewer(photoThumb.src);
    }
});

// 恢復圖片檢視器的控制事件
document.getElementById('photo-viewer-close-btn').addEventListener('click', closePhotoViewer);
document.getElementById('photo-viewer-next-btn').addEventListener('click', showNextPhoto);
document.getElementById('photo-viewer-prev-btn').addEventListener('click', showPrevPhoto);

// 恢復鍵盤左右箭頭和ESC鍵的功能
document.addEventListener('keydown', (e) => {
    if (!photoViewerState.isOpen) return; 

    if (e.key === 'ArrowRight') {
        showNextPhoto();
    } else if (e.key === 'ArrowLeft') {
        showPrevPhoto();
    } else if (e.key === 'Escape') {
        closePhotoViewer();
    }
});

// --- ↑↑↑ 複製到這裡結束 ↑↑↑ ---
         
document.getElementById('create-album-btn-page').addEventListener('click', async () => { const albumName = await showCustomPrompt("創建新相冊", "請輸入相冊名稱"); if (albumName && albumName.trim()) { const newAlbum = { name: albumName.trim(), coverUrl: 'https://i.postimg.cc/pT2xKzPz/album-cover-placeholder.png', photoCount: 0, createdAt: Date.now() }; await db.qzoneAlbums.add(newAlbum); await renderAlbumList(); alert(`相冊 "${albumName}" 創建成功！`); } else if (albumName !== null) { alert("相冊名稱不能為空！"); } });

            document.getElementById('cancel-create-post-btn').addEventListener('click', () => document.getElementById('create-post-modal').classList.remove('visible'));
            document.getElementById('post-upload-local-btn').addEventListener('click', () => document.getElementById('post-local-image-input').click());
            document.getElementById('post-local-image-input').addEventListener('change', (event) => { const file = event.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = (e) => { document.getElementById('post-image-preview').src = e.target.result; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; }; reader.readAsDataURL(file); } });
            document.getElementById('post-use-url-btn').addEventListener('click', async () => { const url = await showCustomPrompt("輸入圖片URL", "請輸入網路圖片的連結", "", "url"); if (url) { document.getElementById('post-image-preview').src = url; document.getElementById('post-image-preview-container').classList.add('visible'); document.getElementById('post-image-desc-group').style.display = 'block'; } });
            document.getElementById('post-remove-image-btn').addEventListener('click', () => resetCreatePostModal());
            const imageModeBtn = document.getElementById('switch-to-image-mode');
            const textImageModeBtn = document.getElementById('switch-to-text-image-mode');
            const imageModeContent = document.getElementById('image-mode-content');
            const textImageModeContent = document.getElementById('text-image-mode-content');
            imageModeBtn.addEventListener('click', () => { imageModeBtn.classList.add('active'); textImageModeBtn.classList.remove('active'); imageModeContent.classList.add('active'); textImageModeContent.classList.remove('active'); });
            textImageModeBtn.addEventListener('click', () => { textImageModeBtn.classList.add('active'); imageModeBtn.classList.remove('active'); textImageModeContent.classList.add('active'); imageModeContent.classList.remove('active'); });

// ▼▼▼ 請用下面這一整塊【修復後】的代碼，替換掉剛才刪除的舊代碼 ▼▼▼

// ▼▼▼ 用這【一整塊】代碼，替換掉舊的 'confirm-create-post-btn' 事件監聽器 ▼▼▼

// ▼▼▼ 用這塊【新代碼】替換舊的 'confirm-create-post-btn' 事件監聽器 ▼▼▼
document.getElementById('confirm-create-post-btn').addEventListener('click', async () => {
    const modal = document.getElementById('create-post-modal');
    const mode = modal.dataset.mode;

    // 【核心改造】我們在這里加一個判斷
    // 如果當前是 'forum' (小組發帖) 模式，就調用我們剛剛寫的發帖函數
    if (mode === 'forum') {
        await handleCreateForumPost();
        return; // 執行完就結束，不往下走了
    }
    
    // 如果是 'weibo' 模式，就調用發微博的函數
    if (mode === 'weibo') {
        await handlePublishWeibo();
        return;
    }

    // --- 下面是你原來已有的發佈“動態”的邏輯，我們保持不變 ---
    const editingId = parseInt(modal.dataset.editingPostId);
    const areCommentsVisible = document.getElementById('post-comments-toggle').checked;
    
    const visibility = document.querySelector('input[name="visibility"]:checked').value;
    let visibleGroupIds = null;
    if (visibility === 'groups') {
        visibleGroupIds = Array.from(document.querySelectorAll('#post-visibility-groups input:checked'))
                           .map(cb => parseInt(cb.value));
        if (visibleGroupIds.length === 0) {
            alert("請至少選擇一個可見的分組！");
            return;
        }
    }

    let postData = {};

    if (mode === 'edit') {
        const existingPost = await db.qzonePosts.get(editingId);
        if (!existingPost) {
            alert('錯誤：找不到要編輯的動態！');
            return;
        }
        postData = { 
            ...existingPost, 
            areCommentsVisible: areCommentsVisible,
            visibleGroupIds: visibleGroupIds
        };
        
        if (postData.type === 'shuoshuo') {
            postData.content = document.getElementById('post-public-text').value.trim();
        } else {
            postData.publicText = document.getElementById('post-public-text').value.trim();
            if (postData.type === 'image_post') {
                postData.imageUrl = document.getElementById('post-image-preview').src;
                postData.imageDescription = document.getElementById('post-image-description').value.trim();
            } else if (postData.type === 'text_image') {
                postData.hiddenContent = document.getElementById('post-hidden-text').value.trim();
            }
        }
        await db.qzonePosts.put(postData);

    } else {
        const basePostData = {
            timestamp: Date.now(),
            authorId: 'user',
            areCommentsVisible: areCommentsVisible,
            visibleGroupIds: visibleGroupIds
        };
        
        if (mode === 'shuoshuo') {
            const content = document.getElementById('post-public-text').value.trim();
            if (!content) return alert('說說內容不能為空哦！');
            postData = { ...basePostData, type: 'shuoshuo', content: content };
        } else {
            const publicText = document.getElementById('post-public-text').value.trim();
            const isImageModeActive = document.getElementById('image-mode-content').classList.contains('active');
            if (isImageModeActive) {
                const imageUrl = document.getElementById('post-image-preview').src;
                const imageDescription = document.getElementById('post-image-description').value.trim();
                if (!imageUrl || !(imageUrl.startsWith('http') || imageUrl.startsWith('data:'))) return alert('請先添加一張圖片再發佈動態哦！');
                if (!imageDescription) return alert('請為你的圖片添加一個簡單的描述（必填，給AI看的）！');
                postData = { ...basePostData, type: 'image_post', publicText, imageUrl, imageDescription };
            } else {
                const hiddenText = document.getElementById('post-hidden-text').value.trim();
                if (!hiddenText) return alert('請輸入文字圖描述！');
                postData = { ...basePostData, type: 'text_image', publicText, hiddenContent: hiddenText };
            }
        }
        const newPostId = await db.qzonePosts.add(postData);
        postData.id = newPostId;
    }
    
    let postSummary = postData.content || postData.publicText || postData.imageDescription || postData.hiddenContent || "（無文字內容）";
    postSummary = postSummary.substring(0, 50) + (postSummary.length > 50 ? '...' : '');
    for (const chatId in state.chats) {
        const chat = state.chats[chatId];
        if (chat.isGroup) continue;
        const historyMessage = { role: 'system', content: `[系統提示：用戶${editingId ? '編輯了' : '發佈了'}一條動態(ID: ${editingId || postData.id})，內容摘要是：“${postSummary}”。]`, timestamp: Date.now(), isHidden: true };
        chat.history.push(historyMessage);
        await db.chats.put(chat);
    }
    
    await renderQzonePosts();
    modal.classList.remove('visible');
    delete modal.dataset.editingPostId;
    delete modal.dataset.mode;
    alert(`動態${editingId ? '編輯' : '發佈'}成功！`);
});
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 在 init() 函數的事件監聽器區域，黏貼下面這【一整塊】新代碼 ▼▼▼

// 【全新】為全域聊天背景的上傳按鈕綁定事件
document.getElementById('global-bg-upload-input').addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if(file) {
        const dataUrl = await new Promise((res) => {
            const reader = new FileReader();
            reader.onload = () => res(reader.result);
            reader.readAsDataURL(file);
        });
        newGlobalBgBase64 = dataUrl; // 將新背景存入臨時變數
        // 即時更新預覽
        const preview = document.getElementById('global-bg-preview');
        preview.style.backgroundImage = `url(${dataUrl})`;
        preview.textContent = '';
    }
});

// 【全新】為全域聊天背景的移除按鈕綁定事件
document.getElementById('remove-global-bg-btn').addEventListener('click', () => {
    newGlobalBgBase64 = 'REMOVED'; // 用一個特殊標記表示“移除”
    const preview = document.getElementById('global-bg-preview');
    preview.style.backgroundImage = 'none';
    preview.textContent = '已移除';
    alert('全域背景將在點擊“保存”後被移除。');
});

// 【全新】為“一鍵清空單人背景”按鈕綁定事件
document.getElementById('clear-all-single-bgs-btn').addEventListener('click', clearAllSingleChatBackgrounds);

// ▲▲▲ 新代碼黏貼結束 ▲▲▲
// ▼▼▼ 請用這【一整塊】包含所有滑動和點擊事件的完整代碼，替換掉舊的 postsList 事件監聽器 ▼▼▼

const postsList = document.getElementById('qzone-posts-list');
let swipeState = { isDragging: false, startX: 0, startY: 0, currentX: 0, activeContainer: null, swipeDirection: null, isClick: true };

function resetAllSwipes(exceptThisOne = null) {
    document.querySelectorAll('.qzone-post-container').forEach(container => {
        if (container !== exceptThisOne) {
            container.querySelector('.qzone-post-item').classList.remove('swiped');
        }
    });
}

const handleSwipeStart = (e) => {
    const targetContainer = e.target.closest('.qzone-post-container');
    if (!targetContainer) return;

    resetAllSwipes(targetContainer);
    swipeState.activeContainer = targetContainer;
    swipeState.isDragging = true;
    swipeState.isClick = true;
    swipeState.swipeDirection = null;
    swipeState.startX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
    swipeState.startY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
    swipeState.activeContainer.querySelector('.qzone-post-item').style.transition = 'none';
};

const handleSwipeMove = (e) => {
    if (!swipeState.isDragging || !swipeState.activeContainer) return;

    const currentX = e.type.includes('mouse') ? e.pageX : e.touches[0].pageX;
    const currentY = e.type.includes('mouse') ? e.pageY : e.touches[0].pageY;
    const diffX = currentX - swipeState.startX;
    const diffY = currentY - swipeState.startY;
    const absDiffX = Math.abs(diffX);
    const absDiffY = Math.abs(diffY);
    const clickThreshold = 5;

    if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
        swipeState.isClick = false;
    }

    if (swipeState.swipeDirection === null) {
        if (absDiffX > clickThreshold || absDiffY > clickThreshold) {
            if (absDiffX > absDiffY) {
                swipeState.swipeDirection = 'horizontal';
            } else {
                swipeState.swipeDirection = 'vertical';
            }
        }
    }
    if (swipeState.swipeDirection === 'vertical') {
        handleSwipeEnd(e);
        return;
    }
    if (swipeState.swipeDirection === 'horizontal') {
        e.preventDefault();
        swipeState.currentX = currentX;
        let translation = diffX;
        if (translation > 0) translation = 0;
        if (translation < -90) translation = -90;
        swipeState.activeContainer.querySelector('.qzone-post-item').style.transform = `translateX(${translation}px)`;
    }
};

const handleSwipeEnd = (e) => {
    if (swipeState.isClick) {
        swipeState.isDragging = false;
        swipeState.activeContainer = null;
        return;
    }
    if (!swipeState.isDragging || !swipeState.activeContainer) return;

    const postItem = swipeState.activeContainer.querySelector('.qzone-post-item');
    postItem.style.transition = 'transform 0.3s ease';

    const finalX = e.type.includes('touchend') ? e.changedTouches[0].pageX : e.pageX;
    const diffX = finalX - swipeState.startX;
    const swipeThreshold = -40;

    if (swipeState.swipeDirection === 'horizontal' && diffX < swipeThreshold) {
        postItem.classList.add('swiped');
        postItem.style.transform = '';
    } else {
        postItem.classList.remove('swiped');
        postItem.style.transform = '';
    }

    swipeState.isDragging = false;
    swipeState.startX = 0;
    swipeState.startY = 0;
    swipeState.currentX = 0;
    swipeState.activeContainer = null;
    swipeState.swipeDirection = null;
    swipeState.isClick = true;
};

// --- 綁定所有滑動事件 ---
postsList.addEventListener('mousedown', handleSwipeStart);
document.addEventListener('mousemove', handleSwipeMove);
document.addEventListener('mouseup', handleSwipeEnd);
postsList.addEventListener('touchstart', handleSwipeStart, { passive: false });
postsList.addEventListener('touchmove', handleSwipeMove, { passive: false });
postsList.addEventListener('touchend', handleSwipeEnd);

// ▼▼▼ 步驟3.3：用這整塊代碼替換舊的 qzone-posts-list 的 click 事件監聽器 ▼▼▼
postsList.addEventListener('click', async (e) => {
    e.stopPropagation();
    const target = e.target;
// ▼▼▼ 在這裡黏貼新代碼 ▼▼▼
const summonBtn = target.closest('.action-icon.summon-npc');
if (summonBtn) {
    const postId = parseInt(summonBtn.dataset.postId);
    const authorId = summonBtn.dataset.authorId;
    if (!isNaN(postId) && authorId) {
        handleNpcSummonClick(postId, authorId);
    }
    return; // 處理完召喚邏輯後，直接結束，不執行後續的點贊等判斷
}
// ▲▲▲ 黏貼結束 ▲▲▲

    // ★★★★★【核心修改：處理點擊評論本身（用於回復）】★★★★★
    const commentItem = target.closest('.comment-item');
    // 確保點擊的不是刪除按鈕或評論裡的名字連結
    if (commentItem && !target.classList.contains('comment-delete-btn') && !target.classList.contains('commenter-name') && !target.classList.contains('reply-target-name')) {
        const postContainer = commentItem.closest('.qzone-post-container');
        if (postContainer) {
            const commenterName = commentItem.dataset.commenterName;
            const myNickname = state.qzoneSettings.nickname;
            
            // 如果點擊的是自己的評論，則不進入回復模式
            if (commenterName !== myNickname) {
                const commentInput = postContainer.querySelector('.comment-input');
                commentInput.placeholder = `回復 ${commenterName}:`;
                commentInput.dataset.replyTo = commenterName; // 把要回復的人的名字，臨時存起來
                commentInput.focus(); // 自動聚焦到輸入框
            }
        }
        return; // 處理完點擊評論後，就不用往下執行了
    }

    if (target.classList.contains('comment-delete-btn')) {
        const postContainer = target.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        const commentIndex = parseInt(target.dataset.commentIndex);
        if (isNaN(postId) || isNaN(commentIndex)) return;
        const post = await db.qzonePosts.get(postId);
        if (!post || !post.comments || !post.comments[commentIndex]) return;
        const commentText = post.comments[commentIndex].text;
        const confirmed = await showCustomConfirm('刪除評論', `確定要刪除這條評論嗎？\n\n“${commentText.substring(0, 50)}...”`, { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            post.comments.splice(commentIndex, 1);
            await db.qzonePosts.update(postId, { comments: post.comments });
            await renderQzonePosts();
            alert('評論已刪除。');
        }
        return;
    }

    if (target.classList.contains('post-actions-btn')) {
        const container = target.closest('.qzone-post-container');
        if (container && container.dataset.postId) showPostActions(parseInt(container.dataset.postId));
        return;
    }

    if (target.closest('.qzone-post-delete-action')) {
        const container = target.closest('.qzone-post-delete-action').parentElement;
        if (!container) return;
        const postIdToDelete = parseInt(container.dataset.postId);
        if (isNaN(postIdToDelete)) return;
        const confirmed = await showCustomConfirm('刪除動態', '確定要永久刪除這條動態嗎？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            container.style.transition = 'all 0.3s ease';
            container.style.transform = 'scale(0.8)';
            container.style.opacity = '0';
            setTimeout(async () => {
                 await db.qzonePosts.delete(postIdToDelete);
                 const notificationIdentifier = `(ID: ${postIdToDelete})`;
                 for (const chatId in state.chats) {
                     const chat = state.chats[chatId];
                     const originalHistoryLength = chat.history.length;
                     chat.history = chat.history.filter(msg => !(msg.role === 'system' && msg.content.includes(notificationIdentifier)));
                     if (chat.history.length < originalHistoryLength) await db.chats.put(chat);
                 }
                 await renderQzonePosts();
                 alert('動態已刪除。');
            }, 300);
        }
        return;
    }

    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        showCustomAlert("圖片內容", target.dataset.hiddenText.replace(/<br>/g, '\n'));
        return;
    }
    const icon = target.closest('.action-icon');
    if (icon) {
        const postContainer = icon.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        if (isNaN(postId)) return;
        if (icon.classList.contains('like')) {
            const post = await db.qzonePosts.get(postId);
            if (!post) return;
            if (!post.likes) post.likes = [];
            const userNickname = state.qzoneSettings.nickname;
            const userLikeIndex = post.likes.indexOf(userNickname);
            if (userLikeIndex > -1) {
                post.likes.splice(userLikeIndex, 1);
            } else {
                post.likes.push(userNickname);
                icon.classList.add('animate-like');
                icon.addEventListener('animationend', () => icon.classList.remove('animate-like'), { once: true });
            }
            await db.qzonePosts.update(postId, { likes: post.likes });
        }
        if (icon.classList.contains('favorite')) {
            const existingFavorite = await db.favorites.where({ type: 'qzone_post', 'content.id': postId }).first();
            if (existingFavorite) {
                await db.favorites.delete(existingFavorite.id);
                await showCustomAlert('提示', '已取消收藏');
            } else {
                const postToSave = await db.qzonePosts.get(postId);
                if (postToSave) {
                    await db.favorites.add({ type: 'qzone_post', content: postToSave, timestamp: Date.now() });
                    await showCustomAlert('提示', '收藏成功！');
                }
            }
        }
        await renderQzonePosts();
        return;
    }
    
    // ★★★★★【核心修改：處理評論發送邏輯】★★★★★
    const sendBtn = target.closest('.comment-send-btn');
    if (sendBtn) {
        const postContainer = sendBtn.closest('.qzone-post-container');
        if (!postContainer) return;
        const postId = parseInt(postContainer.dataset.postId);
        const commentInput = postContainer.querySelector('.comment-input');
        const commentText = commentInput.value.trim();
        if (!commentText) return alert('評論內容不能為空哦！');
        const post = await db.qzonePosts.get(postId);
        if (!post) return;
        if (!post.comments) post.comments = [];

        // 創建新的評論物件
        const newComment = { 
            commenterName: state.qzoneSettings.nickname, 
            text: commentText, 
            timestamp: Date.now() 
        };

        // 檢查是不是在回復模式
        if (commentInput.dataset.replyTo) {
            newComment.replyTo = commentInput.dataset.replyTo; // 如果是，就把回復物件的名字加上
        }

        post.comments.push(newComment);
        await db.qzonePosts.update(postId, { comments: post.comments });
        for (const chatId in state.chats) {
            const chat = state.chats[chatId];
            if (!chat.isGroup) {
                let aiNotification = `[系統提示：'${state.qzoneSettings.nickname}' 在ID為${postId}的動態下發表了評論：“${commentText}”`;
                if(newComment.replyTo) {
                    aiNotification += ` (這是對'${newComment.replyTo}'的回復)`;
                }
                aiNotification += `]`;
                chat.history.push({ role: 'system', content: aiNotification, timestamp: Date.now(), isHidden: true });
                await db.chats.put(chat);
            }
        }
        
        // 發送後，重置輸入框狀態
        commentInput.value = '';
        commentInput.placeholder = '友善的評論是交流的起點';
        delete commentInput.dataset.replyTo; // 清除回復狀態

        await renderQzonePosts();
        return;
    }
});
// ▲▲▲ 步驟3.3替換結束 ▲▲▲

            // ▼▼▼ 在 init() 函數的事件監聽器區域，黏貼下面這兩行 ▼▼▼

            // 綁定動態頁和收藏頁的返回按鈕
            document.getElementById('qzone-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));
            document.getElementById('favorites-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

            // ▲▲▲ 添加結束 ▲▲▲

            // ▼▼▼ 在 init() 函數的事件監聽器區域，檢查並確保你有這段完整的代碼 ▼▼▼

            // 收藏頁搜索功能
            const searchInput = document.getElementById('favorites-search-input');
            const searchClearBtn = document.getElementById('favorites-search-clear-btn');

            searchInput.addEventListener('input', () => {
                const searchTerm = searchInput.value.trim().toLowerCase();
                
                // 控制清除按鈕的顯示/隱藏
                searchClearBtn.style.display = searchTerm ? 'block' : 'none';

                if (!searchTerm) {
                    displayFilteredFavorites(allFavoriteItems); // 如果搜索框為空，顯示所有
                    return;
                }

                // 篩選邏輯
                const filteredItems = allFavoriteItems.filter(item => {
                    let contentToSearch = '';
                    let authorToSearch = '';

                    if (item.type === 'qzone_post') {
                        const post = item.content;
                        contentToSearch += (post.publicText || '') + ' ' + (post.content || '');
                        if (post.authorId === 'user') {
                            authorToSearch = state.qzoneSettings.nickname;
                        } else if (state.chats[post.authorId]) {
                            authorToSearch = state.chats[post.authorId].name;
                        }
                    } else if (item.type === 'chat_message') {
                        const msg = item.content;
                        if (typeof msg.content === 'string') {
                            contentToSearch = msg.content;
                        }
                        const chat = state.chats[item.chatId];
                        if (chat) {
                           if (msg.role === 'user') {
                                authorToSearch = chat.isGroup ? (chat.settings.myNickname || '我') : '我';
                           } else {
                                authorToSearch = chat.isGroup ? msg.senderName : chat.name;
                           }
                        }
                    }
                    
                    // 同時搜索內容和作者，並且不區分大小寫
                    return contentToSearch.toLowerCase().includes(searchTerm) || 
                           authorToSearch.toLowerCase().includes(searchTerm);
                });

                displayFilteredFavorites(filteredItems);
            });

            // 清除按鈕的點擊事件
            searchClearBtn.addEventListener('click', () => {
                searchInput.value = '';
                searchClearBtn.style.display = 'none';
                displayFilteredFavorites(allFavoriteItems);
                searchInput.focus();
            });

            // ▲▲▲ 代碼檢查結束 ▲▲▲

            // ▼▼▼ 新增/修改的事件監聽器 ▼▼▼
            
            // 為聊天介面的批量收藏按鈕綁定事件
                        // 為聊天介面的批量收藏按鈕綁定事件 (已修正)
            document.getElementById('selection-favorite-btn').addEventListener('click', async () => {
                if (selectedMessages.size === 0) return;
                const chat = state.chats[state.activeChatId];
                if (!chat) return;

                const favoritesToAdd = [];
                const timestampsToFavorite = [...selectedMessages];

                for (const timestamp of timestampsToFavorite) {
                    // 【核心修正1】使用新的、高效的索引進行查詢
                    const existing = await db.favorites.where('originalTimestamp').equals(timestamp).first();
                    
                    if (!existing) {
                        const messageToSave = chat.history.find(msg => msg.timestamp === timestamp);
                        if (messageToSave) {
                            favoritesToAdd.push({
                                type: 'chat_message',
                                content: messageToSave,
                                chatId: state.activeChatId,
                                timestamp: Date.now(), // 這是收藏操作發生的時間
                                originalTimestamp: messageToSave.timestamp // 【核心修正2】保存原始消息的時間戳記到新欄位
                            });
                        }
                    }
                }

                if (favoritesToAdd.length > 0) {
                    await db.favorites.bulkAdd(favoritesToAdd);
                    allFavoriteItems = await db.favorites.orderBy('timestamp').reverse().toArray(); // 更新全域收藏緩存
                    await showCustomAlert('收藏成功', `已成功收藏 ${favoritesToAdd.length} 條消息。`);
                } else {
                    await showCustomAlert('提示', '選中的消息均已收藏過。');
                }
                
                exitSelectionMode();
            });

            // 收藏頁面的"編輯"按鈕事件 (已修正)
            const favoritesEditBtn = document.getElementById('favorites-edit-btn');
            const favoritesView = document.getElementById('favorites-view');
            const favoritesActionBar = document.getElementById('favorites-action-bar');
            const mainBottomNav = document.getElementById('chat-list-bottom-nav'); // 獲取主巡覽列
            const favoritesList = document.getElementById('favorites-list'); // 獲取收藏列表
            
            favoritesEditBtn.addEventListener('click', () => {
                isFavoritesSelectionMode = !isFavoritesSelectionMode;
                favoritesView.classList.toggle('selection-mode', isFavoritesSelectionMode);

                if (isFavoritesSelectionMode) {
                    // --- 進入編輯模式 ---
                    favoritesEditBtn.textContent = '完成';
                    favoritesActionBar.style.display = 'block'; // 顯示刪除操作欄
                    mainBottomNav.style.display = 'none'; // ▼ 新增：隱藏主巡覽列
                    favoritesList.style.paddingBottom = '80px'; // ▼ 新增：給列表底部增加空間
                } else {
                    // --- 退出編輯模式 ---
                    favoritesEditBtn.textContent = '編輯';
                    favoritesActionBar.style.display = 'none'; // 隱藏刪除操作欄
                    mainBottomNav.style.display = 'flex';  // ▼ 新增：恢復主巡覽列
                    favoritesList.style.paddingBottom = ''; // ▼ 新增：恢復列表默認padding

                    // 退出時清空所有選擇
                    selectedFavorites.clear();
                    document.querySelectorAll('.favorite-item-card.selected').forEach(card => card.classList.remove('selected'));
                    document.getElementById('favorites-delete-selected-btn').textContent = `刪除 (0)`;
                }
            });

// ▼▼▼ 將它【完整替換】為下面這段修正後的代碼 ▼▼▼
// 收藏列表的點擊選擇事件 (事件委託)
document.getElementById('favorites-list').addEventListener('click', (e) => {
    const target = e.target;
    const card = target.closest('.favorite-item-card');

    // 【新增】處理文字圖點擊，這段邏輯要放在最前面，保證任何模式下都生效
    if (target.tagName === 'IMG' && target.dataset.hiddenText) {
        const hiddenText = target.dataset.hiddenText;
        showCustomAlert("圖片內容", hiddenText.replace(/<br>/g, '\n'));
        return; // 處理完就退出，不繼續執行選擇邏輯
    }
    
    // 如果不在選擇模式，則不執行後續的選擇操作
    if (!isFavoritesSelectionMode) return;

    // --- 以下是原有的選擇邏輯，保持不變 ---
    if (!card) return;

    const favId = parseInt(card.dataset.favid);
    if (isNaN(favId)) return;

    // 切換選擇狀態
    if (selectedFavorites.has(favId)) {
        selectedFavorites.delete(favId);
        card.classList.remove('selected');
    } else {
        selectedFavorites.add(favId);
        card.classList.add('selected');
    }
    
    // 更新底部刪除按鈕的計數
    document.getElementById('favorites-delete-selected-btn').textContent = `刪除 (${selectedFavorites.size})`;
});

// ▼▼▼ 將它【完整替換】為下面這段修正後的代碼 ▼▼▼
// 收藏頁面批量刪除按鈕事件
document.getElementById('favorites-delete-selected-btn').addEventListener('click', async () => {
    if (selectedFavorites.size === 0) return;

    const confirmed = await showCustomConfirm(
        '確認刪除', 
        `確定要從我的最愛中移除這 ${selectedFavorites.size} 條內容嗎？`, 
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const idsToDelete = [...selectedFavorites];
        await db.favorites.bulkDelete(idsToDelete);
        await showCustomAlert('刪除成功', '選中的收藏已被移除。');
        
        // 【核心修正1】從前端緩存中也移除被刪除的項
        allFavoriteItems = allFavoriteItems.filter(item => !idsToDelete.includes(item.id));
        
        // 【核心修正2】使用更新後的緩存，立即重新渲染列表
        displayFilteredFavorites(allFavoriteItems);
        
        // 最後，再退出編輯模式
        favoritesEditBtn.click(); // 類比點擊"完成"按鈕來退出編輯模式
    }
});

// ▼▼▼ 在 init() 函數末尾添加 ▼▼▼
if (state.globalSettings.enableBackgroundActivity) {
    startBackgroundSimulation();
    console.log("後臺活動模擬已自動啟動。");
}
// ▲▲▲ 添加結束 ▲▲▲

// ▼▼▼ 【這是最終的正確代碼】請黏貼這段代碼到 init() 的事件監聽器區域末尾 ▼▼▼

// --- 統一處理所有影響預覽的控制項的事件 ---

// 1. 監聽主題選擇
document.querySelectorAll('input[name="theme-select"]').forEach(radio => {
    radio.addEventListener('change', updateSettingsPreview);
});

// 2. 監聽字體大小滑塊
const fontSizeSlider = document.getElementById('font-size-slider');
fontSizeSlider.addEventListener('input', () => {
    // a. 即時更新數值顯示
    document.getElementById('font-size-value').textContent = `${fontSizeSlider.value}px`;
    // b. 更新預覽
    updateSettingsPreview();
});

// 3. 監聽自訂CSS輸入框
const customCssInputForPreview = document.getElementById('custom-css-input');
customCssInputForPreview.addEventListener('input', updateSettingsPreview);

// 4. 監聽重新開機按鈕
document.getElementById('reset-theme-btn').addEventListener('click', () => {
    document.getElementById('theme-default').checked = true;
    updateSettingsPreview();
});

document.getElementById('reset-custom-css-btn').addEventListener('click', () => {
    document.getElementById('custom-css-input').value = '';
    updateSettingsPreview();
});

// ▲▲▲ 黏貼結束 ▲▲▲

// ▼▼▼ 請將這段【新代碼】黏貼到 init() 的事件監聽器區域末尾 ▼▼▼
document.querySelectorAll('input[name="visibility"]').forEach(radio => {
    radio.addEventListener('change', function() {
        const groupsContainer = document.getElementById('post-visibility-groups');
        if (this.value === 'include' || this.value === 'exclude') {
            groupsContainer.style.display = 'block';
        } else {
            groupsContainer.style.display = 'none';
        }
    });
});
// ▲▲▲ 新代碼黏貼結束 ▲▲▲

// ▼▼▼ 請將這段【新代碼】黏貼到 init() 的事件監聽器區域末尾 ▼▼▼
document.getElementById('manage-groups-btn').addEventListener('click', openGroupManager);
document.getElementById('close-group-manager-btn').addEventListener('click', () => {
    document.getElementById('group-management-modal').classList.remove('visible');
    // 刷新聊天設置裡的分組列表
    const chatSettingsBtn = document.getElementById('chat-settings-btn');
    if (document.getElementById('chat-settings-modal').classList.contains('visible')) {
       chatSettingsBtn.click(); // 再次點擊以重新打開
    }
});

document.getElementById('add-new-group-btn').addEventListener('click', addNewGroup);
document.getElementById('existing-groups-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-group-btn')) {
        const groupId = parseInt(e.target.dataset.id);
        deleteGroup(groupId);
    }
});
// ▲▲▲ 新代碼黏貼結束 ▲▲▲

// ▼▼▼ 請將這段【新代碼】黏貼到 init() 的事件監聽器區域末尾 ▼▼▼
// 消息操作功能表的按鈕事件
document.getElementById('cancel-message-action-btn').addEventListener('click', hideMessageActions);
// ▼▼▼ 【修正】使用新的編輯器入口 ▼▼▼
document.getElementById('edit-message-btn').addEventListener('click', openAdvancedMessageEditor);
// ▲▲▲ 替換結束 ▲▲▲
document.getElementById('copy-message-btn').addEventListener('click', copyMessageContent);

// ▼▼▼ 在這裡添加新代碼 ▼▼▼
document.getElementById('recall-message-btn').addEventListener('click', handleRecallClick);
// ▲▲▲ 添加結束 ▲▲▲

// ▼▼▼ 請用這段【修正後】的代碼替換舊的 select-message-btn 事件監聽器 ▼▼▼
document.getElementById('select-message-btn').addEventListener('click', () => {
    // 【核心修復】在關閉菜單前，先捕獲時間戳記
    const timestampToSelect = activeMessageTimestamp; 
    hideMessageActions();
    // 使用捕獲到的值
    if (timestampToSelect) {
        enterSelectionMode(timestampToSelect);
    }
});
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 在 init() 函數的事件監聽器區域末尾添加 ▼▼▼

// 動態操作功能表的按鈕事件
document.getElementById('edit-post-btn').addEventListener('click', openPostEditor);
document.getElementById('copy-post-btn').addEventListener('click', copyPostContent);
document.getElementById('cancel-post-action-btn').addEventListener('click', hidePostActions);

// ▲▲▲ 添加結束 ▲▲▲

// ▼▼▼ 【新增】連絡人選擇器事件綁定 ▼▼▼
document.getElementById('cancel-contact-picker-btn').addEventListener('click', () => {
    showScreen('chat-list-screen');
});

document.getElementById('contact-picker-list').addEventListener('click', (e) => {
    const item = e.target.closest('.contact-picker-item');
    if (!item) return;

    const contactId = item.dataset.contactId;
    item.classList.toggle('selected');
    
    if (selectedContacts.has(contactId)) {
        selectedContacts.delete(contactId);
    } else {
        selectedContacts.add(contactId);
    }
    updateContactPickerConfirmButton();
});

// ▼▼▼ 【新增】綁定“管理群成員”按鈕事件 ▼▼▼
document.getElementById('manage-members-btn').addEventListener('click', () => {
    // 在切換螢幕前，先隱藏當前的聊天設置彈窗
    document.getElementById('chat-settings-modal').classList.remove('visible');
    // 然後再打開成員管理螢幕
    openMemberManagementScreen();
});
// ▲▲▲ 新增代碼結束 ▲▲▲

// ▼▼▼ 【最終完整版】群成員管理功能事件綁定 ▼▼▼
document.getElementById('back-from-member-management').addEventListener('click', () => {

    showScreen('chat-interface-screen');    
    document.getElementById('chat-settings-btn').click();
});
// ▲▲▲ 替換結束 ▲▲▲

document.getElementById('member-management-list').addEventListener('click', (e) => {
    // 【已恢復】移除成員的事件
    if (e.target.classList.contains('remove-member-btn')) {
        removeMemberFromGroup(e.target.dataset.memberId);
    }
});

document.getElementById('add-existing-contact-btn').addEventListener('click', async () => {
    // 【已恢復】從好友列表添加的事件
    // 【關鍵】為“完成”按鈕綁定“拉人入群”的邏輯
    const confirmBtn = document.getElementById('confirm-contact-picker-btn');
    // 使用克隆節點方法清除舊的事件監聽器，防止重複綁定
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    newConfirmBtn.addEventListener('click', handleAddMembersToGroup);
    
    await openContactPickerForAddMember();
});

document.getElementById('create-new-member-btn').addEventListener('click', createNewMemberInGroup);
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 【全新】視頻通話功能事件監聽器 ▼▼▼

// 綁定單聊和群聊的發起按鈕
document.getElementById('video-call-btn').addEventListener('click', handleInitiateCall);
document.getElementById('group-video-call-btn').addEventListener('click', handleInitiateCall);

// 綁定“掛斷”按鈕
document.getElementById('hang-up-btn').addEventListener('click', endVideoCall);

// 綁定“取消呼叫”按鈕
document.getElementById('cancel-call-btn').addEventListener('click', () => {
    videoCallState.isAwaitingResponse = false;
    showScreen('chat-interface-screen');
});

// 【全新】綁定“加入通話”按鈕
document.getElementById('join-call-btn').addEventListener('click', handleUserJoinCall);

// ▼▼▼ 用這個【已修復並啟動旁觀模式】的版本替換舊的 decline-call-btn 事件監聽器 ▼▼▼
// 綁定來電請求的“拒絕”按鈕
document.getElementById('decline-call-btn').addEventListener('click', async () => {
    stopRingtone(); 
    hideIncomingCallModal();
    const callerChatId = videoCallState.activeChatId; // 【核心修正1】從專用通道獲取來電者ID
    if (!callerChatId) return;

    const chat = state.chats[callerChatId];
    if (!chat) return;
    
    // 【核心修正2】根據是否群聊，執行不同的拒絕邏輯
    if (videoCallState.isGroupCall) {
        // 對於群聊，拒絕=旁觀，這個邏輯不變
        videoCallState.isUserParticipating = false;
        const systemNote = {
            role: 'system',
            content: `[系統提示：用戶拒絕了通話邀請，但你們可以自己開始。請你們各自決策是否加入。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(systemNote);
        await db.chats.put(chat);
        await triggerAiResponse(); 
    } else { 
        // 對於單聊，我們不再打擾使用者當前介面，而是靜默處理
        const declineMessage = { role: 'user', content: '我拒絕了你的視頻通話請求。', timestamp: Date.now(), isHidden: true };
        chat.history.push(declineMessage);
        await db.chats.put(chat);
        
        // 【核心修正3】只通知，不切換螢幕
        showNotification(callerChatId, "你已拒絕通話邀請。");
        // 【重要】在後臺為對方觸發一個回應，讓它知道自己被拒絕了
        // 我們需要臨時切換activeChatId來觸發，然後再換回來
        const originalActiveChatId = state.activeChatId;
        state.activeChatId = callerChatId;
        await triggerAiResponse();
        state.activeChatId = originalActiveChatId;
    }
    
    // 清理狀態
    videoCallState.isAwaitingResponse = false;
    videoCallState.activeChatId = null;
});
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 用這個【已修復重複頭像BUG】的版本替換舊的 accept-call-btn 事件監聽器 ▼▼▼
// 綁定來電請求的“接聽”按鈕
document.getElementById('accept-call-btn').addEventListener('click', async () => {
    stopRingtone();
    hideIncomingCallModal();
    const callerChatId = videoCallState.activeChatId; // 【核心修正1】從專用通道獲取ID
    if (!callerChatId) return;
    
    // 【核心修正2】在接聽時，我們才真正改變全域狀態，並打開通話介面
    state.activeChatId = callerChatId; // <-- 在這裡，我們才授權修改全域狀態！
    
    videoCallState.initiator = 'ai';
    videoCallState.isUserParticipating = true;
    
    if (videoCallState.isGroupCall) {
        const chat = state.chats[videoCallState.activeChatId];
        const requester = chat.members.find(m => m.name === videoCallState.callRequester);
        if (requester) {
            videoCallState.participants = [requester];
        } else {
            videoCallState.participants = [];
        }
    }
    
    startVideoCall(); // 啟動通話介面
});
// ▲▲▲ 替換結束 ▲▲▲


// ▼▼▼ 請用這個【已增加用戶高亮】的全新版本，完整替換舊的 user-speak-btn 事件監聽器 ▼▼▼
// 綁定使用者在通話中發言的按鈕
document.getElementById('user-speak-btn').addEventListener('click', async () => {
    if (!videoCallState.isActive) return;

    // ★★★★★ 核心新增：在彈出輸入框前，先找到並高亮用戶頭像 ★★★★★
    const userAvatar = document.querySelector('.participant-avatar-wrapper[data-participant-id="user"] .participant-avatar');
    if (userAvatar) {
        userAvatar.classList.add('speaking');
    }

    const userInput = await showCustomPrompt('你說', '請輸入你想說的話...');
    
    // ★★★★★ 核心新增：無論用戶是否輸入，只要關閉輸入框就移除高亮 ★★★★★
    if (userAvatar) {
        userAvatar.classList.remove('speaking');
    }

    if (userInput && userInput.trim()) {
        triggerAiInCallAction(userInput.trim());
    }
});
// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 【新增】回憶錄相關事件綁定 ▼▼▼
// 1. 將“回憶”頁簽和它的視圖連接起來
document.querySelector('.nav-item[data-view="memories-view"]').addEventListener('click', () => {
    // 在切換前，確保"收藏"頁面的編輯模式已關閉
    if (isFavoritesSelectionMode) {
        document.getElementById('favorites-edit-btn').click(); 
    }
    switchToChatListView('memories-view');
    renderMemoriesScreen(); // 點擊時渲染
});

// 2. 綁定回憶錄介面的返回按鈕
document.getElementById('memories-back-btn').addEventListener('click', () => switchToChatListView('messages-view'));

// ▲▲▲ 新增結束 ▲▲▲

// 【全新】約定/倒計時功能事件綁定
document.getElementById('add-countdown-btn').addEventListener('click', () => {
    document.getElementById('create-countdown-modal').classList.add('visible');
});
document.getElementById('cancel-create-countdown-btn').addEventListener('click', () => {
    document.getElementById('create-countdown-modal').classList.remove('visible');
});
document.getElementById('confirm-create-countdown-btn').addEventListener('click', async () => {
    const title = document.getElementById('countdown-title-input').value.trim();
    const dateValue = document.getElementById('countdown-date-input').value;
    
    if (!title || !dateValue) {
        alert('請填寫完整的約定標題和日期！');
        return;
    }

    const targetDate = new Date(dateValue);
    if (isNaN(targetDate) || targetDate <= new Date()) {
        alert('請輸入一個有效的、未來的日期！');
        return;
    }

    const newCountdown = {
        chatId: null, // 用戶創建的，不屬於任何特定AI
        authorName: '我',
        description: title,
        timestamp: Date.now(),
        type: 'countdown',
        targetDate: targetDate.getTime()
    };
    
    await db.memories.add(newCountdown);
    document.getElementById('create-countdown-modal').classList.remove('visible');
    renderMemoriesScreen();
});

// 【全新】拉黑功能事件綁定
document.getElementById('block-chat-btn').addEventListener('click', async () => {
    if (!state.activeChatId || state.chats[state.activeChatId].isGroup) return;

    const chat = state.chats[state.activeChatId];
    const confirmed = await showCustomConfirm(
        '確認拉黑', 
        `確定要拉黑“${chat.name}”嗎？拉黑後您將無法向其發送消息，直到您將Ta移出黑名單，或等待Ta重新申請好友。`,
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();

        // ▼▼▼ 在這裡添加下面的代碼 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系統提示：你剛剛被用戶拉黑了。在對方解除拉黑之前，你無法再主動發起對話，也無法回應。]`,
            timestamp: Date.now() + 1,
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加結束 ▲▲▲

        await db.chats.put(chat);
        
        // 關閉設置彈窗，並刷新聊天介面
        document.getElementById('chat-settings-modal').classList.remove('visible');
        renderChatInterface(state.activeChatId);
        // 刷新聊天列表，可能會有UI變化
        renderChatList();
    }
});

document.getElementById('chat-lock-overlay').addEventListener('click', async (e) => {
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    if (e.target.id === 'force-apply-check-btn') {
        alert("正在手動觸發好友申請流程，請稍後...\n如果API調用成功，將彈出提示。如果失敗，也會有錯誤提示。如果長時間無反應，說明AI可能決定暫時不申請。");
        await triggerAiFriendApplication(chat.id);
        renderChatInterface(chat.id); 
        return;
    }

    if (e.target.id === 'unblock-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.blockedTimestamp = null;

        // ▼▼▼ 在這裡添加下面的代碼 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系統提示：用戶剛剛解除了對你的拉黑。現在你們可以重新開始對話了。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加結束 ▲▲▲

        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
        triggerAiResponse(); // 【可選但推薦】解除後讓AI主動說點什麼
    }
    else if (e.target.id === 'accept-friend-btn') {
        chat.relationship.status = 'friend';
        chat.relationship.applicationReason = '';

        // ▼▼▼ 在這裡添加下面的代碼 ▼▼▼
        const hiddenMessage = {
            role: 'system',
            content: `[系統提示：用戶剛剛通過了你的好友申請。你們現在又可以正常聊天了。]`,
            timestamp: Date.now(),
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        // ▲▲▲ 添加結束 ▲▲▲

        await db.chats.put(chat);
        renderChatInterface(chat.id);
        renderChatList();
        const msg = { role: 'user', content: '我通過了你的好友請求', timestamp: Date.now() };
        chat.history.push(msg);
        await db.chats.put(chat);
        appendMessage(msg, chat);
        triggerAiResponse();
    }
    else if (e.target.id === 'reject-friend-btn') {
        chat.relationship.status = 'blocked_by_user';
        chat.relationship.blockedTimestamp = Date.now();
        chat.relationship.applicationReason = '';
        await db.chats.put(chat);
        renderChatInterface(chat.id);
    }
    // 【新增】處理申請好友按鈕的點擊事件
    else if (e.target.id === 'apply-friend-btn') {
        const reason = await showCustomPrompt(
            '發送好友申請', 
            `請輸入你想對“${chat.name}”說的申請理由：`,
            "我們和好吧！"
        );
        // 只有當使用者輸入了內容並點擊“確定”後才繼續
        if (reason !== null) {
            // 更新關係狀態為“等待AI批准”
            chat.relationship.status = 'pending_ai_approval';
            chat.relationship.applicationReason = reason;
            await db.chats.put(chat);

            // 刷新UI，顯示“等待通過”的介面
            renderChatInterface(chat.id);
            renderChatList();
            
            // 【關鍵】觸發AI回應，讓它去處理這個好友申請
            triggerAiResponse();
        }
    }
});

// ▼▼▼ 【全新】紅包功能事件綁定 ▼▼▼

// 1. 將原有的轉帳按鈕(￥)的點擊事件，重定向到新的總入口函數
document.getElementById('transfer-btn').addEventListener('click', handlePaymentButtonClick);

// 2. 紅包模態框內部的控制按鈕
document.getElementById('cancel-red-packet-btn').addEventListener('click', () => {
    document.getElementById('red-packet-modal').classList.remove('visible');
});
document.getElementById('send-group-packet-btn').addEventListener('click', sendGroupRedPacket);
document.getElementById('send-direct-packet-btn').addEventListener('click', sendDirectRedPacket);

// 3. 紅包模態框的頁簽切換邏輯
const rpTabGroup = document.getElementById('rp-tab-group');
const rpTabDirect = document.getElementById('rp-tab-direct');
const rpContentGroup = document.getElementById('rp-content-group');
const rpContentDirect = document.getElementById('rp-content-direct');

rpTabGroup.addEventListener('click', () => {
    rpTabGroup.classList.add('active');
    rpTabDirect.classList.remove('active');
    rpContentGroup.style.display = 'block';
    rpContentDirect.style.display = 'none';
});
rpTabDirect.addEventListener('click', () => {
    rpTabDirect.classList.add('active');
    rpTabGroup.classList.remove('active');
    rpContentDirect.style.display = 'block';
    rpContentGroup.style.display = 'none';
});

// 4. 即時更新紅包金額顯示
document.getElementById('rp-group-amount').addEventListener('input', (e) => {
    const amount = parseFloat(e.target.value) || 0;
    document.getElementById('rp-group-total').textContent = `¥ ${amount.toFixed(2)}`;
});
document.getElementById('rp-direct-amount').addEventListener('input', (e) => {
    const amount = parseFloat(e.target.value) || 0;
    document.getElementById('rp-direct-total').textContent = `¥ ${amount.toFixed(2)}`;
});

// ▲▲▲ 新事件綁定結束 ▲▲▲

// ▼▼▼ 【全新添加】使用事件委託處理紅包點擊，修復失效問題 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 找到被點擊的紅包卡片
    const packetCard = e.target.closest('.red-packet-card');
    if (!packetCard) return; // 如果點擊的不是紅包，就什麼也不做

    // 2. 從紅包卡片的父級.message-bubble獲取時間戳記
    const messageBubble = packetCard.closest('.message-bubble');
    if (!messageBubble || !messageBubble.dataset.timestamp) return;

    // 3. 調用我們現有的處理函數
    const timestamp = parseInt(messageBubble.dataset.timestamp);
    handlePacketClick(timestamp);
});
// ▲▲▲ 新增代碼結束 ▲▲▲

// ▼▼▼ 【全新】投票功能事件監聽器 ▼▼▼
// 在輸入框工具列添加按鈕
document.getElementById('send-poll-btn').addEventListener('click', openCreatePollModal);

// 投票創建模態框的按鈕
document.getElementById('add-poll-option-btn').addEventListener('click', addPollOptionInput);
document.getElementById('cancel-create-poll-btn').addEventListener('click', () => {
    document.getElementById('create-poll-modal').classList.remove('visible');
});
document.getElementById('confirm-create-poll-btn').addEventListener('click', sendPoll);

// 使用事件委託處理投票卡片內的所有點擊事件
document.getElementById('chat-messages').addEventListener('click', (e) => {
    const pollCard = e.target.closest('.poll-card');
    if (!pollCard) return;

    const timestamp = parseInt(pollCard.dataset.pollTimestamp);
    if (isNaN(timestamp)) return;
    
    // 點擊了選項
    const optionItem = e.target.closest('.poll-option-item');
    if (optionItem && !pollCard.classList.contains('closed')) {
        handleUserVote(timestamp, optionItem.dataset.option);
        return;
    }
    
    // 點擊了動作按鈕（結束投票/查看結果）
    const actionBtn = e.target.closest('.poll-action-btn');
    if (actionBtn) {
        if (pollCard.classList.contains('closed')) {
            showPollResults(timestamp);
        } else {
            endPoll(timestamp);
        }
        return;
    }

    // 如果是已結束的投票，點擊卡片任何地方都可以查看結果
    if (pollCard.classList.contains('closed')) {
        showPollResults(timestamp);
    }
});
// ▲▲▲ 新事件監聽器黏貼結束 ▲▲▲

  // ▼▼▼ 【全新】AI頭像庫功能事件綁定 ▼▼▼
document.getElementById('manage-ai-avatar-library-btn').addEventListener('click', openAiAvatarLibraryModal);
document.getElementById('add-ai-avatar-btn').addEventListener('click', addAvatarToLibrary);
document.getElementById('close-ai-avatar-library-btn').addEventListener('click', closeAiAvatarLibraryModal);
// ▲▲▲ 新增結束 ▲▲▲

// ▼▼▼ 在 init() 的事件監聽區域，黏貼這段【新代碼】▼▼▼
            // ▼▼▼ 【請求4】App圖示上傳功能升級 (請用這整塊代碼替換舊的icon-settings-grid監聽器) ▼▼▼
            document.getElementById('icon-settings-grid').addEventListener('click', async (e) => {
                if (e.target.classList.contains('change-icon-btn')) {
                    const item = e.target.closest('.icon-setting-item');
                    const iconId = item.dataset.iconId;
                    if (!iconId) return;

                    // 1. 彈出選擇模態框
                    const choice = await showChoiceModal("更換圖示", [
                        { text: '📁 從本地上傳', value: 'local' },
                        { text: '🌐 使用網路URL', value: 'url' }
                    ]);

                    let newUrl = null;

                    // 2. 根據使用者的選擇執行不同操作
                    if (choice === 'local') {
                        newUrl = await uploadImageLocally(); // 調用我們之前寫好的本地上傳輔助函數
                    } else if (choice === 'url') {
                        const currentUrl = state.globalSettings.appIcons[iconId];
                        newUrl = await showCustomPrompt(`更換“${item.querySelector('.icon-preview').alt}”圖示`, '請輸入新的圖片URL', currentUrl, 'url');
                    }

                    // 3. 處理最終結果
                    if (newUrl && newUrl.trim()) {
                        const trimmedUrl = newUrl.trim();
                        // 僅在記憶體中更新，等待使用者點擊“保存”
                        state.globalSettings.appIcons[iconId] = trimmedUrl;
                        // 即時更新設置頁面的預覽圖
                        item.querySelector('.icon-preview').src = trimmedUrl;
                    } else if (newUrl !== null) {
                        alert("請輸入一個有效的URL或選擇一個檔！");
                    }
                }
            });
            // ▲▲▲ 替換結束 ▲▲▲


// ▼▼▼ 在 init() 函數的末尾，黏貼這段【全新的事件監聽器】 ▼▼▼

    document.getElementById('chat-messages').addEventListener('click', (e) => {
        // 使用 .closest() 向上查找被點擊的卡片
        const linkCard = e.target.closest('.link-share-card');
        if (linkCard) {
            const timestamp = parseInt(linkCard.dataset.timestamp);
            if (!isNaN(timestamp)) {
                openBrowser(timestamp); // 調用我們的函數
            }
        }
    });

    // 流覽器返回按鈕的事件監聽，確保它只綁定一次
    document.getElementById('browser-back-btn').addEventListener('click', () => {
        showScreen('chat-interface-screen');
    });

// ▲▲▲ 新代碼黏貼結束 ▲▲▲

// ▼▼▼ 在 init() 函數的末尾，黏貼這段【全新的事件監聽器】 ▼▼▼

    // 1. 綁定輸入框上方“分享連結”按鈕的點擊事件
    document.getElementById('share-link-btn').addEventListener('click', openShareLinkModal);

    // 2. 綁定模態框中“取消”按鈕的點擊事件
    document.getElementById('cancel-share-link-btn').addEventListener('click', () => {
        document.getElementById('share-link-modal').classList.remove('visible');
    });

    // 3. 綁定模態框中“分享”按鈕的點擊事件
    document.getElementById('confirm-share-link-btn').addEventListener('click', sendUserLinkShare);

// ▲▲▲ 新代碼黏貼結束 ▲▲▲

document.getElementById('theme-toggle-switch').addEventListener('change', toggleTheme);

// ▼▼▼ 在 init() 的事件監聽器區域，黏貼下面這幾行 ▼▼▼
// 綁定消息操作功能表中的“引用”按鈕
document.getElementById('quote-message-btn').addEventListener('click', startReplyToMessage);

// 綁定回復預覽欄中的“取消”按鈕
document.getElementById('cancel-reply-btn').addEventListener('click', cancelReplyMode);
// ▲▲▲ 黏貼結束 ▲▲▲

// 在你的 init() 函數的事件監聽器區域...

// ▼▼▼ 用這段代碼替換舊的轉帳卡片點擊事件 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 向上查找被點擊的元素是否在一個消息氣泡內
    const bubble = e.target.closest('.message-bubble');
    if (!bubble) return; // 如果不在，就退出

    // 2. 【核心修正】在這裡添加嚴格的篩選條件
    // 必須是 AI 的消息 (.ai)
    // 必須是轉帳類型 (.is-transfer)
    // 必須是我們標記為“待處理”的 (data-status="pending")
    if (bubble.classList.contains('ai') && 
        bubble.classList.contains('is-transfer') && 
        bubble.dataset.status === 'pending') {
        
        // 3. 只有滿足所有條件，才執行後續邏輯
        const timestamp = parseInt(bubble.dataset.timestamp);
        if (!isNaN(timestamp)) {
            showTransferActionModal(timestamp);
        }
    }
});
// ▲▲▲ 替換結束 ▲▲▲

// 在 init() 的事件監聽區域添加
document.getElementById('transfer-action-accept').addEventListener('click', () => handleUserTransferResponse('accepted'));
document.getElementById('transfer-action-decline').addEventListener('click', () => handleUserTransferResponse('declined'));
document.getElementById('transfer-action-cancel').addEventListener('click', hideTransferActionModal);

// ▼▼▼ 用這段【新代碼】替換舊的通話記錄事件綁定 ▼▼▼

document.getElementById('chat-list-title').addEventListener('click', renderCallHistoryScreen);

// 2. 綁定通話記錄頁面的“返回”按鈕
document.getElementById('call-history-back-btn').addEventListener('click', () => {
    // 【核心修改】返回到聊天清單頁面，而不是聊天介面
    showScreen('chat-list-screen');
});

// 3. 監聽卡片點擊的邏輯保持不變
document.getElementById('call-history-list').addEventListener('click', (e) => {
    const card = e.target.closest('.call-record-card');
    if (card && card.dataset.recordId) {
        showCallTranscript(parseInt(card.dataset.recordId));
    }
});

// 4. 關閉詳情彈窗的邏輯保持不變
document.getElementById('close-transcript-modal-btn').addEventListener('click', () => {
    document.getElementById('call-transcript-modal').classList.remove('visible');
});

// ▲▲▲ 替換結束 ▲▲▲

document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 1. 檢查點擊的是否是語音條
    const voiceBody = e.target.closest('.voice-message-body');
    if (!voiceBody) return;

    // 2. 找到相關的DOM元素
    const bubble = voiceBody.closest('.message-bubble');
    if (!bubble) return;
    
    const spinner = voiceBody.querySelector('.loading-spinner');
    const transcriptEl = bubble.querySelector('.voice-transcript');

    // 如果正在載入中，則不響應點擊
    if (bubble.dataset.state === 'loading') {
        return;
    }

    // 3. 如果文字已經展開，則收起
    if (bubble.dataset.state === 'expanded') {
        transcriptEl.style.display = 'none';
        bubble.dataset.state = 'collapsed';
    } 
    // 4. 如果是收起狀態，則開始“轉錄”流程
    else {
        bubble.dataset.state = 'loading'; // 進入載入狀態
        spinner.style.display = 'block';   // 顯示載入動畫

        // 模擬1.5秒的語音辨識過程
        setTimeout(() => {
            // 檢查此時元素是否還存在（可能用戶已經切換了聊天）
            if (document.body.contains(bubble)) {
                const voiceText = bubble.dataset.voiceText || '(無法識別)';
                transcriptEl.textContent = voiceText; // 填充文字
                
                spinner.style.display = 'none';      // 隱藏載入動畫
                transcriptEl.style.display = 'block';// 顯示文字
                bubble.dataset.state = 'expanded';     // 進入展開狀態
            }
        }, 500);
    }
});

document.getElementById('chat-header-status').addEventListener('click', handleEditStatusClick);

// 在 init() 的事件監聽器區域添加
document.getElementById('selection-share-btn').addEventListener('click', () => {
    if (selectedMessages.size > 0) {
        openShareTargetPicker(); // 打開我們即將創建的目標選擇器
    }
});

// 在 init() 的事件監聽器區域添加
document.getElementById('confirm-share-target-btn').addEventListener('click', async () => {
    const sourceChat = state.chats[state.activeChatId];
    const selectedTargetIds = Array.from(document.querySelectorAll('.share-target-checkbox:checked'))
                                   .map(cb => cb.dataset.chatId);

    if (selectedTargetIds.length === 0) {
        alert("請至少選擇一個要分享的聊天。");
        return;
    }

    // 1. 打包聊天記錄
    const sharedHistory = [];
    const sortedTimestamps = [...selectedMessages].sort((a, b) => a - b);
    for (const timestamp of sortedTimestamps) {
        const msg = sourceChat.history.find(m => m.timestamp === timestamp);
        if (msg) {
            sharedHistory.push(msg);
        }
    }
    
    // 2. 創建分享卡片消息物件
    const shareCardMessage = {
        role: 'user',
        senderName: sourceChat.isGroup ? (sourceChat.settings.myNickname || '我') : '我',
        type: 'share_card',
        timestamp: Date.now(),
        payload: {
            sourceChatName: sourceChat.name,
            title: `來自“${sourceChat.name}”的聊天記錄`,
            sharedHistory: sharedHistory
        }
    };

    // 3. 迴圈發送到所有目標聊天
    for (const targetId of selectedTargetIds) {
        const targetChat = state.chats[targetId];
        if (targetChat) {
            targetChat.history.push(shareCardMessage);
            await db.chats.put(targetChat);
        }
    }
    
    // 4. 收尾工作
    document.getElementById('share-target-modal').classList.remove('visible');
    exitSelectionMode(); // 退出多選模式
    await showCustomAlert("分享成功", `聊天記錄已成功分享到 ${selectedTargetIds.length} 個會話中。`);
    renderChatList(); // 刷新清單，可能會有新消息提示
});

// 綁定取消按鈕
document.getElementById('cancel-share-target-btn').addEventListener('click', () => {
    document.getElementById('share-target-modal').classList.remove('visible');
});

// 在 init() 的事件監聽器區域添加
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // ...你已有的其他點擊事件邏輯...

    // 新增邏輯：處理分享卡片的點擊
    const shareCard = e.target.closest('.link-share-card[data-timestamp]');
    if (shareCard && shareCard.closest('.message-bubble.is-link-share')) {
        const timestamp = parseInt(shareCard.dataset.timestamp);
        openSharedHistoryViewer(timestamp);
    }
});

// 綁定檢視器的關閉按鈕
document.getElementById('close-shared-history-viewer-btn').addEventListener('click', () => {
    document.getElementById('shared-history-viewer-modal').classList.remove('visible');
});

// 創建新函數來處理渲染邏輯
function openSharedHistoryViewer(timestamp) {
    const chat = state.chats[state.activeChatId];
    const message = chat.history.find(m => m.timestamp === timestamp);
    if (!message || message.type !== 'share_card') return;

    const viewerModal = document.getElementById('shared-history-viewer-modal');
    const viewerTitle = document.getElementById('shared-history-viewer-title');
    const viewerContent = document.getElementById('shared-history-viewer-content');

    viewerTitle.textContent = message.payload.title;
    viewerContent.innerHTML = ''; // 清空舊內容

    // 【核心】複用 createMessageElement 來渲染每一條被分享的消息
    message.payload.sharedHistory.forEach(sharedMsg => {
        // 注意：這裡我們傳入的是 sourceChat 物件，以確保頭像、昵稱等正確
        const sourceChat = Object.values(state.chats).find(c => c.name === message.payload.sourceChatName) || chat;
        const bubbleEl = createMessageElement(sharedMsg, sourceChat);
        if (bubbleEl) {
            viewerContent.appendChild(bubbleEl);
        }
    });

    viewerModal.classList.add('visible');
}

audioPlayer.addEventListener('timeupdate', updateMusicProgressBar);

audioPlayer.addEventListener('pause', () => { 
    if(musicState.isActive) { 
        musicState.isPlaying = false; 
        updatePlayerUI(); 
    } 
});
audioPlayer.addEventListener('play', () => { 
    if(musicState.isActive) { 
        musicState.isPlaying = true; 
        updatePlayerUI(); 
    } 
});

document.getElementById('playlist-body').addEventListener('click', async (e) => {
    const target = e.target;
    if (target.classList.contains('delete-track-btn')) {
        const index = parseInt(target.dataset.index);
        const track = musicState.playlist[index];
        const confirmed = await showCustomConfirm('刪除歌曲', `確定要從播放清單中刪除《${track.name}》嗎？`);
        if (confirmed) {
            deleteTrack(index);
        }
        return;
    }
    // ▼▼▼ 在 lyrics-btn 的判斷邏輯【上方】，添加這段新代碼 ▼▼▼
            if (target.classList.contains('cover-btn')) {
                const index = parseInt(target.dataset.index);
                if (!isNaN(index)) {
                    handleCoverUpload(index);
                }
                return; // 處理完就退出，避免觸發其他邏輯
            }
// ▲▲▲ 添加結束 ▲▲▲

            // ▼▼▼ 請用這【一整塊新代碼】替換舊的 lyrics-btn 點擊邏輯 ▼▼▼
            if (target.classList.contains('lyrics-btn')) {
                const index = parseInt(target.dataset.index);
                if (isNaN(index)) return;

                // 1. 彈窗詢問使用者選擇（已移除圖示）
                const choice = await showChoiceModal("選擇歌詞來源", [
                    { text: '使用網路URL', value: 'url' },
                    { text: '從本地上傳', value: 'local' }
                ]);

                let lrcContent = null;

                // 2. 根據選擇執行不同操作
                if (choice === 'url') {
                    const url = await showCustomPrompt("歌詞URL", "請輸入.lrc歌詞檔的網路連結");
                    if (url && url.trim()) {
                        try {
                            const response = await fetch(url.trim());
                            if (response.ok) {
                                lrcContent = await response.text();
                            } else {
                                alert('無法獲取歌詞檔，請檢查URL是否正確。');
                            }
                        } catch (error) {
                            alert('獲取歌詞失敗: ' + error.message);
                        }
                    }
                } else if (choice === 'local') {
                    lrcContent = await new Promise(resolve => {
                        const lrcInput = document.getElementById('lrc-upload-input');
                        const handler = (event) => {
                            const file = event.target.files[0];
                            if (file) {
                                const reader = new FileReader();
                                reader.onload = (re) => resolve(re.target.result);
                                reader.readAsText(file);
                            } else {
                                resolve(null);
                            }
                            lrcInput.removeEventListener('change', handler);
                            lrcInput.value = '';
                        };
                        lrcInput.addEventListener('change', handler);
                        lrcInput.click();
                    });
                }

                // 3. 如果成功獲取到歌詞，就保存並更新
                if (lrcContent !== null) {
                    musicState.playlist[index].lrcContent = lrcContent;
                    await saveGlobalPlaylist();
                    alert('歌詞導入成功！');
                    if (musicState.currentIndex === index) {
                        musicState.parsedLyrics = parseLRC(lrcContent);
                        renderLyrics();
                    }
                }
            }
            // ▲▲▲ 替換結束 ▲▲▲
});

document.querySelector('.progress-bar').addEventListener('click', (e) => {
    if (!audioPlayer.duration) return;
    const progressBar = e.currentTarget;
    const barWidth = progressBar.clientWidth;
    const clickX = e.offsetX;
    audioPlayer.currentTime = (clickX / barWidth) * audioPlayer.duration;
});

// ▼▼▼ 在 init() 函數的事件監聽器區域，黏貼這段新代碼 ▼▼▼

// 使用事件委託來處理所有“已撤回消息”的點擊事件
document.getElementById('chat-messages').addEventListener('click', (e) => {
    // 檢查被點擊的元素或其父元素是否是“已撤回”提示
    const placeholder = e.target.closest('.recalled-message-placeholder');
    if (!placeholder) return; // 如果不是，就退出

    // 如果是，就從聊天記錄中找到對應的資料並顯示
    const chat = state.chats[state.activeChatId];
    const wrapper = placeholder.closest('.message-wrapper'); // 找到它的父容器
    if (chat && wrapper) {
        // 從父容器上找到時間戳記
        const timestamp = parseInt(wrapper.dataset.timestamp);
        const recalledMsg = chat.history.find(m => m.timestamp === timestamp);
        
        if (recalledMsg && recalledMsg.recalledData) {
            let originalContentText = '';
            const recalled = recalledMsg.recalledData;
            
            if (recalled.originalType === 'text') {
                originalContentText = `原文: "${recalled.originalContent}"`;
            } else {
                originalContentText = `撤回了一條[${recalled.originalType}]類型的消息`;
            }
            showCustomAlert('已撤回的消息', originalContentText);
        }
    }
});

// ▲▲▲ 新代碼黏貼結束 ▲▲▲

// ▼▼▼ 在 init() 的事件監聽器區域，黏貼這段新代碼 ▼▼▼
document.getElementById('manage-world-book-categories-btn').addEventListener('click', openCategoryManager);
document.getElementById('close-category-manager-btn').addEventListener('click', () => {
    document.getElementById('world-book-category-manager-modal').classList.remove('visible');
    renderWorldBookScreen(); // 關閉後刷新主列表
});
document.getElementById('add-new-category-btn').addEventListener('click', addNewCategory);
document.getElementById('existing-categories-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-group-btn')) {
        const categoryId = parseInt(e.target.dataset.id);
        deleteCategory(categoryId);
    }
});
// ▲▲▲ 新代碼黏貼結束 ▲▲▲

// --- ▼▼▼ 【全新】自訂頭像框功能事件綁定 ▼▼▼ ---

// 打開“選擇”彈窗的按鈕
document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
    if (e.target.classList.contains('change-frame-btn')) {
        openFrameSelectorModal(e.target.dataset.type);
    }
});
document.getElementById('member-settings-modal').addEventListener('click', (e) => {
    if (e.target.classList.contains('change-frame-btn')) {
        openFrameSelectorModal('member', editingMemberId);
    }
});

// “選擇”彈窗內的按鈕
// “選擇”彈窗內的按鈕（已修正）
document.getElementById('manage-custom-frames-btn').addEventListener('click', () => {
    // 1. 先關閉當前的選擇彈窗
    document.getElementById('avatar-frame-modal').classList.remove('visible');
    
    // 2. 然後再打開管理彈窗
    openFrameManager();
});
document.getElementById('cancel-frame-settings-btn').addEventListener('click', () => document.getElementById('avatar-frame-modal').classList.remove('visible'));
document.getElementById('save-frame-settings-btn').addEventListener('click', saveSelectedFrames);

// “管理”彈窗內的按鈕
document.getElementById('upload-custom-frame-btn').addEventListener('click', handleUploadCustomFrame);
document.getElementById('close-frame-manager-btn').addEventListener('click', () => {
    document.getElementById('custom-frame-manager-modal').classList.remove('visible');
    // 關閉管理後，刷新選擇介面，因為清單可能變了
    openFrameSelectorModal(currentFrameSelection.type, currentFrameSelection.target);
});

// ▲▲▲ 新事件綁定結束 ▲▲▲

// ▼▼▼ 【全新】聊天清單左滑功能JS邏輯 ▼▼▼
const chatListEl = document.getElementById('chat-list');
let chatSwipeState = { isDragging: false, startX: 0, activeContent: null };

// 關閉所有已滑開的項
function resetAllChatSwipes(exceptThisOne = null) {
    document.querySelectorAll('.chat-list-item-content.swiped').forEach(content => {
        if (content !== exceptThisOne) {
            content.classList.remove('swiped');
        }
    });
}

chatListEl.addEventListener('mousedown', (e) => {
    const content = e.target.closest('.chat-list-item-content');
    if (content) {
        resetAllChatSwipes(content);
        chatSwipeState.isDragging = true;
        chatSwipeState.startX = e.pageX;
        chatSwipeState.activeContent = content;
        // 阻止拖動時選中文本
        e.preventDefault();
    }
});

document.addEventListener('mousemove', (e) => {
    if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;
    const diffX = e.pageX - chatSwipeState.startX;
    if (diffX < 0 && diffX > -170) { // 只允許向左滑, 限制最大距離
        chatSwipeState.activeContent.style.transition = 'none'; // 滑動時禁用動畫
        chatSwipeState.activeContent.style.transform = `translateX(${diffX}px)`;
    }
});

document.addEventListener('mouseup', (e) => {
    if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;
    
    chatSwipeState.activeContent.style.transition = 'transform 0.3s ease';
    const transformStyle = window.getComputedStyle(chatSwipeState.activeContent).transform;
    const currentTranslateX = new DOMMatrix(transformStyle).m41;

    if (currentTranslateX < -60) { // 滑動超過閾值
        chatSwipeState.activeContent.classList.add('swiped');
    } else {
        chatSwipeState.activeContent.classList.remove('swiped');
    }
    chatSwipeState.activeContent.style.transform = ''; // 清除內聯樣式，交由CSS class控制

    // 重置狀態
    chatSwipeState.isDragging = false;
    chatSwipeState.activeContent = null;
});

// 移動端觸摸事件的相容
chatListEl.addEventListener('touchstart', (e) => {
     const content = e.target.closest('.chat-list-item-content');
    if (content) {
        resetAllChatSwipes(content);
        chatSwipeState.isDragging = true;
        chatSwipeState.startX = e.touches[0].pageX;
        chatSwipeState.activeContent = content;
    }
}, { passive: true });

chatListEl.addEventListener('touchmove', (e) => {
    if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;
    const diffX = e.touches[0].pageX - chatSwipeState.startX;
     if (diffX < 0 && diffX > -170) {
        chatSwipeState.activeContent.style.transition = 'none';
        chatSwipeState.activeContent.style.transform = `translateX(${diffX}px)`;
    }
}, { passive: true });

chatListEl.addEventListener('touchend', (e) => {
    if (!chatSwipeState.isDragging || !chatSwipeState.activeContent) return;
    
    chatSwipeState.activeContent.style.transition = 'transform 0.3s ease';
    const transformStyle = window.getComputedStyle(chatSwipeState.activeContent).transform;
    const currentTranslateX = new DOMMatrix(transformStyle).m41;

    if (currentTranslateX < -60) {
        chatSwipeState.activeContent.classList.add('swiped');
    } else {
        chatSwipeState.activeContent.classList.remove('swiped');
    }
    chatSwipeState.activeContent.style.transform = '';

    chatSwipeState.isDragging = false;
    chatSwipeState.activeContent = null;
});
// ▲▲▲ 新JS邏輯黏貼結束 ▲▲▲

// ▼▼▼ 【全新】聊天清單操作按鈕點擊事件 ▼▼▼
chatListEl.addEventListener('click', async (e) => {
    const target = e.target;
    if (target.classList.contains('swipe-action-btn')) {
        const container = target.closest('.chat-list-item-swipe-container');
        if (!container) return;

        const chatId = container.dataset.chatId;
        const chat = state.chats[chatId];
        if (!chat) return;

        if (target.classList.contains('pin') || target.classList.contains('unpin')) {
            // 置頂或取消置頂
            chat.isPinned = !chat.isPinned;
            await db.chats.put(chat);
            await renderChatList(); // 重新渲染列表以更新排序
        } else if (target.classList.contains('delete')) {
            // 刪除
            const confirmed = await showCustomConfirm('刪除對話', `確定要刪除與 "${chat.name}" 的整個對話嗎？此操作不可撤銷。`, { confirmButtonClass: 'btn-danger' });
            if (confirmed) {
                if (musicState.isActive && musicState.activeChatId === chat.id) await endListenTogetherSession(false);
                delete state.chats[chat.id];
                if (state.activeChatId === chat.id) state.activeChatId = null;
                await db.chats.delete(chat.id);
                await renderChatList();
            } else {
                // 如果取消刪除，則把滑塊收回去
                const content = container.querySelector('.chat-list-item-content');
                if (content) content.classList.remove('swiped');
            }
        }
    }
});
// ▲▲▲ 新事件監聽黏貼結束 ▲▲▲
// ▼▼▼ 從這裡開始，把下面這兩塊完整的 eventListener 代碼【剪切】掉 ▼▼▼

// 使用事件委託來處理所有點擊和勾選事件，效率更高
worldBookCheckboxesContainer.addEventListener('click', (e) => {
    const header = e.target.closest('.wb-category-header');
    // 如果點擊的是資料夾頭部，並且不是點在核取方塊上
    if (header && !e.target.matches('input[type="checkbox"]')) {
        const categoryId = header.querySelector('.wb-category-checkbox')?.dataset.categoryId;
        if (categoryId) {
            const bookContainer = worldBookCheckboxesContainer.querySelector(`.wb-book-container[data-container-for="${categoryId}"]`);
            if (bookContainer) {
                header.classList.toggle('collapsed');
                bookContainer.classList.toggle('collapsed');
            }
        }
    }
});

worldBookCheckboxesContainer.addEventListener('change', (e) => {
    const target = e.target;
    
    // 如果點擊的是分類的“全選”核取方塊
    if (target.classList.contains('wb-category-checkbox')) {
        const categoryId = target.dataset.categoryId;
        const isChecked = target.checked;
        // 找到這個分類下的所有書籍核取方塊，並將它們的狀態設置為與分類核取方塊一致
        const bookCheckboxes = worldBookCheckboxesContainer.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
        bookCheckboxes.forEach(cb => cb.checked = isChecked);
    }
    
    // 如果點擊的是單個書籍的核取方塊
    if (target.classList.contains('wb-book-checkbox')) {
        const categoryId = target.dataset.parentCategory;
        if (categoryId) { // 檢查它是否屬於一個分類
            const categoryCheckbox = worldBookCheckboxesContainer.querySelector(`input.wb-category-checkbox[data-category-id="${categoryId}"]`);
            const allBookCheckboxes = worldBookCheckboxesContainer.querySelectorAll(`input.wb-book-checkbox[data-parent-category="${categoryId}"]`);
            // 檢查該分類下是否所有書籍都被選中了
            const allChecked = Array.from(allBookCheckboxes).every(cb => cb.checked);
            // 同步分類“全選”核取方塊的狀態
            if(categoryCheckbox) categoryCheckbox.checked = allChecked;
        }
    }
    
    // 每次變更後都更新頂部的已選數量顯示
    updateWorldBookSelectionDisplay();
});

// ▲▲▲ 把上面這兩塊完整的 eventListener 代碼【剪切】掉 ▲▲▲


    // ▼▼▼ 在 init() 的事件監聽器區域末尾，黏貼下面這一整塊新代碼 ▼▼▼

    // --- 美化功能事件綁定 ---
    const themeEditor = document.getElementById('theme-css-editor');
    
    // 頁面載入時，載入主題清單並顯示範本
    await loadThemesToDropdown();
    themeEditor.value = THEME_CSS_TEMPLATE;

    // 綁定下拉清單選擇事件
    document.getElementById('theme-selector').addEventListener('change', handleThemeSelection);
    
    // 綁定所有操作按鈕
    document.getElementById('apply-theme-btn').addEventListener('click', () => applyThemeCss(themeEditor.value));
    document.getElementById('save-theme-btn').addEventListener('click', saveCurrentTheme);
    document.getElementById('save-as-new-theme-btn').addEventListener('click', saveAsNewTheme);
    document.getElementById('rename-theme-btn').addEventListener('click', renameSelectedTheme);
    document.getElementById('delete-theme-btn').addEventListener('click', deleteSelectedTheme);
    document.getElementById('export-theme-btn').addEventListener('click', exportTheme);
    
    // 綁定導入按鈕和隱藏的檔選擇器
    document.getElementById('import-theme-btn').addEventListener('click', () => {
        document.getElementById('import-theme-input').click();
    });
    document.getElementById('import-theme-input').addEventListener('change', (e) => {
        importTheme(e.target.files[0]);
        e.target.value = null; // 清空，以便下次能選擇同一個文件
    });
    
    // ▲▲▲ 新事件綁定結束 ▲▲▲

document.getElementById('api-preset-select').addEventListener('change', handleApiPresetSelectChange);
document.getElementById('manage-api-presets-btn').addEventListener('click', openApiPresetManager);

            // ▼▼▼ 【全新】鎖屏功能事件監聽器 ▼▼▼

            // 1. 鎖屏壁紙上傳
            document.getElementById('lockscreen-wallpaper-upload-input').addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if(file) {
                    const dataUrl = await new Promise((res, rej) => {
                        const reader = new FileReader();
                        reader.onload = () => res(reader.result);
                        reader.onerror = () => rej(reader.error);
                        reader.readAsDataURL(file);
                    });
                    newLockscreenWallpaperBase64 = dataUrl;
                    renderWallpaperScreen(); // 上傳後即時預覽
                }
            });

            // 2. 密碼輸入框按鈕
            document.getElementById('password-confirm-btn').addEventListener('click', checkPassword);
            document.getElementById('password-cancel-btn').addEventListener('click', hidePasswordModal);
            // 允許在輸入框內按回車鍵確認
            document.getElementById('password-input-field').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    checkPassword();
                }
            });

            // 3. 【全新】帶有動畫效果的上滑解鎖手勢
            const lockScreen = document.getElementById('lock-screen');
            const unlockHint = document.getElementById('unlock-hint');
            let touchStartY = 0;
            let isSwiping = false;

// 統一的開始處理函數
const handleUnlockStart = (e) => {
    if (document.getElementById('password-modal-overlay').classList.contains('visible')) return;
    
    // (你原來的其他邏輯保持不變)
    const blurBg = document.getElementById('lock-screen-background-blur');
    if (state.globalSettings.password) {
        blurBg.style.backgroundImage = lockScreen.style.backgroundImage;
        blurBg.style.display = 'block';
    } else {
        document.getElementById('home-screen').classList.add('active');
    }
    
    touchStartY = getEventCoords(e).y; // 使用輔助函數獲取Y座標
    isSwiping = true;
    lockScreen.style.transition = 'none';
    unlockHint.style.transition = 'none';
};

// 統一的移動處理函數
const handleUnlockMove = (e) => {
    if (!isSwiping) return;
    const currentY = getEventCoords(e).y; // 使用輔助函數
    let diffY = currentY - touchStartY;
    // (你原來的其他邏輯保持不變)
    if (diffY > 0) diffY = 0;
    lockScreen.style.transform = `translateY(${diffY}px)`;
    unlockHint.style.opacity = Math.max(0, 1 - Math.abs(diffY) / 100);
    if (state.globalSettings.password) {
        const blurBg = document.getElementById('lock-screen-background-blur');
        blurBg.style.opacity = Math.min(1, Math.abs(diffY) / 80);
    }
};

// 統一的結束處理函數
const handleUnlockEnd = (e) => {
    if (!isSwiping) return;
    isSwiping = false;

    // (你原來的其他邏輯保持不變)
    lockScreen.style.transition = 'transform 0.3s ease-out';
    unlockHint.style.transition = 'opacity 0.3s ease-out';
    const blurBg = document.getElementById('lock-screen-background-blur');
    
    // 注意：touchend事件的座標在 e.changedTouches[0]
    const touchEndY = e.changedTouches ? e.changedTouches[0].clientY : e.pageY;
    const swipeDistance = touchStartY - touchEndY;
    
    if (swipeDistance > 80) {
        lockScreen.style.transform = 'translateY(-100%)';
        setTimeout(() => {
            if (state.globalSettings.password) {
                showPasswordModal();
            } else {
                unlockPhone();
            }
        }, 300);
    } else {
        lockScreen.style.transform = 'translateY(0)';
        unlockHint.style.opacity = '1';
        if (state.globalSettings.password) {
            blurBg.style.opacity = '0';
            setTimeout(() => { blurBg.style.display = 'none'; }, 300);
        } else {
            document.getElementById('home-screen').classList.remove('active');
        }
    }
};

// 2. 綁定兩種事件到同一套處理邏輯上
lockScreen.addEventListener('touchstart', handleUnlockStart, { passive: true });
lockScreen.addEventListener('touchmove', handleUnlockMove, { passive: true });
lockScreen.addEventListener('touchend', handleUnlockEnd, { passive: true });

lockScreen.addEventListener('mousedown', handleUnlockStart);
// 注意：mousemove和mouseup最好綁定在document上，防止滑鼠拖出範圍後失效
document.addEventListener('mousemove', handleUnlockMove);
document.addEventListener('mouseup', handleUnlockEnd);
            
            // ▲▲▲ 新事件監聽器黏貼結束 ▲▲▲

// 【全新】為聊天底部工具列添加滑鼠拖動滾動功能
const actionsTopBar = document.getElementById('chat-input-actions-top');
let isDown = false;
let startX;
let scrollLeft;

actionsTopBar.addEventListener('mousedown', (e) => {
    isDown = true;
    actionsTopBar.classList.add('grabbing'); // 添加一個class來改變滑鼠樣式
    startX = e.pageX - actionsTopBar.offsetLeft;
    scrollLeft = actionsTopBar.scrollLeft;
});

actionsTopBar.addEventListener('mouseleave', () => {
    isDown = false;
    actionsTopBar.classList.remove('grabbing');
});

actionsTopBar.addEventListener('mouseup', () => {
    isDown = false;
    actionsTopBar.classList.remove('grabbing');
});

actionsTopBar.addEventListener('mousemove', (e) => {
    if (!isDown) return;
    e.preventDefault();
    const x = e.pageX - actionsTopBar.offsetLeft;
    const walk = (x - startX) * 2; // 乘以2可以增加拖動速度，感覺更靈敏
    actionsTopBar.scrollLeft = scrollLeft - walk;
});

// ▼▼▼ 在 init() 的事件監聽器區域末尾，黏貼這段新代碼 ▼▼▼
document.getElementById('location-cancel-btn').addEventListener('click', () => {
    document.getElementById('send-location-modal').classList.remove('visible');
});
document.getElementById('location-confirm-btn').addEventListener('click', sendUserLocation);
// ▲▲▲ 新代碼黏貼結束 ▲▲▲

// ▼▼▼ 在 init() 的事件監聽器區域末尾，黏貼這段新代碼 ▼▼▼

// 【全新】為定位模態框的“添加途經點”按鈕綁定事件
document.getElementById('add-trajectory-point-btn').addEventListener('click', () => {
    // 限制最多添加3個途經點，防止UI過於擁擠
    if (document.querySelectorAll('.trajectory-point-input').length < 3) {
        addTrajectoryPointInput();
    } else {
        alert("最多只能添加3個途經點哦！");
    }
});

// 【新增】打開定位模態框時，清空舊的途經點
document.getElementById('send-location-btn').addEventListener('click', () => {
    document.getElementById('trajectory-points-container').innerHTML = '';
    document.getElementById('send-location-modal').classList.add('visible');
});

// ▲▲▲ 新代碼黏貼結束 ▲▲▲

// ▼▼▼ 在這裡黏貼下面這行新代碼 ▼▼▼
document.getElementById('reroll-btn').addEventListener('click', handleRerollClick);
// ▲▲▲ 黏貼結束 ▲▲▲

// ▼▼▼ 【全新】黏貼這整塊事件監聽代碼到 init() 末尾 ▼▼▼

// --- 懸浮歌詞欄設置功能 ---
document.getElementById('lyrics-settings-btn').addEventListener('click', (e) => {
    e.stopPropagation(); // 阻止事件冒泡觸發拖動或打開播放機
    document.getElementById('lyrics-settings-modal').classList.add('visible');
});

document.getElementById('close-lyrics-settings-btn').addEventListener('click', async () => {
    // 保存設置到全域狀態並寫入資料庫
    state.globalSettings.lyricsBarSettings = lyricsBarSettings;
    await db.globalSettings.put(state.globalSettings);
    document.getElementById('lyrics-settings-modal').classList.remove('visible');
    alert('設置已保存！');
});

document.getElementById('reset-lyrics-settings-btn').addEventListener('click', () => {
    // 恢復到預設值
    lyricsBarSettings = { fontSize: 14, bgOpacity: 0, fontColor: '#FFFFFF', showOnClose: true };
    applyLyricsSettings(); // 應用默認設置
});

// 即時更新樣式
document.getElementById('lyrics-font-size-slider').addEventListener('input', (e) => {
    lyricsBarSettings.fontSize = e.target.value;
    applyLyricsSettings();
});
document.getElementById('lyrics-bg-opacity-slider').addEventListener('input', (e) => {
    lyricsBarSettings.bgOpacity = e.target.value;
    applyLyricsSettings();
});
document.getElementById('lyrics-font-color-picker').addEventListener('input', (e) => {
    lyricsBarSettings.fontColor = e.target.value;
    applyLyricsSettings();
});

// 歌詞欄上的關閉按鈕
document.querySelector('#floating-lyrics-bar .close-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    document.getElementById('floating-lyrics-bar').style.display = 'none';
});

// 播放機裡的“懸浮/隱藏”開關
document.getElementById('toggle-lyrics-bar-btn').addEventListener('click', async (e) => {
    lyricsBarSettings.showOnClose = !lyricsBarSettings.showOnClose;
    e.target.textContent = lyricsBarSettings.showOnClose ? '懸浮' : '隱藏';
    e.target.style.opacity = lyricsBarSettings.showOnClose ? '1' : '0.5';
    // 立即保存這個設置
    state.globalSettings.lyricsBarSettings = lyricsBarSettings;
    await db.globalSettings.put(state.globalSettings);
});

// 【重要】在頁面載入時，就應用一次已保存的設置
applyLyricsSettings();

// ▲▲▲ 新代碼黏貼結束 ▲▲▲

            // ▼▼▼ 【全新】“查角色手機”功能事件監聽器 ▼▼▼

            // 1. 綁定主螢幕上的“查手機”APP圖示
            const checkPhoneAppIcon = document.querySelector('.app-icon[data-app-id="check-phone"]');
            if (checkPhoneAppIcon) {
                checkPhoneAppIcon.onclick = openCharacterSelectionScreen; // 修改onclick事件
            }

            // 2. 角色選擇列表的點擊事件 (事件委託)
            document.getElementById('character-selection-list').addEventListener('click', (e) => {
                const item = e.target.closest('.character-select-item');
                if (item && item.dataset.chatId) {
                    openCharacterPhone(item.dataset.chatId);
                }
            });
// ▼▼▼ 請用這整塊代碼替換 ▼▼▼
// 【V3版】角色手機聊天列表的點擊事件 (事件委託)
document.getElementById('character-chat-list').addEventListener('click', (e) => {
    const item = e.target.closest('.chat-list-item');
    if (item && item.dataset.contactName) {
        // ▼▼▼ 在這裡黏貼探針 #2 ▼▼▼
        const isUserChat = item.dataset.isUserChat === 'true';
        console.log("【診斷日誌 2】: 點擊了聊天列表項", {
            contactName: item.dataset.contactName,
            isUserChat: isUserChat
        });
        // ▲▲▲ 探針結束 ▲▲▲
        
        // 將連絡人名字和“身份證”一起傳遞給渲染函數
        renderCharacterChatHistory(item.dataset.contactName, isUserChat);
        showCharacterPhonePage('character-chat-history-screen');
    }
});
// ▲▲▲ 替換結束 ▲▲▲



            // 3. 角色手機頂部的“刷新”和“清空”按鈕
            document.getElementById('generate-character-data-btn').addEventListener('click', generateCharacterPhoneData);
            document.getElementById('clear-character-data-btn').addEventListener('click', clearCharacterPhoneData);

            // ▲▲▲ 事件監聽器添加結束 ▲▲▲

            // ▼▼▼ 【全新】角色手機內部統一返回事件監聽器 ▼▼▼
            document.getElementById('character-phone-container').addEventListener('click', (e) => {
                const backBtn = e.target.closest('.back-btn');
                if (!backBtn) return;

                // 檢查是返回到角色手機內部頁面，還是返回到主螢幕
                if (backBtn.dataset.targetPage) {
                    showCharacterPhonePage(backBtn.dataset.targetPage);
                } else if (backBtn.dataset.targetScreen) {
                    showScreen(backBtn.dataset.targetScreen);
                }
            });
            // ▲▲▲ 新代碼黏貼結束 ▲▲▲

            // ▼▼▼ 【全新】角色手機日記APP事件監聽器 ▼▼▼
            document.getElementById('character-app-grid').addEventListener('click', (e) => {
                const icon = e.target.closest('.app-icon');
                if (icon && icon.querySelector('.label').textContent === '日記') {
                    renderCharacterDiary();
                }
            });
            document.getElementById('generate-diary-entry-btn').addEventListener('click', generateNewDiaryEntry);
            // ▲▲▲ 新代碼黏貼結束 ▲▲▲
// ▼▼▼ 【全新】“查手機”內容單條刪除功能事件綁定 ▼▼▼
document.getElementById('character-phone-container').addEventListener('click', (e) => {
    const deleteBtn = e.target.closest('.item-delete-btn');
    if (deleteBtn) {
        // 【新增】處理微信消息刪除
        if (deleteBtn.classList.contains('message-delete-btn')) {
            const contactName = deleteBtn.dataset.contactName;
            const index = parseInt(deleteBtn.dataset.index);
            if (contactName && !isNaN(index)) {
                handleCharacterChatMessageDeletion(contactName, index);
            }
        } 
        // 處理其他列表刪除
        else {
            const dataType = deleteBtn.dataset.type;
            const index = parseInt(deleteBtn.dataset.index);
            if (dataType && !isNaN(index)) {
                handleCharacterDataDeletion(dataType, index);
            }
        }
    }
});
// ▲▲▲ 刪除功能事件綁定結束 ▲▲▲

// ▼▼▼ 【全新】NPC庫管理功能事件綁定 ▼▼▼

// 聊天設置裡的“管理NPC庫”按鈕
document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
    if (e.target.id === 'manage-npcs-btn') {
        // 先關閉聊天設置，再打開NPC管理
        document.getElementById('chat-settings-modal').classList.remove('visible');
        openNpcManager();
    }
});

// NPC管理介面的返回按鈕
document.getElementById('back-from-npc-management').addEventListener('click', () => {
    // 返回時，重新打開聊天設置
    showScreen('chat-interface-screen');
    document.getElementById('chat-settings-btn').click();
});

// NPC管理介面的“+”按鈕
document.getElementById('add-new-npc-btn').addEventListener('click', () => openNpcEditor(null));



// ▼▼▼ 【全新】黏貼這整塊事件監聽器代碼 ▼▼▼
// --- 後臺活動設置介面的事件綁定 ---

// 1. 總開關的事件
document.getElementById('background-activity-switch').addEventListener('change', () => {
    // 每次點擊總開關，都重新渲染一次詳細設置區（它會根據開關狀態自動顯示或隱藏）
    renderBackgroundFrequencySelector();
});

// 2. 全選按鈕
document.getElementById('bg-select-all-chars').addEventListener('click', () => {
    document.querySelectorAll('.bg-char-checkbox').forEach(checkbox => {
        checkbox.checked = true;
    });
});

// 3. 全不選按鈕
document.getElementById('bg-deselect-all-chars').addEventListener('click', () => {
    document.querySelectorAll('.bg-char-checkbox').forEach(checkbox => {
        checkbox.checked = false;
    });
});

// 這是修復後的新代碼塊，用它替換掉舊的
document.querySelector('#background-activity-details').addEventListener('click', async (e) => { // 注意這里加了 async
    if (e.target.classList.contains('bg-freq-btn')) {
        const freq = e.target.dataset.freq;
        const selectedCheckboxes = document.querySelectorAll('.bg-char-checkbox:checked');
        
        if (selectedCheckboxes.length === 0) {
            alert('請先選擇至少一個角色！');
            return;
        }

        const config = state.globalSettings.backgroundActivityConfig || {};
        selectedCheckboxes.forEach(checkbox => {
            const chatId = checkbox.dataset.chatId;
            if (freq === 'none') {
                delete config[chatId];
            } else {
                config[chatId] = freq;
            }
        });
        
        state.globalSettings.backgroundActivityConfig = config;
        
        // ★★★★★ 這就是我們新加的關鍵代碼！★★★
        await db.globalSettings.put(state.globalSettings);
        // ★★★★★ 添加結束 ★★★★★
        
        renderBackgroundFrequencySelector();

        const freqTextMap = {low:'低', medium:'中', high:'高', none: '關閉'};
        const freqText = freqTextMap[freq];
        alert(`已為 ${selectedCheckboxes.length} 個角色將後臺活動頻率設為 "${freqText}"`);
    }
});
// 使用事件委託，為所有可編輯元素統一綁定點擊事件
// ▼▼▼ 用這塊【功能增強版】的代碼替換舊的 ▼▼▼
// 使用事件委託，為所有可編輯元素統一綁定點擊事件
document.getElementById('home-screen').addEventListener('click', async (e) => { // <-- 把這行也改成 async
    // 【核心修正】使用 .closest() 來確保即使點擊到子元素也能正確觸發
    const editableText = e.target.closest('.editable-text');
    if (editableText) {
        handleEditText(editableText);
        return; // 處理完就退出，避免重複觸發
    }

    const editableImage = e.target.closest('.editable-image');
    if (editableImage) {
        // --- ▼▼▼ 這就是我們本次修改的核心代碼 ▼▼▼ ---
        // 1. 判斷被點擊的圖片是不是主螢幕的那個大頭像
        if (editableImage.id === 'profile-avatar-img') {
            // 2. 如果是，就彈出一個選擇功能表
            const choice = await showChoiceModal("編輯頭像", [
                { text: '更換頭像圖片', value: 'avatar' },
                { text: '更換頭像框', value: 'frame' }
            ]);
            
            // 3. 根據使用者的選擇，執行不同的操作
            if (choice === 'avatar') {
                handleEditImage(editableImage); // 調用原來的更換圖片函數
            } else if (choice === 'frame') {
                openFrameSelectorModal('home_profile'); // 調用我們新增的更換頭像框函數
            }
        } else {
            // 4. 如果點擊的不是主頭像（比如是其他小元件的圖片），就還執行原來的邏輯
            handleEditImage(editableImage);
        }
        // --- ▲▲▲ 核心代碼修改結束 ▲▲▲ ---
        return;
    }
});
// ▲▲▲ 替換結束 ▲▲▲


// ▼▼▼ 【全新】“查手機”內容單條刪除功能 ▼▼▼
/**
 * 處理角色手機內資料刪除的通用函數
 * @param {string} dataType - 要刪除的資料類型, 比如 'memos', 'shoppingCart'
 * @param {number} index - 要刪除的資料在陣列中的索引
 */
async function handleCharacterDataDeletion(dataType, index) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    
    let dataArray;
    // 【核心修改】處理像 bank.transactions 這樣的嵌套數據
    if (dataType.includes('.')) {
        const keys = dataType.split('.');
        dataArray = chat.characterPhoneData[keys[0]][keys[1]];
    } else {
        dataArray = chat.characterPhoneData[dataType];
    }

    if (!chat || !dataArray) return;

    const itemToDelete = dataArray[index];
    if (!itemToDelete) return;

    const confirmed = await showCustomConfirm(
        '確認刪除',
        '確定要刪除這條記錄嗎？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        dataArray.splice(index, 1);
        await db.chats.put(chat);
        
        // 根據刪除的類型，重新渲染對應的APP介面
        switch(dataType) {
            case 'memos': renderCharacterMemos(); break;
            case 'shoppingCart': renderCharacterShoppingCart(); break;
            case 'browserHistory': renderCharacterBrowser(); break;
            case 'diary': renderCharacterDiary(); break;
            case 'bank.transactions': renderCharacterBank(); break; // 新增
            case 'trajectory': renderCharacterTrajectory(); break;   // 新增
            case 'appUsage': renderCharacterAppUsage(); break;       // 新增
            case 'photoAlbum': renderCharacterPhotoAlbum(); break;   // 新增
        }
        alert('記錄已刪除。');
    }
}
// 使用事件委託來處理所有刪除按鈕的點擊
document.getElementById('character-phone-container').addEventListener('click', (e) => {
    if (e.target.classList.contains('item-delete-btn')) {
        const dataType = e.target.dataset.type;
        const index = parseInt(e.target.dataset.index);
        if (dataType && !isNaN(index)) {
            handleCharacterDataDeletion(dataType, index);
        }
    }
});
// ▲▲▲ 刪除功能結束 ▲▲▲
// ▼▼▼ 【全新】“查手機”內容單條刪除功能 ▼▼▼
/**
 * 處理角色手機內資料刪除的通用函數
 * @param {string} dataType - 要刪除的資料類型, 比如 'memos', 'shoppingCart'
 * @param {number} index - 要刪除的資料在陣列中的索引
 */
async function handleCharacterDataDeletion(dataType, index) {
    if (!activeCharacterPhoneId) return;
    const chat = state.chats[activeCharacterPhoneId];
    
    let dataArray;
    // 處理像 bank.transactions 這樣的嵌套數據
    if (dataType.includes('.')) {
        const keys = dataType.split('.');
        dataArray = chat.characterPhoneData[keys[0]][keys[1]];
    } else {
        dataArray = chat.characterPhoneData[dataType];
    }

    if (!chat || !dataArray) return;

    const itemToDelete = dataArray[index];
    if (!itemToDelete) return;

    const confirmed = await showCustomConfirm(
        '確認刪除',
        '確定要刪除這條記錄嗎？',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        dataArray.splice(index, 1);
        await db.chats.put(chat);
        
        // 根據刪除的類型，重新渲染對應的APP介面
        switch(dataType) {
            case 'memos': renderCharacterMemos(); break;
            case 'shoppingCart': renderCharacterShoppingCart(); break;
            case 'browserHistory': renderCharacterBrowser(); break;
            case 'diary': renderCharacterDiary(); break;
            case 'bank.transactions': renderCharacterBank(); break;
            case 'trajectory': renderCharacterTrajectory(); break;
            case 'appUsage': renderCharacterAppUsage(); break;
            case 'photoAlbum': renderCharacterPhotoAlbum(); break;
        }
        alert('記錄已刪除。');
    }
}
// ▲▲▲ 刪除功能結束 ▲▲▲
startGroupSimulation(); // 啟動群聊專屬的後臺時鐘
// ▲▲▲ 新事件綁定結束 ▲▲▲
    // ▼▼▼ 步驟3.3：在 init() 的前面黏貼這段新代碼 ▼▼▼
    // 使用事件委託，監聽整個動態清單的“焦點移出”事件
    document.getElementById('qzone-posts-list').addEventListener('focusout', (e) => {
        // 如果是評論輸入框失去了焦點
        if (e.target.classList.contains('comment-input')) {
            const commentInput = e.target;
            // 並且輸入框是空的
            if (commentInput.value.trim() === '') {
                // 就重置它的狀態，取消回復
                commentInput.placeholder = '友善的評論是交流的起點';
                delete commentInput.dataset.replyTo;
            }
        }
    });
    // ▲▲▲ 步驟3.3黏貼結束 ▲▲▲
// ▼▼▼ 把這一整塊代碼，黏貼到 init(); 的正上方 ▼▼▼
// 【全新】為時間感知開關添加即時交互事件
document.getElementById('time-perception-toggle').addEventListener('change', (e) => {
    const customTimeContainer = document.getElementById('custom-time-container');
    customTimeContainer.style.display = e.target.checked ? 'none' : 'block';
});
// ▲▲▲ 黏貼結束 ▲▲▲
// 請用這段新代碼替換上面的錯誤代碼
document.getElementById('char-heart-btn').addEventListener('click', openInnerVoiceModal);

document.getElementById('close-inner-voice-modal').addEventListener('click', () => {
    document.getElementById('inner-voice-modal').classList.remove('visible');
});
document.getElementById('inner-voice-history-btn').addEventListener('click', toggleInnerVoiceHistory);
document.getElementById('back-from-history-btn').addEventListener('click', toggleInnerVoiceHistory);
// ▲▲▲ 心聲功能事件監聽器結束 ▲▲▲
// ▼▼▼ 把下面這一整塊新函數，黏貼到你的JS功能函式定義區 ▼▼▼

/**
 * 【全新】匯出當前角色的聊天記錄
 */
async function exportChatHistory() {
    if (!state.activeChatId) return;
    const chat = state.chats[state.activeChatId];
    if (!chat) return;

    // 1. 創建一個隻包含聊天記錄和角色名的物件
    const exportData = {
        characterName: chat.name,
        exportedAt: new Date().toISOString(),
        history: chat.history
    };

    // 2. 將這個物件轉換為格式化的JSON字串
    const jsonString = JSON.stringify(exportData, null, 2);
    
    // 3. 創建一個Blob物件
    const blob = new Blob([jsonString], { type: 'application/json' });
    
    // 4. 創建一個臨時的下載連結
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    
    // 5. 設置下載連結的屬性，包括檔案名
    const dateStr = new Date().toISOString().split('T')[0];
    link.href = url;
    link.download = `[${chat.name}]-聊天記錄-${dateStr}.json`;
    
    // 6. 模擬點選連結來觸發下載
    document.body.appendChild(link);
    link.click();
    
    // 7. 清理臨時創建的元素和URL
    document.body.removeChild(link);
    URL.revokeObjectURL(url);

    await showCustomAlert('匯出成功', `與“${chat.name}”的聊天記錄已開始下載！`);
}

/**
 * 【全新】導入聊天記錄到當前角色
 */
async function importChatHistory(file) {
    if (!file) return;
    if (!state.activeChatId) return;
    
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);

            // 關鍵驗證：檢查導入的檔是否包含一個名為 'history' 的陣列
            if (!data.history || !Array.isArray(data.history)) {
                throw new Error("檔案格式不正確，缺少有效的'history'資料。");
            }

            const chat = state.chats[state.activeChatId];
            
            // 安全警告：提醒使用者這將覆蓋現有記錄
            const confirmed = await showCustomConfirm(
                '確認導入',
                `這將會【覆蓋】你與“${chat.name}”的當前所有聊天記錄。此操作無法撤銷，確定要繼續嗎？`,
                { confirmButtonClass: 'btn-danger' }
            );

            if (confirmed) {
                // 替換歷史記錄
                chat.history = data.history;
                // 保存到資料庫
                await db.chats.put(chat);
                // 刷新介面
                renderChatInterface(state.activeChatId);
                renderChatList(); // 刷新清單以更新最後一條消息
                await showCustomAlert('導入成功', '聊天記錄已成功導入並覆蓋！');
            }
        } catch (error) {
            console.error("導入聊天記錄失敗:", error);
            await showCustomAlert('導入失敗', `無法導入檔，請檢查檔是否為正確的聊天記錄備份檔案。\n\n錯誤: ${error.message}`);
        }
    };
    reader.readAsText(file, 'UTF-8');
}

// ▲▲▲ 新函數黏貼結束 ▲▲▲
// ▼▼▼ 【全新】氣泡樣式預設導入/匯出功能 ▼▼▼

/**
 * 匯出當前選中的氣泡樣式預設
 */
async function exportSelectedBubblePreset() {
    const selectEl = document.getElementById('bubble-style-preset-select');
    const selectedId = parseInt(selectEl.value);

    if (!selectedId) {
        alert("請先從下拉清單中選擇一個要匯出的預設。");
        return;
    }

    const preset = await db.bubbleStylePresets.get(selectedId);
    if (!preset) {
        alert("找不到選中的預設。");
        return;
    }

    // 準備要匯出的數據
    const exportData = {
        presetName: preset.name,
        presetCss: preset.css
    };

    // 創建並觸發下載
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `[EPhone氣泡]${preset.name}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

/**
 * 處理導入的氣泡樣式預設檔
 * @param {File} file - 用戶選擇的.json文件
 */
function importBubblePreset(file) {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async (e) => {
        try {
            const data = JSON.parse(e.target.result);
            // 驗證檔內容是否正確
            if (data.presetName && typeof data.presetCss !== 'undefined') {
                const newPreset = {
                    name: `${data.presetName} (導入)`,
                    css: data.presetCss
                };
                const newId = await db.bubbleStylePresets.add(newPreset);

                if (!state.bubbleStylePresets) state.bubbleStylePresets = [];
                state.bubbleStylePresets.push({ id: newId, ...newPreset });

                // 刷新下拉清單並自動選中新導入的預設
                renderBubblePresetSelector();
                document.getElementById('bubble-style-preset-select').value = newId;
                handlePresetSelectChange();
                await showCustomAlert('導入成功', `氣泡預設 "${newPreset.name}" 已成功導入！`);
            } else {
                alert("導入失敗：檔案格式不正確。");
            }
        } catch (error) {
            alert(`導入失敗：檔解析錯誤。 ${error.message}`);
        }
    };
    reader.readAsText(file);
}

// ▲▲▲ 新增功能函數結束 ▲▲▲

// ▼▼▼ 用這【一整塊】代碼，替換掉所有舊的、和微博相關的事件監聽器 ▼▼▼

// ▼▼▼ 請用下面這【一整塊】代碼，完整替換掉上面那段舊代碼 ▼▼▼
document.getElementById('weibo-app-icon').addEventListener('click', () => {
    renderWeiboProfile(); // 渲染個人資料
    renderMyWeiboFeed(); // <-- 就是新增了這一行！主動渲染“我的微博”列表
    switchToWeiboView('weibo-my-profile-view'); // 預設顯示“我的微博”
    showScreen('weibo-screen');
});
// ▲▲▲ 替換結束 ▲▲▲


// 2. 綁定微博頁面內的各種點擊事件 (使用事件委託)
document.getElementById('weibo-screen').addEventListener('click', async (e) => {
    // --- 【全新】處理微博帖子中頭像點擊的邏輯 ---
    const avatarWrapper = e.target.closest('.weibo-post-avatar-clickable');
    if (avatarWrapper) {
        const charId = avatarWrapper.dataset.charId;
        // 如果點擊的不是用戶自己，就打開TA的主頁
        if (charId && charId !== 'user') {
            openWeiboCharProfile(charId);
        }
        return; // 處理完就結束，不再執行後面的邏輯
    }
    
    // ▲▲▲ 新代碼黏貼結束 ▲▲▲
    const target = e.target;
// ▼▼▼ 在這裡黏貼新代碼 ▼▼▼
            // ▼▼▼ 在 'const target = e.target;' 的下一行，黏貼下面這整塊新代碼 ▼▼▼

            // --- 【全新】處理熱搜和廣場帖子的刪除按鈕 ---
            const deleteBtn = target.closest('.weibo-post-delete-btn');
            if (deleteBtn) {
                const postItem = deleteBtn.closest('.weibo-post-item');
                if (postItem) {
                    // 先給用戶一個確認的機會，防止誤刪
                    const confirmed = await showCustomConfirm(
                        '刪除動態',
                        '確定要刪除這條動態嗎？（此操作僅在本頁面生效）',
                        { confirmButtonClass: 'btn-danger' }
                    );
                    
                    if (confirmed) {
                        // 如果用戶確認，就播放一個好看的消失動畫，然後移除帖子
                        postItem.style.transition = 'opacity 0.3s, transform 0.3s';
                        postItem.style.opacity = '0';
                        postItem.style.transform = 'scale(0.95)';
                        setTimeout(() => {
                            postItem.remove();
                        }, 300); // 等動畫播放完再徹底刪除
                    }
                }
                return; // ★★★ 關鍵！處理完刪除後，必須立刻結束，防止觸發下面的其他點擊事件
            }
            
            // ▲▲▲ 新代碼黏貼結束 ▲▲▲
// 【核心修復】處理微博中的“文字圖”點擊事件
if (target.classList.contains('weibo-post-image') && target.dataset.hiddenText) {
    showCustomAlert("圖片內容", target.dataset.hiddenText.replace(/<br>/g, '\n'));
    return; // 處理完後，立刻退出，避免觸發其他邏輯
}
// ▲▲▲ 新代碼黏貼結束 ▲▲▲

    const postItem = target.closest('.weibo-post-item');
    const postId = postItem ? parseInt(postItem.dataset.postId) : null;

    // --- 處理“刪除評論”按鈕 ---
    const deleteCommentBtn = target.closest('.comment-delete-btn');
    if (deleteCommentBtn) {
        const commentItem = deleteCommentBtn.closest('.weibo-comment-item');
        if (postId && commentItem && commentItem.dataset.commentId) {
            deleteWeiboComment(postId, commentItem.dataset.commentId);
        }
        return;
    }

    // --- 處理“生成評論”按鈕 ---
    const generateBtn = target.closest('.generate-comments-btn');
    if (generateBtn) {
        if (postId) {
            generateWeiboComments(postId);
        }
        return; 
    }

    // --- 處理底部巡覽列切換 ---
    const navItem = target.closest('.weibo-nav-item');
    if (navItem && navItem.dataset.view) {
        switchToWeiboView(navItem.dataset.view);
        return;
    }

// ▼▼▼ 用這塊新代碼替換 ▼▼▼

            const actionsBtn = target.closest('.post-actions-btn');
            if (actionsBtn) {
                // 核心修正1：從按鈕本身獲取正確的 postId
                const postId = parseInt(actionsBtn.dataset.postId);

                const confirmed = await showCustomConfirm('刪除微博', '確定要永久刪除這條微博嗎？此操作不可恢復。', { confirmButtonClass: 'btn-danger' });
                
                // 核心修正2：檢查 postId 是否是一個有效的數字
                if (confirmed && !isNaN(postId)) { 
                    await db.weiboPosts.delete(postId);
                    // 刪除後，刷新所有相關的微博列表和個人資料
                    await renderMyWeiboFeed(); 
                    await renderFollowingWeiboFeed();
                    await renderWeiboProfile();
                    alert('微博已刪除。');
                }
                return;
            }

// ▲▲▲ 替換結束 ▲▲▲

    
    // --- 處理點贊、評論、回復 ---
    if (target.closest('.like-btn')) { if (postId) handleWeiboLike(postId); return; }
    if (target.closest('.weibo-comment-send-btn')) { const input = postItem.querySelector('.weibo-comment-input'); if (postId && input) handleWeiboComment(postId, input); return; }
    
    const commentItem = target.closest('.weibo-comment-item');
    if (commentItem) {
        const commenterName = commentItem.dataset.commenterName;
        const commentId = commentItem.dataset.commentId;
        const input = postItem.querySelector('.weibo-comment-input');
        if (input.dataset.replyToId === commentId) {
            input.placeholder = '留下你的精彩評論吧...';
            delete input.dataset.replyToId; delete input.dataset.replyToNickname;
        } else {
            input.placeholder = `回復 @${commenterName}:`;
            input.dataset.replyToId = commentId; input.dataset.replyToNickname = commenterName;
            input.focus();
        }
        return;
    }
});

// 3. 【核心】為微博個人主頁的所有可編輯元素，綁定專屬的編輯函數
// ▼▼▼ 用這塊【功能增強版】的代碼，替換舊的 weibo-profile-page 事件監聽器 ▼▼▼
document.getElementById('weibo-profile-page').addEventListener('click', async (e) => {
    const target = e.target;
    
    // --- ▼▼▼ 核心修改在這裡 ▼▼▼ ---
    if (target.id === 'weibo-avatar-img' || target.closest('.weibo-avatar-container')) {
        // 1. 彈出一個選擇功能表，讓使用者決定是換頭像還是換框
        const choice = await showChoiceModal("編輯頭像", [
            { text: '更換頭像圖片', value: 'avatar' },
            { text: '更換頭像框', value: 'frame' }
        ]);
        
        // 2. 根據使用者的選擇，執行不同的操作
        if (choice === 'avatar') {
            editWeiboAvatar(); // 調用原來的更換頭像函數
        } else if (choice === 'frame') {
            openFrameSelectorModal('weibo_profile'); // 調用我們新增的更換頭像框函數
        }
        return; // 處理完後直接退出
    } 
    // --- ▲▲▲ 修改結束 ▲▲▲

    else if (target.id === 'weibo-nickname') {
        editWeiboNickname();
    } 
    else if (target.id === 'weibo-user-profession-display') {
        openWeiboUserSettingsModal();
    } 
    else if (target.id === 'weibo-background-img') {
        editWeiboBackground();
    } else if (target.closest('#weibo-fans-item')) {
        editWeiboFansCount();
    }
});
// ▲▲▲ 替換結束 ▲▲▲

// 4. 【核心】為“關注”數字和“發佈微博”按鈕綁定事件
document.getElementById('weibo-following-btn').addEventListener('click', showFollowingList);
document.getElementById('create-weibo-post-btn').addEventListener('click', openWeiboPublisherClean);
document.getElementById('close-following-list-btn').addEventListener('click', () => {
    document.getElementById('weibo-following-modal').classList.remove('visible');
});
document.getElementById('clear-following-feed-btn').addEventListener('click', clearFollowingFeed);

// ▲▲▲ 替換結束 ▲▲▲

// ▼▼▼ 用這塊【已隱藏可見範圍】的代碼，替換舊的 openWeiboPublisherClean 函數 ▼▼▼
function openWeiboPublisherClean() {
    // 1. 重置並獲取模態框
    resetCreatePostModal(); 
    const modal = document.getElementById('create-post-modal');
    
    // 2. 設置為“微博”模式，並修改標題和提示語
    modal.dataset.mode = 'weibo';
    document.getElementById('create-post-modal-title').textContent = '發微博';
    document.getElementById('post-public-text').placeholder = '有什麼新鮮事想分享給大家？';

    // 3. 確保所有“動態”專屬的HTML元素都被隱藏
    const imageDescGroup = document.getElementById('post-image-desc-group');
    if (imageDescGroup) imageDescGroup.style.display = 'none';
    
    const commentsToggleGroup = document.getElementById('post-comments-toggle-group');
    if (commentsToggleGroup) commentsToggleGroup.style.display = 'none';

    // ▼▼▼ 就是在這裡新增了一行代碼！▼▼▼
    const visibilityGroup = document.getElementById('post-visibility-group');
    if (visibilityGroup) visibilityGroup.style.display = 'none';
    // ▲▲▲ 新增結束 ▲▲▲

    // 4. 顯示微博需要的控制項
    const modeSwitcher = document.getElementById('post-mode-switcher');
    if (modeSwitcher) modeSwitcher.style.display = 'flex';
    
    // 5. 顯示彈窗
    modal.classList.add('visible');
}
// ▲▲▲ 替換結束 ▲▲▲


document.getElementById('close-following-list-btn').addEventListener('click', () => {
    document.getElementById('weibo-following-modal').classList.remove('visible');
});
document.getElementById('clear-following-feed-btn').addEventListener('click', clearFollowingFeed);

// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 用這塊【已修復】的代碼，完整替換掉你舊的 `editWeiboProfileBtn` 事件監聽器 ▼▼▼
    // 【全新】微博用戶人設設置功能事件綁定
    document.getElementById('edit-weibo-profile-btn').addEventListener('click', openWeiboUserSettingsModal);
    document.getElementById('cancel-weibo-user-settings-btn').addEventListener('click', () => {
        document.getElementById('weibo-user-settings-modal').classList.remove('visible');
    });
    document.getElementById('save-weibo-user-settings-btn').addEventListener('click', saveWeiboUserSettings);
    document.getElementById('weibo-user-preset-select').addEventListener('change', handleWeiboUserPresetSelection);
    document.getElementById('manage-weibo-user-presets-btn').addEventListener('click', openWeiboUserPresetManager);
// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 【全新】論壇功能事件監聽器 ▼▼▼

// 1. 初始化時創建默認小組
await initializeDefaultGroups();

// 2. 當使用者點擊“圈子”App圖示時，渲染小組清單
document.querySelector('.desktop-app-icon[onclick="showScreen(\'forum-screen\')"]').addEventListener('click', renderForumScreen);

// 3. 綁定小組頁和帖子頁的返回按鈕
document.getElementById('back-to-forum-list').addEventListener('click', () => showScreen('forum-screen'));
document.getElementById('back-to-group-screen').addEventListener('click', () => openGroup(activeGroupId, document.getElementById('group-screen-title').textContent));

// 4. 綁定帖子評論區的發送按鈕
document.getElementById('send-post-comment-btn').addEventListener('click', handleAddComment);

// ▼▼▼ 在 init() 函數中，用下面【這兩行】替換舊的 generate-fanfic-btn 監聽器 ▼▼▼
// 綁定同人文小組偏好選擇器裡的“生成”按鈕
document.getElementById('trigger-fanfic-generation-btn').addEventListener('click', generateFanfic);
// 綁定所有小組頭部通用的“生成”按鈕
document.getElementById('generate-group-content-btn').addEventListener('click', handleGenerateGroupContent);
// ▲▲▲ 替換結束 ▲▲▲


// 6. 綁定帖子詳情頁的“轉載”按鈕
document.getElementById('repost-to-chat-btn').addEventListener('click', repostToChat);

// ▼▼▼ 在 init() 函數中，用【這一行】替換舊的 create-group-btn 監聽器 ▼▼▼
document.getElementById('create-group-btn').addEventListener('click', openGroupCreator);
// ▲▲▲ 替換結束 ▲▲▲


// ▼▼▼ 用這塊新代碼替換 ▼▼▼
document.getElementById('create-forum-post-btn').addEventListener('click', () => {
    // 【核心修改】我們不再彈窗提示，而是調用一個新函數來打開真正的發帖視窗
    openCreateForumPostModal(); 
});
// ▲▲▲ 替換結束 ▲▲▲
// ▼▼▼ 在 init() 的事件監聽器區域，黏貼下面這塊【新代碼】 ▼▼▼

// 使用事件委託，為帖子詳情頁的“生成評論”按鈕綁定事件
document.getElementById('post-detail-content').addEventListener('click', (e) => {
    if (e.target.id === 'generate-forum-comments-btn') {
        generateForumComments();
    }
});

// 在用戶手動輸入評論後，如果輸入框為空就失去焦點時，自動取消回復狀態
document.getElementById('post-comment-input').addEventListener('blur', (e) => {
    const input = e.target;
    if (input.value.trim() === '') {
        input.placeholder = '發佈你的評論...';
        delete input.dataset.replyTo;
    }
});
// ▲▲▲ 新代碼黏貼結束 ▲▲▲
// ▼▼▼ 在 init() 函數的事件監聽器區域末尾，黏貼下面這整塊新代碼 ▼▼▼

// 使用事件委託，為所有轉載的帖子卡片添加點擊事件
document.getElementById('chat-messages').addEventListener('click', (e) => {
    const repostCard = e.target.closest('.link-share-card[data-post-id]');
    if (repostCard) {
        const postId = parseInt(repostCard.dataset.postId);
        if (!isNaN(postId)) {
            // 調用你已經寫好的“打開帖子”函數
            openPost(postId);
        }
    }
});

// ▲▲▲ 新增代碼結束 ▲▲▲
// ▼▼▼ 【全新】論壇帖子列表事件委託 ▼▼▼
document.getElementById('group-post-list').addEventListener('click', async (e) => {
    const postItem = e.target.closest('.forum-post-item');
    if (!postItem) return;

    // 檢查點擊的是否是刪除按鈕
    if (e.target.classList.contains('forum-post-delete-btn')) {
        const postId = postItem.dataset.postId;
        if (!postId) return;
        
        const post = await db.forumPosts.get(parseInt(postId));
        if (!post) return;

        const confirmed = await showCustomConfirm(
            '刪除帖子', 
            `確定要刪除帖子《${post.title}》嗎？此操作將同時刪除帖子下的所有評論，且無法恢復。`, 
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            try {
                // 使用資料庫事務來確保帖子和評論被同時刪除
                await db.transaction('rw', db.forumPosts, db.forumComments, async () => {
                    // 1. 刪除所有與該帖子關聯的評論
                    await db.forumComments.where('postId').equals(parseInt(postId)).delete();
                    // 2. 刪除帖子本身
                    await db.forumPosts.delete(parseInt(postId));
                });

                await showCustomAlert('刪除成功', '帖子及其所有評論已被刪除。');
                // 刷新帖子列表
                await renderGroupPosts(activeGroupId);
            } catch (error) {
                console.error('刪除帖子失敗:', error);
                await showCustomAlert('刪除失敗', `操作失敗: ${error.message}`);
            }
        }
    } else {
        // 如果點擊的不是刪除按鈕，那就是點擊了帖子本身，執行跳轉邏輯
        const postId = postItem.dataset.postId;
        if (postId) {
            openPost(parseInt(postId));
        }
    }
});
// ▲▲▲ 新事件監聽器結束 ▲▲▲
// ▼▼▼ 【全新】圈子/小組高級功能事件監聽 ▼▼▼

// 1. 為“圈子”主頁右上角的“+”按鈕，綁定創建小組的事件
document.getElementById('create-group-btn').addEventListener('click', openGroupCreator);

// 2. 為小組編輯器彈窗的“保存”和“取消”按鈕綁定事件
document.getElementById('save-group-editor-btn').addEventListener('click', saveGroupSettings);
document.getElementById('cancel-group-editor-btn').addEventListener('click', () => {
    document.getElementById('forum-group-editor-modal').classList.remove('visible');
});

// 3. 為分類管理彈窗的按鈕綁定事件
document.getElementById('add-new-forum-category-btn').addEventListener('click', addNewForumCategory);
document.getElementById('close-forum-category-manager-btn').addEventListener('click', () => {
    document.getElementById('forum-category-manager-modal').classList.remove('visible');
});

// 4. 使用事件委託，為分類清單中的“刪除”按鈕綁定事件
document.getElementById('existing-forum-categories-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-group-btn')) { // 複用樣式
        const categoryId = parseInt(e.target.dataset.id);
        deleteForumCategory(categoryId);
    }
});
// ▲▲▲ 新增事件監聽結束 ▲▲▲


// ▲▲▲ 論壇事件監聽器結束 ▲▲▲
// ▼▼▼ 把這一整塊全新的事件監聽器代碼，黏貼到 init() 函數的末尾，就在 init(); 的正上方 ▼▼▼

// --- 塔羅牌占卜功能事件綁定 ---
document.getElementById('open-tarot-btn').addEventListener('click', openTarotModal);
document.getElementById('close-tarot-modal-btn').addEventListener('click', () => {
    document.getElementById('tarot-divination-modal').classList.remove('visible');
});
document.getElementById('draw-tarot-cards-btn').addEventListener('click', handleDrawCards);
document.getElementById('back-to-tarot-setup-btn').addEventListener('click', () => {
    document.getElementById('tarot-result-view').style.display = 'none';
    document.getElementById('tarot-setup-view').style.display = 'block';
});
document.getElementById('send-tarot-result-btn').addEventListener('click', sendTarotReadingToChat);
document.getElementById('tarot-history-btn').addEventListener('click', openTarotHistory);
document.getElementById('back-to-tarot-main-btn').addEventListener('click', () => {
    document.getElementById('tarot-history-view').style.display = 'none';
    document.getElementById('tarot-setup-view').style.display = 'block';
});
// 使用事件委託處理歷史記錄的刪除按鈕
document.getElementById('tarot-history-list').addEventListener('click', (e) => {
    if (e.target.classList.contains('tarot-history-delete-btn')) {
        const readingId = parseInt(e.target.dataset.id);
        if (!isNaN(readingId)) {
            deleteTarotReading(readingId);
        }
    }
});

// --- 塔羅牌占卜功能事件綁定結束 ---

// ▲▲▲ 黏貼結束 ▲▲▲
// ▼▼▼ 【全新】情侶空間功能事件監聽器 ▼▼▼
// ▼▼▼ 第3步.3：在這裡黏貼新代碼 ▼▼▼
document.getElementById('ls-change-bg-btn').addEventListener('click', handleChangeLoversSpaceBackground);
// ▲▲▲ 新代碼黏貼結束 ▲▲▲

// 綁定主螢幕App圖示的點擊事件
document.getElementById('lovers-space-app-icon').addEventListener('click', openLoversSpaceEntry);

// ▼▼▼ 用這塊代碼替換 ▼▼▼
document.getElementById('ls-char-selector-list').addEventListener('click', async (e) => {
    const item = e.target.closest('.chat-list-item');
    if (item && item.dataset.chatId) {
        const chatId = item.dataset.chatId;
        const chat = state.chats[chatId];
        
        // 關閉選擇彈窗
        document.getElementById('ls-char-selector-modal').classList.remove('visible');
        
        // 【核心邏輯】判斷情侶空間狀態
        if (chat.loversSpaceData) {
            // 如果已開通，直接進入
            openLoversSpace(chatId);
        } else {
            // 如果未開通，彈窗確認是否發送邀請
            const confirmed = await showCustomConfirm(
                '邀請開啟情侶空間',
                `你和“${chat.name}”的情侶空間還未開啟，要現在邀請Ta嗎？`
            );
            if (confirmed) {
                // 如果用戶確認，發送邀請並跳轉到聊天介面
                await sendLoversSpaceInvitation(chatId);
                openChat(chatId);
            }
        }
    }
});
// ▲▲▲ 替換結束 ▲▲▲

document.getElementById('ls-cancel-switch-char-btn').addEventListener('click', () => {
    document.getElementById('ls-char-selector-modal').classList.remove('visible');
});
document.getElementById('ls-switch-char-btn').addEventListener('click', openCharSelectorForLoversSpace);

// ▼▼▼ 用這塊【修復後】的代碼，完整替換舊的 'ls-tab-bar' 事件監聽器 ▼▼▼
// 綁定頁簽切換事件
document.getElementById('ls-tab-bar').addEventListener('click', (e) => {
    const tab = e.target.closest('.ls-tab-item');
    if (tab && tab.dataset.view) {
        const viewId = tab.dataset.view;
        // 1. 切換高亮和視圖
        document.querySelectorAll('.ls-tab-item').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        switchLoversSpaceTab(viewId);

        // 2. 【核心修復】根據點擊的頁簽，渲染對應的內容
        const chat = state.chats[activeLoversSpaceCharId];
        if (!chat) return;

        if (viewId === 'ls-moments-view') {
            renderLSMoments(chat.loversSpaceData.moments, chat);
        } else if (viewId === 'ls-album-view') {
            renderLSPhotos(chat.loversSpaceData.photos, chat);
        } else if (viewId === 'ls-letters-view') {
            renderLSLetters(chat.loversSpaceData.loveLetters, chat);
        } else if (viewId === 'ls-questions-view') {
            // 這就是我們新增的邏輯！
            renderLSQuestions(chat.loversSpaceData.questions, chat);    
        }
        else if (viewId === 'ls-diary-view') {
    const now = new Date();
    renderLSDiaryView(now.getFullYear(), now.getMonth() + 1);
}
    else if (viewId === 'ls-shares-view') {
        renderLSShares(chat.loversSpaceData.shares, chat);
    }
    // ▼▼▼ 在這裡添加下面這3行新代碼 ▼▼▼
    else if (viewId === 'ls-pomodoro-view') {
        openPomodoroScreen();
    }
    }
});
// ▲▲▲ 替換結束 ▲▲▲


// 綁定“說說”功能的按鈕
document.getElementById('ls-add-moment-btn').addEventListener('click', openMomentCreator);
document.getElementById('ls-cancel-moment-btn').addEventListener('click', () => {
    document.getElementById('ls-create-moment-modal').classList.remove('visible');
});
document.getElementById('ls-confirm-moment-btn').addEventListener('click', handlePostMoment);

// 綁定“相冊”功能的按鈕
document.getElementById('ls-add-album-btn').addEventListener('click', openAlbumCreator);
document.getElementById('ls-select-photos-btn').addEventListener('click', () => {
    document.getElementById('ls-photo-input').click();
});
document.getElementById('ls-photo-input').addEventListener('change', (e) => {
    handlePhotoSelection(e.target.files);
});
// 綁定新彈窗裡的模式切換按鈕
const lsImageModeBtn = document.getElementById('ls-switch-to-image-mode');
const lsTextImageModeBtn = document.getElementById('ls-switch-to-text-image-mode');
const lsImageModeContent = document.getElementById('ls-image-mode-content');
const lsTextImageModeContent = document.getElementById('ls-text-image-mode-content');
// ▼▼▼ 用這塊【已修復】的代碼，替換掉上面那段錯誤的代碼 ▼▼▼
lsImageModeBtn.addEventListener('click', () => {
    lsImageModeBtn.classList.add('active');
    lsTextImageModeBtn.classList.remove('active');
    // 新增下面這兩行，這才是關鍵！
    lsImageModeContent.classList.add('active');
    lsTextImageModeContent.classList.remove('active');
    // 舊的樣式控制也保留，確保萬無一失
    lsImageModeContent.style.display = 'block';
    lsTextImageModeContent.style.display = 'none';
});

lsTextImageModeBtn.addEventListener('click', () => {
    lsTextImageModeBtn.classList.add('active');
    lsImageModeBtn.classList.remove('active');
    // 新增下面這兩行，這才是關鍵！
    lsTextImageModeContent.classList.add('active');
    lsImageModeContent.classList.remove('active');
    // 舊的樣式控制也保留，確保萬無一失
    lsTextImageModeContent.style.display = 'block';
    lsImageModeContent.style.display = 'none';
});
// ▲▲▲ 替換結束 ▲▲▲

 document.getElementById('ls-cancel-album-btn').addEventListener('click', () => {
    document.getElementById('ls-create-album-modal').classList.remove('visible');
});
 document.getElementById('ls-confirm-album-btn').addEventListener('click', handleConfirmAlbum);
// ▼▼▼ 【全新】情侶空間設置功能事件監聽 ▼▼▼
document.getElementById('ls-settings-btn').addEventListener('click', () => {
    const chat = state.chats[activeLoversSpaceCharId];
    if (chat && chat.loversSpaceData) {
        // 將已保存的日期載入到輸入框中
        document.getElementById('ls-start-date-input').value = chat.loversSpaceData.relationshipStartDate || '';
    }
    document.getElementById('ls-settings-modal').classList.add('visible');
});

document.getElementById('ls-settings-cancel-btn').addEventListener('click', () => {
    document.getElementById('ls-settings-modal').classList.remove('visible');
});

document.getElementById('ls-settings-save-btn').addEventListener('click', async () => {
    const chat = state.chats[activeLoversSpaceCharId];
    if (!chat) return;

    const newDate = document.getElementById('ls-start-date-input').value;
    chat.loversSpaceData.relationshipStartDate = newDate;
    
    await db.chats.put(chat); // 保存到資料庫
    
    // 重新渲染整個空間以顯示更新
    await renderLoversSpace(chat);

    document.getElementById('ls-settings-modal').classList.remove('visible');
    alert('紀念日已保存！');
});
// ▲▲▲ 事件監聽結束 ▲▲▲
// ▼▼▼ 把這段新代碼黏貼到 init() 的事件監聽器區域 ▼▼▼

// 【情侶空間相冊】事件監聽
document.getElementById('ls-album-list').addEventListener('click', (e) => {
    const item = e.target.closest('.ls-album-item');
    if (!item) return;

    const timestamp = parseInt(item.dataset.timestamp);
    if (isNaN(timestamp)) return;
    
    // 檢查點擊的是否是刪除按鈕
    if (e.target.classList.contains('ls-photo-delete-btn')) {
        handleDeleteLSPhoto(timestamp);
    } else {
        // 否則，就是點擊了圖片本身，執行查看描述的邏輯
        const chat = state.chats[activeLoversSpaceCharId];
        if (chat && chat.loversSpaceData && chat.loversSpaceData.photos) {
            const photo = chat.loversSpaceData.photos.find(p => p.timestamp === timestamp);
            if (photo) {
                showCustomAlert(`照片描述 (${formatPostTimestamp(photo.timestamp)})`, photo.description);
            }
        }
    }
});
// ▲▲▲ 事件監聽結束 ▲▲▲
// ▼▼▼ 【全新】情侶空間說說互動功能事件監聽 ▼▼▼
document.getElementById('ls-moments-list').addEventListener('click', async (e) => {
    const target = e.target;
    const momentCard = target.closest('.ls-moment-card');
    if (!momentCard) return;

    // 1. 【核心】從被點擊的卡片上獲取正確的索引
    const momentIndex = parseInt(momentCard.dataset.momentIndex);
    const chat = state.chats[activeLoversSpaceCharId];
    // 安全檢查，確保能找到對應的資料
    if (!chat || !chat.loversSpaceData || !chat.loversSpaceData.moments[momentIndex]) return;
    
    const moment = chat.loversSpaceData.moments[momentIndex];

    // --- 處理“發送評論”按鈕 ---
    if (target.classList.contains('ls-comment-send-btn')) {
        const input = momentCard.querySelector('.ls-comment-input-area input');
        const commentText = input.value.trim();
        if (!commentText) {
            alert("評論內容不能為空！");
            return;
        }

        const newComment = {
            author: chat.settings.myNickname || '我',
            text: commentText
        };
        
        if (!moment.comments) {
            moment.comments = [];
        }
        moment.comments.push(newComment);
        
        await db.chats.put(chat); // 保存到資料庫
        renderLSMoments(chat.loversSpaceData.moments, chat); // 刷新介面
    }

    // --- 2. 【核心】處理“刪除說說”按鈕 ---
    if (target.classList.contains('ls-moment-delete-btn')) {
        const confirmed = await showCustomConfirm('刪除說說', '確定要刪除這條說說嗎？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            // 2. 【核心】使用我們剛剛獲取的、絕對正確的 momentIndex 來刪除陣列中的元素
            chat.loversSpaceData.moments.splice(momentIndex, 1);
            await db.chats.put(chat);
            renderLSMoments(chat.loversSpaceData.moments, chat);
        }
    }

    // --- 3. 處理“刪除評論”按鈕 ---
    if (target.classList.contains('ls-comment-delete-btn')) {
        const commentIndex = parseInt(target.dataset.commentIndex);
        const confirmed = await showCustomConfirm('刪除評論', '確定要刪除這條評論嗎？', { confirmButtonClass: 'btn-danger' });
        if (confirmed) {
            moment.comments.splice(commentIndex, 1);
            await db.chats.put(chat);
            renderLSMoments(chat.loversSpaceData.moments, chat);
        }
    }
});

/* ▼▼▼ 把這一整塊全新的事件監聽器代碼，黏貼到 // ▲▲▲ 情侶空間事件監聽結束 ▲▲▲ 的正上方 ▼▼▼ */

// --- 【全新】情侶空間情書功能事件監聽 ---

// 1. 綁定“寫情書”的浮動按鈕
document.getElementById('ls-add-letter-btn').addEventListener('click', () => openLoveLetterEditor());

// 2. 綁定寫信彈窗的“取消”和“寄出”按鈕
document.getElementById('ls-cancel-letter-btn').addEventListener('click', () => {
    document.getElementById('ls-create-letter-modal').classList.remove('visible');
});
document.getElementById('ls-confirm-letter-btn').addEventListener('click', handlePostLoveLetter);

// ▼▼▼ 用這塊【功能更強大的】代碼，完整替換舊的 ls-letters-list 事件監聽器 ▼▼▼
// 使用事件委託，為情書清單中的所有卡片和按鈕綁定點擊事件
document.getElementById('ls-letters-list').addEventListener('click', async (e) => {
    const letterItem = e.target.closest('.ls-love-letter-item');
    if (!letterItem) return;

    // 檢查點擊的是否是刪除按鈕
    if (e.target.classList.contains('ls-letter-delete-btn')) {
        const letterId = letterItem.dataset.letterId;
        const chat = state.chats[activeLoversSpaceCharId];
        const letter = chat.loversSpaceData.loveLetters.find(l => l.id === letterId);
        
        const confirmed = await showCustomConfirm(
            '刪除情書',
            `確定要刪除這封寫給“${letter.recipientName}”的情書嗎？`,
            { confirmButtonClass: 'btn-danger' }
        );

        if (confirmed) {
            chat.loversSpaceData.loveLetters = chat.loversSpaceData.loveLetters.filter(l => l.id !== letterId);
            await db.chats.put(chat);
            renderLSLetters(chat.loversSpaceData.loveLetters, chat);
            alert('情書已刪除。');
        }
    } 
    // 否則，就是點擊了卡片本身，執行查看詳情的邏輯
    else if (letterItem.dataset.letterId) {
        showLoveLetterDetail(letterItem.dataset.letterId);
    }
});
// ▲▲▲ 替換結束 ▲▲▲


/* ▲▲▲ 新增事件監聽結束 ▲▲▲ */
/* ▼▼▼ 把這段新代碼黏貼到 // ▲▲▲ 情侶空間事件監聽結束 ▲▲▲ 的正上方 ▼▼▼ */

// --- 【全新】情書檢視器按鈕事件監聽 ---
document.getElementById('ls-close-letter-viewer-btn').addEventListener('click', () => {
    document.getElementById('ls-letter-viewer-modal').classList.remove('visible');
    activeLoveLetter = null; // 關閉時清理暫存的資料
});

document.getElementById('ls-reply-letter-btn').addEventListener('click', () => {
    // 先關閉檢視器
    document.getElementById('ls-letter-viewer-modal').classList.remove('visible');
    // 然後打開回復編輯器
    if (activeLoveLetter) {
        openLoveLetterEditor(activeLoveLetter);
    }
    activeLoveLetter = null; // 清理
});

/* ▲▲▲ 新增代碼黏貼結束 ▲▲▲ */
// ▼▼▼ 把這一整塊全新的事件監聽器代碼，黏貼到 // ▲▲▲ 情侶空間事件監聽結束 ▲▲▲ 的正上方 ▼▼▼

/* --- 【全新】情侶空間-情侶提問功能事件監聽 --- */

// 1. 綁定“提問”的浮動按鈕
document.getElementById('ls-add-question-btn').addEventListener('click', openQuestionAsker);

// 2. 綁定提問彈窗的按鈕
document.getElementById('ls-cancel-ask-btn').addEventListener('click', () => {
    document.getElementById('ls-ask-question-modal').classList.remove('visible');
});
document.getElementById('ls-confirm-ask-btn').addEventListener('click', handlePostQuestion);

// 3. 綁定回答彈窗的按鈕
document.getElementById('ls-cancel-answer-btn').addEventListener('click', () => {
    document.getElementById('ls-answer-question-modal').classList.remove('visible');
});
document.getElementById('ls-confirm-answer-btn').addEventListener('click', handlePostAnswer);

// 4. 使用事件委託，為所有“回答”和“刪除”按鈕綁定點擊事件
document.getElementById('ls-questions-list').addEventListener('click', (e) => {
    // 這是你已有的處理“回答”按鈕的邏輯
    if (e.target.classList.contains('ls-answer-btn')) {
        const questionId = e.target.dataset.questionId;
        if (questionId) {
            openAnswerEditor(questionId);
        }
    }

    // ▼▼▼ 這是我們新加的處理“刪除”按鈕的邏輯 ▼▼▼
    if (e.target.classList.contains('ls-question-delete-btn')) {
        const questionId = e.target.dataset.questionId;
        if (questionId) {
            handleDeleteLSQuestion(questionId);
        }
    }
    // ▲▲▲ 新增邏輯結束 ▲▲▲
});


/* --- 情侶提問事件監聽結束 --- */

// ▼▼▼ 【全新】情侶空間專屬播放機事件監聽器 ▼▼▼

// 1. 監聽主播放機內的所有按鈕
document.getElementById('ls-close-player-btn').addEventListener('click', () => {
    document.getElementById('ls-music-player-overlay').classList.remove('visible');
});
document.getElementById('ls-playlist-btn').addEventListener('click', () => {
    renderLSMusicPlaylist();
    document.getElementById('ls-music-playlist-panel').classList.add('visible');
});
document.getElementById('ls-play-pause-btn').addEventListener('click', toggleLSMusicPlayPause);
document.getElementById('ls-next-btn').addEventListener('click', playNextLSSong);
document.getElementById('ls-prev-btn').addEventListener('click', playPrevLSSong);

// 2. 監聽播放清單面板內的所有按鈕
document.getElementById('ls-close-playlist-btn').addEventListener('click', () => {
    document.getElementById('ls-music-playlist-panel').classList.remove('visible');
});
document.getElementById('ls-clear-playlist-btn').addEventListener('click', async () => {
    const confirmed = await showCustomConfirm('清空列表', '確定要清空情侶空間的播放清單嗎？', { confirmButtonClass: 'btn-danger' });
    if (confirmed) {
        clearLSMusicPlaylist();
    }
});
document.getElementById('ls-playlist-body').addEventListener('click', (e) => {
    if (e.target.classList.contains('delete-track-btn')) {
        const index = parseInt(e.target.dataset.index);
        lsMusicState.playlist.splice(index, 1);
        
        // 如果刪除的是正在播放的歌曲
        if (index === lsMusicState.currentIndex) {
            playNextLSSong();
        } else if (index < lsMusicState.currentIndex) {
            lsMusicState.currentIndex--; // 修正索引
        }
        renderLSMusicPlaylist();
    }
});

// 3. 監聽音訊播放機的狀態
const lsAudioPlayer = document.getElementById('ls-audio-player');
lsAudioPlayer.addEventListener('timeupdate', updateLSProgressBar);
lsAudioPlayer.addEventListener('ended', playNextLSSong);
lsAudioPlayer.addEventListener('play', () => {
    lsMusicState.isPlaying = true;
    renderLSMusicPlayerUI();
});
lsAudioPlayer.addEventListener('pause', () => {
    lsMusicState.isPlaying = false;
    renderLSMusicPlayerUI();
});

// 4. 監聽進度條的點擊
document.getElementById('ls-progress-bar').addEventListener('click', (e) => {
    if (!lsAudioPlayer.duration) return;
    const progressBar = e.currentTarget;
    const barWidth = progressBar.clientWidth;
    const clickX = e.offsetX;
    lsAudioPlayer.currentTime = (clickX / barWidth) * lsAudioPlayer.duration;
});

// 5. 【核心】攔截情侶空間分享列表的點擊事件，不再觸發“一起聽”
document.getElementById('ls-shares-list').addEventListener('click', async (e) => {
    const item = e.target.closest('.ls-share-item');
    if (!item || !item.dataset.shareData) return;

    const shareData = JSON.parse(item.dataset.shareData);

    // 如果是歌曲，就調用我們新的播放機函數！
    if (shareData.shareType === 'song') {
        openLoversSpaceMusicPlayer(shareData);
    } 
    // 其他類型的分享，保持原來的邏輯
    else if (shareData.shareType === 'movie' || shareData.shareType === 'book') {
        await showCustomAlert(`分享詳情 - ${shareData.title}`, shareData.thoughts || shareData.summary || '暫無簡介');
    }
    // ▼▼▼ 在這裡黏貼下面這塊【全新】的代碼 ▼▼▼
else if (shareData.shareType === 'game') {
    // 為遊戲分享卡片構建一個更詳細的彈窗內容
    const gameInfo = `遊戲名：${shareData.title}\n\n簡介：${shareData.summary || '暫無簡介'}\n\nTa說：“${shareData.thoughts || '一起玩吧！'}”`;
    await showCustomAlert(`分享的遊戲`, gameInfo);
}
});

// ▲▲▲ 新增事件監聽結束 ▲▲▲
// ▼▼▼ 在 init() 的事件監聽器區域末尾，黏貼這段新代碼 ▼▼▼

// 【全新】情侶空間播放機封面/歌詞切換事件
document.getElementById('ls-display-area').addEventListener('click', () => {
    document.getElementById('ls-display-area').classList.toggle('show-lyrics');
});

// ▲▲▲ 新代碼黏貼結束 ▲▲▲
// ▼▼▼ 在 init() 函數的末尾，黏貼這整塊新代碼 ▼▼▼

// ▼▼▼ 把這一整塊全新的代碼，黏貼到 init(); 的正上方 ▼▼▼

/* --- 【全新】情侶番茄鐘事件監聽器 --- */

// 1. 綁定“開啟新的專注時光”按鈕
document.getElementById('ls-pomodoro-start-btn-container').addEventListener('click', openPomodoroSetup);

// 2. 綁定設置彈窗的按鈕
document.getElementById('pomodoro-cancel-setup-btn').addEventListener('click', () => {
    document.getElementById('ls-pomodoro-setup-modal').classList.remove('visible');
});
document.getElementById('pomodoro-confirm-setup-btn').addEventListener('click', startPomodoroSession);

// 3. 【核心】為我們新增的“本地上傳”按鈕綁定事件
document.getElementById('pomodoro-bg-local-upload-btn').addEventListener('click', () => {
    document.getElementById('pomodoro-bg-file-input').click();
});
document.getElementById('pomodoro-bg-file-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
            pomodoroState.tempBgDataUrl = event.target.result; // 將本地圖片轉為DataURL暫存起來
            document.getElementById('pomodoro-bg-url-input').value = `[本地圖片: ${file.name}]`; // 在輸入框裡給個提示
        };
        reader.readAsDataURL(file);
    }
});

// 4. 綁定計時器介面上的元素
document.getElementById('pomodoro-char-avatar').addEventListener('click', () => {
    // 【核心修改】現在它會調用API來生成話語
    triggerPomodoroAIResponse('user_click');
});
document.getElementById('pomodoro-end-btn').addEventListener('click', () => {
    endPomodoroSession(false); // false表示是用戶手動中斷
});

// 5. 綁定歷史詳情彈窗的關閉按鈕
document.getElementById('pomodoro-close-history-viewer-btn').addEventListener('click', () => {
    document.getElementById('ls-pomodoro-history-viewer-modal').classList.remove('visible');
});
// ▼▼▼ 【全新】這是為番茄鐘計時模式新增的交互代碼 ▼▼▼
document.querySelector('#ls-pomodoro-setup-modal').addEventListener('change', (e) => {
    if (e.target.name === 'pomodoro-mode') {
        const durationGroup = document.getElementById('pomodoro-duration-input').parentElement;
        if (e.target.value === 'countup') {
            // 如果選擇正計時，就隱藏時長輸入框
            durationGroup.style.display = 'none';
        } else {
            // 否則（選擇倒計時），就顯示它
            durationGroup.style.display = 'block';
        }
    }
});
// ▲▲▲ 新增代碼結束 ▲▲▲

/* --- 番茄鐘事件監聽結束 --- */
// ▼▼▼ 在 init() 的事件監聽器區域，黏貼這塊新代碼 ▼▼▼
// 【全新】處理情侶空間邀請卡片的點擊事件
document.getElementById('chat-messages').addEventListener('click', async (e) => {
    const card = e.target.closest('.waimai-card');
    if (!card) return;
    const messageBubble = card.closest('.message-bubble');
    const invitationMsg = state.chats[state.activeChatId].history.find(m => m.timestamp === parseInt(messageBubble.dataset.timestamp));

    if (invitationMsg && invitationMsg.type === 'lovers_space_invitation' && invitationMsg.status === 'pending') {
        const choice = e.target.dataset.choice; // 'accepted' or 'rejected'
// ▼▼▼ 用這塊【最終通知版】的代碼，替換掉你舊的 if (choice) { ... } 代碼塊 ▼▼▼
if (choice) {
    // 1. 更新邀請卡片的狀態
    invitationMsg.status = choice;
    const chat = state.chats[state.activeChatId];
    
    // 2. 判斷用戶的選擇
    if (choice === 'accepted') {
        // 如果同意，創建情侶空間資料
        chat.loversSpaceData = {
            background: 'https://i.postimg.cc/k495F4W5/profile-banner.jpg',
            relationshipStartDate: null,
            moments: [], albums: [], photos: [], loveLetters: [], shares: [], questions: [],
        };
        
        // 創建對【使用者可見】的系統通知
        const visibleNotice = {
            role: 'system',
            type: 'pat_message',
            content: `[系統：你和“${chat.name}”的情侶空間已成功開啟！]`,
            timestamp: Date.now()
        };
        chat.history.push(visibleNotice);

        // 創建給【AI看】的隱藏指令
        const hiddenMessage = {
            role: 'system',
            content: `[系統指令：用戶同意了你開啟情侶空間的邀請。]`,
            timestamp: Date.now() + 1,
            isHidden: true
        };
        chat.history.push(hiddenMessage);
        
        await db.chats.put(chat);
        renderChatInterface(state.activeChatId);
        // (這裡沒有 triggerAiResponse()，AI不會回應)

    } else { // 如果拒絕 (choice === 'rejected')
        
        // --- ▼▼▼ 這就是我們為你新增的核心代碼 ▼▼▼ ---

        // a. 創建一條對【使用者可見】的系統通知
        const visibleNotice = {
            role: 'system',
            type: 'pat_message', // 複用灰色居中氣泡樣式
            content: `[系統：你拒絕了“${chat.name}”的情侶空間邀請。]`,
            timestamp: Date.now()
        };
        chat.history.push(visibleNotice);

        // b. 創建一條給【AI看】的隱藏指令，告訴它被拒絕了
        const hiddenMessage = {
            role: 'system',
            content: `[系統指令：用戶拒絕了你開啟情侶空間的邀請。]`,
            timestamp: Date.now() + 1,
            isHidden: true
        };
        chat.history.push(hiddenMessage);

        // c. 保存所有更改到資料庫
        await db.chats.put(chat);

        // d. 刷新聊天介面，讓卡片狀態和新的系統通知都顯示出來
        renderChatInterface(state.activeChatId);
        
        // (這裡也沒有 triggerAiResponse()，AI不會回應)
        
        // --- ▲▲▲ 新增代碼結束 ▲▲▲ ---
    }
}
// ▲▲▲ 替換結束 ▲▲▲


    }
});
// ▲▲▲ 黏貼結束 ▲▲▲

// ▼▼▼ 在 init() 的事件監聽器區域末尾，黏貼這段新代碼 ▼▼▼
// 【全新】處理情侶空間邀請卡片的點擊事件
document.getElementById('chat-messages').addEventListener('click', async (e) => {
    // 尋找被點擊的元素是否在邀請卡片內
    const card = e.target.closest('.waimai-card');
    if (!card) return;
    const messageBubble = card.closest('.message-bubble');
    // 通過時間戳記找到對應的消息資料
    const invitationMsg = state.chats[state.activeChatId].history.find(m => m.timestamp === parseInt(messageBubble.dataset.timestamp));

    // 確保這是一條待處理的情侶空間邀請
    if (invitationMsg && invitationMsg.type === 'lovers_space_invitation' && invitationMsg.status === 'pending') {
        const choice = e.target.dataset.choice; // 獲取點擊的是 'accepted' 還是 'rejected'
        if (choice) {
            // 調用我們剛剛創建的處理器函數
            handleLoversSpaceResponse(invitationMsg.timestamp, choice);
        }
    }
});
// ▲▲▲ 黏貼結束 ▲▲▲

// ▲▲▲ 新代碼黏貼結束 ▲▲▲
// ▲▲▲ 情侶空間事件監聽結束 ▲▲▲
// ▼▼▼ 【全新】這是主螢幕滑動分頁的JS邏輯 ▼▼▼
function initHomeScreenSlider() {
    const slider = document.querySelector('.home-screen-slider');
    const dots = document.querySelectorAll('.pagination-dots .dot');

    if (!slider || dots.length === 0) return;

    // 監聽滑動事件
    slider.addEventListener('scroll', () => {
        // 計算當前滑到了第幾頁
        const pageIndex = Math.round(slider.scrollLeft / slider.clientWidth);
        
        // 更新小圓點的狀態
        dots.forEach((dot, index) => {
            dot.classList.toggle('active', index === pageIndex);
        });
    });
}
// ▲▲▲ 新增JS邏輯結束 ▲▲▲
initHomeScreenSlider(); // 初始化主螢幕滑動功能

// ▼▼▼ 在這裡黏貼新代碼 ▼▼▼
// 監聽主螢幕圖示和小元件顏色選擇器的即時變化
document.getElementById('home-icon-widget-text-color-picker').addEventListener('input', (e) => {
    applyHomeIconWidgetTextColor(e.target.value);
});
// ▲▲▲ 新代碼黏貼結束 ▲▲▲
// 【全新】主螢幕字型陰影開關的即時預覽事件
document.getElementById('remove-home-font-shadow-toggle').addEventListener('change', (e) => {
    document.getElementById('phone-screen').classList.toggle('no-home-font-shadow', e.target.checked);
});
// ▲▲▲ 新代碼黏貼結束 ▲▲▲
// ▼▼▼ 【全新】圈子/小組分類篩選功能事件監聽 ▼▼▼
// 1. 綁定主頁和小組頁的篩選按鈕
document.getElementById('forum-filter-btn').addEventListener('click', () => openForumFilterModal('global'));
document.getElementById('group-filter-btn').addEventListener('click', () => openForumFilterModal('group', activeGroupId));

// 2. 綁定篩選彈窗內的按鈕
document.getElementById('apply-forum-filter-btn').addEventListener('click', applyForumFilter);
document.getElementById('cancel-forum-filter-btn').addEventListener('click', () => {
    document.getElementById('forum-filter-modal').classList.remove('visible');
});
document.getElementById('reset-forum-filter-btn').addEventListener('click', async () => {
    // 清空核取方塊並應用
    document.querySelectorAll('#forum-filter-category-list input:checked').forEach(cb => cb.checked = false);
    await applyForumFilter();
});
// ▲▲▲ 新增事件監聽結束 ▲▲▲
// ▼▼▼ 用這塊【已添加飛行棋】的代碼，替換舊的 game-hall-grid 事件監聽器 ▼▼▼
document.getElementById('game-hall-grid').addEventListener('click', (e) => {
    const gameCard = e.target.closest('.game-card');
    if (!gameCard) return;

    const gameId = gameCard.dataset.game;
    if (gameId === 'werewolf') {
        openWerewolfSetup();
    } else if (gameId === 'sea-turtle-soup') {
        openSeaTurtleSoupSetup();
    } else if (gameId === 'script-kill') {
        openScriptKillSetup();
    } else if (gameId === 'guess-what') {
        openGuessWhatSetup();
    } 
    // ★★★ 這就是我們新增的分支 ★★★
    else if (gameId === 'ludo') {
        openLudoSetup(); // 調用我們新寫的函數
    } 
    // ★★★ 新增結束 ★★★
    else {
        alert(`“${gameCard.querySelector('.game-title').textContent}”還在開發中，敬請期待！`);
    }
});
// ▲▲▲ 替換結束 ▲▲▲


// ▲▲▲ 新增事件監聽結束 ▲▲▲
// ▼▼▼ 【全新】狼人殺遊戲事件監聽器 ▼▼▼
document.getElementById('start-werewolf-game-btn').addEventListener('click', startWerewolfGame);

document.getElementById('exit-werewolf-game-btn').addEventListener('click', async () => {
    const confirmed = await showCustomConfirm('退出遊戲', '確定要中途退出遊戲嗎？當前進度不會保存。');
    if (confirmed) {
        werewolfGameState.isActive = false; // 停止遊戲迴圈
        showScreen('game-hall-screen');
    }
});

document.getElementById('werewolf-my-role-btn').addEventListener('click', () => {
    if (werewolfGameState.isActive) {
        const me = werewolfGameState.players.find(p => p.isUser);
        if (me) {
            alert(`你的身份是：【${me.role}】`);
        }
    }
});
// ▲▲▲ 新增事件監聽結束 ▲▲▲
// ▼▼▼ 【全新】海龜湯遊戲事件監聽器 ▼▼▼

// 1. 設置彈窗內的交互
document.getElementById('cancel-sts-setup-btn').addEventListener('click', () => {
    document.getElementById('sea-turtle-soup-setup-modal').classList.remove('visible');
});
document.getElementById('start-sts-game-btn').addEventListener('click', startSeaTurtleSoupGame);

// 監聽“出題人”下拉清單的變化
document.getElementById('sts-riddle-provider-select').addEventListener('change', (e) => {
    const userArea = document.getElementById('sts-user-riddle-input-area');
    const aiArea = document.getElementById('sts-ai-riddle-input-area');
    userArea.style.display = 'none';
    aiArea.style.display = 'none';
    if (e.target.value === 'user') {
        userArea.style.display = 'block';
    } else if (e.target.value === 'random_ai') {
        aiArea.style.display = 'block';
    }
});

// 2. 遊戲主介面的按鈕
document.getElementById('exit-sts-game-btn').addEventListener('click', async () => {
    const confirmed = await showCustomConfirm('退出遊戲', '確定要中途退出遊戲嗎？');
    if (confirmed) {
        seaTurtleSoupState.isActive = false;
        showScreen('game-hall-screen');
    }
});
document.getElementById('reveal-sts-answer-btn').addEventListener('click', async () => {
    const confirmed = await showCustomConfirm('揭曉答案', '確定要提前揭曉答案並結束遊戲嗎？');
    if (confirmed) {
        revealStsAnswer();
    }
});
document.getElementById('send-sts-question-btn').addEventListener('click', handleStsUserQuestion);
// ▼▼▼ 在 init() 的事件監聽器區域末尾添加 ▼▼▼
document.getElementById('guess-sts-answer-btn').addEventListener('click', handleStsUserGuess);
// ▲▲▲ 添加結束 ▲▲▲
document.getElementById('sts-question-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        document.getElementById('send-sts-question-btn').click();
    }
});

// ▲▲▲ 新事件監聽器結束 ▲▲▲
// ▼▼▼ 【全新】劇本殺遊戲事件監聽器 ▼▼▼
document.getElementById('start-script-kill-game-btn').addEventListener('click', startScriptKillGame);
document.getElementById('exit-script-kill-game-btn').addEventListener('click', async () => {
    const confirmed = await showCustomConfirm('退出遊戲', '確定要中途退出遊戲嗎？當前進度不會保存。');
    if (confirmed) {
        scriptKillGameState.isActive = false; // 停止遊戲迴圈
        showScreen('game-hall-screen');
    }
});
// 劇本殺遊戲事件監聽器
document.getElementById('script-kill-my-role-btn').addEventListener('click', () => {
    if (!scriptKillGameState.isActive) return;
    const myPlayer = scriptKillGameState.players.find(p => p.isUser);
    if (myPlayer) {
        const modal = document.getElementById('script-kill-role-modal');
        document.getElementById('sk-role-name').textContent = `你的角色：${myPlayer.role.name}`;
        // ▼▼▼ 核心修改在這裡 ▼▼▼
        document.getElementById('sk-role-details').innerHTML = `
            <p><strong>角色介紹:</strong><br>${myPlayer.role.description}</p>
            <p><strong>你的時間線:</strong><br>${myPlayer.role.storyline || '（暫無時間線資訊）'}</p>
            <p><strong>你的任務:</strong><br>${myPlayer.role.tasks}</p>
        `;
        // ▲▲▲ 修改結束 ▲▲▲
        modal.classList.add('visible');
    }
});
document.getElementById('close-sk-role-modal-btn').addEventListener('click', () => {
    document.getElementById('script-kill-role-modal').classList.remove('visible');
});

// 查看線索板
document.getElementById('script-kill-all-evidence-btn').addEventListener('click', () => {
    if (!scriptKillGameState.isActive) return;
    const modal = document.getElementById('script-kill-evidence-modal');
    const listEl = document.getElementById('sk-evidence-list');
    listEl.innerHTML = '';

    const myPlayer = scriptKillGameState.players.find(p => p.isUser);
    if (myPlayer.evidence.length === 0) {
        listEl.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">你還沒有搜到任何線索。</p>';
    } else {
        myPlayer.evidence.forEach(clue => {
            const card = document.createElement('div');
            card.className = 'sk-evidence-card';
            card.innerHTML = `
                <div class="source">來源: ${clue.source}</div>
                <div class="description">${clue.description}</div>
            `;
            listEl.appendChild(card);
        });
    }
    modal.classList.add('visible');
});
document.getElementById('close-sk-evidence-modal-btn').addEventListener('click', () => {
    document.getElementById('script-kill-evidence-modal').classList.remove('visible');
});

// ▼▼▼ 【最終流程版】請用這整塊代碼，完整替換舊的 script-kill-action-area 事件監聽器 ▼▼▼
document.getElementById('script-kill-action-area').addEventListener('click', async (e) => {
    const phase = scriptKillGameState.gamePhase;

// ▼▼▼ 從這裡開始複製，替換掉你舊的 'sk-search-evidence-btn' 的 if 代碼塊 ▼▼▼
if (e.target.id === 'sk-search-evidence-btn') {
    const user = scriptKillGameState.players.find(p => p.isUser);
    const script = scriptKillGameState.script;
    
    const searchCount = scriptKillGameState.evidenceCounts[user.id] || 0;
    const phase = scriptKillGameState.gamePhase;

    // 檢查搜證次數限制
    if ((phase === 'evidence_round_1' && searchCount >= 2) || (phase === 'evidence_round_2' && searchCount >= 3)) {
        alert("本輪搜證次數已用完！");
        return;
    }
    
    // 消耗一次搜證機會並更新UI
    scriptKillGameState.evidenceCounts[user.id] = searchCount + 1;
    updateActionAreaSK();

    let foundMessage = '';

    // 找出所有還未被發現的線索
    const uncollectedClues = script.clues.filter(c => !scriptKillGameState.collectedClueIds.has(c.description));

    if (uncollectedClues.length > 0) {
        // 隨機找到一條新線索
        const foundClue = uncollectedClues[Math.floor(Math.random() * uncollectedClues.length)];
        const clueSource = foundClue.owner === '公共' ? '公共區域' : `角色 ${foundClue.owner} 的私人物品`;
        
        // 無論如何，線索都會先加入玩家手牌，並標記為已發現
        user.evidence.push({ description: foundClue.description, source: clueSource });
        scriptKillGameState.collectedClueIds.add(foundClue.description);

        // --- ★★★ 核心修改邏輯開始 ★★★ ---

        // 判斷這條線索是不是關於玩家自己的
        if (foundClue.owner === user.role.name) {
            // 如果是，彈出一個選擇框讓玩家決定
            const choice = await showChoiceModal(
                '發現個人線索',
                [
                    { text: '公開這條線索', value: 'public' },
                    { text: '隱藏這條線索', value: 'private' }
                ]
            );

            if (choice === 'public') {
                // 玩家選擇【公開】
                foundMessage = `在【${clueSource}】發現並公開了線索：“${foundClue.description}”`;
                logToScriptKillGame(`${user.name} 完成了一次搜證: ${foundMessage}`);
                await showCustomAlert("搜證結果", foundMessage);
            } else {
                // 玩家選擇【隱藏】或關閉了彈窗
                foundMessage = `你在【${clueSource}】發現了一條關於自己的線索，並選擇將其隱藏。`;
                // 只給玩家自己一個彈窗提示，告訴他已經拿到了線索
                await showCustomAlert("搜證結果", `你已將線索“${foundClue.description}”收入囊中。`);
                // 在公共日誌裡只顯示一個模糊的資訊，告訴大家你搜過證了
                logToScriptKillGame(`${user.name} 完成了一次搜證。`);
            }
        } else {
            // 如果線索是公共的，或者關於其他人的，就按原來的邏輯直接公開
            foundMessage = `在【${clueSource}】發現線索：“${foundClue.description}”`;
            logToScriptKillGame(`${user.name} 完成了一次搜證: ${foundMessage}`);
            await showCustomAlert("搜證結果", foundMessage);
        }
        
        // --- ★★★ 核心修改邏輯結束 ★★★ ---

    } else {
        // 如果已經沒有新線索了
        foundMessage = "沒有發現更多新線索了。";
        logToScriptKillGame(`${user.name} 完成了一次搜證: ${foundMessage}`);
        await showCustomAlert("搜證結果", foundMessage);
    }
}
// ▲▲▲ 複製到這裡結束 ▲▲▲


    // --- 2. 處理“結束搜證”按鈕 ---
    if (e.target.id === 'sk-end-search-btn') {
        if (phase === 'evidence_round_1') {
            scriptKillGameState.gamePhase = 'discussion_round_1';
            await processScriptKillTurn();
        } else if (phase === 'evidence_round_2') {
            // 【核心修改】第二輪搜證後，進入第二輪討論
            scriptKillGameState.gamePhase = 'discussion_round_2';
            await processScriptKillTurn();
        }
    }

    // --- 3. 處理“我要發言”按鈕 ---
    if (e.target.id === 'sk-speak-btn') {
        const speech = await waitForUserActionSK('輪到你發言了', 'speak', '請輸入你的發言...');
        const userPlayer = scriptKillGameState.players.find(p => p.isUser);
        logToScriptKillGame({ player: userPlayer, speech: speech }, 'speech');
        
        for (const player of scriptKillGameState.players.filter(p => !p.isUser)) {
             await sleep(2000);
             renderScriptKillGameScreen({ speakingPlayerId: player.id });
             const aiSpeech = await triggerScriptKillAiAction(player.id, 'discuss');
             logToScriptKillGame({ player: player, speech: aiSpeech }, 'speech');
        }
        renderScriptKillGameScreen();
        
        // 【核心修改】根據當前討論輪次，決定下一個階段
        if (phase === 'discussion_round_1') {
            scriptKillGameState.gamePhase = 'evidence_round_2';
            await processScriptKillTurn();
        } else if (phase === 'discussion_round_2') {
            // 第二輪討論後，進入第三輪（最終）討論
            scriptKillGameState.gamePhase = 'discussion_round_3';
            await processScriptKillTurn();
        } else if (phase === 'discussion_round_3') {
            // 最終討論後，才進入投票
            scriptKillGameState.gamePhase = 'voting';
            await processScriptKillTurn();
        }
    }
});
// ▲▲▲ 替換結束 ▲▲▲



// ▼▼▼ 【全新 | 已修復】劇本殺管理功能事件監聽器 ▼▼▼
document.getElementById('manage-custom-scripts-btn').addEventListener('click', openScriptManager);

// 管理器彈窗的按鈕
document.getElementById('add-new-script-btn').addEventListener('click', () => {
    document.getElementById('script-kill-manager-modal').classList.remove('visible');
    openScriptEditorForCreate();
});
document.getElementById('close-script-manager-btn').addEventListener('click', () => {
    document.getElementById('script-kill-manager-modal').classList.remove('visible');
    // 關閉後刷新一下設置頁面的劇本下拉清單
    openScriptKillSetup();
    showScreen('script-kill-setup-screen');
});

// 編輯器彈窗的按鈕
document.getElementById('save-script-btn').addEventListener('click', saveCustomScript);
document.getElementById('cancel-script-editor-btn').addEventListener('click', () => {
    document.getElementById('script-kill-editor-modal').classList.remove('visible');
    // 如果是從管理介面進來的，就返回管理介面
    if (document.getElementById('script-kill-manager-modal').classList.contains('visible') === false) {
       openScriptManager();
    }
});
// ▲▲▲ 修復結束 ▲▲▲
// ▼▼▼ 【全新】劇本殺視覺化編輯器事件監聽器 ▼▼▼
document.getElementById('sk-add-role-btn').addEventListener('click', () => openRoleEditor());
document.getElementById('sk-add-clue-btn').addEventListener('click', () => openClueEditor());

document.getElementById('sk-item-editor-cancel-btn').addEventListener('click', () => {
    document.getElementById('sk-item-editor-modal').classList.remove('visible');
});
document.getElementById('sk-item-editor-save-btn').addEventListener('click', saveItemFromEditor);

// 使用事件委託處理角色和線索卡片上的按鈕點擊
document.getElementById('script-kill-editor-modal').addEventListener('click', (e) => {
    const target = e.target;
    if (target.classList.contains('edit-role-btn')) {
        openRoleEditor(parseInt(target.dataset.index));
    }
    if (target.classList.contains('delete-role-btn')) {
        const index = parseInt(target.dataset.index);
        currentEditingScriptData.roles.splice(index, 1);
        renderVisualScriptEditor();
    }
    if (target.classList.contains('edit-clue-btn')) {
        openClueEditor(parseInt(target.dataset.index));
    }
    if (target.classList.contains('delete-clue-btn')) {
        const index = parseInt(target.dataset.index);
        currentEditingScriptData.clues.splice(index, 1);
        renderVisualScriptEditor();
    }
});
// ▲▲▲ 新增事件監聽結束 ▲▲▲
// ▼▼▼ 在 init() 函數的事件監聽器區域末尾，黏貼這塊新代碼 ▼▼▼

// 【全新】劇本殺複盤分享功能事件綁定
document.getElementById('sk-cancel-share-btn').addEventListener('click', () => {
    document.getElementById('script-kill-target-picker-modal').classList.remove('visible');
});
document.getElementById('sk-select-all-btn').addEventListener('click', () => {
    document.querySelectorAll('.script-kill-target-checkbox').forEach(cb => cb.checked = true);
});
document.getElementById('sk-deselect-all-btn').addEventListener('click', () => {
    document.querySelectorAll('.script-kill-target-checkbox').forEach(cb => cb.checked = false);
});
// ▲▲▲ 新代碼黏貼結束 ▲▲▲
// ▼▼▼ 【全新】AI劇本生成器事件監聽器 ▼▼▼
document.getElementById('open-sk-ai-generator-btn').addEventListener('click', openAiScriptGenerator);
document.getElementById('sk-ai-generator-cancel-btn').addEventListener('click', () => {
    document.getElementById('sk-ai-generator-modal').classList.remove('visible');
    // 返回到劇本管理介面
    openScriptManager();
});
document.getElementById('sk-trigger-ai-generation-btn').addEventListener('click', generateSkScriptWithAI);
document.getElementById('sk-ai-generator-save-btn').addEventListener('click', saveAiGeneratedScript);
// ▲▲▲ 新事件監聽器結束 ▲▲▲

// ▲▲▲ 劇本殺事件監聽器結束 ▲▲▲
// ▼▼▼ 【全新】“你說我猜”遊戲事件監聽器 ▼▼▼

// 1. 設置介面的交互
document.querySelectorAll('input[name="guess_what_mode"]').forEach(radio => {
    radio.addEventListener('change', function() {
        document.getElementById('user-word-input-container').style.display = this.value === 'ai_guesses' ? 'block' : 'none';
    });
});
document.getElementById('start-guess-what-game-btn').addEventListener('click', startGuessWhatGame);

// 2. 遊戲介面的交互
document.getElementById('exit-guess-what-game-btn').addEventListener('click', async () => {
    const confirmed = await showCustomConfirm('退出遊戲', '確定要中途退出遊戲嗎？謎底將會揭曉。');
    if (confirmed) {
        endGuessWhatGame('none', '遊戲被中途放棄。');
        // 延遲一點再返回大廳，讓玩家能看到結果
        setTimeout(() => {
            showScreen('game-hall-screen');
        }, 3000);
    }
});

document.getElementById('give-up-guess-what-btn').addEventListener('click', () => {
    endGuessWhatGame(guessWhatGameState.currentTurn === 'user' ? 'ai' : 'user', '玩家放棄了遊戲。');
});

document.getElementById('send-guess-what-input-btn').addEventListener('click', () => {
    const input = document.getElementById('guess-what-user-input');
    const text = input.value.trim();
    if (text) {
        processGuessWhatTurn(text);
        input.value = '';
    }
});

document.getElementById('guess-what-user-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        document.getElementById('send-guess-what-input-btn').click();
    }
});

// ▲▲▲ “你說我猜”事件監聽器結束 ▲▲▲
// ▼▼▼ 【全新】寵物功能事件監聽器 ▼▼▼

// 1. 綁定輸入框上方的寵物圖示按鈕
document.getElementById('pet-action-btn').addEventListener('click', openPetModal);

// 2. 綁定寵物彈窗內的各種按鈕
document.getElementById('pet-modal-cancel-btn').addEventListener('click', () => {
    document.getElementById('pet-modal').classList.remove('visible');
    currentPetData = null; // 取消時也要清理
});
document.getElementById('pet-modal-save-btn').addEventListener('click', savePetSettings);

// 3. 即時更新預覽
document.getElementById('pet-type-input').addEventListener('input', updatePetPreview);
document.getElementById('pet-name-input').addEventListener('input', updatePetPreview);
document.getElementById('pet-image-input').addEventListener('input', updatePetPreview);

// 4. “在聊天介面顯示”開關的交互
document.getElementById('pet-display-toggle').addEventListener('change', (e) => {
    document.getElementById('pet-position-controls').style.display = e.target.checked ? 'block' : 'none';
});

// 5. 尺寸滑塊的交互
const sizeSlider = document.getElementById('pet-size-slider');
sizeSlider.addEventListener('input', () => {
    document.getElementById('pet-size-value').textContent = `${sizeSlider.value}px`;
});

// 6. 綁定更換自訂圖片的點擊事件
document.getElementById('pet-preview-display').addEventListener('click', () => {
    document.getElementById('pet-custom-image-input').click();
});
document.getElementById('pet-custom-image-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
            // 將圖片的Base64連結直接填入輸入框
            document.getElementById('pet-image-input').value = event.target.result;
            updatePetPreview(); // 並更新預覽
        };
        reader.readAsDataURL(file);
    }
});

// 7. 綁定互動按鈕 (使用事件委託)
document.getElementById('pet-interaction-area').addEventListener('click', (e) => {
    if (e.target.tagName === 'BUTTON' && e.target.dataset.action) {
        handlePetInteraction(e.target.dataset.action);
    }
});

// 8. 初始化寵物的拖動功能
initPetDragging();
// ▼▼▼ 【全新】寵物聊天功能事件綁定 ▼▼▼
document.getElementById('send-to-pet-btn').addEventListener('click', handleSendToPet);
document.getElementById('pet-chat-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        document.getElementById('send-to-pet-btn').click();
    }
});

// 為寵物聊天視窗的“外部”點擊添加關閉功能
const petChatModal = document.getElementById('pet-chat-modal');
petChatModal.addEventListener('click', (e) => {
    if (e.target === petChatModal) { // 只有點擊灰色遮罩層才關閉
        petChatModal.classList.remove('visible');
    }
});
// ▲▲▲ 新事件綁定結束 ▲▲▲
// ▼▼▼ 在 init() 的事件監聽器區域末尾，黏貼這段新代碼 ▼▼▼
// 【全新】為“放生寵物”按鈕綁定事件
document.getElementById('pet-abandon-btn').addEventListener('click', async () => {
    if (!state.activeChatId) return;

    const confirmed = await showCustomConfirm(
        '確認放生',
        '確定要關閉寵物系統嗎？這將會重置所有寵物資料（數值、聊天記錄等），但不會刪除你的設置。你可以隨時重新領養。',
        { confirmButtonClass: 'btn-danger' }
    );

    if (confirmed) {
        const chat = state.chats[state.activeChatId];
        chat.settings.petAdopted = false; // 關閉領養狀態
        delete chat.settings.pet; // 刪除寵物資料物件
        
        await db.chats.put(chat);
        
        renderChatPet(); // 從聊天介面移除寵物
        document.getElementById('pet-modal').classList.remove('visible'); // 關閉彈窗
        alert('寵物已放生，江湖再見！');
    }
});
// ▲▲▲ 新代碼黏貼結束 ▲▲▲

// ▲▲▲ 寵物功能事件監聽器結束 ▲▲▲
// ▼▼▼ 在 init() 的事件監聽器區域末尾，黏貼下面這整塊新代碼 ▼▼▼

/* --- 【全新】情侶空間-情緒日記事件監聽 --- */
document.getElementById('lovers-space-screen').addEventListener('click', (e) => {
    const chat = state.chats[activeLoversSpaceCharId];
    if (!chat) return;

    // 日曆月份切換
    if (e.target.id === 'ls-prev-month-btn' || e.target.id === 'ls-next-month-btn') {
        const currentDisplay = document.getElementById('ls-current-month-display').textContent;
        const [year, month] = currentDisplay.match(/\d+/g).map(Number);
        let newDate = new Date(year, month - 1, 1);
        
        if (e.target.id === 'ls-prev-month-btn') {
            newDate.setMonth(newDate.getMonth() - 1);
        } else {
            newDate.setMonth(newDate.getMonth() + 1);
        }
        renderLSDiaryView(newDate.getFullYear(), newDate.getMonth() + 1);
        return;
    }
    
    // 點擊日曆格子
    const dayCell = e.target.closest('.ls-calendar-day:not(.empty)');
    if (dayCell) {
        openDiaryModal(dayCell.dataset.date);
    }
});

// 日記編輯彈窗事件
document.getElementById('ls-emoji-selector').addEventListener('click', (e) => {
    if (e.target.classList.contains('emoji-option')) {
        document.querySelectorAll('#ls-emoji-selector .emoji-option').forEach(el => el.classList.remove('selected'));
        e.target.classList.add('selected');
    }
});
document.getElementById('ls-cancel-diary-btn').addEventListener('click', () => {
    document.getElementById('ls-diary-editor-modal').classList.remove('visible');
});
document.getElementById('ls-save-diary-btn').addEventListener('click', handleSaveUserDiary);

// 日記查看彈窗關閉按鈕
document.getElementById('ls-close-diary-viewer-btn').addEventListener('click', () => {
    document.getElementById('ls-diary-viewer-modal').classList.remove('visible');
});

/* --- 情緒日記事件監聽結束 --- */

// ▲▲▲ 新增代碼黏貼結束 ▲▲▲
// 在 init() 函數的事件監聽器區域末尾...

// ▼▼▼ 在這裡黏貼下面這幾行新代碼 ▼▼▼

// 綁定線下模式預設的下拉清單和管理按鈕
document.getElementById('offline-preset-select').addEventListener('change', handleOfflinePresetSelection);
document.getElementById('manage-offline-presets-btn').addEventListener('click', openOfflinePresetManager);

// ▲▲▲ 新代碼黏貼結束 ▲▲▲
// ▼▼▼ 【已修復】用這段新代碼替換舊的 ▼▼▼
document.getElementById('back-from-dm-list').addEventListener('click', () => {
    // 從私信清單返回時，直接顯示微博主螢幕
    showScreen('weibo-screen');
    // 並且確保預設顯示的是“我的微博”那個頁簽
    switchToWeiboView('weibo-my-profile-view');
});
// ▲▲▲ 替換結束 ▲▲▲


document.getElementById('back-from-dm-detail').addEventListener('click', () => {
    // 從私信詳情返回私信列表
    showScreen('weibo-dm-list-screen');
});

// 綁定“繼續生成”按鈕
document.getElementById('generate-more-dms-btn').addEventListener('click', handleGenerateMoreDms);

// 使用事件委託處理私信列表的點擊
document.getElementById('weibo-dm-list').addEventListener('click', (e) => {
    const item = e.target.closest('.dm-list-item');
    if (item && item.dataset.fanIndex) {
        openDmDetail(parseInt(item.dataset.fanIndex));
    }
});

// 使用事件委託處理私信詳情頁的刪除按鈕點擊
document.getElementById('weibo-dm-messages').addEventListener('click', (e) => {
    const deleteBtn = e.target.closest('.dm-message-delete-btn');
    if (deleteBtn) {
        const fanIndex = parseInt(document.querySelector('.dm-list-item.active')?.dataset.fanIndex ?? document.getElementById('weibo-dm-detail-screen').dataset.currentFanIndex);
        const messageIndex = parseInt(deleteBtn.dataset.messageIndex);
        
        const conversation = state.chats[currentViewingDmsFor.isNpc ? currentViewingDmsFor.ownerId : currentViewingDmsFor.id].weiboDms.find(convo => convo.fanName === document.getElementById('weibo-dm-detail-title').textContent);
        const fanIdx = state.chats[currentViewingDmsFor.isNpc ? currentViewingDmsFor.ownerId : currentViewingDmsFor.id].weiboDms.indexOf(conversation);

        if (!isNaN(fanIdx) && !isNaN(messageIndex)) {
            handleDeleteWeiboDm(fanIdx, messageIndex);
        }
    }
});
// ▲▲▲ 新事件監聽器黏貼結束 ▲▲▲
document.getElementById('clear-all-dms-btn').addEventListener('click', handleClearAllDms);
// 在 init() 的事件監聽器區域
// ▼▼▼ 【全新】聊天總結功能事件綁定 ▼▼▼
document.getElementById('view-summaries-btn').addEventListener('click', openSummaryViewer);
document.getElementById('close-summary-viewer-btn').addEventListener('click', () => {
    document.getElementById('summary-viewer-modal').classList.remove('visible');
    // 關閉後重新打開設置彈窗，回到上一級
    document.getElementById('chat-settings-btn').click();
});

// ▼▼▼ 用這塊【功能更全】的代碼，替換舊的 summary-list 事件監聽器 ▼▼▼
// 使用事件委託處理總結清單中的所有按鈕
document.getElementById('summary-list').addEventListener('click', (e) => {
    const editBtn = e.target.closest('.edit-summary-btn');
    if (editBtn) {
        const timestamp = parseInt(editBtn.dataset.timestamp);
        editSummary(timestamp);
        return;
    }
    
    const deleteBtn = e.target.closest('.delete-summary-btn');
    if (deleteBtn) {
        const timestamp = parseInt(deleteBtn.dataset.timestamp);
        deleteSummary(timestamp);
        return;
    }

    // 【核心新增】處理單條精簡按鈕的點擊
    const conciseBtn = e.target.closest('.concise-summary-btn');
    if (conciseBtn) {
        const timestamp = parseInt(conciseBtn.dataset.timestamp);
        handleConciseSummary(timestamp);
        return;
    }
});

// 【全新】為“全部精簡”按鈕綁定事件
document.getElementById('concise-all-summaries-btn').addEventListener('click', handleConciseAllSummaries);
// ▲▲▲ 替換結束 ▲▲▲

// 在 init() 函數的事件監聽器區域
// ▼▼▼ 【全新】為“立即手動總結”按鈕綁定事件 ▼▼▼
document.getElementById('chat-settings-modal').addEventListener('click', (e) => {
    if (e.target.id === 'manual-summary-btn') {
        // 點擊後先關閉設置彈窗，避免遮擋後續的提示
        document.getElementById('chat-settings-modal').classList.remove('visible');
        triggerManualSummaryNow();
    }
});
// ▲▲▲ 新事件綁定結束 ▲▲▲
// ▼▼▼ 把這一整塊全新的事件監聽器代碼，黏貼到 init() 的事件監聽器區域末尾 ▼▼▼

/* --- 【全新】“桃寶”App 事件監聽器 --- */

// 1. 綁定主螢幕的App圖示
document.getElementById('taobao-app-icon').addEventListener('click', openTaobaoApp);
// 綁定新加的“清空”按鈕
document.getElementById('clear-taobao-products-btn').addEventListener('click', clearTaobaoProducts);
// ▼▼▼ 在 init() 的事件監聽區域末尾，黏貼下面這整塊新代碼 ▼▼▼

/* --- 【全新】桃寶購物車功能事件監聽器 --- */

// 1. 綁定App內部的頁簽切換
document.querySelector('.taobao-tabs').addEventListener('click', (e) => {
    if (e.target.classList.contains('taobao-tab')) {
        switchTaobaoView(e.target.dataset.view);
    }
});

// 2. 使用事件委託，處理商品列表和購物車列表中的所有點擊
document.getElementById('taobao-screen').addEventListener('click', async (e) => {
    const target = e.target;
    
    // 點擊“加入購物車”按鈕
    if (target.classList.contains('add-cart-btn')) {
        const productId = parseInt(target.dataset.productId);
        if (!isNaN(productId)) {
            await handleAddToCart(productId);
        }
        return;
    }
    
    // 點擊商品卡片（圖片或資訊區），打開詳情頁
    const productCard = target.closest('.product-card');
    if (productCard && !target.classList.contains('add-cart-btn')) {
        const productId = parseInt(productCard.dataset.productId);
        if (!isNaN(productId)) {
            await openProductDetail(productId);
        }
        return;
    }
    
    // 點擊購物車裡的商品（圖片或資訊區），打開詳情頁
    const cartItem = target.closest('.cart-item');
    if (cartItem && (target.classList.contains('product-image') || target.closest('.cart-item-info'))) {
         const productId = parseInt(target.dataset.productId);
         if (!isNaN(productId)) {
            await openProductDetail(productId);
        }
        return;
    }

    // 點擊購物車數量控制按鈕
    if (target.classList.contains('quantity-increase')) {
        const cartId = parseInt(target.dataset.cartId);
        if (!isNaN(cartId)) await handleChangeCartItemQuantity(cartId, 1);
        return;
    }
    if (target.classList.contains('quantity-decrease')) {
        const cartId = parseInt(target.dataset.cartId);
        if (!isNaN(cartId)) await handleChangeCartItemQuantity(cartId, -1);
        return;
    }

    // 點擊購物車刪除按鈕
    if (target.classList.contains('delete-cart-item-btn')) {
        const cartId = parseInt(target.dataset.cartId);
        if (!isNaN(cartId)) {
            const confirmed = await showCustomConfirm('移出購物車', '確定要刪除這個寶貝嗎？');
            if (confirmed) await handleRemoveFromCart(cartId);
        }
        return;
    }

    // 點擊分類頁簽
    const categoryTab = target.closest('.category-tab-btn');
    if (categoryTab) {
        const category = categoryTab.dataset.category === 'all' ? null : categoryTab.dataset.category;
        await renderTaobaoProducts(category);
        return;
    }
});

// 3. 綁定商品詳情彈窗的關閉按鈕
document.getElementById('close-product-detail-btn').addEventListener('click', () => {
    document.getElementById('product-detail-modal').classList.remove('visible');
});

// 4. 綁定結算按鈕
document.getElementById('checkout-btn').addEventListener('click', handleCheckout);


// ▲▲▲ 新增事件監聽結束 ▲▲▲


// ▼▼▼ 用這塊新代碼替換舊的 'top-up-btn' 事件監聽器 ▼▼▼
document.getElementById('top-up-btn').addEventListener('click', async () => {
    const amountStr = await showCustomPrompt("充值", "請輸入要充值的金額 (元):", "", "number");
    if (amountStr !== null) {
        const amount = parseFloat(amountStr);
        if (!isNaN(amount) && amount > 0) {
            // 【核心修改】調用我們的新函數來處理充值和記錄
            await updateUserBalanceAndLogTransaction(amount, '充值');
            await renderBalanceDetails(); // 刷新餘額和明細
            alert(`成功充值 ¥${amount.toFixed(2)}！`);
        } else {
            alert("請輸入有效的金額！");
        }
    }
});
// ▲▲▲ 替換結束 ▲▲▲


// 4. 綁定首頁右上角的“+”按鈕
document.getElementById('add-product-btn').addEventListener('click', openAddProductChoiceModal);

// 5. 綁定添加方式選擇彈窗的按鈕
document.getElementById('add-product-manual-btn').addEventListener('click', () => {
    document.getElementById('add-product-choice-modal').classList.remove('visible');
    openProductEditor();
});
document.getElementById('add-product-link-btn').addEventListener('click', () => {
    document.getElementById('add-product-choice-modal').classList.remove('visible');
    openAddFromLinkModal();
});
document.getElementById('add-product-ai-btn').addEventListener('click', () => {
    document.getElementById('add-product-choice-modal').classList.remove('visible');
    handleGenerateProductsAI();
});
document.getElementById('cancel-add-choice-btn').addEventListener('click', () => {
    document.getElementById('add-product-choice-modal').classList.remove('visible');
});

// 6. 綁定手動添加/編輯彈窗的按鈕
document.getElementById('cancel-product-editor-btn').addEventListener('click', () => {
    document.getElementById('product-editor-modal').classList.remove('visible');
});
document.getElementById('save-product-btn').addEventListener('click', saveProduct);

// 7. 綁定識別連結彈窗的按鈕
document.getElementById('cancel-link-paste-btn').addEventListener('click', () => {
    document.getElementById('add-from-link-modal').classList.remove('visible');
});
document.getElementById('confirm-link-paste-btn').addEventListener('click', handleAddFromLink);

// ▼▼▼ 在 init() 的事件監聽器區域，用這塊【新代碼】替換舊的 'products-view' 點擊事件 ▼▼▼
document.getElementById('products-view').addEventListener('click', async (e) => {
    const target = e.target;
    
    // 【核心修改】我們把原來的購買邏輯，改成了打開詳情頁的邏輯
    const productCard = target.closest('.product-card');
    if (productCard && !target.classList.contains('add-cart-btn')) {
        const productId = parseInt(productCard.dataset.productId);
        if (!isNaN(productId)) {
            await openProductDetail(productId); // <--- 就是修改了這裡！
        }
        return;
    }
    
    // 下面這兩部分邏輯保持不變
    if (target.classList.contains('add-cart-btn')) {
        const productId = parseInt(target.dataset.productId);
        if (!isNaN(productId)) {
            await handleAddToCart(productId);
        }
        return;
    }
    const categoryTab = target.closest('.category-tab-btn');
    if (categoryTab) {
        const category = categoryTab.dataset.category === 'all' ? null : categoryTab.dataset.category;
        renderTaobaoProducts(category);
        return;
    }
});
// ▲▲▲ 替換結束 ▲▲▲


// ▼▼▼ 把這一整塊全新的事件監聽器代碼，黏貼到 init() 的事件監聽器區域末尾 ▼▼▼

/* --- 【全新】“桃寶”App 搜索與AI結果彈窗事件監聽器 --- */

// 1. 綁定搜索按鈕
productSearchBtn.addEventListener('click', handleSearchProductsAI);
productSearchInput.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        handleSearchProductsAI();
    }
});

// 2. 綁定AI結果彈窗的關閉按鈕
document.getElementById('close-ai-products-modal-btn').addEventListener('click', async () => {
    aiGeneratedProductsModal.classList.remove('visible');
    // 關閉後刷新主頁，顯示新添加的商品
    await renderTaobaoProducts(); 
});

// 3. 使用事件委託，處理結果彈窗內所有“添加”按鈕的點擊
document.getElementById('ai-product-results-grid').addEventListener('click', async (e) => {
    if (e.target.classList.contains('add-to-my-page-btn')) {
        const button = e.target;
        const productData = JSON.parse(button.dataset.product);
        // ▼▼▼ 在這裡黏貼下面這段新代碼 ▼▼▼
        // 【核心修改】如果AI返回的商品資料裡沒有圖片URL
        if (!productData.imageUrl) {
            // 就調用我們的輔助函數，給它一張隨機默認圖
            productData.imageUrl = getRandomDefaultProductImage();
            console.log(`AI生成的商品 "${productData.name}" 缺少圖片，已自動補充預設圖。`);
        }
        // ▲▲▲ 新增代碼黏貼結束 ▲▲▲
        // 檢查商品是否已存在
        const existingProduct = await db.taobaoProducts.where('name').equals(productData.name).first();
        if (existingProduct) {
            alert('這個商品已經存在於你的桃寶主頁啦！');
            button.textContent = '已添加';
            button.disabled = true;
            return;
        }

        // 添加到資料庫
        await db.taobaoProducts.add(productData);
        
        // 禁用按鈕並更新文本，給使用者回饋
        button.textContent = '✓ 已添加';
        button.disabled = true;
        
        // （可選）給個小提示
        // await showCustomAlert('添加成功', `“${productData.name}”已添加到你的桃寶！`);
    }
});

// ▼▼▼ 在 init() 的事件監聽器區域末尾，黏貼下面這整塊新代碼 ▼▼▼

/* --- 【全新】桃寶訂單物流功能事件監聽器 --- */

// 1. 使用事件委託，為“我的訂單”清單中的所有訂單項綁定點擊事件
document.getElementById('orders-view').addEventListener('click', (e) => {
    const item = e.target.closest('.order-item');
    if (item && item.dataset.orderId) {
        const orderId = parseInt(item.dataset.orderId);
        if (!isNaN(orderId)) {
            openLogisticsView(orderId);
        }
    }
});

// 2. 綁定物流頁面的返回按鈕
document.getElementById('logistics-back-btn').addEventListener('click', () => {
    // 返回時，直接顯示“桃寶”主介面，並自動切換到“我的訂單”頁簽
    showScreen('taobao-screen');
    switchTaobaoView('orders-view'); 
});

/* --- 事件監聽結束 --- */

// ▲▲▲ 新增代碼黏貼結束 ▲▲▲
document.getElementById('share-cart-to-char-btn').addEventListener('click', handleShareCartRequest);
// ▼▼▼ 在 init() 的事件監聽器區域黏貼 ▼▼▼
document.getElementById('buy-for-char-btn').addEventListener('click', handleBuyForChar);
// ▲▲▲ 黏貼結束 ▲▲▲
/* --- “桃寶”App 事件監聽器結束 --- */
// ▼▼▼ 【全新】這是角色手機外觀設置的事件監聽器 ▼▼▼
document.getElementById('character-phone-container').addEventListener('click', (e) => {
    // 使用事件委託，判斷點擊的是哪個按鈕
    if (e.target.id === 'upload-char-phone-wallpaper-btn') {
        document.getElementById('char-phone-wallpaper-upload-input').click();
    } 
    else if (e.target.id === 'remove-char-phone-wallpaper-btn') {
        handleCharPhoneWallpaperChange(''); // 傳入空字串來移除壁紙
    }
    else {
        const changeIconButton = e.target.closest('.change-icon-btn');
        if (changeIconButton) {
            const iconId = changeIconButton.dataset.iconId;
            handleChangeCharPhoneIcon(iconId);
        }
    }
});

// 監聽壁紙檔選擇
document.getElementById('char-phone-wallpaper-upload-input').addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if(file) {
        const dataUrl = await new Promise(res => {
            const reader = new FileReader();
            reader.onload = () => res(reader.result);
            reader.readAsDataURL(file);
        });
        handleCharPhoneWallpaperChange(dataUrl);
    }
    event.target.value = null; // 清空，以便下次能選擇同一個文件
});
// ▲▲▲ 事件監聽結束 ▲▲▲
// ▼▼▼ 在 init() 的事件監聽器區域末尾，黏貼下面這整塊新代碼 ▼▼▼

/* --- 【全新】角色微博主頁事件監聽器 --- */
// ▼▼▼ 在 init() 的事件監聽器區域黏貼這段新代碼 ▼▼▼

// 為角色微博主頁的“關注”和“粉絲”添加點擊編輯功能
document.getElementById('weibo-char-profile-page').addEventListener('click', async (e) => {
    if (!currentViewingWeiboProfileId) return;
    const chat = state.chats[currentViewingWeiboProfileId];
    if (!chat) return;

    // 判斷點擊的是否是“關注”區域
    if (e.target.closest('#weibo-char-following-item')) {
        const newFollowing = await showCustomPrompt("編輯關注數", "請輸入新的關注數:", chat.settings.weiboFollowingCount);
        if (newFollowing !== null) {
            chat.settings.weiboFollowingCount = newFollowing.trim() || '0';
            await db.chats.put(chat);
            await renderWeiboCharProfile(currentViewingWeiboProfileId);
        }
    }
    // 判斷點擊的是否是“粉絲”區域
    else if (e.target.closest('#weibo-char-fans-item')) {
        const newFans = await showCustomPrompt("編輯粉絲數", "請輸入新的粉絲數 (支持'萬'/'億'):", chat.settings.weiboFansCount);
        if (newFans !== null) {
            chat.settings.weiboFansCount = newFans.trim() || '0';
            await db.chats.put(chat);
            await renderWeiboCharProfile(currentViewingWeiboProfileId);
        }
    }
});

// ▲▲▲ 新代碼黏貼結束 ▲▲▲

// ▼▼▼ 請用下面這塊【已修復】的代碼，完整替換掉上面那段舊代碼 ▼▼▼
document.getElementById('back-from-char-profile').addEventListener('click', () => {
    // 【核心修改】我們不再顯示關注清單彈窗，而是直接返回到微博主螢幕
    showScreen('weibo-screen'); 
});
// ▲▲▲ 替換結束 ▲▲▲


// 2. 綁定新頁面右上角的編輯按鈕
document.getElementById('edit-char-weibo-profile-btn').addEventListener('click', openCharWeiboEditor);

// 3. 綁定角色資料編輯彈窗的按鈕
document.getElementById('cancel-char-weibo-editor-btn').addEventListener('click', () => {
    document.getElementById('char-weibo-editor-modal').classList.remove('visible');
});
document.getElementById('save-char-weibo-editor-btn').addEventListener('click', saveCharWeiboProfile);

// 4. 為角色資料編輯彈窗的圖片上傳綁定事件
setupFileUpload('char-weibo-editor-avatar-input', (base64) => {
    document.getElementById('char-weibo-editor-avatar-preview').src = base64;
});
setupFileUpload('char-weibo-editor-bg-input', (base64) => {
    document.getElementById('char-weibo-editor-bg-preview').src = base64;
});

// 5. 綁定關注列表的點擊事件（事件委託）
document.getElementById('weibo-following-list-container').addEventListener('click', (e) => {
    const viewProfileBtn = e.target.closest('.view-profile-btn');
    if (viewProfileBtn && viewProfileBtn.dataset.charId) {
        openWeiboCharProfile(viewProfileBtn.dataset.charId);
    }
});

/* --- 新事件監聽結束 --- */
// ▲▲▲ 新增代碼黏貼結束 ▲▲▲
// ▼▼▼ 在 init() 函數的事件監聽器區域末尾，黏貼下面這整塊新代碼 ▼▼▼

/* --- 【全新】角色微博資料編輯器事件綁定 --- */

// 1. 使用事件委託，為角色微博編輯彈窗內的所有按鈕綁定事件
document.getElementById('char-weibo-editor-modal').addEventListener('click', (e) => {
    // a. 如果點擊的是“更換頭像框”按鈕
    if (e.target.classList.contains('change-frame-btn')) {
        const type = e.target.dataset.type; // 獲取按鈕類型 'char-weibo'
        const targetId = currentViewingWeiboProfileId; // 獲取當前正在查看的角色ID
        
        // 調用頭像框選擇函數，並傳入正確的參數
        openFrameSelectorModal(type, targetId);
    }
    // b. 如果點擊的是“取消”按鈕
    else if (e.target.id === 'cancel-char-weibo-editor-btn') {
        document.getElementById('char-weibo-editor-modal').classList.remove('visible');
    }
    // c. 如果點擊的是“保存”按鈕
    else if (e.target.id === 'save-char-weibo-editor-btn') {
        saveCharWeiboProfile();
    }
});

// 2. 為角色手機的圖片上傳輸入框綁定事件（這是之前就有的，確保它在正確的位置）
setupFileUpload('char-weibo-editor-avatar-input', (base64) => {
    document.getElementById('char-weibo-editor-avatar-preview').src = base64;
});
setupFileUpload('char-weibo-editor-bg-input', (base64) => {
    document.getElementById('char-weibo-editor-bg-preview').src = base64;
});

// ▲▲▲ 新代碼黏貼結束 ▲▲▲
        // ▼▼▼ 在 init() 的事件監聽器區域末尾，黏貼這整塊新代碼 ▼▼▼

        /* --- 【全新】角色手機小組件上傳功能事件綁定 --- */

        // 輔助函數：處理圖片上傳的通用邏輯
        const handleWidgetUpload = async (widgetKey, inputFileId) => {
            const fileInput = document.getElementById(inputFileId);
            const file = fileInput.files[0];
            if (!file) return;

            const dataUrl = await new Promise(res => {
                const reader = new FileReader();
                reader.onload = () => res(reader.result);
                reader.readAsDataURL(file);
            });
            
            const chat = state.chats[activeCharacterPhoneId];
            if (!chat.characterPhoneData.widgets) {
                chat.characterPhoneData.widgets = {};
            }
            chat.characterPhoneData.widgets[widgetKey] = dataUrl;
            
            await db.chats.put(chat);
            renderCharPhoneAppearanceScreen(); // 刷新設置頁預覽
            openCharacterPhone(activeCharacterPhoneId); // 刷新手機主螢幕
            alert('小元件圖片已更新！');
            fileInput.value = null; // 清空以便下次選擇
        };

        // 輔助函數：處理圖片移除的通用邏輯
        const handleWidgetRemove = async (widgetKey) => {
             const chat = state.chats[activeCharacterPhoneId];
             if (chat.characterPhoneData.widgets && chat.characterPhoneData.widgets[widgetKey]) {
                delete chat.characterPhoneData.widgets[widgetKey];
                await db.chats.put(chat);
                renderCharPhoneAppearanceScreen();
                openCharacterPhone(activeCharacterPhoneId);
                alert('小元件圖片已移除！');
             }
        };

        // 為四個新按鈕綁定事件
        document.getElementById('upload-widget-1-btn').addEventListener('click', () => {
            document.getElementById('char-phone-widget-1-upload-input').click();
        });
        document.getElementById('remove-widget-1-btn').addEventListener('click', () => {
            handleWidgetRemove('widget1_url');
        });
        document.getElementById('char-phone-widget-1-upload-input').addEventListener('change', () => {
            handleWidgetUpload('widget1_url', 'char-phone-widget-1-upload-input');
        });

        document.getElementById('upload-widget-2-btn').addEventListener('click', () => {
            document.getElementById('char-phone-widget-2-upload-input').click();
        });
        document.getElementById('remove-widget-2-btn').addEventListener('click', () => {
            handleWidgetRemove('widget2_url');
        });
        document.getElementById('char-phone-widget-2-upload-input').addEventListener('change', () => {
            handleWidgetUpload('widget2_url', 'char-phone-widget-2-upload-input');
        });

        /* --- 小組件事件綁定結束 --- */
        // ▲▲▲ 新代碼黏貼結束 ▲▲▲

// ▲▲▲ 新增事件監聽結束 ▲▲▲
// ▼▼▼ 【全新】角色手機外觀預設功能事件綁定 ▼▼▼
document.getElementById('char-phone-preset-selector').addEventListener('change', handleCharPhonePresetSelection);
document.getElementById('apply-char-phone-preset-btn').addEventListener('click', applySelectedCharPhonePreset);
document.getElementById('save-char-phone-preset-btn').addEventListener('click', saveCurrentCharPhonePreset);
document.getElementById('update-char-phone-preset-btn').addEventListener('click', updateSelectedCharPhonePreset);
document.getElementById('rename-char-phone-preset-btn').addEventListener('click', renameSelectedCharPhonePreset);
document.getElementById('delete-char-phone-preset-btn').addEventListener('click', deleteSelectedCharPhonePreset);
document.getElementById('export-char-phone-preset-btn').addEventListener('click', exportCharPhonePreset);
document.getElementById('import-char-phone-preset-btn').addEventListener('click', () => {
    document.getElementById('import-char-phone-preset-input').click();
});
document.getElementById('import-char-phone-preset-input').addEventListener('change', (e) => {
    importCharPhonePreset(e.target.files[0]);
    e.target.value = null; // 清空以便下次能選擇同一個文件
});
// ▲▲▲ 事件綁定結束 ▲▲▲
// ▼▼▼ 【全新】角色手機App內壁紙功能事件綁定 ▼▼▼

// 監聽“上傳”按鈕的點擊，去觸發隱藏的檔選擇器
document.getElementById('upload-char-phone-app-wallpaper-btn').addEventListener('click', () => {
    document.getElementById('char-phone-app-wallpaper-upload-input').click();
});

// 監聽檔選擇器的變化
document.getElementById('char-phone-app-wallpaper-upload-input').addEventListener('change', async (event) => {
    const file = event.target.files[0];
    if(file) {
        const dataUrl = await new Promise((res) => {
            const reader = new FileReader();
            reader.onload = () => res(reader.result);
            reader.readAsDataURL(file);
        });
        // 檔讀取成功後，立刻調用處理函數來保存和應用
        handleCharPhoneAppWallpaperChange(dataUrl);
    }
    event.target.value = null; // 清空，以便下次能選擇同一個文件
});

// 監聽“移除”按鈕的點擊
document.getElementById('remove-char-phone-app-wallpaper-btn').addEventListener('click', () => {
    // 調用處理函數，並傳入空字串表示移除
    handleCharPhoneAppWallpaperChange('');
});

// ▲▲▲ 新事件綁定結束 ▲▲▲
// ▼▼▼ 在這裡黏貼下面這整塊【全新的】事件監聽器代碼 ▼▼▼
// ▼▼▼ 用這整塊新代碼，替換舊的飛行棋事件監聽器 ▼▼▼
/* --- 【全新 | V2分類版】心動飛行棋功能事件監聽器 --- */

// 1. 設置頁面的按鈕
document.getElementById('start-ludo-game-btn').addEventListener('click', startLudoGame);
document.getElementById('manage-ludo-question-banks-btn').addEventListener('click', openLudoQuestionBankManager);

// 2. 遊戲主介面的按鈕
document.getElementById('exit-ludo-game-btn').addEventListener('click', async () => {
    const confirmed = await showCustomConfirm('退出遊戲', '確定要中途退出遊戲嗎？');
    if (confirmed) {
        ludoGameState.isActive = false;
        showScreen('game-hall-screen');
    }
});
document.getElementById('restart-ludo-game-btn').addEventListener('click', async () => {
    const confirmed = await showCustomConfirm('重新開始', '確定要重新開始這一局嗎？');
    if (confirmed) {
        startLudoGame(); 
    }
});

// 3. 問題庫管理彈窗的按鈕
document.getElementById('close-qbank-manager-btn').addEventListener('click', async () => {
    document.getElementById('ludo-qbank-manager-modal').classList.remove('visible');
    // 如果設置頁面還開著，就刷新一下下拉清單
    if(document.getElementById('ludo-setup-screen').classList.contains('active')) {
        await openLudoSetup();
    }
});
document.getElementById('add-ludo-qbank-btn').addEventListener('click', addNewLudoQuestionBank);

// 4. 問題編輯器彈窗的按鈕
document.getElementById('back-to-qbank-manager-btn').addEventListener('click', () => {
    document.getElementById('ludo-question-editor-modal').classList.remove('visible');
    openLudoQuestionBankManager(); // 返回到題庫管理列表
});
document.getElementById('add-ludo-question-btn').addEventListener('click', () => openSingleQuestionEditor(null));

// 5. 單個問題編輯/添加彈窗的按鈕
document.getElementById('cancel-single-question-btn').addEventListener('click', () => {
    document.getElementById('ludo-single-question-editor-modal').classList.remove('visible');
});
document.getElementById('save-single-question-btn').addEventListener('click', saveSingleQuestion);
// ▼▼▼ 在這裡黏貼下面的新代碼 ▼▼▼
/* --- 【全新】飛行棋題庫導入功能事件監聽 --- */
document.getElementById('import-ludo-qbank-btn').addEventListener('click', () => {
    // 點擊“導入”按鈕時，觸發隱藏的檔選擇框
    document.getElementById('ludo-qbank-import-input').click();
});

document.getElementById('ludo-qbank-import-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (file) {
        // 當用戶選擇了檔後，調用我們的導入處理函數
        importLudoQuestionBank(file);
    }
    e.target.value = null; // 清空，以便下次能選擇同一個文件
});
/* --- 事件監聽結束 --- */
// ▲▲▲ 新代碼黏貼結束 ▲▲▲

/* --- 飛行棋事件監聽器結束 --- */
// ▲▲▲ 替換結束 ▲▲▲


// ▲▲▲ 新增代碼結束 ▲▲▲

// ===================================================================
// 5. 啟動！

// 應用壁紙並更新所有時鐘
applyLockscreenWallpaper();
updateLockClock();

// ▼▼▼ 【最終修復版】請用這整塊代碼，替換掉你 init() 函數中舊的鎖屏和狀態列開關邏輯 ▼▼▼

// 1. 讀取、應用並監聽“啟用鎖屏”設置
const enableLockScreenToggle = document.getElementById('enable-lock-screen-toggle');
const lockScreenEnabled = localStorage.getItem('lockScreenEnabled') !== 'false';
enableLockScreenToggle.checked = lockScreenEnabled;

// 2. 讀取、應用並監聽“顯示狀態列”設置
const showStatusBarToggle = document.getElementById('show-status-bar-toggle');
const statusBar = document.getElementById('status-bar');
// 讀取保存的狀態，如果沒保存過，預設是 true (顯示)
const showStatusBar = localStorage.getItem('showStatusBar') !== 'false'; 
// 讓開關的狀態和保存的狀態同步
showStatusBarToggle.checked = showStatusBar; 
// 根據保存的狀態，決定一載入進來時是否顯示狀態列
if (showStatusBar) {
    statusBar.style.display = 'flex';
} else {
    statusBar.style.display = 'none';
}

// 3. 【關鍵】給開關添加“變化”監聽器，這樣你每次點擊它都會保存狀態
showStatusBarToggle.addEventListener('change', (e) => {
    const isEnabled = e.target.checked;
    // a. 將新的開關狀態 (true 或 false) 保存到流覽器的 localStorage 裡
    localStorage.setItem('showStatusBar', isEnabled);
    // b. 立刻根據新的狀態來顯示或隱藏狀態列
    statusBar.style.display = isEnabled ? 'flex' : 'none';
});

// 4. 根據最終的鎖屏設置，決定應用啟動時第一個顯示的螢幕
if (lockScreenEnabled) {
    lockPhone(); // 如果設置是“啟用”，就鎖定手機
} else {
    showScreen('home-screen'); // 否則，直接進入主螢幕
}
// ▲▲▲ 替換結束 ▲▲▲

        }

        init();
 // ▼▼▼ 把這【一整塊】全新的代碼，黏貼到 <script> 標籤內的【變數定義區域】的末尾 ▼▼▼

const avatarFrames = [
    { id: 'none', url: '', name: '無' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/fLDnz5Pn/IMG-5574.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/HxH3cNHz/IMG-6871.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/jCVK0fGL/IMG-6890.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/85Zsyjwn/IMG-6895.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/cJtpZCB3/IMG-6894.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/63sDQKMm/IMG-6893.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/cHQPgzj4/IMG-6888.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/dVLXm3Xf/IMG-6885.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/kGsZwbq0/IMG-6886.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/63NmX03s/IMG-4366.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/zvz2LGK0/IMG-4367.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/prsGKMBx/IMG-4370.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/gk0BmrY0/IMG-4371.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/fRt2SFSn/IMG-4368.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/kGgwJhPH/IMG-4374.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/PrcKH436/IMG-4376.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/fRV86FMq/IMG-4381.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/HsyqMVyk/IMG-4385.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/qBbKK7dS/IMG-4386.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/05wnd389/IMG-4388.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/RZNLhbbr/IMG-4389.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/fLTc42dg/IMG-4391.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/FzbGNdRT/IMG-4392.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/XY63sTS3/IMG-4393.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Cx9vCVWH/IMG-4395.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/kMfPQBwQ/IMG-4396.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/CLrZQMMD/IMG-4398.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/L4zwDhTC/IMG-4399.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/yN3s8szM/IMG-4400.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/59Cn1tkB/IMG-4401.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/g0s1V0PX/IMG-4402.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/Jn1DFPgY/IMG-4403.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/q7cQnDy1/IMG-4404.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/RFK3q2t0/IMG-4407.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/gcV0VR2t/IMG-4408.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/W1CjLb4J/IMG-4409.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/Ss7pM6fW/IMG-4410.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/nrFfYX3N/IMG-4412.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/cHWp0KG6/IMG-4413.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/4yNjHrdg/IMG-4414.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/hPX5F8Qp/IMG-4415.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/vHCSG1WM/IMG-4416.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/x1Hp80Rm/IMG-4417.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/FHRcCGfH/IMG-4418.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/13hhJ77p/IMG-4419.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/J4WCQd2j/IMG-4420.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/Dydkpd9H/IMG-4421.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/mrkvDxPW/IMG-4422.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/76Tj3g1B/IMG-4425.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/3N5Vndn3/IMG-4426.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/05DLr0yj/IMG-4427.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/GhR6DT4Q/IMG-4428.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/fRTF24jS/IMG-4430.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/R0WYmcYM/IMG-4431.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/nrJSqNhz/IMG-4432.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/tC9mJ0cv/IMG-4438.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/XNkQTHvf/IMG-5561.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/Mpv5fzm5/IMG-4439.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/T1tjhsyB/IMG-4720.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/c4JMPd2W/IMG-4724.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/g2XykNGB/IMG-4727.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/y8MmJcd6/IMG-4728.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/Lsjzj5Yt/IMG-4729.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/bNdk33SN/IMG-4893.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/4x9tTy1D/IMG-5563.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/DZshzKv6/IMG-5576.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Fsvr71JL/IMG-5573.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/Fz3HwLk9/IMG-5569.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/wjH180kn/IMG-5566.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/MG6qtLYK/IMG-5565.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/CKgDNYVb/IMG-5577.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/hj4dkrvj/IMG-5578.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/C5XnfpNB/IMG-5579.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/4y7mGFgJ/IMG-5716.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/FzM1Hgr0/IMG-5717.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/rF4KYbjj/IMG-5720.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/6pLTBvDG/IMG-5721.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/VNK6Ccsf/IMG-5722.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/wx72fhr2/IMG-5968.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/QdrqdvdY/IMG-5969.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/0yd0MZ6k/IMG-5971.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/1zmcp66p/IMG-5973.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/wBw5Fvcn/IMG-5974.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/R0pfKYvB/IMG-5976.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/9fQZ425b/IMG-5975.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/v8V9xXjJ/IMG-6137.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/WbmkXzsS/IMG-6138.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/Dw2bDhZh/IMG-6140.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/ZqQBCyLY/IMG-6144.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/qRCtnMms/IMG-6145.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/1Rwn3XVP/IMG-6146.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/Kv51tW5H/IMG-6147.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/nhcC21Rc/IMG-6148.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/fTWzQRx8/IMG-6149.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/LXyyqDbY/IMG-6294.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/7Zgm1wRy/IMG-6295.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/5tbpnDcQ/IMG-6296.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/YSRRV8kn/IMG-6297.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/k45sd8gn/IMG-6375.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/50k390X8/IMG-6376.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/90RBDh9K/IMG-6377.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/cCpBYbMH/IMG-6552.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/Pf9g2fSL/IMG-6554.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/gkhf597g/IMG-6555.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/g2PfbSFm/IMG-6556.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/pLY3WfR8/IMG-6557.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/65Cmcr7S/IMG-6559.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Y94XWYKd/IMG-6560.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/ydwLXx7s/IMG-6562.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/G3y73Fj2/IMG-6563.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/TYvkKKkc/IMG-6565.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/GmcqjZn8/IMG-6566.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/k5Gs0K47/IMG-6567.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/XJy8JWdh/IMG-6568.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/fycfcvHf/IMG-6569.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/J7ZxC11H/IMG-6570.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/hPnrSHjy/IMG-4434.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/YqxxjbLp/IMG-6572.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/wjfcQMkZ/IMG-6573.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/Vv8jkCYr/IMG-6574.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/MZ77rdDy/IMG-6850.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/T3NvqJCZ/IMG-6851.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/28TsrxRV/IMG-6852.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/VkV2bLNw/IMG-6853.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/gJ95NSRB/IMG-6854.gif', name: '14' }, 
    { id: 'frame_cat_ear', url: 'https://i.postimg.cc/d1qsQsbQ/IMG-6855.gif', name: '1' }, 
    { id: 'frame_ribbon', url: 'https://i.postimg.cc/gJNYx9pV/IMG-6856.gif', name: '2' }, 
    { id: 'frame_flower', url: 'https://i.postimg.cc/fyPDvxJk/IMG-6860.gif', name: '3' }, 
    { id: 'frame_tech', url: 'https://i.postimg.cc/QMDsSNxg/IMG-6861.gif', name: '4' }, 
    { id: 'frame_5', url: 'https://i.postimg.cc/vBqsQW7X/IMG-6858.gif', name: '5' }, 
    { id: 'frame_6', url: 'https://i.postimg.cc/Y0vwjhb7/IMG-6857.gif', name: '6' }, 
    { id: 'frame_7', url: 'https://i.postimg.cc/90sH9Cn7/IMG-6868.gif', name: '7' }, 
    { id: 'frame_8', url: 'https://i.postimg.cc/Y2PHZzCC/IMG-6866.gif', name: '8' }, 
    { id: 'frame_9', url: 'https://i.postimg.cc/7Z8yYP7v/IMG-6889.gif', name: '9' }, 
    { id: 'frame_10', url: 'https://i.postimg.cc/nryNzTXK/IMG-6915.gif', name: '10' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Qx5dqyJ3/IMG-6917.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/Wbr0JSDD/IMG-5316.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/tgR6wjBP/IMG-5570.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/d0WCKxff/IMG-6932.gif', name: '14' }, 
    { id: 'frame_11', url: 'https://i.postimg.cc/Ss3znzk7/IMG-6934.gif', name: '11' }, 
    { id: 'frame_12', url: 'https://i.postimg.cc/nrm9BcL8/IMG-6941.gif', name: '12' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/ZYvd1jxf/IMG-6937.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/sDFhySn3/IMG-6936.gif', name: '14' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/43PhvxRq/IMG-6922.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/3Rb46fRZ/IMG-6923.gif', name: '14' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/PJppkbvn/IMG-6918.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/XqRZNZ9G/IMG-6916.gif', name: '14' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/RVt6sRzc/IMG-6939.gif', name: '14' }, 
    { id: 'frame_13', url: 'https://i.postimg.cc/mgGc0HbK/IMG-6926.gif', name: '13' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/P5zLh5JJ/IMG-6942.gif', name: '14' }, 
    { id: 'frame_14', url: 'https://i.postimg.cc/xCqqKGRN/IMG-6929.gif', name: '14' },
    { id: 'frame_12', url: 'https://i.postimg.cc/7LSRp4hx/e7fa949b9pc84cff0dabe57defceb54c.gif', name: '12' },
    { id: 'frame_13', url: 'https://i.postimg.cc/DZgMwc1H/817178fdbpf2ff7740dc98e26ab78759.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/3NffgJSZ/e09c07034ld7e62266c0a5de6a36ae62.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/vHDNGfT2/35ac7f372v588bf48d4f659077196b85.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/KvVsjjgG/3c3aa5219s18b90187ef1f54b3db7ba8.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/k5P1NHcL/55f3e31d8qbc8a02d152b07b99d31567.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/FFCTCzpy/641bad3b3udc599fdb63ca75fde427e5.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/8k7YSLjK/1689aa46aqc4b9ffc0f970e668f56537.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/J0CZSwyW/IMG-6938.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/Df1qLzDf/IMG-6927.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/CLNkrQSW/IMG-6925.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/y8p9s3Jj/IMG-6919.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/Lsr1Zd3Z/IMG-6928.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/Ssgbv41n/IMG-6876.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/SNByPrf9/IMG-7005.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/Z5nrCyS5/IMG-7006.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/mDfMXXFP/IMG-7007.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/DZrGtrqB/IMG-7008.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/ZnJNZWHZ/IMG-7009.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/RhGH0vpt/IMG-7010.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/tRzPkzRg/IMG-7012.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/wTTNGs3Q/IMG-7013.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/3JSG5Jv5/IMG-7014.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/rwDr8X1d/IMG-7015.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/DzDy2vS7/IMG-7017.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/QMVdG9x6/IMG-7016.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/mZ9hgH3J/IMG-7019.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/t4ksHGdg/IMG-7020.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/hP9JpdfT/IMG-7023.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/wTKyXVT9/IMG-7024.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/ZqjKXPSv/IMG-7025.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/gj3Tmqz5/mmexport1751030241029.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/4yCXW52F/mmexport1751030908335.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/VkXngG72/mmexport1751031208329.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/LscBkxZb/mmexport1751017556565.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/1XqzGKwJ/mmexport1751018282681.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/8kHCQwbQ/mmexport1751020645824.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/HWynLK7f/mmexport1751021724230.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/JnwFp3Kx/mmexport1751031208329.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/HLZNWkQw/mmexport1751031767634.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/vH2X6N1y/mmexport1751032231179.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/NFS4ZyvM/mmexport1751032686953.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/3RpmWc8c/mmexport1751033102811.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/L5RLr3tg/mmexport1751035976943.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/4NCPsp5d/mmexport1751034427637.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/CMv02LHm/mmexport1751034842120.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/rFnSzWGx/mmexport1751035618517.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/7YRbzN51/mmexport1751036276038.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/cJpbtPWq/mmexport1751036607799.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/HxLV5v92/mmexport1751036977582.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/D01rYy86/mmexport1751037965259.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/J4fwkTLW/mmexport1751038167142.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/xjpN4swz/IMG-7240.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/ZnzbGdxX/IMG-7239.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/DyYDmKtw/IMG-7238.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/W40f9qtd/IMG-7098.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/8PsK20jQ/IMG-7236.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/cHsTXDVz/IMG-7235.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/sXwm8Yzg/IMG-7234.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/xTk5xN49/IMG-7233.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/k5yv6QBv/IMG-7232.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/yx2m4nbs/IMG-7231.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/vZt0fFKn/IMB-r-HMBXY.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/pddJj9zN/IMG-7094.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/rmB17Qbc/IMB-f-VDf-Fc.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/VkKjzYTK/IMB-f4kk-CT.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/B6KD52vz/IMG-7096.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/9XPwWmwy/IMB-Kf7um-P.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/mrFhKBGz/IMB-e-QWBpa.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/bw4wxW2z/IMB-16r-COL.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/3x0Kx1fz/IMB-K1u-Jp-P.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/CLz0cJ0d/IMG-7116.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/fyyGgW61/IMG-7115.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/gkk7s0vD/IMG-6984.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/0NpZPgYj/IMG-6985.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/tTWKKmTN/IMG-7073.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/jS8tc9wW/IMG-7083.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/rmRVKJpD/IMG-7087.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/zvWGPjms/IMG-7090.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/YSkqDg8V/IMG-7092.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/FzqHTBng/IMG-7093.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/tTpZ6wLs/IMG-7095.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/8P5vt8sW/IMG-7097.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/wMxmCZVC/IMG-7099.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/2jxd0FGp/IMG-7100.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/B6T59xGK/IMG-7101.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/kXfcgFRN/IMG-7106.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/htZppbS4/IMG-7107.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/hPgyjtyn/IMG-7108.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/HLKvs0Kv/IMG-7109.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/wjwbnYkp/IMG-7111.gif', name: '14' },
    { id: 'frame_13', url: 'https://i.postimg.cc/bJDMQVkj/IMG-7112.gif', name: '13' },
    { id: 'frame_14', url: 'https://i.postimg.cc/SNWBTP5S/IMG-7113.gif', name: '14' },
    { id: 'frame_14', url: 'https://i.postimg.cc/jCVMQsKH/IMG-7114.gif', name: '14' },
];

// ▲▲▲ 黏貼結束 ▲▲▲       
    });
</script>
<!-- ▼▼▼ 這是我們新加的隱藏檔選擇器 ▼▼▼ -->
<input type="file" id="character-card-input" accept=".png, .json" style="display: none;">
<!-- ▲▲▲ 檔選擇器結束 ▲▲▲ -->
<input type="file" id="world-book-import-input" accept=".json, .jsonl" style="display: none;">
<input type="file" id="ludo-qbank-import-input" accept=".json" hidden>
</body>
</html>

